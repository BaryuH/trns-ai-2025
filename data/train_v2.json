[
  {
    "input": "Translate into first-order logic: All people who regularly drink coffee are dependent on caffeine.",
    "output": "∀x (Drinks(x) → Dependent(x))"
  },
  {
    "input": "Translate into first-order logic: People either regularly drink coffee or joke about being addicted to caffeine.",
    "output": "∀x (Drinks(x) ⊕ Jokes(x))"
  },
  {
    "input": "Translate into first-order logic: No one who jokes about being addicted to caffeine is unaware that caffeine is a drug.",
    "output": "∀x (Jokes(x) → ¬Unaware(x))"
  },
  {
    "input": "Translate into first-order logic: Rina is either a student and unaware that caffeine is a drug, or neither a student nor unaware that caffeine is a drug.",
    "output": "(Student(rina) ∧ Unaware(rina)) ⊕ ¬(Student(rina) ∨ Unaware(rina))"
  },
  {
    "input": "Translate into first-order logic: If Rina is not a person dependent on caffeine and a student, then Rina is either a person dependent on caffeine and a student, or neither a person dependent on caffeine nor a student.",
    "output": "¬(Dependent(rina) ∧ Student(rina)) → (Dependent(rina) ∧ Student(rina)) ⊕ ¬(Dependent(rina) ∨ Student(rina))"
  },
  {
    "input": "Translate into first-order logic: All people who regularly drink coffee are dependent on caffeine.",
    "output": "∀x (Drinks(x) → Dependent(x))"
  },
  {
    "input": "Translate into first-order logic: People either regularly drink coffee or joke about being addicted to caffeine.",
    "output": "∀x (Drinks(x) ⊕ Jokes(x))"
  },
  {
    "input": "Translate into first-order logic: No one who jokes about being addicted to caffeine is unaware that caffeine is a drug.",
    "output": "∀x (Jokes(x) → ¬Unaware(x))"
  },
  {
    "input": "Translate into first-order logic: Rina is either a student and unaware that caffeine is a drug, or neither a student nor unaware that caffeine is a drug.",
    "output": "(Student(rina) ∧ Unaware(rina)) ⊕ ¬(Student(rina) ∨ Unaware(rina))"
  },
  {
    "input": "Translate into first-order logic: If Rina is not a person dependent on caffeine and a student, then Rina is either a person dependent on caffeine and a student, or neither a person dependent on caffeine nor a student.",
    "output": "¬(Dependent(rina) ∧ Student(rina)) → (Dependent(rina) ∧ Student(rina)) ⊕ ¬(Dependent(rina) ∨ Student(rina))"
  },
  {
    "input": "Translate into first-order logic: All people who regularly drink coffee are dependent on caffeine.",
    "output": "∀x (Drinks(x) → Dependent(x))"
  },
  {
    "input": "Translate into first-order logic: People either regularly drink coffee or joke about being addicted to caffeine.",
    "output": "∀x (Drinks(x) ⊕ Jokes(x))"
  },
  {
    "input": "Translate into first-order logic: No one who jokes about being addicted to caffeine is unaware that caffeine is a drug.",
    "output": "∀x (Jokes(x) → ¬Unaware(x))"
  },
  {
    "input": "Translate into first-order logic: Rina is either a student and unaware that caffeine is a drug, or neither a student nor unaware that caffeine is a drug.",
    "output": "(Student(rina) ∧ Unaware(rina)) ⊕ ¬(Student(rina) ∨ Unaware(rina))"
  },
  {
    "input": "Translate into first-order logic: If Rina is not a person dependent on caffeine and a student, then Rina is either a person dependent on caffeine and a student, or neither a person dependent on caffeine nor a student.",
    "output": "¬(Dependent(rina) ∧ Student(rina)) → (Dependent(rina) ∧ Student(rina)) ⊕ ¬(Dependent(rina) ∨ Student(rina))"
  },
  {
    "input": "Translate into first-order logic: All people who regularly drink coffee are dependent on caffeine.",
    "output": "∀x (Drinks(x) → Dependent(x))"
  },
  {
    "input": "Translate into first-order logic: People either regularly drink coffee or joke about being addicted to caffeine.",
    "output": "∀x (Drinks(x) ⊕ Jokes(x))"
  },
  {
    "input": "Translate into first-order logic: No one who jokes about being addicted to caffeine is unaware that caffeine is a drug.",
    "output": "∀x (Jokes(x) → ¬Unaware(x))"
  },
  {
    "input": "Translate into first-order logic: Rina is either a student and unaware that caffeine is a drug, or neither a student nor unaware that caffeine is a drug.",
    "output": "(Student(rina) ∧ Unaware(rina)) ⊕ ¬(Student(rina) ∨ Unaware(rina))"
  },
  {
    "input": "Translate into first-order logic: If Rina is not a person dependent on caffeine and a student, then Rina is either a person dependent on caffeine and a student, or neither a person dependent on caffeine nor a student.",
    "output": "¬(Dependent(rina) ∧ Student(rina)) → (Dependent(rina) ∧ Student(rina)) ⊕ ¬(Dependent(rina) ∨ Student(rina))"
  },
  {
    "input": "Translate into first-order logic: Miroslav Venhoda was a Czech choral conductor who specialized in the performance of Renaissance and Baroque music.",
    "output": "Czech(miroslav) ∧ ChoralConductor(miroslav) ∧ Specialize(miroslav, renaissance) ∧ Specialize(miroslav, baroque)"
  },
  {
    "input": "Translate into first-order logic: Any choral conductor is a musician.",
    "output": "∀x (ChoralConductor(x) → Musician(x))"
  },
  {
    "input": "Translate into first-order logic: Some musicians love music.",
    "output": "∃x (Musician(x) → Love(x, music))"
  },
  {
    "input": "Translate into first-order logic: Miroslav Venhoda published a book in 1946 called Method of Studying Gregorian Chant.",
    "output": "Book(methodOfStudyingGregorianChant) ∧ Author(miroslav, methodOfStudyingGregorianChant) ∧ Publish(methodOfStudyingGregorianChant, year1946)"
  },
  {
    "input": "Translate into first-order logic: Miroslav Venhoda was a Czech choral conductor who specialized in the performance of Renaissance and Baroque music.",
    "output": "Czech(miroslav) ∧ ChoralConductor(miroslav) ∧ Specialize(miroslav, renaissance) ∧ Specialize(miroslav, baroque)"
  },
  {
    "input": "Translate into first-order logic: Any choral conductor is a musician.",
    "output": "∀x (ChoralConductor(x) → Musician(x))"
  },
  {
    "input": "Translate into first-order logic: Some musicians love music.",
    "output": "∃x (Musician(x) → Love(x, music))"
  },
  {
    "input": "Translate into first-order logic: Miroslav Venhoda published a book in 1946 called Method of Studying Gregorian Chant.",
    "output": "Book(methodOfStudyingGregorianChant) ∧ Author(miroslav, methodOfStudyingGregorianChant) ∧ Publish(methodOfStudyingGregorianChant, year1946)"
  },
  {
    "input": "Translate into first-order logic: Miroslav Venhoda was a Czech choral conductor who specialized in the performance of Renaissance and Baroque music.",
    "output": "Czech(miroslav) ∧ ChoralConductor(miroslav) ∧ Specialize(miroslav, renaissance) ∧ Specialize(miroslav, baroque)"
  },
  {
    "input": "Translate into first-order logic: Any choral conductor is a musician.",
    "output": "∀x (ChoralConductor(x) → Musician(x))"
  },
  {
    "input": "Translate into first-order logic: Some musicians love music.",
    "output": "∃x (Musician(x) → Love(x, music))"
  },
  {
    "input": "Translate into first-order logic: Miroslav Venhoda published a book in 1946 called Method of Studying Gregorian Chant.",
    "output": "Book(methodOfStudyingGregorianChant) ∧ Author(miroslav, methodOfStudyingGregorianChant) ∧ Publish(methodOfStudyingGregorianChant, year1946)"
  },
  {
    "input": "Translate into first-order logic: All eels are fish.",
    "output": "∀x  (Eel (x)→  Fish (x))"
  },
  {
    "input": "Translate into first-order logic: No fish are plants.",
    "output": "∀x  (Fish (x)→ ¬ Plant (x))"
  },
  {
    "input": "Translate into first-order logic: A thing is either a plant or animal.",
    "output": "∀x ( Plant (x) ∨  Animal (x))"
  },
  {
    "input": "Translate into first-order logic: Nothing that breathes is paper.",
    "output": "∀x  (Breathe (x)→ ¬ Paper (x))"
  },
  {
    "input": "Translate into first-order logic: All animals breathe.",
    "output": "∀x  (Animal (x)→  Breathe (x))"
  },
  {
    "input": "Translate into first-order logic: If a sea eel is either an eel or a plant, then a sea eel is an eel or an animal.",
    "output": " Eel (seaEel) ⊕ Plant (seaEel) → Eel (seaEel) ∨ Animal (seaEel) "
  },
  {
    "input": "Translate into first-order logic: All eels are fish.",
    "output": "∀x  (Eel (x)→  Fish (x))"
  },
  {
    "input": "Translate into first-order logic: No fish are plants.",
    "output": "∀x  (Fish (x)→ ¬ Plant (x))"
  },
  {
    "input": "Translate into first-order logic: A thing is either a plant or animal.",
    "output": "∀x ( Plant (x) ∨  Animal (x))"
  },
  {
    "input": "Translate into first-order logic: Nothing that breathes is paper.",
    "output": "∀x  (Breathe (x)→ ¬ Paper (x))"
  },
  {
    "input": "Translate into first-order logic: All animals breathe.",
    "output": "∀x  (Animal (x)→  Breathe (x))"
  },
  {
    "input": "Translate into first-order logic: If a sea eel is either an eel or a plant, then a sea eel is an eel or an animal.",
    "output": " Eel (seaEel) ⊕ Plant (seaEel) → Eel (seaEel) ∨ Animal (seaEel) "
  },
  {
    "input": "Translate into first-order logic: All eels are fish.",
    "output": "∀x  (Eel (x)→  Fish (x))"
  },
  {
    "input": "Translate into first-order logic: No fish are plants.",
    "output": "∀x  (Fish (x)→ ¬ Plant (x))"
  },
  {
    "input": "Translate into first-order logic: A thing is either a plant or animal.",
    "output": "∀x ( Plant (x) ∨  Animal (x))"
  },
  {
    "input": "Translate into first-order logic: Nothing that breathes is paper.",
    "output": "∀x  (Breathe (x)→ ¬ Paper (x))"
  },
  {
    "input": "Translate into first-order logic: All animals breathe.",
    "output": "∀x  (Animal (x)→  Breathe (x))"
  },
  {
    "input": "Translate into first-order logic: If a sea eel is either an eel or a plant, then a sea eel is an eel or an animal.",
    "output": " Eel (seaEel) ⊕ Plant (seaEel) → Eel (seaEel) ∨ Animal (seaEel) "
  },
  {
    "input": "Translate into first-order logic: The Blake McFall Company Building is a commercial warehouse listed on the National Register of Historic Places.",
    "output": "∀x (Blake(x) → Building(x))"
  },
  {
    "input": "Translate into first-order logic: The Blake McFall Company Building was added to the National Register of Historic Places in 1990.",
    "output": "∀x (Blake(x) → Historic(x, year1990))"
  },
  {
    "input": "Translate into first-order logic: The Emmet Building is a five-story building in Portland, Oregon.",
    "output": "∀x (Emmet(x) → Building(x) ∧ FiveStory(x) ∧ Locate(x, portland))"
  },
  {
    "input": "Translate into first-order logic: The Emmet Building was built in 1915.",
    "output": "∀x (Emmet(x) → Construct(x, year1915))"
  },
  {
    "input": "Translate into first-order logic: The Emmet Building is another name for the Blake McFall Company Building.",
    "output": "∀x (Emmet(x) ↔ Blake(x))"
  },
  {
    "input": "Translate into first-order logic: John works at the Emmet Building.",
    "output": "∃x (Emmet(x) ∧ Work(john, x))"
  },
  {
    "input": "Translate into first-order logic: The Blake McFall Company Building is a commercial warehouse listed on the National Register of Historic Places.",
    "output": "∀x (Blake(x) → Building(x))"
  },
  {
    "input": "Translate into first-order logic: The Blake McFall Company Building was added to the National Register of Historic Places in 1990.",
    "output": "∀x (Blake(x) → Historic(x, year1990))"
  },
  {
    "input": "Translate into first-order logic: The Emmet Building is a five-story building in Portland, Oregon.",
    "output": "∀x (Emmet(x) → Building(x) ∧ FiveStory(x) ∧ Locate(x, portland))"
  },
  {
    "input": "Translate into first-order logic: The Emmet Building was built in 1915.",
    "output": "∀x (Emmet(x) → Construct(x, year1915))"
  },
  {
    "input": "Translate into first-order logic: The Emmet Building is another name for the Blake McFall Company Building.",
    "output": "∀x (Emmet(x) ↔ Blake(x))"
  },
  {
    "input": "Translate into first-order logic: John works at the Emmet Building.",
    "output": "∃x (Emmet(x) ∧ Work(john, x))"
  },
  {
    "input": "Translate into first-order logic: The Blake McFall Company Building is a commercial warehouse listed on the National Register of Historic Places.",
    "output": "∀x (Blake(x) → Building(x))"
  },
  {
    "input": "Translate into first-order logic: The Blake McFall Company Building was added to the National Register of Historic Places in 1990.",
    "output": "∀x (Blake(x) → Historic(x, year1990))"
  },
  {
    "input": "Translate into first-order logic: The Emmet Building is a five-story building in Portland, Oregon.",
    "output": "∀x (Emmet(x) → Building(x) ∧ FiveStory(x) ∧ Locate(x, portland))"
  },
  {
    "input": "Translate into first-order logic: The Emmet Building was built in 1915.",
    "output": "∀x (Emmet(x) → Construct(x, year1915))"
  },
  {
    "input": "Translate into first-order logic: The Emmet Building is another name for the Blake McFall Company Building.",
    "output": "∀x (Emmet(x) ↔ Blake(x))"
  },
  {
    "input": "Translate into first-order logic: John works at the Emmet Building.",
    "output": "∃x (Emmet(x) ∧ Work(john, x))"
  },
  {
    "input": "Translate into first-order logic: William Dickinson was a British politician who sat in the House of Commons",
    "output": "BritishPolitician(williamdickinson) ∧ SatInHouseOfCommons(williamdickinson)"
  },
  {
    "input": "Translate into first-order logic: William Dickinson attended Westminster school for high school and then the University of Edinburgh.",
    "output": "Attended(williamdickinson, westminster) ∧ Highschool(westminster) ∧ Attended(williamdickinson, universityofedinburgh)"
  },
  {
    "input": "Translate into first-order logic: The University of Edinburgh is a university located in the United Kingdom.",
    "output": "LocatedIn(universityofedinburgh, unitedkingdom) ∧ University(universityofedinburgh)"
  },
  {
    "input": "Translate into first-order logic: William Dickinson supported the Portland Whigs.",
    "output": "Supported(williamdickinson, portlandwhigs)"
  },
  {
    "input": "Translate into first-order logic: People who supported the Portland Whigs did not get a seat in the Parliament.",
    "output": "∀x (Supported(x, portlandwhigs) → ¬SeatInParliament(x))"
  },
  {
    "input": "Translate into first-order logic: William Dickinson was a British politician who sat in the House of Commons",
    "output": "BritishPolitician(williamdickinson) ∧ SatInHouseOfCommons(williamdickinson)"
  },
  {
    "input": "Translate into first-order logic: William Dickinson attended Westminster school for high school and then the University of Edinburgh.",
    "output": "Attended(williamdickinson, westminster) ∧ Highschool(westminster) ∧ Attended(williamdickinson, universityofedinburgh)"
  },
  {
    "input": "Translate into first-order logic: The University of Edinburgh is a university located in the United Kingdom.",
    "output": "LocatedIn(universityofedinburgh, unitedkingdom) ∧ University(universityofedinburgh)"
  },
  {
    "input": "Translate into first-order logic: William Dickinson supported the Portland Whigs.",
    "output": "Supported(williamdickinson, portlandwhigs)"
  },
  {
    "input": "Translate into first-order logic: People who supported the Portland Whigs did not get a seat in the Parliament.",
    "output": "∀x (Supported(x, portlandwhigs) → ¬SeatInParliament(x))"
  },
  {
    "input": "Translate into first-order logic: William Dickinson was a British politician who sat in the House of Commons",
    "output": "BritishPolitician(williamdickinson) ∧ SatInHouseOfCommons(williamdickinson)"
  },
  {
    "input": "Translate into first-order logic: William Dickinson attended Westminster school for high school and then the University of Edinburgh.",
    "output": "Attended(williamdickinson, westminster) ∧ Highschool(westminster) ∧ Attended(williamdickinson, universityofedinburgh)"
  },
  {
    "input": "Translate into first-order logic: The University of Edinburgh is a university located in the United Kingdom.",
    "output": "LocatedIn(universityofedinburgh, unitedkingdom) ∧ University(universityofedinburgh)"
  },
  {
    "input": "Translate into first-order logic: William Dickinson supported the Portland Whigs.",
    "output": "Supported(williamdickinson, portlandwhigs)"
  },
  {
    "input": "Translate into first-order logic: People who supported the Portland Whigs did not get a seat in the Parliament.",
    "output": "∀x (Supported(x, portlandwhigs) → ¬SeatInParliament(x))"
  },
  {
    "input": "Translate into first-order logic: William Dickinson was a British politician who sat in the House of Commons",
    "output": "BritishPolitician(williamdickinson) ∧ SatInHouseOfCommons(williamdickinson)"
  },
  {
    "input": "Translate into first-order logic: William Dickinson attended Westminster school for high school and then the University of Edinburgh.",
    "output": "Attended(williamdickinson, westminster) ∧ Highschool(westminster) ∧ Attended(williamdickinson, universityofedinburgh)"
  },
  {
    "input": "Translate into first-order logic: The University of Edinburgh is a university located in the United Kingdom.",
    "output": "LocatedIn(universityofedinburgh, unitedkingdom) ∧ University(universityofedinburgh)"
  },
  {
    "input": "Translate into first-order logic: William Dickinson supported the Portland Whigs.",
    "output": "Supported(williamdickinson, portlandwhigs)"
  },
  {
    "input": "Translate into first-order logic: People who supported the Portland Whigs did not get a seat in the Parliament.",
    "output": "∀x (Supported(x, portlandwhigs) → ¬SeatInParliament(x))"
  },
  {
    "input": "Translate into first-order logic: LanguageA is a universal language",
    "output": "UniversalLanguage(languageA)"
  },
  {
    "input": "Translate into first-order logic: If a universal language exists, then for every two people if they both know the same universal language they can communicate.",
    "output": "∀x ∀y (∃z (Know(x, z) ∧ Know(y, z) ∧ UniversalLanguage(z)) → Communicate(x, y))"
  },
  {
    "input": "Translate into first-order logic: Katya cannot communicate with Danil.",
    "output": "Know(katya, languageA)"
  },
  {
    "input": "Translate into first-order logic: Katya knows LanguageA.",
    "output": "¬Communicate(katya, danil)"
  },
  {
    "input": "Translate into first-order logic: All customers who are subscribed to AMC List are available to watch 3 movies every week without any additional fees.",
    "output": "∀x (AMC(x) → ThreeMovies(x))"
  },
  {
    "input": "Translate into first-order logic: Some customers go to cinemas every week",
    "output": "∃x (CinemaEveryWeek(x))"
  },
  {
    "input": "Translate into first-order logic: Customers either subscribe to AMC service or HBO service.",
    "output": "∀x (AMC(x) ∨ HBO(x))"
  },
  {
    "input": "Translate into first-order logic: Customers who prefer TV series more and will not watch TV series in cinemas.",
    "output": "∀x (PreferTVSeries(x) → ¬WatchTVInCinema(x))"
  },
  {
    "input": "Translate into first-order logic: All customers who subscribe to HBO services prefer TV series to movies.",
    "output": "∀x (HBO(x) → PreferTVSeries(x))"
  },
  {
    "input": "Translate into first-order logic: James watches TV series in cinemas.",
    "output": "WatchTVInCinema(james)"
  },
  {
    "input": "Translate into first-order logic: All customers who are subscribed to AMC List are available to watch 3 movies every week without any additional fees.",
    "output": "∀x (AMC(x) → ThreeMovies(x))"
  },
  {
    "input": "Translate into first-order logic: Some customers go to cinemas every week",
    "output": "∃x (CinemaEveryWeek(x))"
  },
  {
    "input": "Translate into first-order logic: Customers either subscribe to AMC service or HBO service.",
    "output": "∀x (AMC(x) ∨ HBO(x))"
  },
  {
    "input": "Translate into first-order logic: Customers who prefer TV series more and will not watch TV series in cinemas.",
    "output": "∀x (PreferTVSeries(x) → ¬WatchTVInCinema(x))"
  },
  {
    "input": "Translate into first-order logic: All customers who subscribe to HBO services prefer TV series to movies.",
    "output": "∀x (HBO(x) → PreferTVSeries(x))"
  },
  {
    "input": "Translate into first-order logic: James watches TV series in cinemas.",
    "output": "WatchTVInCinema(james)"
  },
  {
    "input": "Translate into first-order logic: All customers who are subscribed to AMC List are available to watch 3 movies every week without any additional fees.",
    "output": "∀x (AMC(x) → ThreeMovies(x))"
  },
  {
    "input": "Translate into first-order logic: Some customers go to cinemas every week",
    "output": "∃x (CinemaEveryWeek(x))"
  },
  {
    "input": "Translate into first-order logic: Customers either subscribe to AMC service or HBO service.",
    "output": "∀x (AMC(x) ∨ HBO(x))"
  },
  {
    "input": "Translate into first-order logic: Customers who prefer TV series more and will not watch TV series in cinemas.",
    "output": "∀x (PreferTVSeries(x) → ¬WatchTVInCinema(x))"
  },
  {
    "input": "Translate into first-order logic: All customers who subscribe to HBO services prefer TV series to movies.",
    "output": "∀x (HBO(x) → PreferTVSeries(x))"
  },
  {
    "input": "Translate into first-order logic: James watches TV series in cinemas.",
    "output": "WatchTVInCinema(james)"
  },
  {
    "input": "Translate into first-order logic: All customers who are subscribed to AMC List are available to watch 3 movies every week without any additional fees.",
    "output": "∀x (AMC(x) → ThreeMovies(x))"
  },
  {
    "input": "Translate into first-order logic: Some customers go to cinemas every week",
    "output": "∃x (CinemaEveryWeek(x))"
  },
  {
    "input": "Translate into first-order logic: Customers either subscribe to AMC service or HBO service.",
    "output": "∀x (AMC(x) ∨ HBO(x))"
  },
  {
    "input": "Translate into first-order logic: Customers who prefer TV series more and will not watch TV series in cinemas.",
    "output": "∀x (PreferTVSeries(x) → ¬WatchTVInCinema(x))"
  },
  {
    "input": "Translate into first-order logic: All customers who subscribe to HBO services prefer TV series to movies.",
    "output": "∀x (HBO(x) → PreferTVSeries(x))"
  },
  {
    "input": "Translate into first-order logic: James watches TV series in cinemas.",
    "output": "WatchTVInCinema(james)"
  },
  {
    "input": "Translate into first-order logic: All customers who are subscribed to AMC List are available to watch 3 movies every week without any additional fees.",
    "output": "∀x (AMC(x) → ThreeMovies(x))"
  },
  {
    "input": "Translate into first-order logic: Some customers go to cinemas every week",
    "output": "∃x (CinemaEveryWeek(x))"
  },
  {
    "input": "Translate into first-order logic: Customers either subscribe to AMC service or HBO service.",
    "output": "∀x (AMC(x) ∨ HBO(x))"
  },
  {
    "input": "Translate into first-order logic: Customers who prefer TV series more and will not watch TV series in cinemas.",
    "output": "∀x (PreferTVSeries(x) → ¬WatchTVInCinema(x))"
  },
  {
    "input": "Translate into first-order logic: All customers who subscribe to HBO services prefer TV series to movies.",
    "output": "∀x (HBO(x) → PreferTVSeries(x))"
  },
  {
    "input": "Translate into first-order logic: James watches TV series in cinemas.",
    "output": "WatchTVInCinema(james)"
  },
  {
    "input": "Translate into first-order logic: A La Liga soccer team ranks higher than another if it receives more points.",
    "output": "∀x ∀y (LaLiga(x) ∧ LaLiga(y) ∧ MorePoints(x, y) → HigherRank(x, y))"
  },
  {
    "input": "Translate into first-order logic: If two La Liga soccer teams recieve the same points, the team which recieves more points from the games between the two teams ranks higher.",
    "output": "∀x ∀y (LaLiga(x) ∧ LaLiga(y) ∧ ¬MorePoints(x, y) ∧ ¬MorePoints(y, x) ∧ MorePointsInGameBetween(x, y) → HigherRank(x, y))"
  },
  {
    "input": "Translate into first-order logic: Real Madrid and Barcelona are both La Liga soccer teams.",
    "output": "LaLiga(realMadrid) ∧ LaLiga(barcelona)"
  },
  {
    "input": "Translate into first-order logic: In La Liga 2021-2022, Real Madrid recieves 86 points and Barcelon recieves 73 points.",
    "output": "MorePoints(realMadrid, barcelona)"
  },
  {
    "input": "Translate into first-order logic: In La Liga 2021-2022, Real Madrid and Barcelona both recieve 3 points from the games between them.",
    "output": "¬MorePointsInGameBetween(realMadrid, barcelona) ∧ ¬MorePointsInGameBetween(barcelona, realMadrid)"
  },
  {
    "input": "Translate into first-order logic: A La Liga soccer team ranks higher than another if it receives more points.",
    "output": "∀x ∀y (LaLiga(x) ∧ LaLiga(y) ∧ MorePoints(x, y) → HigherRank(x, y))"
  },
  {
    "input": "Translate into first-order logic: If two La Liga soccer teams recieve the same points, the team which recieves more points from the games between the two teams ranks higher.",
    "output": "∀x ∀y (LaLiga(x) ∧ LaLiga(y) ∧ ¬MorePoints(x, y) ∧ ¬MorePoints(y, x) ∧ MorePointsInGameBetween(x, y) → HigherRank(x, y))"
  },
  {
    "input": "Translate into first-order logic: Real Madrid and Barcelona are both La Liga soccer teams.",
    "output": "LaLiga(realMadrid) ∧ LaLiga(barcelona)"
  },
  {
    "input": "Translate into first-order logic: In La Liga 2021-2022, Real Madrid recieves 86 points and Barcelon recieves 73 points.",
    "output": "MorePoints(realMadrid, barcelona)"
  },
  {
    "input": "Translate into first-order logic: In La Liga 2021-2022, Real Madrid and Barcelona both recieve 3 points from the games between them.",
    "output": "¬MorePointsInGameBetween(realMadrid, barcelona) ∧ ¬MorePointsInGameBetween(barcelona, realMadrid)"
  },
  {
    "input": "Translate into first-order logic: Lawton Park is a neighbourhood in Seattle.",
    "output": "Neighbourhoodin(lawtonPark, seattle)"
  },
  {
    "input": "Translate into first-order logic: All citizens of Lawton Park use the zip code 98199.",
    "output": "∀x (Citizenof(x, lawtonPark) → Usezipcode(x, number98199))"
  },
  {
    "input": "Translate into first-order logic: Tom is a citizen of Lawton Park.",
    "output": "Citizenof(tom, lawtonPark)"
  },
  {
    "input": "Translate into first-order logic: Daniel uses the zip code 98199.",
    "output": "Usezipcode(daniel, number98199)"
  },
  {
    "input": "Translate into first-order logic: Lawton Park is a neighbourhood in Seattle.",
    "output": "Neighbourhoodin(lawtonPark, seattle)"
  },
  {
    "input": "Translate into first-order logic: All citizens of Lawton Park use the zip code 98199.",
    "output": "∀x (Citizenof(x, lawtonPark) → Usezipcode(x, number98199))"
  },
  {
    "input": "Translate into first-order logic: Tom is a citizen of Lawton Park.",
    "output": "Citizenof(tom, lawtonPark)"
  },
  {
    "input": "Translate into first-order logic: Daniel uses the zip code 98199.",
    "output": "Usezipcode(daniel, number98199)"
  },
  {
    "input": "Translate into first-order logic: Lawton Park is a neighbourhood in Seattle.",
    "output": "Neighbourhoodin(lawtonPark, seattle)"
  },
  {
    "input": "Translate into first-order logic: All citizens of Lawton Park use the zip code 98199.",
    "output": "∀x (Citizenof(x, lawtonPark) → Usezipcode(x, number98199))"
  },
  {
    "input": "Translate into first-order logic: Tom is a citizen of Lawton Park.",
    "output": "Citizenof(tom, lawtonPark)"
  },
  {
    "input": "Translate into first-order logic: Daniel uses the zip code 98199.",
    "output": "Usezipcode(daniel, number98199)"
  },
  {
    "input": "Translate into first-order logic: Lawton Park is a neighbourhood in Seattle.",
    "output": "Neighbourhoodin(lawtonPark, seattle)"
  },
  {
    "input": "Translate into first-order logic: All citizens of Lawton Park use the zip code 98199.",
    "output": "∀x (Citizenof(x, lawtonPark) → Usezipcode(x, number98199))"
  },
  {
    "input": "Translate into first-order logic: Tom is a citizen of Lawton Park.",
    "output": "Citizenof(tom, lawtonPark)"
  },
  {
    "input": "Translate into first-order logic: Daniel uses the zip code 98199.",
    "output": "Usezipcode(daniel, number98199)"
  },
  {
    "input": "Translate into first-order logic: If a legislator is found guilty of stealing government funds, they will be suspended from office.",
    "output": "∀x (IsLegislator(x) ∧ StealsFunds(x) → Suspended(x))"
  },
  {
    "input": "Translate into first-order logic: Tiffany T. Alston was a legislator in Maryland's House of Delegates from 2011 to 2013.",
    "output": "IsLegislator(tiffanyTAlston)"
  },
  {
    "input": "Translate into first-order logic: Tiffany T. Alston was found guilty of stealing government funds in 2012.",
    "output": "StealsFunds(tiffanyTAlston)"
  },
  {
    "input": "Translate into first-order logic: If a legislator is found guilty of stealing government funds, they will be suspended from office.",
    "output": "∀x (IsLegislator(x) ∧ StealsFunds(x) → Suspended(x))"
  },
  {
    "input": "Translate into first-order logic: Tiffany T. Alston was a legislator in Maryland's House of Delegates from 2011 to 2013.",
    "output": "IsLegislator(tiffanyTAlston)"
  },
  {
    "input": "Translate into first-order logic: Tiffany T. Alston was found guilty of stealing government funds in 2012.",
    "output": "StealsFunds(tiffanyTAlston)"
  },
  {
    "input": "Translate into first-order logic: If a legislator is found guilty of stealing government funds, they will be suspended from office.",
    "output": "∀x (IsLegislator(x) ∧ StealsFunds(x) → Suspended(x))"
  },
  {
    "input": "Translate into first-order logic: Tiffany T. Alston was a legislator in Maryland's House of Delegates from 2011 to 2013.",
    "output": "IsLegislator(tiffanyTAlston)"
  },
  {
    "input": "Translate into first-order logic: Tiffany T. Alston was found guilty of stealing government funds in 2012.",
    "output": "StealsFunds(tiffanyTAlston)"
  },
  {
    "input": "Translate into first-order logic: Some fish may sting.",
    "output": "∃x ∃y (Fish(x) → Sting(x,y))"
  },
  {
    "input": "Translate into first-order logic: Stonefish is a fish.",
    "output": "Fish(stonefish)"
  },
  {
    "input": "Translate into first-order logic: It stings to step on a stonefish.",
    "output": "∀x (StepOn(stonefish, x) → Sting(stonefish, x))"
  },
  {
    "input": "Translate into first-order logic: Stonefish stings cause death if not treated.",
    "output": "∀x (Sting(stonefish, x) ∧ ¬Treated(x) → CauseDeath(x))"
  },
  {
    "input": "Translate into first-order logic: To treat stonefish stings, apply heat to the affected area or use an antivenom.",
    "output": "∀x (Sting(stonefish, x) ∧ (ApplyHeat(x) ∨ UseAntivenom(x)) → Treated(x))"
  },
  {
    "input": "Translate into first-order logic: Some fish may sting.",
    "output": "∃x ∃y (Fish(x) → Sting(x,y))"
  },
  {
    "input": "Translate into first-order logic: Stonefish is a fish.",
    "output": "Fish(stonefish)"
  },
  {
    "input": "Translate into first-order logic: It stings to step on a stonefish.",
    "output": "∀x (StepOn(stonefish, x) → Sting(stonefish, x))"
  },
  {
    "input": "Translate into first-order logic: Stonefish stings cause death if not treated.",
    "output": "∀x (Sting(stonefish, x) ∧ ¬Treated(x) → CauseDeath(x))"
  },
  {
    "input": "Translate into first-order logic: To treat stonefish stings, apply heat to the affected area or use an antivenom.",
    "output": "∀x (Sting(stonefish, x) ∧ (ApplyHeat(x) ∨ UseAntivenom(x)) → Treated(x))"
  },
  {
    "input": "Translate into first-order logic: Some fish may sting.",
    "output": "∃x ∃y (Fish(x) → Sting(x,y))"
  },
  {
    "input": "Translate into first-order logic: Stonefish is a fish.",
    "output": "Fish(stonefish)"
  },
  {
    "input": "Translate into first-order logic: It stings to step on a stonefish.",
    "output": "∀x (StepOn(stonefish, x) → Sting(stonefish, x))"
  },
  {
    "input": "Translate into first-order logic: Stonefish stings cause death if not treated.",
    "output": "∀x (Sting(stonefish, x) ∧ ¬Treated(x) → CauseDeath(x))"
  },
  {
    "input": "Translate into first-order logic: To treat stonefish stings, apply heat to the affected area or use an antivenom.",
    "output": "∀x (Sting(stonefish, x) ∧ (ApplyHeat(x) ∨ UseAntivenom(x)) → Treated(x))"
  },
  {
    "input": "Translate into first-order logic: Some monitors produced by LG have a type-c port.",
    "output": "∃x (LG(x) ∧ TypeC(x))"
  },
  {
    "input": "Translate into first-order logic: If the monitor has a type-c port, then it is not produced by AOC.",
    "output": "∀x (TypeC(x) → ¬AOC(x))"
  },
  {
    "input": "Translate into first-order logic: All monitors in the library are produced by AOC.",
    "output": "∀x (Library(x) → AOC(x))"
  },
  {
    "input": "Translate into first-order logic: L-2021 is either in the library or has a type-c port.",
    "output": "Library(l-2021) ⊕ TypeC(l-2021) "
  },
  {
    "input": "Translate into first-order logic: L-2021 is either produced by AOC and produced by LG, or neither produced by AOC nor produced by LG.",
    "output": "¬(AOC(l-2021) ⊕ LG(l-2021))"
  },
  {
    "input": "Translate into first-order logic: Some monitors produced by LG have a type-c port.",
    "output": "∃x (LG(x) ∧ TypeC(x))"
  },
  {
    "input": "Translate into first-order logic: If the monitor has a type-c port, then it is not produced by AOC.",
    "output": "∀x (TypeC(x) → ¬AOC(x))"
  },
  {
    "input": "Translate into first-order logic: All monitors in the library are produced by AOC.",
    "output": "∀x (Library(x) → AOC(x))"
  },
  {
    "input": "Translate into first-order logic: L-2021 is either in the library or has a type-c port.",
    "output": "Library(l-2021) ⊕ TypeC(l-2021) "
  },
  {
    "input": "Translate into first-order logic: L-2021 is either produced by AOC and produced by LG, or neither produced by AOC nor produced by LG.",
    "output": "¬(AOC(l-2021) ⊕ LG(l-2021))"
  },
  {
    "input": "Translate into first-order logic: Some monitors produced by LG have a type-c port.",
    "output": "∃x (LG(x) ∧ TypeC(x))"
  },
  {
    "input": "Translate into first-order logic: If the monitor has a type-c port, then it is not produced by AOC.",
    "output": "∀x (TypeC(x) → ¬AOC(x))"
  },
  {
    "input": "Translate into first-order logic: All monitors in the library are produced by AOC.",
    "output": "∀x (Library(x) → AOC(x))"
  },
  {
    "input": "Translate into first-order logic: L-2021 is either in the library or has a type-c port.",
    "output": "Library(l-2021) ⊕ TypeC(l-2021) "
  },
  {
    "input": "Translate into first-order logic: L-2021 is either produced by AOC and produced by LG, or neither produced by AOC nor produced by LG.",
    "output": "¬(AOC(l-2021) ⊕ LG(l-2021))"
  },
  {
    "input": "Translate into first-order logic: Some monitors produced by LG have a type-c port.",
    "output": "∃x (LG(x) ∧ TypeC(x))"
  },
  {
    "input": "Translate into first-order logic: If the monitor has a type-c port, then it is not produced by AOC.",
    "output": "∀x (TypeC(x) → ¬AOC(x))"
  },
  {
    "input": "Translate into first-order logic: All monitors in the library are produced by AOC.",
    "output": "∀x (Library(x) → AOC(x))"
  },
  {
    "input": "Translate into first-order logic: L-2021 is either in the library or has a type-c port.",
    "output": "Library(l-2021) ⊕ TypeC(l-2021) "
  },
  {
    "input": "Translate into first-order logic: L-2021 is either produced by AOC and produced by LG, or neither produced by AOC nor produced by LG.",
    "output": "¬(AOC(l-2021) ⊕ LG(l-2021))"
  },
  {
    "input": "Translate into first-order logic: Some monitors produced by LG have a type-c port.",
    "output": "∃x (LG(x) ∧ TypeC(x))"
  },
  {
    "input": "Translate into first-order logic: If the monitor has a type-c port, then it is not produced by AOC.",
    "output": "∀x (TypeC(x) → ¬AOC(x))"
  },
  {
    "input": "Translate into first-order logic: All monitors in the library are produced by AOC.",
    "output": "∀x (Library(x) → AOC(x))"
  },
  {
    "input": "Translate into first-order logic: L-2021 is either in the library or has a type-c port.",
    "output": "Library(l-2021) ⊕ TypeC(l-2021) "
  },
  {
    "input": "Translate into first-order logic: L-2021 is either produced by AOC and produced by LG, or neither produced by AOC nor produced by LG.",
    "output": "¬(AOC(l-2021) ⊕ LG(l-2021))"
  },
  {
    "input": "Translate into first-order logic: People eat meat regularly or are vegetation.",
    "output": "∀x (Meat(x) ∨ Vegetarian(x))"
  },
  {
    "input": "Translate into first-order logic: If people eat meat regularly, then they enjoy eating hamburgers and steaks.",
    "output": "∀x (Meat(x) → Hamburgers(x))"
  },
  {
    "input": "Translate into first-order logic: All people who are vegetarian are conscious of the environment or their health.",
    "output": "∀x (Vegetarian(x) → Conscious(x))"
  },
  {
    "input": "Translate into first-order logic: If people are conscious about the environment or their health, then they do not go to fast food places often.",
    "output": "∀x (Conscious(x) → ¬FastFood(x))"
  },
  {
    "input": "Translate into first-order logic: If people have busy schedules without time to cook, then they go to fast food places often.",
    "output": "∀x (Busy(x) → FastFood(x))"
  },
  {
    "input": "Translate into first-order logic: If Jeremy does not both go to fast food places often and is conscious about the environment or their health, then he goes to fast food places often.",
    "output": "¬(FastFood(jeremy) ∧ Conscious(jeremy)) → FastFood(jeremy)"
  },
  {
    "input": "Translate into first-order logic: People eat meat regularly or are vegetation.",
    "output": "∀x (Meat(x) ∨ Vegetarian(x))"
  },
  {
    "input": "Translate into first-order logic: If people eat meat regularly, then they enjoy eating hamburgers and steaks.",
    "output": "∀x (Meat(x) → Hamburgers(x))"
  },
  {
    "input": "Translate into first-order logic: All people who are vegetarian are conscious of the environment or their health.",
    "output": "∀x (Vegetarian(x) → Conscious(x))"
  },
  {
    "input": "Translate into first-order logic: If people are conscious about the environment or their health, then they do not go to fast food places often.",
    "output": "∀x (Conscious(x) → ¬FastFood(x))"
  },
  {
    "input": "Translate into first-order logic: If people have busy schedules without time to cook, then they go to fast food places often.",
    "output": "∀x (Busy(x) → FastFood(x))"
  },
  {
    "input": "Translate into first-order logic: If Jeremy does not both go to fast food places often and is conscious about the environment or their health, then he goes to fast food places often.",
    "output": "¬(FastFood(jeremy) ∧ Conscious(jeremy)) → FastFood(jeremy)"
  },
  {
    "input": "Translate into first-order logic: People eat meat regularly or are vegetation.",
    "output": "∀x (Meat(x) ∨ Vegetarian(x))"
  },
  {
    "input": "Translate into first-order logic: If people eat meat regularly, then they enjoy eating hamburgers and steaks.",
    "output": "∀x (Meat(x) → Hamburgers(x))"
  },
  {
    "input": "Translate into first-order logic: All people who are vegetarian are conscious of the environment or their health.",
    "output": "∀x (Vegetarian(x) → Conscious(x))"
  },
  {
    "input": "Translate into first-order logic: If people are conscious about the environment or their health, then they do not go to fast food places often.",
    "output": "∀x (Conscious(x) → ¬FastFood(x))"
  },
  {
    "input": "Translate into first-order logic: If people have busy schedules without time to cook, then they go to fast food places often.",
    "output": "∀x (Busy(x) → FastFood(x))"
  },
  {
    "input": "Translate into first-order logic: If Jeremy does not both go to fast food places often and is conscious about the environment or their health, then he goes to fast food places often.",
    "output": "¬(FastFood(jeremy) ∧ Conscious(jeremy)) → FastFood(jeremy)"
  },
  {
    "input": "Translate into first-order logic: Sam is doing a project.",
    "output": "∃x (Project(x) ∧ Do(sam, x))"
  },
  {
    "input": "Translate into first-order logic: A project is written either in C++ or in Python.",
    "output": " ∀x (Project(x) → (WrittenIn(x, python) ⊕ WrittenIn(x, c++)))"
  },
  {
    "input": "Translate into first-order logic: If Sam does a project written in Python, he will not use a Mac.",
    "output": " ∀x (Project(x) ∧ WrittenIn(x, python) ∧ Do(sam, x) → ¬Use(sam, mac))"
  },
  {
    "input": "Translate into first-order logic: Sam is using a Mac.",
    "output": " Use(sam, mac)"
  },
  {
    "input": "Translate into first-order logic: If Sam uses a Mac, he will play a song.",
    "output": " Use(sam, mac) → ∃x (Song(x) ∧ Play(sam, x))"
  },
  {
    "input": "Translate into first-order logic: If a song is not \"Perfect\", Sam will never play it.",
    "output": " ∀x (¬Be(x, perfect) → ¬Play(sam, x))"
  },
  {
    "input": "Translate into first-order logic: Sam is doing a project.",
    "output": "∃x (Project(x) ∧ Do(sam, x))"
  },
  {
    "input": "Translate into first-order logic: A project is written either in C++ or in Python.",
    "output": " ∀x (Project(x) → (WrittenIn(x, python) ⊕ WrittenIn(x, c++)))"
  },
  {
    "input": "Translate into first-order logic: If Sam does a project written in Python, he will not use a Mac.",
    "output": " ∀x (Project(x) ∧ WrittenIn(x, python) ∧ Do(sam, x) → ¬Use(sam, mac))"
  },
  {
    "input": "Translate into first-order logic: Sam is using a Mac.",
    "output": " Use(sam, mac)"
  },
  {
    "input": "Translate into first-order logic: If Sam uses a Mac, he will play a song.",
    "output": " Use(sam, mac) → ∃x (Song(x) ∧ Play(sam, x))"
  },
  {
    "input": "Translate into first-order logic: If a song is not \"Perfect\", Sam will never play it.",
    "output": " ∀x (¬Be(x, perfect) → ¬Play(sam, x))"
  },
  {
    "input": "Translate into first-order logic: Sam is doing a project.",
    "output": "∃x (Project(x) ∧ Do(sam, x))"
  },
  {
    "input": "Translate into first-order logic: A project is written either in C++ or in Python.",
    "output": " ∀x (Project(x) → (WrittenIn(x, python) ⊕ WrittenIn(x, c++)))"
  },
  {
    "input": "Translate into first-order logic: If Sam does a project written in Python, he will not use a Mac.",
    "output": " ∀x (Project(x) ∧ WrittenIn(x, python) ∧ Do(sam, x) → ¬Use(sam, mac))"
  },
  {
    "input": "Translate into first-order logic: Sam is using a Mac.",
    "output": " Use(sam, mac)"
  },
  {
    "input": "Translate into first-order logic: If Sam uses a Mac, he will play a song.",
    "output": " Use(sam, mac) → ∃x (Song(x) ∧ Play(sam, x))"
  },
  {
    "input": "Translate into first-order logic: If a song is not \"Perfect\", Sam will never play it.",
    "output": " ∀x (¬Be(x, perfect) → ¬Play(sam, x))"
  },
  {
    "input": "Translate into first-order logic: All rabbits have fur",
    "output": "∀x (Rabbit(x) → HasFur(x))"
  },
  {
    "input": "Translate into first-order logic: Some pets are rabbits.",
    "output": "∃x (Pet(x) ∧ Reptile(x))"
  },
  {
    "input": "Translate into first-order logic: All video applications are software.",
    "output": "∀x (App(x) → Software(x))"
  },
  {
    "input": "Translate into first-order logic: All YouTube-related applications are video applications.",
    "output": "∀x (Youtube(x) → App(x))"
  },
  {
    "input": "Translate into first-order logic: An APP is either related to YouTube or Instagram.",
    "output": "∀x (Youtube(x) ∨ Instagram(x))"
  },
  {
    "input": "Translate into first-order logic: All Instagram is entertainment.",
    "output": "∀x (Instagram(x) → Entertainment(x))"
  },
  {
    "input": "Translate into first-order logic: All software is programmed.",
    "output": "∀x (Software(x) → Program(x))"
  },
  {
    "input": "Translate into first-order logic: All entertainments are interesting.",
    "output": "∀x (Entertainment(x) → Interesting(x))"
  },
  {
    "input": "Translate into first-order logic: If something is interesting, then it is good.",
    "output": "∀x (Interesting(x) → Good(x))"
  },
  {
    "input": "Translate into first-order logic: TikTok is not good.",
    "output": "¬Good(tiktok)"
  },
  {
    "input": "Translate into first-order logic: All video applications are software.",
    "output": "∀x (App(x) → Software(x))"
  },
  {
    "input": "Translate into first-order logic: All YouTube-related applications are video applications.",
    "output": "∀x (Youtube(x) → App(x))"
  },
  {
    "input": "Translate into first-order logic: An APP is either related to YouTube or Instagram.",
    "output": "∀x (Youtube(x) ∨ Instagram(x))"
  },
  {
    "input": "Translate into first-order logic: All Instagram is entertainment.",
    "output": "∀x (Instagram(x) → Entertainment(x))"
  },
  {
    "input": "Translate into first-order logic: All software is programmed.",
    "output": "∀x (Software(x) → Program(x))"
  },
  {
    "input": "Translate into first-order logic: All entertainments are interesting.",
    "output": "∀x (Entertainment(x) → Interesting(x))"
  },
  {
    "input": "Translate into first-order logic: If something is interesting, then it is good.",
    "output": "∀x (Interesting(x) → Good(x))"
  },
  {
    "input": "Translate into first-order logic: TikTok is not good.",
    "output": "¬Good(tiktok)"
  },
  {
    "input": "Translate into first-order logic: All video applications are software.",
    "output": "∀x (App(x) → Software(x))"
  },
  {
    "input": "Translate into first-order logic: All YouTube-related applications are video applications.",
    "output": "∀x (Youtube(x) → App(x))"
  },
  {
    "input": "Translate into first-order logic: An APP is either related to YouTube or Instagram.",
    "output": "∀x (Youtube(x) ∨ Instagram(x))"
  },
  {
    "input": "Translate into first-order logic: All Instagram is entertainment.",
    "output": "∀x (Instagram(x) → Entertainment(x))"
  },
  {
    "input": "Translate into first-order logic: All software is programmed.",
    "output": "∀x (Software(x) → Program(x))"
  },
  {
    "input": "Translate into first-order logic: All entertainments are interesting.",
    "output": "∀x (Entertainment(x) → Interesting(x))"
  },
  {
    "input": "Translate into first-order logic: If something is interesting, then it is good.",
    "output": "∀x (Interesting(x) → Good(x))"
  },
  {
    "input": "Translate into first-order logic: TikTok is not good.",
    "output": "¬Good(tiktok)"
  },
  {
    "input": "Translate into first-order logic: All video applications are software.",
    "output": "∀x (App(x) → Software(x))"
  },
  {
    "input": "Translate into first-order logic: All YouTube-related applications are video applications.",
    "output": "∀x (Youtube(x) → App(x))"
  },
  {
    "input": "Translate into first-order logic: An APP is either related to YouTube or Instagram.",
    "output": "∀x (Youtube(x) ∨ Instagram(x))"
  },
  {
    "input": "Translate into first-order logic: All Instagram is entertainment.",
    "output": "∀x (Instagram(x) → Entertainment(x))"
  },
  {
    "input": "Translate into first-order logic: All software is programmed.",
    "output": "∀x (Software(x) → Program(x))"
  },
  {
    "input": "Translate into first-order logic: All entertainments are interesting.",
    "output": "∀x (Entertainment(x) → Interesting(x))"
  },
  {
    "input": "Translate into first-order logic: If something is interesting, then it is good.",
    "output": "∀x (Interesting(x) → Good(x))"
  },
  {
    "input": "Translate into first-order logic: TikTok is not good.",
    "output": "¬Good(tiktok)"
  },
  {
    "input": "Translate into first-order logic: Ordinary is an unincorporated community.",
    "output": "UnincorporatedCommunity(ordinary)"
  },
  {
    "input": "Translate into first-order logic: Located within Elliot County, Ordinary is on Kentucky Route 32.",
    "output": "In(ordinary, elliotcounty) ∧ On(ordinary, kentuckyroute32)"
  },
  {
    "input": "Translate into first-order logic: Ordinary is located northwest of Sandy Hook.",
    "output": "NorthwestOf(ordinary, sandyhook)"
  },
  {
    "input": "Translate into first-order logic: Ordinary is an unincorporated community.",
    "output": "UnincorporatedCommunity(ordinary)"
  },
  {
    "input": "Translate into first-order logic: Located within Elliot County, Ordinary is on Kentucky Route 32.",
    "output": "In(ordinary, elliotcounty) ∧ On(ordinary, kentuckyroute32)"
  },
  {
    "input": "Translate into first-order logic: Ordinary is located northwest of Sandy Hook.",
    "output": "NorthwestOf(ordinary, sandyhook)"
  },
  {
    "input": "Translate into first-order logic: All young adults go on a diet.",
    "output": "∀x (YoungAdult(x) → GoOnDiet(x))"
  },
  {
    "input": "Translate into first-order logic: All college students are young adults.",
    "output": "∀x (CollegeStudent(x) → YoungAdult(x))"
  },
  {
    "input": "Translate into first-order logic: All Yale students are college students.",
    "output": "∀x (YaleStudent(x) → CollegeStudent(x))"
  },
  {
    "input": "Translate into first-order logic: Someone is either a Yale student or a Harvard student.",
    "output": "∀x (YaleStudent(x) ∨ HarvardStudent(x))"
  },
  {
    "input": "Translate into first-order logic: All Harvard students are diligent.",
    "output": "∀x (HarvardStudent(x) → Diligent(x))"
  },
  {
    "input": "Translate into first-order logic: If Susan is a Harvard student, then she is a young adult.",
    "output": "HarvardStudent(susan) → YoungAdult(susan)"
  },
  {
    "input": "Translate into first-order logic: If Susan is a Yale student, then she does not go on a diet.",
    "output": "YaleStudent(susan) → ¬GoOnDiet(susan)"
  },
  {
    "input": "Translate into first-order logic: All young adults go on a diet.",
    "output": "∀x (YoungAdult(x) → GoOnDiet(x))"
  },
  {
    "input": "Translate into first-order logic: All college students are young adults.",
    "output": "∀x (CollegeStudent(x) → YoungAdult(x))"
  },
  {
    "input": "Translate into first-order logic: All Yale students are college students.",
    "output": "∀x (YaleStudent(x) → CollegeStudent(x))"
  },
  {
    "input": "Translate into first-order logic: Someone is either a Yale student or a Harvard student.",
    "output": "∀x (YaleStudent(x) ∨ HarvardStudent(x))"
  },
  {
    "input": "Translate into first-order logic: All Harvard students are diligent.",
    "output": "∀x (HarvardStudent(x) → Diligent(x))"
  },
  {
    "input": "Translate into first-order logic: If Susan is a Harvard student, then she is a young adult.",
    "output": "HarvardStudent(susan) → YoungAdult(susan)"
  },
  {
    "input": "Translate into first-order logic: If Susan is a Yale student, then she does not go on a diet.",
    "output": "YaleStudent(susan) → ¬GoOnDiet(susan)"
  },
  {
    "input": "Translate into first-order logic: All young adults go on a diet.",
    "output": "∀x (YoungAdult(x) → GoOnDiet(x))"
  },
  {
    "input": "Translate into first-order logic: All college students are young adults.",
    "output": "∀x (CollegeStudent(x) → YoungAdult(x))"
  },
  {
    "input": "Translate into first-order logic: All Yale students are college students.",
    "output": "∀x (YaleStudent(x) → CollegeStudent(x))"
  },
  {
    "input": "Translate into first-order logic: Someone is either a Yale student or a Harvard student.",
    "output": "∀x (YaleStudent(x) ∨ HarvardStudent(x))"
  },
  {
    "input": "Translate into first-order logic: All Harvard students are diligent.",
    "output": "∀x (HarvardStudent(x) → Diligent(x))"
  },
  {
    "input": "Translate into first-order logic: If Susan is a Harvard student, then she is a young adult.",
    "output": "HarvardStudent(susan) → YoungAdult(susan)"
  },
  {
    "input": "Translate into first-order logic: If Susan is a Yale student, then she does not go on a diet.",
    "output": "YaleStudent(susan) → ¬GoOnDiet(susan)"
  },
  {
    "input": "Translate into first-order logic: Vic DiCara plays guitar and bass.",
    "output": "Play(vicdicara, guitar) ∧ Play(vicdicara, bass)"
  },
  {
    "input": "Translate into first-order logic: The only style of music Vic DiCara plays is punk music.",
    "output": "¬(∃x (Music (vicdicara, punk) ∧ Music (vicdicara, x)))"
  },
  {
    "input": "Translate into first-order logic: Vic DiCara played in the band Inside Out.",
    "output": "Band(vicdicara, insideOut)"
  },
  {
    "input": "Translate into first-order logic: Vic DiCara plays guitar and bass.",
    "output": "Play(vicdicara, guitar) ∧ Play(vicdicara, bass)"
  },
  {
    "input": "Translate into first-order logic: The only style of music Vic DiCara plays is punk music.",
    "output": "¬(∃x (Music (vicdicara, punk) ∧ Music (vicdicara, x)))"
  },
  {
    "input": "Translate into first-order logic: Vic DiCara played in the band Inside Out.",
    "output": "Band(vicdicara, insideOut)"
  },
  {
    "input": "Translate into first-order logic: All athletes are good at sports.",
    "output": "∀x (Athlete(x) → GoodAtSports(x))"
  },
  {
    "input": "Translate into first-order logic: All Olympic gold medal winners are good athletes.",
    "output": "∀x (OlympicGoldMedalWinner(x) → Athlete(x))"
  },
  {
    "input": "Translate into first-order logic: No scientists are good at sports.",
    "output": "∀x (Scientist(x) → ¬GoodAtSports(x))"
  },
  {
    "input": "Translate into first-order logic: All Nobel laureates are scientists.",
    "output": "∀x (NobelLaureate(x) → Scientist(x))"
  },
  {
    "input": "Translate into first-order logic: Amy is good at sports or Amy is an Olympic gold medal winner.",
    "output": "GoodAtSports(amy) ∨ OlympicGoldMedalWinner(amy)"
  },
  {
    "input": "Translate into first-order logic: If Amy is not a Nobel laureate, then Amy is not an Olympic gold medal winner.",
    "output": "¬NobelLaureate(amy) → ¬OlympicGoldMedalWinner(amy)"
  },
  {
    "input": "Translate into first-order logic: All athletes are good at sports.",
    "output": "∀x (Athlete(x) → GoodAtSports(x))"
  },
  {
    "input": "Translate into first-order logic: All Olympic gold medal winners are good athletes.",
    "output": "∀x (OlympicGoldMedalWinner(x) → Athlete(x))"
  },
  {
    "input": "Translate into first-order logic: No scientists are good at sports.",
    "output": "∀x (Scientist(x) → ¬GoodAtSports(x))"
  },
  {
    "input": "Translate into first-order logic: All Nobel laureates are scientists.",
    "output": "∀x (NobelLaureate(x) → Scientist(x))"
  },
  {
    "input": "Translate into first-order logic: Amy is good at sports or Amy is an Olympic gold medal winner.",
    "output": "GoodAtSports(amy) ∨ OlympicGoldMedalWinner(amy)"
  },
  {
    "input": "Translate into first-order logic: If Amy is not a Nobel laureate, then Amy is not an Olympic gold medal winner.",
    "output": "¬NobelLaureate(amy) → ¬OlympicGoldMedalWinner(amy)"
  },
  {
    "input": "Translate into first-order logic: All athletes are good at sports.",
    "output": "∀x (Athlete(x) → GoodAtSports(x))"
  },
  {
    "input": "Translate into first-order logic: All Olympic gold medal winners are good athletes.",
    "output": "∀x (OlympicGoldMedalWinner(x) → Athlete(x))"
  },
  {
    "input": "Translate into first-order logic: No scientists are good at sports.",
    "output": "∀x (Scientist(x) → ¬GoodAtSports(x))"
  },
  {
    "input": "Translate into first-order logic: All Nobel laureates are scientists.",
    "output": "∀x (NobelLaureate(x) → Scientist(x))"
  },
  {
    "input": "Translate into first-order logic: Amy is good at sports or Amy is an Olympic gold medal winner.",
    "output": "GoodAtSports(amy) ∨ OlympicGoldMedalWinner(amy)"
  },
  {
    "input": "Translate into first-order logic: If Amy is not a Nobel laureate, then Amy is not an Olympic gold medal winner.",
    "output": "¬NobelLaureate(amy) → ¬OlympicGoldMedalWinner(amy)"
  },
  {
    "input": "Translate into first-order logic: All fruits with the color red contain a large amount of vitamin C.",
    "output": "∀x (RedFruit(x) → VC(x))"
  },
  {
    "input": "Translate into first-order logic: All apples are fruits with the color red.",
    "output": "∀x (Apple(x) → RedFruit(x))"
  },
  {
    "input": "Translate into first-order logic: All fruits containing a large amount of vitamin C are beneficial to people.",
    "output": "∀x (VC(x) → Benefit(x))"
  },
  {
    "input": "Translate into first-order logic: No fruits that are beneficial to people are on a warning list.",
    "output": "∀x (Benefit(x) → ¬WarningList(x))"
  },
  {
    "input": "Translate into first-order logic: If K is not beneficial to people and also not an apple, then it is a fruit with the color red.",
    "output": "¬(Benefit(k) ∧ Apple(k)) → RedFruit(k)"
  },
  {
    "input": "Translate into first-order logic: All fruits with the color red contain a large amount of vitamin C.",
    "output": "∀x (RedFruit(x) → VC(x))"
  },
  {
    "input": "Translate into first-order logic: All apples are fruits with the color red.",
    "output": "∀x (Apple(x) → RedFruit(x))"
  },
  {
    "input": "Translate into first-order logic: All fruits containing a large amount of vitamin C are beneficial to people.",
    "output": "∀x (VC(x) → Benefit(x))"
  },
  {
    "input": "Translate into first-order logic: No fruits that are beneficial to people are on a warning list.",
    "output": "∀x (Benefit(x) → ¬WarningList(x))"
  },
  {
    "input": "Translate into first-order logic: If K is not beneficial to people and also not an apple, then it is a fruit with the color red.",
    "output": "¬(Benefit(k) ∧ Apple(k)) → RedFruit(k)"
  },
  {
    "input": "Translate into first-order logic: All fruits with the color red contain a large amount of vitamin C.",
    "output": "∀x (RedFruit(x) → VC(x))"
  },
  {
    "input": "Translate into first-order logic: All apples are fruits with the color red.",
    "output": "∀x (Apple(x) → RedFruit(x))"
  },
  {
    "input": "Translate into first-order logic: All fruits containing a large amount of vitamin C are beneficial to people.",
    "output": "∀x (VC(x) → Benefit(x))"
  },
  {
    "input": "Translate into first-order logic: No fruits that are beneficial to people are on a warning list.",
    "output": "∀x (Benefit(x) → ¬WarningList(x))"
  },
  {
    "input": "Translate into first-order logic: If K is not beneficial to people and also not an apple, then it is a fruit with the color red.",
    "output": "¬(Benefit(k) ∧ Apple(k)) → RedFruit(k)"
  },
  {
    "input": "Translate into first-order logic: All fruits with the color red contain a large amount of vitamin C.",
    "output": "∀x (RedFruit(x) → VC(x))"
  },
  {
    "input": "Translate into first-order logic: All apples are fruits with the color red.",
    "output": "∀x (Apple(x) → RedFruit(x))"
  },
  {
    "input": "Translate into first-order logic: All fruits containing a large amount of vitamin C are beneficial to people.",
    "output": "∀x (VC(x) → Benefit(x))"
  },
  {
    "input": "Translate into first-order logic: No fruits that are beneficial to people are on a warning list.",
    "output": "∀x (Benefit(x) → ¬WarningList(x))"
  },
  {
    "input": "Translate into first-order logic: If K is not beneficial to people and also not an apple, then it is a fruit with the color red.",
    "output": "¬(Benefit(k) ∧ Apple(k)) → RedFruit(k)"
  },
  {
    "input": "Translate into first-order logic: All fruits with the color red contain a large amount of vitamin C.",
    "output": "∀x (RedFruit(x) → VC(x))"
  },
  {
    "input": "Translate into first-order logic: All apples are fruits with the color red.",
    "output": "∀x (Apple(x) → RedFruit(x))"
  },
  {
    "input": "Translate into first-order logic: All fruits containing a large amount of vitamin C are beneficial to people.",
    "output": "∀x (VC(x) → Benefit(x))"
  },
  {
    "input": "Translate into first-order logic: No fruits that are beneficial to people are on a warning list.",
    "output": "∀x (Benefit(x) → ¬WarningList(x))"
  },
  {
    "input": "Translate into first-order logic: If K is not beneficial to people and also not an apple, then it is a fruit with the color red.",
    "output": "¬(Benefit(k) ∧ Apple(k)) → RedFruit(k)"
  },
  {
    "input": "Translate into first-order logic: Everyone working at Meta has a high income.",
    "output": "∀x (Meta(x) → HighIncome(x))"
  },
  {
    "input": "Translate into first-order logic: If a person has a high income, then he/she will not take a bus to their destination.",
    "output": "∀x (HighIncome(x) → ¬Bus(x))"
  },
  {
    "input": "Translate into first-order logic: People will either take a bus or drive to their destination.",
    "output": "∀x (Bus(x) ∨ Drive(x))"
  },
  {
    "input": "Translate into first-order logic: Everyone who has a car will choose to drive to their destination.",
    "output": "∀x (HaveCars(x) → Drive(x))"
  },
  {
    "input": "Translate into first-order logic: No students drive to their destination.",
    "output": "∀x (Student(x) → ¬Drive(x))"
  },
  {
    "input": "Translate into first-order logic: James has a car or works at Meta.",
    "output": "HaveCars(james) ∨ Meta(james)"
  },
  {
    "input": "Translate into first-order logic: Everyone working at Meta has a high income.",
    "output": "∀x (Meta(x) → HighIncome(x))"
  },
  {
    "input": "Translate into first-order logic: If a person has a high income, then he/she will not take a bus to their destination.",
    "output": "∀x (HighIncome(x) → ¬Bus(x))"
  },
  {
    "input": "Translate into first-order logic: People will either take a bus or drive to their destination.",
    "output": "∀x (Bus(x) ∨ Drive(x))"
  },
  {
    "input": "Translate into first-order logic: Everyone who has a car will choose to drive to their destination.",
    "output": "∀x (HaveCars(x) → Drive(x))"
  },
  {
    "input": "Translate into first-order logic: No students drive to their destination.",
    "output": "∀x (Student(x) → ¬Drive(x))"
  },
  {
    "input": "Translate into first-order logic: James has a car or works at Meta.",
    "output": "HaveCars(james) ∨ Meta(james)"
  },
  {
    "input": "Translate into first-order logic: Everyone working at Meta has a high income.",
    "output": "∀x (Meta(x) → HighIncome(x))"
  },
  {
    "input": "Translate into first-order logic: If a person has a high income, then he/she will not take a bus to their destination.",
    "output": "∀x (HighIncome(x) → ¬Bus(x))"
  },
  {
    "input": "Translate into first-order logic: People will either take a bus or drive to their destination.",
    "output": "∀x (Bus(x) ∨ Drive(x))"
  },
  {
    "input": "Translate into first-order logic: Everyone who has a car will choose to drive to their destination.",
    "output": "∀x (HaveCars(x) → Drive(x))"
  },
  {
    "input": "Translate into first-order logic: No students drive to their destination.",
    "output": "∀x (Student(x) → ¬Drive(x))"
  },
  {
    "input": "Translate into first-order logic: James has a car or works at Meta.",
    "output": "HaveCars(james) ∨ Meta(james)"
  },
  {
    "input": "Translate into first-order logic: Everyone working at Meta has a high income.",
    "output": "∀x (Meta(x) → HighIncome(x))"
  },
  {
    "input": "Translate into first-order logic: If a person has a high income, then he/she will not take a bus to their destination.",
    "output": "∀x (HighIncome(x) → ¬Bus(x))"
  },
  {
    "input": "Translate into first-order logic: People will either take a bus or drive to their destination.",
    "output": "∀x (Bus(x) ∨ Drive(x))"
  },
  {
    "input": "Translate into first-order logic: Everyone who has a car will choose to drive to their destination.",
    "output": "∀x (HaveCars(x) → Drive(x))"
  },
  {
    "input": "Translate into first-order logic: No students drive to their destination.",
    "output": "∀x (Student(x) → ¬Drive(x))"
  },
  {
    "input": "Translate into first-order logic: James has a car or works at Meta.",
    "output": "HaveCars(james) ∨ Meta(james)"
  },
  {
    "input": "Translate into first-order logic: Everyone working at Meta has a high income.",
    "output": "∀x (Meta(x) → HighIncome(x))"
  },
  {
    "input": "Translate into first-order logic: If a person has a high income, then he/she will not take a bus to their destination.",
    "output": "∀x (HighIncome(x) → ¬Bus(x))"
  },
  {
    "input": "Translate into first-order logic: People will either take a bus or drive to their destination.",
    "output": "∀x (Bus(x) ∨ Drive(x))"
  },
  {
    "input": "Translate into first-order logic: Everyone who has a car will choose to drive to their destination.",
    "output": "∀x (HaveCars(x) → Drive(x))"
  },
  {
    "input": "Translate into first-order logic: No students drive to their destination.",
    "output": "∀x (Student(x) → ¬Drive(x))"
  },
  {
    "input": "Translate into first-order logic: James has a car or works at Meta.",
    "output": "HaveCars(james) ∨ Meta(james)"
  },
  {
    "input": "Translate into first-order logic: Everyone working at Meta has a high income.",
    "output": "∀x (Meta(x) → HighIncome(x))"
  },
  {
    "input": "Translate into first-order logic: If a person has a high income, then he/she will not take a bus to their destination.",
    "output": "∀x (HighIncome(x) → ¬Bus(x))"
  },
  {
    "input": "Translate into first-order logic: People will either take a bus or drive to their destination.",
    "output": "∀x (Bus(x) ∨ Drive(x))"
  },
  {
    "input": "Translate into first-order logic: Everyone who has a car will choose to drive to their destination.",
    "output": "∀x (HaveCars(x) → Drive(x))"
  },
  {
    "input": "Translate into first-order logic: No students drive to their destination.",
    "output": "∀x (Student(x) → ¬Drive(x))"
  },
  {
    "input": "Translate into first-order logic: James has a car or works at Meta.",
    "output": "HaveCars(james) ∨ Meta(james)"
  },
  {
    "input": "Translate into first-order logic: Students either go to the park or go to the movies.",
    "output": "∀x (Park(x) ⊕ Movies(x))"
  },
  {
    "input": "Translate into first-order logic: No student who enjoys nature has free time during the weekend.",
    "output": "∀x (Nature(x) → ¬FreeTime(x))"
  },
  {
    "input": "Translate into first-order logic: All students who go to the movies enjoy nature.",
    "output": "∀x (Movies(x) → Nature(x))"
  },
  {
    "input": "Translate into first-order logic: All students who do not have class during the weekend have free time during the weekend.",
    "output": "∀x (NoClass(x) → FreeTime(x))"
  },
  {
    "input": "Translate into first-order logic: All students not in summer camp do not have class during the weekend.",
    "output": "∀x (SummerCamp(x) → NoClass(x))"
  },
  {
    "input": "Translate into first-order logic: James does not have class during the weekend.",
    "output": "NoClass(james)"
  },
  {
    "input": "Translate into first-order logic: Students either go to the park or go to the movies.",
    "output": "∀x (Park(x) ⊕ Movies(x))"
  },
  {
    "input": "Translate into first-order logic: No student who enjoys nature has free time during the weekend.",
    "output": "∀x (Nature(x) → ¬FreeTime(x))"
  },
  {
    "input": "Translate into first-order logic: All students who go to the movies enjoy nature.",
    "output": "∀x (Movies(x) → Nature(x))"
  },
  {
    "input": "Translate into first-order logic: All students who do not have class during the weekend have free time during the weekend.",
    "output": "∀x (NoClass(x) → FreeTime(x))"
  },
  {
    "input": "Translate into first-order logic: All students not in summer camp do not have class during the weekend.",
    "output": "∀x (SummerCamp(x) → NoClass(x))"
  },
  {
    "input": "Translate into first-order logic: James does not have class during the weekend.",
    "output": "NoClass(james)"
  },
  {
    "input": "Translate into first-order logic: No television stars are certified public accountants.",
    "output": "∀x (TelevisionStar(x) → ¬CertifiedPublicAccoutant(x))"
  },
  {
    "input": "Translate into first-order logic: All certified public accountants have good business sense.",
    "output": "∀x (CertifiedPublicAccoutant(x) → GoodBusinessSense(x))"
  },
  {
    "input": "Translate into first-order logic: Some students good at math are good at chemistry.",
    "output": "∃x (Math(x) ∧ Chemistry(x))"
  },
  {
    "input": "Translate into first-order logic: All students good at chemistry enjoy conducting experiments.",
    "output": "∀x (Chemistry(x) → Experiment(x))"
  },
  {
    "input": "Translate into first-order logic: All students that enjoy conducting experiments are good at planning.",
    "output": "∀x (Experiment(x) → Planning(x))"
  },
  {
    "input": "Translate into first-order logic: No student good at planning is awarded the Dean's List.",
    "output": "∀x (Planning(x) → ¬Award(x))"
  },
  {
    "input": "Translate into first-order logic: James is either good at chemistry and awarded the Dean's List, or neither good at chemistry nor awarded the Dean's List.",
    "output": "¬(Chemistry(james) ⊕ Award(james))"
  },
  {
    "input": "Translate into first-order logic: Some students good at math are good at chemistry.",
    "output": "∃x (Math(x) ∧ Chemistry(x))"
  },
  {
    "input": "Translate into first-order logic: All students good at chemistry enjoy conducting experiments.",
    "output": "∀x (Chemistry(x) → Experiment(x))"
  },
  {
    "input": "Translate into first-order logic: All students that enjoy conducting experiments are good at planning.",
    "output": "∀x (Experiment(x) → Planning(x))"
  },
  {
    "input": "Translate into first-order logic: No student good at planning is awarded the Dean's List.",
    "output": "∀x (Planning(x) → ¬Award(x))"
  },
  {
    "input": "Translate into first-order logic: James is either good at chemistry and awarded the Dean's List, or neither good at chemistry nor awarded the Dean's List.",
    "output": "¬(Chemistry(james) ⊕ Award(james))"
  },
  {
    "input": "Translate into first-order logic: Some students good at math are good at chemistry.",
    "output": "∃x (Math(x) ∧ Chemistry(x))"
  },
  {
    "input": "Translate into first-order logic: All students good at chemistry enjoy conducting experiments.",
    "output": "∀x (Chemistry(x) → Experiment(x))"
  },
  {
    "input": "Translate into first-order logic: All students that enjoy conducting experiments are good at planning.",
    "output": "∀x (Experiment(x) → Planning(x))"
  },
  {
    "input": "Translate into first-order logic: No student good at planning is awarded the Dean's List.",
    "output": "∀x (Planning(x) → ¬Award(x))"
  },
  {
    "input": "Translate into first-order logic: James is either good at chemistry and awarded the Dean's List, or neither good at chemistry nor awarded the Dean's List.",
    "output": "¬(Chemistry(james) ⊕ Award(james))"
  },
  {
    "input": "Translate into first-order logic: Some students good at math are good at chemistry.",
    "output": "∃x (Math(x) ∧ Chemistry(x))"
  },
  {
    "input": "Translate into first-order logic: All students good at chemistry enjoy conducting experiments.",
    "output": "∀x (Chemistry(x) → Experiment(x))"
  },
  {
    "input": "Translate into first-order logic: All students that enjoy conducting experiments are good at planning.",
    "output": "∀x (Experiment(x) → Planning(x))"
  },
  {
    "input": "Translate into first-order logic: No student good at planning is awarded the Dean's List.",
    "output": "∀x (Planning(x) → ¬Award(x))"
  },
  {
    "input": "Translate into first-order logic: James is either good at chemistry and awarded the Dean's List, or neither good at chemistry nor awarded the Dean's List.",
    "output": "¬(Chemistry(james) ⊕ Award(james))"
  },
  {
    "input": "Translate into first-order logic: If a Leetcode problem is at the easy level, then its AC rate is lower than 20 percent.",
    "output": "∀x (Easy(x) → LowerAC(x))"
  },
  {
    "input": "Translate into first-order logic: All Leetcode problems that are recommended to novices are easy.",
    "output": "∀x (Recommended(x) → Easy(x))"
  },
  {
    "input": "Translate into first-order logic: A Leetode problem is either easy or hard.",
    "output": "∀x (Easy(x) ⊕ Hard(x))"
  },
  {
    "input": "Translate into first-order logic: Leetcode problems that are starred by more than 1 thousand users are hard.",
    "output": "∀x (Starred(x) → Hard(x))"
  },
  {
    "input": "Translate into first-order logic: 2Sum is recommended to novices.",
    "output": "Recommended(twosum) "
  },
  {
    "input": "Translate into first-order logic: 4Sum is starred by more than 1 thousand users.",
    "output": "Starred(foursum)"
  },
  {
    "input": "Translate into first-order logic: If a Leetcode problem is at the easy level, then its AC rate is lower than 20 percent.",
    "output": "∀x (Easy(x) → LowerAC(x))"
  },
  {
    "input": "Translate into first-order logic: All Leetcode problems that are recommended to novices are easy.",
    "output": "∀x (Recommended(x) → Easy(x))"
  },
  {
    "input": "Translate into first-order logic: A Leetode problem is either easy or hard.",
    "output": "∀x (Easy(x) ⊕ Hard(x))"
  },
  {
    "input": "Translate into first-order logic: Leetcode problems that are starred by more than 1 thousand users are hard.",
    "output": "∀x (Starred(x) → Hard(x))"
  },
  {
    "input": "Translate into first-order logic: 2Sum is recommended to novices.",
    "output": "Recommended(twosum) "
  },
  {
    "input": "Translate into first-order logic: 4Sum is starred by more than 1 thousand users.",
    "output": "Starred(foursum)"
  },
  {
    "input": "Translate into first-order logic: If a Leetcode problem is at the easy level, then its AC rate is lower than 20 percent.",
    "output": "∀x (Easy(x) → LowerAC(x))"
  },
  {
    "input": "Translate into first-order logic: All Leetcode problems that are recommended to novices are easy.",
    "output": "∀x (Recommended(x) → Easy(x))"
  },
  {
    "input": "Translate into first-order logic: A Leetode problem is either easy or hard.",
    "output": "∀x (Easy(x) ⊕ Hard(x))"
  },
  {
    "input": "Translate into first-order logic: Leetcode problems that are starred by more than 1 thousand users are hard.",
    "output": "∀x (Starred(x) → Hard(x))"
  },
  {
    "input": "Translate into first-order logic: 2Sum is recommended to novices.",
    "output": "Recommended(twosum) "
  },
  {
    "input": "Translate into first-order logic: 4Sum is starred by more than 1 thousand users.",
    "output": "Starred(foursum)"
  },
  {
    "input": "Translate into first-order logic: All rental cars cost the renter money.",
    "output": "∀x (Rent(x, car) → Spend(x, money))"
  },
  {
    "input": "Translate into first-order logic: Whenever Sarah goes to Vermont, Sarah drives there.",
    "output": "GoesTo(sarah, vermont) → DriveTo(sarah, vermont)"
  },
  {
    "input": "Translate into first-order logic: For someone who does not own a car to drive somewhere, they must either borrow a car or rent a car.",
    "output": "∀x ∀y (¬Own(x, car) ∧ DriveTo(x, y) → Borrow(x, car) ⊕ Rent(x, car))"
  },
  {
    "input": "Translate into first-order logic: Sarah doesn’t own a car.",
    "output": "¬Own(sarah, car)"
  },
  {
    "input": "Translate into first-order logic: Sarah never borrows a car to go camping.",
    "output": "∀x (Camping(sarah, x) → ¬(Borrow(sarah, car)))"
  },
  {
    "input": "Translate into first-order logic: Sarah is going to go camping in Vermont this weekend.",
    "output": "Camping(sarah, vermont)"
  },
  {
    "input": "Translate into first-order logic: To go camping somewhere, you must go to that place.",
    "output": "∀x ∀y (Camping(x, y) → GoesTo(x, y))"
  },
  {
    "input": "Translate into first-order logic: All people who attend weddings are getting married or have friends who are getting married.",
    "output": "∀x Weddings(x) → GettingMarried(x)"
  },
  {
    "input": "Translate into first-order logic: No preteens and other young children are getting married or have friends who are getting married.",
    "output": "∀x PreTeen(x) → ¬GettingMarried(x)"
  },
  {
    "input": "Translate into first-order logic: If people enjoy celebrating life milestone events with other people, then they attend weddings.",
    "output": "∀x Celebrating(x) → Weddings(x)"
  },
  {
    "input": "Translate into first-order logic: If people are fond of large organized group functions, then they enjoy celebrating life milestone events with other people.",
    "output": "∀x LargeGathering(x) → Celebrating(x)"
  },
  {
    "input": "Translate into first-order logic: All people who are outgoing and very spirited are fond of large organized group functions.",
    "output": "∀x Outgoing(x) → LargeGathering(x)"
  },
  {
    "input": "Translate into first-order logic: If Carol is not both a pre-teen or other young child and attends weddings, then Carol is not getting married or has friends who are getting married.",
    "output": "¬(PreTeen(Carol) ∧ Weddings(Carol)) → ¬GettingMarried(Carol)"
  },
  {
    "input": "Translate into first-order logic: All people who attend weddings are getting married or have friends who are getting married.",
    "output": "∀x Weddings(x) → GettingMarried(x)"
  },
  {
    "input": "Translate into first-order logic: No preteens and other young children are getting married or have friends who are getting married.",
    "output": "∀x PreTeen(x) → ¬GettingMarried(x)"
  },
  {
    "input": "Translate into first-order logic: If people enjoy celebrating life milestone events with other people, then they attend weddings.",
    "output": "∀x Celebrating(x) → Weddings(x)"
  },
  {
    "input": "Translate into first-order logic: If people are fond of large organized group functions, then they enjoy celebrating life milestone events with other people.",
    "output": "∀x LargeGathering(x) → Celebrating(x)"
  },
  {
    "input": "Translate into first-order logic: All people who are outgoing and very spirited are fond of large organized group functions.",
    "output": "∀x Outgoing(x) → LargeGathering(x)"
  },
  {
    "input": "Translate into first-order logic: If Carol is not both a pre-teen or other young child and attends weddings, then Carol is not getting married or has friends who are getting married.",
    "output": "¬(PreTeen(Carol) ∧ Weddings(Carol)) → ¬GettingMarried(Carol)"
  },
  {
    "input": "Translate into first-order logic: All people who attend weddings are getting married or have friends who are getting married.",
    "output": "∀x Weddings(x) → GettingMarried(x)"
  },
  {
    "input": "Translate into first-order logic: No preteens and other young children are getting married or have friends who are getting married.",
    "output": "∀x PreTeen(x) → ¬GettingMarried(x)"
  },
  {
    "input": "Translate into first-order logic: If people enjoy celebrating life milestone events with other people, then they attend weddings.",
    "output": "∀x Celebrating(x) → Weddings(x)"
  },
  {
    "input": "Translate into first-order logic: If people are fond of large organized group functions, then they enjoy celebrating life milestone events with other people.",
    "output": "∀x LargeGathering(x) → Celebrating(x)"
  },
  {
    "input": "Translate into first-order logic: All people who are outgoing and very spirited are fond of large organized group functions.",
    "output": "∀x Outgoing(x) → LargeGathering(x)"
  },
  {
    "input": "Translate into first-order logic: If Carol is not both a pre-teen or other young child and attends weddings, then Carol is not getting married or has friends who are getting married.",
    "output": "¬(PreTeen(Carol) ∧ Weddings(Carol)) → ¬GettingMarried(Carol)"
  },
  {
    "input": "Translate into first-order logic: All Republicans are anti-abortion.",
    "output": "∀x (Republicans(x) → Anti-abortion(x))"
  },
  {
    "input": "Translate into first-order logic: Either Republicans or Democrats.",
    "output": " ∀x (Republicans(x) ∨ Democrats(x))"
  },
  {
    "input": "Translate into first-order logic: No Democrats are conservative.",
    "output": " ∀x (Democrats(x) → ¬Conservative(x))"
  },
  {
    "input": "Translate into first-order logic: Either conservative or liberal.",
    "output": " ∀x (Conservative(x) ∨ Liberal(x))"
  },
  {
    "input": "Translate into first-order logic: A U.S government official is either conservative or a Republican.",
    "output": " Conservative(anU.SGovernmentOfficial) ⊕ Republicans(anU.SGovernmentOfficial)"
  },
  {
    "input": "Translate into first-order logic: All Republicans are anti-abortion.",
    "output": "∀x (Republicans(x) → Anti-abortion(x))"
  },
  {
    "input": "Translate into first-order logic: Either Republicans or Democrats.",
    "output": " ∀x (Republicans(x) ∨ Democrats(x))"
  },
  {
    "input": "Translate into first-order logic: No Democrats are conservative.",
    "output": " ∀x (Democrats(x) → ¬Conservative(x))"
  },
  {
    "input": "Translate into first-order logic: Either conservative or liberal.",
    "output": " ∀x (Conservative(x) ∨ Liberal(x))"
  },
  {
    "input": "Translate into first-order logic: A U.S government official is either conservative or a Republican.",
    "output": " Conservative(anU.SGovernmentOfficial) ⊕ Republicans(anU.SGovernmentOfficial)"
  },
  {
    "input": "Translate into first-order logic: All Republicans are anti-abortion.",
    "output": "∀x (Republicans(x) → Anti-abortion(x))"
  },
  {
    "input": "Translate into first-order logic: Either Republicans or Democrats.",
    "output": " ∀x (Republicans(x) ∨ Democrats(x))"
  },
  {
    "input": "Translate into first-order logic: No Democrats are conservative.",
    "output": " ∀x (Democrats(x) → ¬Conservative(x))"
  },
  {
    "input": "Translate into first-order logic: Either conservative or liberal.",
    "output": " ∀x (Conservative(x) ∨ Liberal(x))"
  },
  {
    "input": "Translate into first-order logic: A U.S government official is either conservative or a Republican.",
    "output": " Conservative(anU.SGovernmentOfficial) ⊕ Republicans(anU.SGovernmentOfficial)"
  },
  {
    "input": "Translate into first-order logic: All Republicans are anti-abortion.",
    "output": "∀x (Republicans(x) → Anti-abortion(x))"
  },
  {
    "input": "Translate into first-order logic: Either Republicans or Democrats.",
    "output": " ∀x (Republicans(x) ∨ Democrats(x))"
  },
  {
    "input": "Translate into first-order logic: No Democrats are conservative.",
    "output": " ∀x (Democrats(x) → ¬Conservative(x))"
  },
  {
    "input": "Translate into first-order logic: Either conservative or liberal.",
    "output": " ∀x (Conservative(x) ∨ Liberal(x))"
  },
  {
    "input": "Translate into first-order logic: A U.S government official is either conservative or a Republican.",
    "output": " Conservative(anU.SGovernmentOfficial) ⊕ Republicans(anU.SGovernmentOfficial)"
  },
  {
    "input": "Translate into first-order logic: All Republicans are anti-abortion.",
    "output": "∀x (Republicans(x) → Anti-abortion(x))"
  },
  {
    "input": "Translate into first-order logic: Either Republicans or Democrats.",
    "output": " ∀x (Republicans(x) ∨ Democrats(x))"
  },
  {
    "input": "Translate into first-order logic: No Democrats are conservative.",
    "output": " ∀x (Democrats(x) → ¬Conservative(x))"
  },
  {
    "input": "Translate into first-order logic: Either conservative or liberal.",
    "output": " ∀x (Conservative(x) ∨ Liberal(x))"
  },
  {
    "input": "Translate into first-order logic: A U.S government official is either conservative or a Republican.",
    "output": " Conservative(anU.SGovernmentOfficial) ⊕ Republicans(anU.SGovernmentOfficial)"
  },
  {
    "input": "Translate into first-order logic: All Republicans are anti-abortion.",
    "output": "∀x (Republicans(x) → Anti-abortion(x))"
  },
  {
    "input": "Translate into first-order logic: Either Republicans or Democrats.",
    "output": " ∀x (Republicans(x) ∨ Democrats(x))"
  },
  {
    "input": "Translate into first-order logic: No Democrats are conservative.",
    "output": " ∀x (Democrats(x) → ¬Conservative(x))"
  },
  {
    "input": "Translate into first-order logic: Either conservative or liberal.",
    "output": " ∀x (Conservative(x) ∨ Liberal(x))"
  },
  {
    "input": "Translate into first-order logic: A U.S government official is either conservative or a Republican.",
    "output": " Conservative(anU.SGovernmentOfficial) ⊕ Republicans(anU.SGovernmentOfficial)"
  },
  {
    "input": "Translate into first-order logic: All Republicans are anti-abortion.",
    "output": "∀x (Republicans(x) → Anti-abortion(x))"
  },
  {
    "input": "Translate into first-order logic: Either Republicans or Democrats.",
    "output": " ∀x (Republicans(x) ∨ Democrats(x))"
  },
  {
    "input": "Translate into first-order logic: No Democrats are conservative.",
    "output": " ∀x (Democrats(x) → ¬Conservative(x))"
  },
  {
    "input": "Translate into first-order logic: Either conservative or liberal.",
    "output": " ∀x (Conservative(x) ∨ Liberal(x))"
  },
  {
    "input": "Translate into first-order logic: A U.S government official is either conservative or a Republican.",
    "output": " Conservative(anU.SGovernmentOfficial) ⊕ Republicans(anU.SGovernmentOfficial)"
  },
  {
    "input": "Translate into first-order logic: All Republicans are anti-abortion.",
    "output": "∀x (Republicans(x) → Anti-abortion(x))"
  },
  {
    "input": "Translate into first-order logic: Either Republicans or Democrats.",
    "output": " ∀x (Republicans(x) ∨ Democrats(x))"
  },
  {
    "input": "Translate into first-order logic: No Democrats are conservative.",
    "output": " ∀x (Democrats(x) → ¬Conservative(x))"
  },
  {
    "input": "Translate into first-order logic: Either conservative or liberal.",
    "output": " ∀x (Conservative(x) ∨ Liberal(x))"
  },
  {
    "input": "Translate into first-order logic: A U.S government official is either conservative or a Republican.",
    "output": " Conservative(anU.SGovernmentOfficial) ⊕ Republicans(anU.SGovernmentOfficial)"
  },
  {
    "input": "Translate into first-order logic: All advocates of high tariff rates are Republicans.",
    "output": "∀x (AdvocateOfHighTariff(x) → Republican(x))"
  },
  {
    "input": "Translate into first-order logic: Some Republicans are not conservatives.",
    "output": "∃x (Republican(x) ∧ ¬Conservative(x))"
  },
  {
    "input": "Translate into first-order logic: No athletes are slow runners.",
    "output": "∀x (Athlete(x) → ¬SlowRunner(x))"
  },
  {
    "input": "Translate into first-order logic: All professional basketball players are athletes.",
    "output": "∀x (ProfessionalBasketballPlayer(x) → Athlete(x))"
  },
  {
    "input": "Translate into first-order logic: All NBA players are professional basketball players.",
    "output": "∀x (NBAPlayer(x) → ProfessionalBasketballPlayer(x))"
  },
  {
    "input": "Translate into first-order logic: All Knicks players are NBA players.",
    "output": "∀x (KnicksPlayer(x) → NBAPlayer(x))"
  },
  {
    "input": "Translate into first-order logic: Jim is either not a professional basketball player or not a slow runner.",
    "output": "¬(ProfessionalBasketballPlayer(jim) ⊕ SlowRunner(jim))"
  },
  {
    "input": "Translate into first-order logic: No athletes are slow runners.",
    "output": "∀x (Athlete(x) → ¬SlowRunner(x))"
  },
  {
    "input": "Translate into first-order logic: All professional basketball players are athletes.",
    "output": "∀x (ProfessionalBasketballPlayer(x) → Athlete(x))"
  },
  {
    "input": "Translate into first-order logic: All NBA players are professional basketball players.",
    "output": "∀x (NBAPlayer(x) → ProfessionalBasketballPlayer(x))"
  },
  {
    "input": "Translate into first-order logic: All Knicks players are NBA players.",
    "output": "∀x (KnicksPlayer(x) → NBAPlayer(x))"
  },
  {
    "input": "Translate into first-order logic: Jim is either not a professional basketball player or not a slow runner.",
    "output": "¬(ProfessionalBasketballPlayer(jim) ⊕ SlowRunner(jim))"
  },
  {
    "input": "Translate into first-order logic: No athletes are slow runners.",
    "output": "∀x (Athlete(x) → ¬SlowRunner(x))"
  },
  {
    "input": "Translate into first-order logic: All professional basketball players are athletes.",
    "output": "∀x (ProfessionalBasketballPlayer(x) → Athlete(x))"
  },
  {
    "input": "Translate into first-order logic: All NBA players are professional basketball players.",
    "output": "∀x (NBAPlayer(x) → ProfessionalBasketballPlayer(x))"
  },
  {
    "input": "Translate into first-order logic: All Knicks players are NBA players.",
    "output": "∀x (KnicksPlayer(x) → NBAPlayer(x))"
  },
  {
    "input": "Translate into first-order logic: Jim is either not a professional basketball player or not a slow runner.",
    "output": "¬(ProfessionalBasketballPlayer(jim) ⊕ SlowRunner(jim))"
  },
  {
    "input": "Translate into first-order logic: All kids love animals.",
    "output": "∀x (Kid(x) → LoveAnimals(x))"
  },
  {
    "input": "Translate into first-order logic: All toddlers are kids.",
    "output": "∀x (Toddler(x) → Kid(x))"
  },
  {
    "input": "Translate into first-order logic: If someone loves animals, then they are not bad.",
    "output": "∀x (LoveAnimals(x) → ¬Bad(x))"
  },
  {
    "input": "Translate into first-order logic: All pirates are bad.",
    "output": "∀x (Pirate(x) → Bad(x))"
  },
  {
    "input": "Translate into first-order logic: If Nancy is not a pirate, then Nancy loves animals.",
    "output": "¬Pirate(nancy) → LoveAnimals(nancy)"
  },
  {
    "input": "Translate into first-order logic: If Nancy is not a toddler, then Nancy is bad.",
    "output": "¬Toddler(nancy) → Bad(nancy)"
  },
  {
    "input": "Translate into first-order logic: All kids love animals.",
    "output": "∀x (Kid(x) → LoveAnimals(x))"
  },
  {
    "input": "Translate into first-order logic: All toddlers are kids.",
    "output": "∀x (Toddler(x) → Kid(x))"
  },
  {
    "input": "Translate into first-order logic: If someone loves animals, then they are not bad.",
    "output": "∀x (LoveAnimals(x) → ¬Bad(x))"
  },
  {
    "input": "Translate into first-order logic: All pirates are bad.",
    "output": "∀x (Pirate(x) → Bad(x))"
  },
  {
    "input": "Translate into first-order logic: If Nancy is not a pirate, then Nancy loves animals.",
    "output": "¬Pirate(nancy) → LoveAnimals(nancy)"
  },
  {
    "input": "Translate into first-order logic: If Nancy is not a toddler, then Nancy is bad.",
    "output": "¬Toddler(nancy) → Bad(nancy)"
  },
  {
    "input": "Translate into first-order logic: All kids love animals.",
    "output": "∀x (Kid(x) → LoveAnimals(x))"
  },
  {
    "input": "Translate into first-order logic: All toddlers are kids.",
    "output": "∀x (Toddler(x) → Kid(x))"
  },
  {
    "input": "Translate into first-order logic: If someone loves animals, then they are not bad.",
    "output": "∀x (LoveAnimals(x) → ¬Bad(x))"
  },
  {
    "input": "Translate into first-order logic: All pirates are bad.",
    "output": "∀x (Pirate(x) → Bad(x))"
  },
  {
    "input": "Translate into first-order logic: If Nancy is not a pirate, then Nancy loves animals.",
    "output": "¬Pirate(nancy) → LoveAnimals(nancy)"
  },
  {
    "input": "Translate into first-order logic: If Nancy is not a toddler, then Nancy is bad.",
    "output": "¬Toddler(nancy) → Bad(nancy)"
  },
  {
    "input": "Translate into first-order logic: Lana Wilson directed After Tiller, The Departure, and Miss Americana.",
    "output": "DirectedBy(after_Tiller, lana_Wilson) ∧ DirectedBy(the_Departure, lana_Wilson) ∧ DirectedBy(miss_Americana, lana_Wilson)"
  },
  {
    "input": "Translate into first-order logic: If a film is directedy by a person, the person is a filmmaker.",
    "output": "∀x ∃y (DirectedBy(y, x) → Filmmaker(x))"
  },
  {
    "input": "Translate into first-order logic: After Tiller is a documentary.",
    "output": "IsDocumentary(after_Tiller)"
  },
  {
    "input": "Translate into first-order logic: The documentary is a type of films.",
    "output": "∀x (IsDocumentary(x) → IsFilm(x))"
  },
  {
    "input": "Translate into first-order logic: Lana Wilson is from Kirkland.",
    "output": "FromCity(lana_Wilson, kirkland)"
  },
  {
    "input": "Translate into first-order logic: Kirkland is a US city.",
    "output": "CityCountry(kirkland, us)"
  },
  {
    "input": "Translate into first-order logic: If a person is from a city in a country, the person is from the country.",
    "output": "∀x ∀y ∀z (FromCity(x, y) ∧ CityCountry(y, z) → FromCountry(x, z))"
  },
  {
    "input": "Translate into first-order logic: After Tiller is nominated for the Independent Spirit Award for Best Documentary.",
    "output": "Nomination(after_Tiller, the_Independent_Spirit_Award_for_Best_Documentary)"
  },
  {
    "input": "Translate into first-order logic: Lana Wilson directed After Tiller, The Departure, and Miss Americana.",
    "output": "DirectedBy(after_Tiller, lana_Wilson) ∧ DirectedBy(the_Departure, lana_Wilson) ∧ DirectedBy(miss_Americana, lana_Wilson)"
  },
  {
    "input": "Translate into first-order logic: If a film is directedy by a person, the person is a filmmaker.",
    "output": "∀x ∃y (DirectedBy(y, x) → Filmmaker(x))"
  },
  {
    "input": "Translate into first-order logic: After Tiller is a documentary.",
    "output": "IsDocumentary(after_Tiller)"
  },
  {
    "input": "Translate into first-order logic: The documentary is a type of films.",
    "output": "∀x (IsDocumentary(x) → IsFilm(x))"
  },
  {
    "input": "Translate into first-order logic: Lana Wilson is from Kirkland.",
    "output": "FromCity(lana_Wilson, kirkland)"
  },
  {
    "input": "Translate into first-order logic: Kirkland is a US city.",
    "output": "CityCountry(kirkland, us)"
  },
  {
    "input": "Translate into first-order logic: If a person is from a city in a country, the person is from the country.",
    "output": "∀x ∀y ∀z (FromCity(x, y) ∧ CityCountry(y, z) → FromCountry(x, z))"
  },
  {
    "input": "Translate into first-order logic: After Tiller is nominated for the Independent Spirit Award for Best Documentary.",
    "output": "Nomination(after_Tiller, the_Independent_Spirit_Award_for_Best_Documentary)"
  },
  {
    "input": "Translate into first-order logic: Lana Wilson directed After Tiller, The Departure, and Miss Americana.",
    "output": "DirectedBy(after_Tiller, lana_Wilson) ∧ DirectedBy(the_Departure, lana_Wilson) ∧ DirectedBy(miss_Americana, lana_Wilson)"
  },
  {
    "input": "Translate into first-order logic: If a film is directedy by a person, the person is a filmmaker.",
    "output": "∀x ∃y (DirectedBy(y, x) → Filmmaker(x))"
  },
  {
    "input": "Translate into first-order logic: After Tiller is a documentary.",
    "output": "IsDocumentary(after_Tiller)"
  },
  {
    "input": "Translate into first-order logic: The documentary is a type of films.",
    "output": "∀x (IsDocumentary(x) → IsFilm(x))"
  },
  {
    "input": "Translate into first-order logic: Lana Wilson is from Kirkland.",
    "output": "FromCity(lana_Wilson, kirkland)"
  },
  {
    "input": "Translate into first-order logic: Kirkland is a US city.",
    "output": "CityCountry(kirkland, us)"
  },
  {
    "input": "Translate into first-order logic: If a person is from a city in a country, the person is from the country.",
    "output": "∀x ∀y ∀z (FromCity(x, y) ∧ CityCountry(y, z) → FromCountry(x, z))"
  },
  {
    "input": "Translate into first-order logic: After Tiller is nominated for the Independent Spirit Award for Best Documentary.",
    "output": "Nomination(after_Tiller, the_Independent_Spirit_Award_for_Best_Documentary)"
  },
  {
    "input": "Translate into first-order logic: All bears in zoos are not wild.",
    "output": "∀x ((Bear(x) ∧ InZoo(x)) → ¬Wild(x))"
  },
  {
    "input": "Translate into first-order logic: Some bears are in zoos.",
    "output": "∃x (Bear(x) ∧ InZoo(x)) "
  },
  {
    "input": "Translate into first-order logic: If a person is the leader of a country for life, that person is in a monarchy.",
    "output": "∀x (Leader(x) → InMonarchy(x))"
  },
  {
    "input": "Translate into first-order logic: Leaders are either a king or a queen.",
    "output": "∀x (Leader(x) → King(x) ⊕ Queen(x))"
  },
  {
    "input": "Translate into first-order logic: Queens are female.",
    "output": "∀x (Queen(x) → Female(x))"
  },
  {
    "input": "Translate into first-order logic: Kings are male.",
    "output": "∀x (King(x) → Male(x))"
  },
  {
    "input": "Translate into first-order logic: Elizabeth is a queen.",
    "output": "Queen(elizabeth)"
  },
  {
    "input": "Translate into first-order logic: Elizabeth is a leader",
    "output": "Leader(elizabeth)"
  },
  {
    "input": "Translate into first-order logic: If a person is the leader of a country for life, that person is in a monarchy.",
    "output": "∀x (Leader(x) → InMonarchy(x))"
  },
  {
    "input": "Translate into first-order logic: Leaders are either a king or a queen.",
    "output": "∀x (Leader(x) → King(x) ⊕ Queen(x))"
  },
  {
    "input": "Translate into first-order logic: Queens are female.",
    "output": "∀x (Queen(x) → Female(x))"
  },
  {
    "input": "Translate into first-order logic: Kings are male.",
    "output": "∀x (King(x) → Male(x))"
  },
  {
    "input": "Translate into first-order logic: Elizabeth is a queen.",
    "output": "Queen(elizabeth)"
  },
  {
    "input": "Translate into first-order logic: Elizabeth is a leader",
    "output": "Leader(elizabeth)"
  },
  {
    "input": "Translate into first-order logic: If a person is the leader of a country for life, that person is in a monarchy.",
    "output": "∀x (Leader(x) → InMonarchy(x))"
  },
  {
    "input": "Translate into first-order logic: Leaders are either a king or a queen.",
    "output": "∀x (Leader(x) → King(x) ⊕ Queen(x))"
  },
  {
    "input": "Translate into first-order logic: Queens are female.",
    "output": "∀x (Queen(x) → Female(x))"
  },
  {
    "input": "Translate into first-order logic: Kings are male.",
    "output": "∀x (King(x) → Male(x))"
  },
  {
    "input": "Translate into first-order logic: Elizabeth is a queen.",
    "output": "Queen(elizabeth)"
  },
  {
    "input": "Translate into first-order logic: Elizabeth is a leader",
    "output": "Leader(elizabeth)"
  },
  {
    "input": "Translate into first-order logic: If people make their own matcha teas every morning with ceremonial-grade matcha powder, then they do not wake up late and start their schedules past noon regularly.",
    "output": "∀x (Matcha(x) → ¬Late(x))"
  },
  {
    "input": "Translate into first-order logic: If people live in California and attend yoga classes regularly, then they make their own matcha teas every morning with ceremonial-grade matcha powder.",
    "output": "∀x (California(x) → Matcha(x))"
  },
  {
    "input": "Translate into first-order logic: If people work in the entertainment industry as high-profile celebrities, then they wake up late and start their schedules past noon regularly.",
    "output": "∀x (Celebrities(x) → Late(x))"
  },
  {
    "input": "Translate into first-order logic: If people do not have regular 9-5 jobs, then they work in the entertainment industry as high-profile celebrities.",
    "output": "∀x (Jobs(x) → Celebrities(x))"
  },
  {
    "input": "Translate into first-order logic: All people who prefer working at home over going to the office every day do not have regular 9-5 jobs.",
    "output": "∀x (WorkHome(x) → Jobs(x))"
  },
  {
    "input": "Translate into first-order logic: Clay either both prefers to work at home over going to the office every day and makes his own matcha teas every morning with ceremonial-grade matcha powder, or he neither prefers to work at home over going to the office every day nor makes his own matcha teas every morning with ceremonial-grade matcha powder.",
    "output": "(WorkHome(clay) ∧ Matcha(clay)) ⊕ (¬WorkHome(clay) ∧ ¬Matcha(clay))"
  },
  {
    "input": "Translate into first-order logic: If people make their own matcha teas every morning with ceremonial-grade matcha powder, then they do not wake up late and start their schedules past noon regularly.",
    "output": "∀x (Matcha(x) → ¬Late(x))"
  },
  {
    "input": "Translate into first-order logic: If people live in California and attend yoga classes regularly, then they make their own matcha teas every morning with ceremonial-grade matcha powder.",
    "output": "∀x (California(x) → Matcha(x))"
  },
  {
    "input": "Translate into first-order logic: If people work in the entertainment industry as high-profile celebrities, then they wake up late and start their schedules past noon regularly.",
    "output": "∀x (Celebrities(x) → Late(x))"
  },
  {
    "input": "Translate into first-order logic: If people do not have regular 9-5 jobs, then they work in the entertainment industry as high-profile celebrities.",
    "output": "∀x (Jobs(x) → Celebrities(x))"
  },
  {
    "input": "Translate into first-order logic: All people who prefer working at home over going to the office every day do not have regular 9-5 jobs.",
    "output": "∀x (WorkHome(x) → Jobs(x))"
  },
  {
    "input": "Translate into first-order logic: Clay either both prefers to work at home over going to the office every day and makes his own matcha teas every morning with ceremonial-grade matcha powder, or he neither prefers to work at home over going to the office every day nor makes his own matcha teas every morning with ceremonial-grade matcha powder.",
    "output": "(WorkHome(clay) ∧ Matcha(clay)) ⊕ (¬WorkHome(clay) ∧ ¬Matcha(clay))"
  },
  {
    "input": "Translate into first-order logic: If people make their own matcha teas every morning with ceremonial-grade matcha powder, then they do not wake up late and start their schedules past noon regularly.",
    "output": "∀x (Matcha(x) → ¬Late(x))"
  },
  {
    "input": "Translate into first-order logic: If people live in California and attend yoga classes regularly, then they make their own matcha teas every morning with ceremonial-grade matcha powder.",
    "output": "∀x (California(x) → Matcha(x))"
  },
  {
    "input": "Translate into first-order logic: If people work in the entertainment industry as high-profile celebrities, then they wake up late and start their schedules past noon regularly.",
    "output": "∀x (Celebrities(x) → Late(x))"
  },
  {
    "input": "Translate into first-order logic: If people do not have regular 9-5 jobs, then they work in the entertainment industry as high-profile celebrities.",
    "output": "∀x (Jobs(x) → Celebrities(x))"
  },
  {
    "input": "Translate into first-order logic: All people who prefer working at home over going to the office every day do not have regular 9-5 jobs.",
    "output": "∀x (WorkHome(x) → Jobs(x))"
  },
  {
    "input": "Translate into first-order logic: Clay either both prefers to work at home over going to the office every day and makes his own matcha teas every morning with ceremonial-grade matcha powder, or he neither prefers to work at home over going to the office every day nor makes his own matcha teas every morning with ceremonial-grade matcha powder.",
    "output": "(WorkHome(clay) ∧ Matcha(clay)) ⊕ (¬WorkHome(clay) ∧ ¬Matcha(clay))"
  },
  {
    "input": "Translate into first-order logic: Thomas Barber was an English professional footballer.",
    "output": "English(thomasBarber) ∧ ProfessionalFootballer(thomasBarber)"
  },
  {
    "input": "Translate into first-order logic: Thomas Barber played in the Football League for Aston Villa.",
    "output": "PlayedInTheFootballLeagueFor(thomasBarber, astonVilla)"
  },
  {
    "input": "Translate into first-order logic: Thomas Barber played as a half back and inside left.",
    "output": "PlayedAs(thomasBarber, aHalfBack) ∧ PlayedAs(thomasBarber, anInsideLeft)"
  },
  {
    "input": "Translate into first-order logic: Thomas Barber scored the winning goal in the 1913 FA Cup Final.",
    "output": "ScoredTheWinningGoalIn(thomasBarber, facupfinal1913)"
  },
  {
    "input": "Translate into first-order logic: Thomas Barber was an English professional footballer.",
    "output": "English(thomasBarber) ∧ ProfessionalFootballer(thomasBarber)"
  },
  {
    "input": "Translate into first-order logic: Thomas Barber played in the Football League for Aston Villa.",
    "output": "PlayedInTheFootballLeagueFor(thomasBarber, astonVilla)"
  },
  {
    "input": "Translate into first-order logic: Thomas Barber played as a half back and inside left.",
    "output": "PlayedAs(thomasBarber, aHalfBack) ∧ PlayedAs(thomasBarber, anInsideLeft)"
  },
  {
    "input": "Translate into first-order logic: Thomas Barber scored the winning goal in the 1913 FA Cup Final.",
    "output": "ScoredTheWinningGoalIn(thomasBarber, facupfinal1913)"
  },
  {
    "input": "Translate into first-order logic: Thomas Barber was an English professional footballer.",
    "output": "English(thomasBarber) ∧ ProfessionalFootballer(thomasBarber)"
  },
  {
    "input": "Translate into first-order logic: Thomas Barber played in the Football League for Aston Villa.",
    "output": "PlayedInTheFootballLeagueFor(thomasBarber, astonVilla)"
  },
  {
    "input": "Translate into first-order logic: Thomas Barber played as a half back and inside left.",
    "output": "PlayedAs(thomasBarber, aHalfBack) ∧ PlayedAs(thomasBarber, anInsideLeft)"
  },
  {
    "input": "Translate into first-order logic: Thomas Barber scored the winning goal in the 1913 FA Cup Final.",
    "output": "ScoredTheWinningGoalIn(thomasBarber, facupfinal1913)"
  },
  {
    "input": "Translate into first-order logic: If people play the instrument in the concert, then he is good at playing this kind of instrument.",
    "output": "∀y (∀x (PlayInConcert(y, x) → GoodAt(y, x)))"
  },
  {
    "input": "Translate into first-order logic: Peter plays piano, violin, and saxophone.",
    "output": "Play(peter, piano) ∧Play(peter, violin)"
  },
  {
    "input": "Translate into first-order logic: Peter was invited to play piano at the concert hall.",
    "output": "PlayInConcert(peter, piano)"
  },
  {
    "input": "Translate into first-order logic: Oliver and Peter were both invited to perform in the concert.",
    "output": "PlayerInConcert(peter) ∧ PlayerInConcert(oliver)"
  },
  {
    "input": "Translate into first-order logic: Oliver plays a different musical instrument from Peter in the concert.",
    "output": "¬PlayInConcert(oliver, piano)"
  },
  {
    "input": "Translate into first-order logic: If people play the instrument in the concert, then he is good at playing this kind of instrument.",
    "output": "∀y (∀x (PlayInConcert(y, x) → GoodAt(y, x)))"
  },
  {
    "input": "Translate into first-order logic: Peter plays piano, violin, and saxophone.",
    "output": "Play(peter, piano) ∧Play(peter, violin)"
  },
  {
    "input": "Translate into first-order logic: Peter was invited to play piano at the concert hall.",
    "output": "PlayInConcert(peter, piano)"
  },
  {
    "input": "Translate into first-order logic: Oliver and Peter were both invited to perform in the concert.",
    "output": "PlayerInConcert(peter) ∧ PlayerInConcert(oliver)"
  },
  {
    "input": "Translate into first-order logic: Oliver plays a different musical instrument from Peter in the concert.",
    "output": "¬PlayInConcert(oliver, piano)"
  },
  {
    "input": "Translate into first-order logic: If people play the instrument in the concert, then he is good at playing this kind of instrument.",
    "output": "∀y (∀x (PlayInConcert(y, x) → GoodAt(y, x)))"
  },
  {
    "input": "Translate into first-order logic: Peter plays piano, violin, and saxophone.",
    "output": "Play(peter, piano) ∧Play(peter, violin)"
  },
  {
    "input": "Translate into first-order logic: Peter was invited to play piano at the concert hall.",
    "output": "PlayInConcert(peter, piano)"
  },
  {
    "input": "Translate into first-order logic: Oliver and Peter were both invited to perform in the concert.",
    "output": "PlayerInConcert(peter) ∧ PlayerInConcert(oliver)"
  },
  {
    "input": "Translate into first-order logic: Oliver plays a different musical instrument from Peter in the concert.",
    "output": "¬PlayInConcert(oliver, piano)"
  },
  {
    "input": "Translate into first-order logic: If something can go underwater, then it enjoys water.",
    "output": "∀x (GoesUnderwater(x) → EnjoysWater(x))"
  },
  {
    "input": "Translate into first-order logic: All animals that can swim can go underwater.",
    "output": "∀x (CanSwim(x) → GoesUnderwater(x))"
  },
  {
    "input": "Translate into first-order logic: Either an animal can swim or it can walk.",
    "output": "∀x (CanSwim(x) ∨ CanWalk(x))"
  },
  {
    "input": "Translate into first-order logic: Animals that can walk travel on land.",
    "output": "∀x (CanWalk(x) → TravelsOnLand(x))"
  },
  {
    "input": "Translate into first-order logic: Animals that enjoy water splash water around.",
    "output": "∀x (EnjoysWater(x) → Splashes(x))"
  },
  {
    "input": "Translate into first-order logic: Every animal that travels on land enjoys basking in the sun.",
    "output": "∀x (TravelsOnLand(x) → EnjoysBasking(x))"
  },
  {
    "input": "Translate into first-order logic: George splashes water around and can swim.",
    "output": "Splashes(george) ∧ CanSwim(george)"
  },
  {
    "input": "Translate into first-order logic: Liam is either an animal that can walk and enjoys water, or is neither an animal that can walk nor enjoys water.",
    "output": "(CanWalk(liam) ∧ EnjoysWater(liam)) ∨ (¬CanWalk(liam) ∧ ¬EnjoysWater(liam))"
  },
  {
    "input": "Translate into first-order logic: If something can go underwater, then it enjoys water.",
    "output": "∀x (GoesUnderwater(x) → EnjoysWater(x))"
  },
  {
    "input": "Translate into first-order logic: All animals that can swim can go underwater.",
    "output": "∀x (CanSwim(x) → GoesUnderwater(x))"
  },
  {
    "input": "Translate into first-order logic: Either an animal can swim or it can walk.",
    "output": "∀x (CanSwim(x) ∨ CanWalk(x))"
  },
  {
    "input": "Translate into first-order logic: Animals that can walk travel on land.",
    "output": "∀x (CanWalk(x) → TravelsOnLand(x))"
  },
  {
    "input": "Translate into first-order logic: Animals that enjoy water splash water around.",
    "output": "∀x (EnjoysWater(x) → Splashes(x))"
  },
  {
    "input": "Translate into first-order logic: Every animal that travels on land enjoys basking in the sun.",
    "output": "∀x (TravelsOnLand(x) → EnjoysBasking(x))"
  },
  {
    "input": "Translate into first-order logic: George splashes water around and can swim.",
    "output": "Splashes(george) ∧ CanSwim(george)"
  },
  {
    "input": "Translate into first-order logic: Liam is either an animal that can walk and enjoys water, or is neither an animal that can walk nor enjoys water.",
    "output": "(CanWalk(liam) ∧ EnjoysWater(liam)) ∨ (¬CanWalk(liam) ∧ ¬EnjoysWater(liam))"
  },
  {
    "input": "Translate into first-order logic: If something can go underwater, then it enjoys water.",
    "output": "∀x (GoesUnderwater(x) → EnjoysWater(x))"
  },
  {
    "input": "Translate into first-order logic: All animals that can swim can go underwater.",
    "output": "∀x (CanSwim(x) → GoesUnderwater(x))"
  },
  {
    "input": "Translate into first-order logic: Either an animal can swim or it can walk.",
    "output": "∀x (CanSwim(x) ∨ CanWalk(x))"
  },
  {
    "input": "Translate into first-order logic: Animals that can walk travel on land.",
    "output": "∀x (CanWalk(x) → TravelsOnLand(x))"
  },
  {
    "input": "Translate into first-order logic: Animals that enjoy water splash water around.",
    "output": "∀x (EnjoysWater(x) → Splashes(x))"
  },
  {
    "input": "Translate into first-order logic: Every animal that travels on land enjoys basking in the sun.",
    "output": "∀x (TravelsOnLand(x) → EnjoysBasking(x))"
  },
  {
    "input": "Translate into first-order logic: George splashes water around and can swim.",
    "output": "Splashes(george) ∧ CanSwim(george)"
  },
  {
    "input": "Translate into first-order logic: Liam is either an animal that can walk and enjoys water, or is neither an animal that can walk nor enjoys water.",
    "output": "(CanWalk(liam) ∧ EnjoysWater(liam)) ∨ (¬CanWalk(liam) ∧ ¬EnjoysWater(liam))"
  },
  {
    "input": "Translate into first-order logic: Cancer biology is finding genetic alterations that confer selective advantage to cancer cells.",
    "output": "FindingGeneticAlterationsConferSelectiveAdvantageCancerCells(cancerBiology)"
  },
  {
    "input": "Translate into first-order logic: Cancer researchers have frequently ranked the importance of substitutions to cancer growth by P value.",
    "output": " PValue(cancerResearchers, theImportanceOfSubstitutionsToCancerGrowth)"
  },
  {
    "input": "Translate into first-order logic: P values are thresholds for belief, not metrics of effect.",
    "output": " ∀x (PValue(x) → ThresholdsForBelief(x) ∧ ¬MetricsOfEffect(x))"
  },
  {
    "input": "Translate into first-order logic: Cancer biology is finding genetic alterations that confer selective advantage to cancer cells.",
    "output": "FindingGeneticAlterationsConferSelectiveAdvantageCancerCells(cancerBiology)"
  },
  {
    "input": "Translate into first-order logic: Cancer researchers have frequently ranked the importance of substitutions to cancer growth by P value.",
    "output": " PValue(cancerResearchers, theImportanceOfSubstitutionsToCancerGrowth)"
  },
  {
    "input": "Translate into first-order logic: P values are thresholds for belief, not metrics of effect.",
    "output": " ∀x (PValue(x) → ThresholdsForBelief(x) ∧ ¬MetricsOfEffect(x))"
  },
  {
    "input": "Translate into first-order logic: Cancer biology is finding genetic alterations that confer selective advantage to cancer cells.",
    "output": "FindingGeneticAlterationsConferSelectiveAdvantageCancerCells(cancerBiology)"
  },
  {
    "input": "Translate into first-order logic: Cancer researchers have frequently ranked the importance of substitutions to cancer growth by P value.",
    "output": " PValue(cancerResearchers, theImportanceOfSubstitutionsToCancerGrowth)"
  },
  {
    "input": "Translate into first-order logic: P values are thresholds for belief, not metrics of effect.",
    "output": " ∀x (PValue(x) → ThresholdsForBelief(x) ∧ ¬MetricsOfEffect(x))"
  },
  {
    "input": "Translate into first-order logic: Cancer biology is finding genetic alterations that confer selective advantage to cancer cells.",
    "output": "FindingGeneticAlterationsConferSelectiveAdvantageCancerCells(cancerBiology)"
  },
  {
    "input": "Translate into first-order logic: Cancer researchers have frequently ranked the importance of substitutions to cancer growth by P value.",
    "output": " PValue(cancerResearchers, theImportanceOfSubstitutionsToCancerGrowth)"
  },
  {
    "input": "Translate into first-order logic: P values are thresholds for belief, not metrics of effect.",
    "output": " ∀x (PValue(x) → ThresholdsForBelief(x) ∧ ¬MetricsOfEffect(x))"
  },
  {
    "input": "Translate into first-order logic: All dispensable things are environment-friendly.",
    "output": "∀x (Dispensable(x) → EnvironmentFriendly(x))"
  },
  {
    "input": "Translate into first-order logic: All woodware is dispensable.",
    "output": "∀x (Woodware(x) → Dispensable(x))"
  },
  {
    "input": "Translate into first-order logic: All paper is woodware.",
    "output": "∀x (Paper(x) → Woodware(x))"
  },
  {
    "input": "Translate into first-order logic: No good things are bad.",
    "output": "∀x (Good(x) → ¬Bad(x))"
  },
  {
    "input": "Translate into first-order logic: All environment-friendly things are good.",
    "output": "∀x (EnvironmentFriendly(x) → Good(x))"
  },
  {
    "input": "Translate into first-order logic: A worksheet is either paper or is environment-friendly.",
    "output": "Paper(worksheet) ⊕ EnvironmentFriendly(worksheet)"
  },
  {
    "input": "Translate into first-order logic: All dispensable things are environment-friendly.",
    "output": "∀x (Dispensable(x) → EnvironmentFriendly(x))"
  },
  {
    "input": "Translate into first-order logic: All woodware is dispensable.",
    "output": "∀x (Woodware(x) → Dispensable(x))"
  },
  {
    "input": "Translate into first-order logic: All paper is woodware.",
    "output": "∀x (Paper(x) → Woodware(x))"
  },
  {
    "input": "Translate into first-order logic: No good things are bad.",
    "output": "∀x (Good(x) → ¬Bad(x))"
  },
  {
    "input": "Translate into first-order logic: All environment-friendly things are good.",
    "output": "∀x (EnvironmentFriendly(x) → Good(x))"
  },
  {
    "input": "Translate into first-order logic: A worksheet is either paper or is environment-friendly.",
    "output": "Paper(worksheet) ⊕ EnvironmentFriendly(worksheet)"
  },
  {
    "input": "Translate into first-order logic: All dispensable things are environment-friendly.",
    "output": "∀x (Dispensable(x) → EnvironmentFriendly(x))"
  },
  {
    "input": "Translate into first-order logic: All woodware is dispensable.",
    "output": "∀x (Woodware(x) → Dispensable(x))"
  },
  {
    "input": "Translate into first-order logic: All paper is woodware.",
    "output": "∀x (Paper(x) → Woodware(x))"
  },
  {
    "input": "Translate into first-order logic: No good things are bad.",
    "output": "∀x (Good(x) → ¬Bad(x))"
  },
  {
    "input": "Translate into first-order logic: All environment-friendly things are good.",
    "output": "∀x (EnvironmentFriendly(x) → Good(x))"
  },
  {
    "input": "Translate into first-order logic: A worksheet is either paper or is environment-friendly.",
    "output": "Paper(worksheet) ⊕ EnvironmentFriendly(worksheet)"
  },
  {
    "input": "Translate into first-order logic: All dispensable things are environment-friendly.",
    "output": "∀x (Dispensable(x) → EnvironmentFriendly(x))"
  },
  {
    "input": "Translate into first-order logic: All woodware is dispensable.",
    "output": "∀x (Woodware(x) → Dispensable(x))"
  },
  {
    "input": "Translate into first-order logic: All paper is woodware.",
    "output": "∀x (Paper(x) → Woodware(x))"
  },
  {
    "input": "Translate into first-order logic: No good things are bad.",
    "output": "∀x (Good(x) → ¬Bad(x))"
  },
  {
    "input": "Translate into first-order logic: All environment-friendly things are good.",
    "output": "∀x (EnvironmentFriendly(x) → Good(x))"
  },
  {
    "input": "Translate into first-order logic: A worksheet is either paper or is environment-friendly.",
    "output": "Paper(worksheet) ⊕ EnvironmentFriendly(worksheet)"
  },
  {
    "input": "Translate into first-order logic: No reptile has fur.",
    "output": "∀x (Reptile(x) → ¬HasFur(x))"
  },
  {
    "input": "Translate into first-order logic: All snakes are reptiles.",
    "output": "∀x (Snake(x) → Reptile(x))"
  },
  {
    "input": "Translate into first-order logic: All buildings in New Haven are low.",
    "output": "∀x (Located(newhaven, x) → ¬High(x))"
  },
  {
    "input": "Translate into first-order logic: All buildings managed by the Yale Housing are located in New Haven.",
    "output": "∀x (YaleHousing(x) → Located(newhaven, x))"
  },
  {
    "input": "Translate into first-order logic: All buildings in Manhattans are high.",
    "output": "∀x (Located(manhattans, x) → High(x))"
  },
  {
    "input": "Translate into first-order logic: All buildings owned by Bloomberg are located in Manhattans.",
    "output": "∀x (Bloomberg(x) → Located(manhattans, x))"
  },
  {
    "input": "Translate into first-order logic: All buildings with the Bloomberg logo are owned by Bloomberg.",
    "output": "∀x (BloombergLogo(x) → Bloomberg(x))"
  },
  {
    "input": "Translate into first-order logic: Tower A is managed by the Yale Housing.",
    "output": "YaleHousing(tower-a)"
  },
  {
    "input": "Translate into first-order logic: Tower B is with the Bloomberg logo.",
    "output": "BloombergLogo(tower-b)"
  },
  {
    "input": "Translate into first-order logic: All buildings in New Haven are low.",
    "output": "∀x (Located(newhaven, x) → ¬High(x))"
  },
  {
    "input": "Translate into first-order logic: All buildings managed by the Yale Housing are located in New Haven.",
    "output": "∀x (YaleHousing(x) → Located(newhaven, x))"
  },
  {
    "input": "Translate into first-order logic: All buildings in Manhattans are high.",
    "output": "∀x (Located(manhattans, x) → High(x))"
  },
  {
    "input": "Translate into first-order logic: All buildings owned by Bloomberg are located in Manhattans.",
    "output": "∀x (Bloomberg(x) → Located(manhattans, x))"
  },
  {
    "input": "Translate into first-order logic: All buildings with the Bloomberg logo are owned by Bloomberg.",
    "output": "∀x (BloombergLogo(x) → Bloomberg(x))"
  },
  {
    "input": "Translate into first-order logic: Tower A is managed by the Yale Housing.",
    "output": "YaleHousing(tower-a)"
  },
  {
    "input": "Translate into first-order logic: Tower B is with the Bloomberg logo.",
    "output": "BloombergLogo(tower-b)"
  },
  {
    "input": "Translate into first-order logic: All buildings in New Haven are low.",
    "output": "∀x (Located(newhaven, x) → ¬High(x))"
  },
  {
    "input": "Translate into first-order logic: All buildings managed by the Yale Housing are located in New Haven.",
    "output": "∀x (YaleHousing(x) → Located(newhaven, x))"
  },
  {
    "input": "Translate into first-order logic: All buildings in Manhattans are high.",
    "output": "∀x (Located(manhattans, x) → High(x))"
  },
  {
    "input": "Translate into first-order logic: All buildings owned by Bloomberg are located in Manhattans.",
    "output": "∀x (Bloomberg(x) → Located(manhattans, x))"
  },
  {
    "input": "Translate into first-order logic: All buildings with the Bloomberg logo are owned by Bloomberg.",
    "output": "∀x (BloombergLogo(x) → Bloomberg(x))"
  },
  {
    "input": "Translate into first-order logic: Tower A is managed by the Yale Housing.",
    "output": "YaleHousing(tower-a)"
  },
  {
    "input": "Translate into first-order logic: Tower B is with the Bloomberg logo.",
    "output": "BloombergLogo(tower-b)"
  },
  {
    "input": "Translate into first-order logic: No cold-blooded animals are birds.",
    "output": "∀x (ColdBlooded(x) → ¬Bird(x))"
  },
  {
    "input": "Translate into first-order logic: All reptiles are cold-blooded.",
    "output": "∀x (Reptile(x) → ColdBlooded(x))"
  },
  {
    "input": "Translate into first-order logic: Either an animal is a bird or it eats other animals.",
    "output": "∀x (Bird(x) ∨ EatOtherAnimals(x))"
  },
  {
    "input": "Translate into first-order logic: If an animal eats other animals, then it is a carnivore.",
    "output": "∀x (EatOtherAnimals(x) → Carnivore(x))"
  },
  {
    "input": "Translate into first-order logic: Ron is neither a cold-blooded animal nor a carnivore.",
    "output": "¬ColdBlooded(ron) ∧ ¬Carnivore(ron)"
  },
  {
    "input": "Translate into first-order logic: Henry is neither a carnivore nor a lizard.",
    "output": "¬Carnivore(henry) ∧ ¬Lizard(henry)"
  },
  {
    "input": "Translate into first-order logic: No cold-blooded animals are birds.",
    "output": "∀x (ColdBlooded(x) → ¬Bird(x))"
  },
  {
    "input": "Translate into first-order logic: All reptiles are cold-blooded.",
    "output": "∀x (Reptile(x) → ColdBlooded(x))"
  },
  {
    "input": "Translate into first-order logic: Either an animal is a bird or it eats other animals.",
    "output": "∀x (Bird(x) ∨ EatOtherAnimals(x))"
  },
  {
    "input": "Translate into first-order logic: If an animal eats other animals, then it is a carnivore.",
    "output": "∀x (EatOtherAnimals(x) → Carnivore(x))"
  },
  {
    "input": "Translate into first-order logic: Ron is neither a cold-blooded animal nor a carnivore.",
    "output": "¬ColdBlooded(ron) ∧ ¬Carnivore(ron)"
  },
  {
    "input": "Translate into first-order logic: Henry is neither a carnivore nor a lizard.",
    "output": "¬Carnivore(henry) ∧ ¬Lizard(henry)"
  },
  {
    "input": "Translate into first-order logic: No cold-blooded animals are birds.",
    "output": "∀x (ColdBlooded(x) → ¬Bird(x))"
  },
  {
    "input": "Translate into first-order logic: All reptiles are cold-blooded.",
    "output": "∀x (Reptile(x) → ColdBlooded(x))"
  },
  {
    "input": "Translate into first-order logic: Either an animal is a bird or it eats other animals.",
    "output": "∀x (Bird(x) ∨ EatOtherAnimals(x))"
  },
  {
    "input": "Translate into first-order logic: If an animal eats other animals, then it is a carnivore.",
    "output": "∀x (EatOtherAnimals(x) → Carnivore(x))"
  },
  {
    "input": "Translate into first-order logic: Ron is neither a cold-blooded animal nor a carnivore.",
    "output": "¬ColdBlooded(ron) ∧ ¬Carnivore(ron)"
  },
  {
    "input": "Translate into first-order logic: Henry is neither a carnivore nor a lizard.",
    "output": "¬Carnivore(henry) ∧ ¬Lizard(henry)"
  },
  {
    "input": "Translate into first-order logic: Ambiortus is a prehistoric bird genus.",
    "output": "Prehistoric(ambiortus) ∧ BirdGenus(ambiortus)"
  },
  {
    "input": "Translate into first-order logic: Ambiorus Dementjevi is the only known species of Ambiortus.",
    "output": "∀x (Species(x, ambiortus) → AmbiortusDementjevi(x))"
  },
  {
    "input": "Translate into first-order logic: The Mongol region was where Ambiorus Dementjevi lived.",
    "output": "∀x (AmbiortusDementjevi(x) → Lived(x, mongolregion))"
  },
  {
    "input": "Translate into first-order logic: Yevgeny Kurochkin was the discoverer of Ambiortus.",
    "output": "Discovered(yevgenykurochkin, ambiortus)"
  },
  {
    "input": "Translate into first-order logic: Ambiortus is a prehistoric bird genus.",
    "output": "Prehistoric(ambiortus) ∧ BirdGenus(ambiortus)"
  },
  {
    "input": "Translate into first-order logic: Ambiorus Dementjevi is the only known species of Ambiortus.",
    "output": "∀x (Species(x, ambiortus) → AmbiortusDementjevi(x))"
  },
  {
    "input": "Translate into first-order logic: The Mongol region was where Ambiorus Dementjevi lived.",
    "output": "∀x (AmbiortusDementjevi(x) → Lived(x, mongolregion))"
  },
  {
    "input": "Translate into first-order logic: Yevgeny Kurochkin was the discoverer of Ambiortus.",
    "output": "Discovered(yevgenykurochkin, ambiortus)"
  },
  {
    "input": "Translate into first-order logic: Ambiortus is a prehistoric bird genus.",
    "output": "Prehistoric(ambiortus) ∧ BirdGenus(ambiortus)"
  },
  {
    "input": "Translate into first-order logic: Ambiorus Dementjevi is the only known species of Ambiortus.",
    "output": "∀x (Species(x, ambiortus) → AmbiortusDementjevi(x))"
  },
  {
    "input": "Translate into first-order logic: The Mongol region was where Ambiorus Dementjevi lived.",
    "output": "∀x (AmbiortusDementjevi(x) → Lived(x, mongolregion))"
  },
  {
    "input": "Translate into first-order logic: Yevgeny Kurochkin was the discoverer of Ambiortus.",
    "output": "Discovered(yevgenykurochkin, ambiortus)"
  },
  {
    "input": "Translate into first-order logic: Ambiortus is a prehistoric bird genus.",
    "output": "Prehistoric(ambiortus) ∧ BirdGenus(ambiortus)"
  },
  {
    "input": "Translate into first-order logic: Ambiorus Dementjevi is the only known species of Ambiortus.",
    "output": "∀x (Species(x, ambiortus) → AmbiortusDementjevi(x))"
  },
  {
    "input": "Translate into first-order logic: The Mongol region was where Ambiorus Dementjevi lived.",
    "output": "∀x (AmbiortusDementjevi(x) → Lived(x, mongolregion))"
  },
  {
    "input": "Translate into first-order logic: Yevgeny Kurochkin was the discoverer of Ambiortus.",
    "output": "Discovered(yevgenykurochkin, ambiortus)"
  },
  {
    "input": "Translate into first-order logic: Everyone that uses a football can throw a football.",
    "output": "∀x (UseFootball(x) → ThrowFootball(x))"
  },
  {
    "input": "Translate into first-order logic: If someone plays football, then they use a football.",
    "output": "∀x (PlayFootball(x) → UseFootball(x))"
  },
  {
    "input": "Translate into first-order logic: Either someone is a football player or a basketball player.",
    "output": "∀x (BasketballPlayer(x) ∨ PlayFootball(x))"
  },
  {
    "input": "Translate into first-order logic: Every basketball player is tall.",
    "output": "∀x (BasketballPlayer(x) → Tall(x))"
  },
  {
    "input": "Translate into first-order logic: Everyone that can throw a football can throw a football with a spiral.",
    "output": "∀x (ThrowFootball(x) → ThrowFootballSpiral(x))"
  },
  {
    "input": "Translate into first-order logic: If someone is tall, then they are in shape.",
    "output": "∀x (Tall(x) → InShape(x))"
  },
  {
    "input": "Translate into first-order logic: If Jack is neither tall nor a basketball player,  then Jack is neither tall nor can throw a football.",
    "output": "¬Tall(jack) ∧ ¬BasketballPlayer(jack) → ¬Tall(jack) ∧ ¬ThrowFootball(jack)"
  },
  {
    "input": "Translate into first-order logic: Everyone that uses a football can throw a football.",
    "output": "∀x (UseFootball(x) → ThrowFootball(x))"
  },
  {
    "input": "Translate into first-order logic: If someone plays football, then they use a football.",
    "output": "∀x (PlayFootball(x) → UseFootball(x))"
  },
  {
    "input": "Translate into first-order logic: Either someone is a football player or a basketball player.",
    "output": "∀x (BasketballPlayer(x) ∨ PlayFootball(x))"
  },
  {
    "input": "Translate into first-order logic: Every basketball player is tall.",
    "output": "∀x (BasketballPlayer(x) → Tall(x))"
  },
  {
    "input": "Translate into first-order logic: Everyone that can throw a football can throw a football with a spiral.",
    "output": "∀x (ThrowFootball(x) → ThrowFootballSpiral(x))"
  },
  {
    "input": "Translate into first-order logic: If someone is tall, then they are in shape.",
    "output": "∀x (Tall(x) → InShape(x))"
  },
  {
    "input": "Translate into first-order logic: If Jack is neither tall nor a basketball player,  then Jack is neither tall nor can throw a football.",
    "output": "¬Tall(jack) ∧ ¬BasketballPlayer(jack) → ¬Tall(jack) ∧ ¬ThrowFootball(jack)"
  },
  {
    "input": "Translate into first-order logic: Everyone that uses a football can throw a football.",
    "output": "∀x (UseFootball(x) → ThrowFootball(x))"
  },
  {
    "input": "Translate into first-order logic: If someone plays football, then they use a football.",
    "output": "∀x (PlayFootball(x) → UseFootball(x))"
  },
  {
    "input": "Translate into first-order logic: Either someone is a football player or a basketball player.",
    "output": "∀x (BasketballPlayer(x) ∨ PlayFootball(x))"
  },
  {
    "input": "Translate into first-order logic: Every basketball player is tall.",
    "output": "∀x (BasketballPlayer(x) → Tall(x))"
  },
  {
    "input": "Translate into first-order logic: Everyone that can throw a football can throw a football with a spiral.",
    "output": "∀x (ThrowFootball(x) → ThrowFootballSpiral(x))"
  },
  {
    "input": "Translate into first-order logic: If someone is tall, then they are in shape.",
    "output": "∀x (Tall(x) → InShape(x))"
  },
  {
    "input": "Translate into first-order logic: If Jack is neither tall nor a basketball player,  then Jack is neither tall nor can throw a football.",
    "output": "¬Tall(jack) ∧ ¬BasketballPlayer(jack) → ¬Tall(jack) ∧ ¬ThrowFootball(jack)"
  },
  {
    "input": "Translate into first-order logic: Fort Ticonderoga is the current name for Fort Carillon.",
    "output": "CurrentName(fortticonderoga, fortcarillon)"
  },
  {
    "input": "Translate into first-order logic: Pierre de Rigaud de Vaudreuil built Fort Carillon.",
    "output": "Built(pierrederigauddevaudreuil, fortcarillon)"
  },
  {
    "input": "Translate into first-order logic: Fort Carillon was located in New France.",
    "output": "LocatedIn(fortcarillon, newfrance)"
  },
  {
    "input": "Translate into first-order logic: New France is not in Europe.",
    "output": "¬LocatedIn(newfrance, europe)"
  },
  {
    "input": "Translate into first-order logic: Fort Ticonderoga is the current name for Fort Carillon.",
    "output": "CurrentName(fortticonderoga, fortcarillon)"
  },
  {
    "input": "Translate into first-order logic: Pierre de Rigaud de Vaudreuil built Fort Carillon.",
    "output": "Built(pierrederigauddevaudreuil, fortcarillon)"
  },
  {
    "input": "Translate into first-order logic: Fort Carillon was located in New France.",
    "output": "LocatedIn(fortcarillon, newfrance)"
  },
  {
    "input": "Translate into first-order logic: New France is not in Europe.",
    "output": "¬LocatedIn(newfrance, europe)"
  },
  {
    "input": "Translate into first-order logic: Fort Ticonderoga is the current name for Fort Carillon.",
    "output": "CurrentName(fortticonderoga, fortcarillon)"
  },
  {
    "input": "Translate into first-order logic: Pierre de Rigaud de Vaudreuil built Fort Carillon.",
    "output": "Built(pierrederigauddevaudreuil, fortcarillon)"
  },
  {
    "input": "Translate into first-order logic: Fort Carillon was located in New France.",
    "output": "LocatedIn(fortcarillon, newfrance)"
  },
  {
    "input": "Translate into first-order logic: New France is not in Europe.",
    "output": "¬LocatedIn(newfrance, europe)"
  },
  {
    "input": "Translate into first-order logic: No soccer players are professional basketball players.",
    "output": "¬(∃x (SoccerPlayer(x) ∧ ProfessionalBasketballPlayer(x)))"
  },
  {
    "input": "Translate into first-order logic: All NBA players are professional basketball players.",
    "output": "∀x (NBAPlayer(x) → ProfessionalBasketballPlayer(x))"
  },
  {
    "input": "Translate into first-order logic: All defenders are soccer players.",
    "output": "∀x (Defender(x) → SoccerPlayer(x))"
  },
  {
    "input": "Translate into first-order logic: All centerback players are defenders.",
    "output": "∀x (Centerback(x) → Defender(x))"
  },
  {
    "input": "Translate into first-order logic: If Stephen Curry is an NBA player or a soccer player, then he is a professional basketball player.",
    "output": "(NBAPlayer(stephencurry) ⊕ SoccerPlayer(stephencurry)) → ProfessionalBasketballPlayer(stephencurry)"
  },
  {
    "input": "Translate into first-order logic: No soccer players are professional basketball players.",
    "output": "¬(∃x (SoccerPlayer(x) ∧ ProfessionalBasketballPlayer(x)))"
  },
  {
    "input": "Translate into first-order logic: All NBA players are professional basketball players.",
    "output": "∀x (NBAPlayer(x) → ProfessionalBasketballPlayer(x))"
  },
  {
    "input": "Translate into first-order logic: All defenders are soccer players.",
    "output": "∀x (Defender(x) → SoccerPlayer(x))"
  },
  {
    "input": "Translate into first-order logic: All centerback players are defenders.",
    "output": "∀x (Centerback(x) → Defender(x))"
  },
  {
    "input": "Translate into first-order logic: If Stephen Curry is an NBA player or a soccer player, then he is a professional basketball player.",
    "output": "(NBAPlayer(stephencurry) ⊕ SoccerPlayer(stephencurry)) → ProfessionalBasketballPlayer(stephencurry)"
  },
  {
    "input": "Translate into first-order logic: No soccer players are professional basketball players.",
    "output": "¬(∃x (SoccerPlayer(x) ∧ ProfessionalBasketballPlayer(x)))"
  },
  {
    "input": "Translate into first-order logic: All NBA players are professional basketball players.",
    "output": "∀x (NBAPlayer(x) → ProfessionalBasketballPlayer(x))"
  },
  {
    "input": "Translate into first-order logic: All defenders are soccer players.",
    "output": "∀x (Defender(x) → SoccerPlayer(x))"
  },
  {
    "input": "Translate into first-order logic: All centerback players are defenders.",
    "output": "∀x (Centerback(x) → Defender(x))"
  },
  {
    "input": "Translate into first-order logic: If Stephen Curry is an NBA player or a soccer player, then he is a professional basketball player.",
    "output": "(NBAPlayer(stephencurry) ⊕ SoccerPlayer(stephencurry)) → ProfessionalBasketballPlayer(stephencurry)"
  },
  {
    "input": "Translate into first-order logic: No songs are visual.",
    "output": "∀x (Song(x) → ¬Visual(x))"
  },
  {
    "input": "Translate into first-order logic: All folk songs are songs.",
    "output": "∀x (FolkSong(x) → Song(x))"
  },
  {
    "input": "Translate into first-order logic: All videos are visual.",
    "output": "∀x (Video(x) → Visual(x))"
  },
  {
    "input": "Translate into first-order logic: All movies are videos.",
    "output": "∀x (Movie(x) → Video(x))"
  },
  {
    "input": "Translate into first-order logic: All sci-fi movies are movies.",
    "output": "∀x (ScifiMovie(x) → Movie(x))"
  },
  {
    "input": "Translate into first-order logic: Inception is a sci-fi movie.",
    "output": "ScifiMovie(inception)"
  },
  {
    "input": "Translate into first-order logic: Mac is neither a folk song nor a sci-fi movie.",
    "output": "¬FolkSong(mac) ∧ ¬ScifiMovie(mac)"
  },
  {
    "input": "Translate into first-order logic: No songs are visual.",
    "output": "∀x (Song(x) → ¬Visual(x))"
  },
  {
    "input": "Translate into first-order logic: All folk songs are songs.",
    "output": "∀x (FolkSong(x) → Song(x))"
  },
  {
    "input": "Translate into first-order logic: All videos are visual.",
    "output": "∀x (Video(x) → Visual(x))"
  },
  {
    "input": "Translate into first-order logic: All movies are videos.",
    "output": "∀x (Movie(x) → Video(x))"
  },
  {
    "input": "Translate into first-order logic: All sci-fi movies are movies.",
    "output": "∀x (ScifiMovie(x) → Movie(x))"
  },
  {
    "input": "Translate into first-order logic: Inception is a sci-fi movie.",
    "output": "ScifiMovie(inception)"
  },
  {
    "input": "Translate into first-order logic: Mac is neither a folk song nor a sci-fi movie.",
    "output": "¬FolkSong(mac) ∧ ¬ScifiMovie(mac)"
  },
  {
    "input": "Translate into first-order logic: No songs are visual.",
    "output": "∀x (Song(x) → ¬Visual(x))"
  },
  {
    "input": "Translate into first-order logic: All folk songs are songs.",
    "output": "∀x (FolkSong(x) → Song(x))"
  },
  {
    "input": "Translate into first-order logic: All videos are visual.",
    "output": "∀x (Video(x) → Visual(x))"
  },
  {
    "input": "Translate into first-order logic: All movies are videos.",
    "output": "∀x (Movie(x) → Video(x))"
  },
  {
    "input": "Translate into first-order logic: All sci-fi movies are movies.",
    "output": "∀x (ScifiMovie(x) → Movie(x))"
  },
  {
    "input": "Translate into first-order logic: Inception is a sci-fi movie.",
    "output": "ScifiMovie(inception)"
  },
  {
    "input": "Translate into first-order logic: Mac is neither a folk song nor a sci-fi movie.",
    "output": "¬FolkSong(mac) ∧ ¬ScifiMovie(mac)"
  },
  {
    "input": "Translate into first-order logic: No songs are visual.",
    "output": "∀x (Song(x) → ¬Visual(x))"
  },
  {
    "input": "Translate into first-order logic: All folk songs are songs.",
    "output": "∀x (FolkSong(x) → Song(x))"
  },
  {
    "input": "Translate into first-order logic: All videos are visual.",
    "output": "∀x (Video(x) → Visual(x))"
  },
  {
    "input": "Translate into first-order logic: All movies are videos.",
    "output": "∀x (Movie(x) → Video(x))"
  },
  {
    "input": "Translate into first-order logic: All sci-fi movies are movies.",
    "output": "∀x (ScifiMovie(x) → Movie(x))"
  },
  {
    "input": "Translate into first-order logic: Inception is a sci-fi movie.",
    "output": "ScifiMovie(inception)"
  },
  {
    "input": "Translate into first-order logic: Mac is neither a folk song nor a sci-fi movie.",
    "output": "¬FolkSong(mac) ∧ ¬ScifiMovie(mac)"
  },
  {
    "input": "Translate into first-order logic: All extroverts are overtly expressive.",
    "output": "∀x (Extroverts(x) → OvertlyExpressive(x))"
  },
  {
    "input": "Translate into first-order logic: People are either extroverts or introverts.",
    "output": " ∀x (Extroverts(x) ∨ Introverts(x)) "
  },
  {
    "input": "Translate into first-order logic: If someone is an introvert, then they are shy and reticent.",
    "output": " ∀x (Introverts(x) → ShyAndReticentPerson(x))"
  },
  {
    "input": "Translate into first-order logic: No shy and reticent person likes to talk to strangers.",
    "output": " ∀x (ShyAndReticentPerson(x) → ¬LikeToTalkToStrangers(x))"
  },
  {
    "input": "Translate into first-order logic: Jeff is not an extrovert and someone who likes to talk to strangers.",
    "output": " ¬Extroverts(jeff) ∧ ¬LikeToTalkToStrangers(jeff)"
  },
  {
    "input": "Translate into first-order logic: All extroverts are overtly expressive.",
    "output": "∀x (Extroverts(x) → OvertlyExpressive(x))"
  },
  {
    "input": "Translate into first-order logic: People are either extroverts or introverts.",
    "output": " ∀x (Extroverts(x) ∨ Introverts(x)) "
  },
  {
    "input": "Translate into first-order logic: If someone is an introvert, then they are shy and reticent.",
    "output": " ∀x (Introverts(x) → ShyAndReticentPerson(x))"
  },
  {
    "input": "Translate into first-order logic: No shy and reticent person likes to talk to strangers.",
    "output": " ∀x (ShyAndReticentPerson(x) → ¬LikeToTalkToStrangers(x))"
  },
  {
    "input": "Translate into first-order logic: Jeff is not an extrovert and someone who likes to talk to strangers.",
    "output": " ¬Extroverts(jeff) ∧ ¬LikeToTalkToStrangers(jeff)"
  },
  {
    "input": "Translate into first-order logic: All extroverts are overtly expressive.",
    "output": "∀x (Extroverts(x) → OvertlyExpressive(x))"
  },
  {
    "input": "Translate into first-order logic: People are either extroverts or introverts.",
    "output": " ∀x (Extroverts(x) ∨ Introverts(x)) "
  },
  {
    "input": "Translate into first-order logic: If someone is an introvert, then they are shy and reticent.",
    "output": " ∀x (Introverts(x) → ShyAndReticentPerson(x))"
  },
  {
    "input": "Translate into first-order logic: No shy and reticent person likes to talk to strangers.",
    "output": " ∀x (ShyAndReticentPerson(x) → ¬LikeToTalkToStrangers(x))"
  },
  {
    "input": "Translate into first-order logic: Jeff is not an extrovert and someone who likes to talk to strangers.",
    "output": " ¬Extroverts(jeff) ∧ ¬LikeToTalkToStrangers(jeff)"
  },
  {
    "input": "Translate into first-order logic: No low-scoring players are top players in the league.",
    "output": "∀x (LowScore(x) → ¬TopPlayer(x))"
  },
  {
    "input": "Translate into first-order logic: Basketball players are either top players in the league or successfully shoot a high percentage of 3-pointers.",
    "output": "∀x (TopPlayer(x) ∨ ThreePointer(x))"
  },
  {
    "input": "Translate into first-order logic: All players who successfully shoot a high percentage of 3-pointers are solid at shooting 2-pointers.",
    "output": "∀x (ThreePointer(x) → TwoPointer(x))"
  },
  {
    "input": "Translate into first-order logic: No players who are solid at shooting 2-pointers are bad at mid-range shots.",
    "output": "∀x (TwoPointer(x) → ¬BadMid(x))"
  },
  {
    "input": "Translate into first-order logic: Candace is either a low-scoring player or successfully shoots a high percentage of 3-pointers.",
    "output": "LowScore(candace) ⊕ ThreePointer(candace)"
  },
  {
    "input": "Translate into first-order logic: No low-scoring players are top players in the league.",
    "output": "∀x (LowScore(x) → ¬TopPlayer(x))"
  },
  {
    "input": "Translate into first-order logic: Basketball players are either top players in the league or successfully shoot a high percentage of 3-pointers.",
    "output": "∀x (TopPlayer(x) ∨ ThreePointer(x))"
  },
  {
    "input": "Translate into first-order logic: All players who successfully shoot a high percentage of 3-pointers are solid at shooting 2-pointers.",
    "output": "∀x (ThreePointer(x) → TwoPointer(x))"
  },
  {
    "input": "Translate into first-order logic: No players who are solid at shooting 2-pointers are bad at mid-range shots.",
    "output": "∀x (TwoPointer(x) → ¬BadMid(x))"
  },
  {
    "input": "Translate into first-order logic: Candace is either a low-scoring player or successfully shoots a high percentage of 3-pointers.",
    "output": "LowScore(candace) ⊕ ThreePointer(candace)"
  },
  {
    "input": "Translate into first-order logic: No low-scoring players are top players in the league.",
    "output": "∀x (LowScore(x) → ¬TopPlayer(x))"
  },
  {
    "input": "Translate into first-order logic: Basketball players are either top players in the league or successfully shoot a high percentage of 3-pointers.",
    "output": "∀x (TopPlayer(x) ∨ ThreePointer(x))"
  },
  {
    "input": "Translate into first-order logic: All players who successfully shoot a high percentage of 3-pointers are solid at shooting 2-pointers.",
    "output": "∀x (ThreePointer(x) → TwoPointer(x))"
  },
  {
    "input": "Translate into first-order logic: No players who are solid at shooting 2-pointers are bad at mid-range shots.",
    "output": "∀x (TwoPointer(x) → ¬BadMid(x))"
  },
  {
    "input": "Translate into first-order logic: Candace is either a low-scoring player or successfully shoots a high percentage of 3-pointers.",
    "output": "LowScore(candace) ⊕ ThreePointer(candace)"
  },
  {
    "input": "Translate into first-order logic: No low-scoring players are top players in the league.",
    "output": "∀x (LowScore(x) → ¬TopPlayer(x))"
  },
  {
    "input": "Translate into first-order logic: Basketball players are either top players in the league or successfully shoot a high percentage of 3-pointers.",
    "output": "∀x (TopPlayer(x) ∨ ThreePointer(x))"
  },
  {
    "input": "Translate into first-order logic: All players who successfully shoot a high percentage of 3-pointers are solid at shooting 2-pointers.",
    "output": "∀x (ThreePointer(x) → TwoPointer(x))"
  },
  {
    "input": "Translate into first-order logic: No players who are solid at shooting 2-pointers are bad at mid-range shots.",
    "output": "∀x (TwoPointer(x) → ¬BadMid(x))"
  },
  {
    "input": "Translate into first-order logic: Candace is either a low-scoring player or successfully shoots a high percentage of 3-pointers.",
    "output": "LowScore(candace) ⊕ ThreePointer(candace)"
  },
  {
    "input": "Translate into first-order logic: No low-scoring players are top players in the league.",
    "output": "∀x (LowScore(x) → ¬TopPlayer(x))"
  },
  {
    "input": "Translate into first-order logic: Basketball players are either top players in the league or successfully shoot a high percentage of 3-pointers.",
    "output": "∀x (TopPlayer(x) ∨ ThreePointer(x))"
  },
  {
    "input": "Translate into first-order logic: All players who successfully shoot a high percentage of 3-pointers are solid at shooting 2-pointers.",
    "output": "∀x (ThreePointer(x) → TwoPointer(x))"
  },
  {
    "input": "Translate into first-order logic: No players who are solid at shooting 2-pointers are bad at mid-range shots.",
    "output": "∀x (TwoPointer(x) → ¬BadMid(x))"
  },
  {
    "input": "Translate into first-order logic: Candace is either a low-scoring player or successfully shoots a high percentage of 3-pointers.",
    "output": "LowScore(candace) ⊕ ThreePointer(candace)"
  },
  {
    "input": "Translate into first-order logic: No low-scoring players are top players in the league.",
    "output": "∀x (LowScore(x) → ¬TopPlayer(x))"
  },
  {
    "input": "Translate into first-order logic: Basketball players are either top players in the league or successfully shoot a high percentage of 3-pointers.",
    "output": "∀x (TopPlayer(x) ∨ ThreePointer(x))"
  },
  {
    "input": "Translate into first-order logic: All players who successfully shoot a high percentage of 3-pointers are solid at shooting 2-pointers.",
    "output": "∀x (ThreePointer(x) → TwoPointer(x))"
  },
  {
    "input": "Translate into first-order logic: No players who are solid at shooting 2-pointers are bad at mid-range shots.",
    "output": "∀x (TwoPointer(x) → ¬BadMid(x))"
  },
  {
    "input": "Translate into first-order logic: Candace is either a low-scoring player or successfully shoots a high percentage of 3-pointers.",
    "output": "LowScore(candace) ⊕ ThreePointer(candace)"
  },
  {
    "input": "Translate into first-order logic: No low-scoring players are top players in the league.",
    "output": "∀x (LowScore(x) → ¬TopPlayer(x))"
  },
  {
    "input": "Translate into first-order logic: Basketball players are either top players in the league or successfully shoot a high percentage of 3-pointers.",
    "output": "∀x (TopPlayer(x) ∨ ThreePointer(x))"
  },
  {
    "input": "Translate into first-order logic: All players who successfully shoot a high percentage of 3-pointers are solid at shooting 2-pointers.",
    "output": "∀x (ThreePointer(x) → TwoPointer(x))"
  },
  {
    "input": "Translate into first-order logic: No players who are solid at shooting 2-pointers are bad at mid-range shots.",
    "output": "∀x (TwoPointer(x) → ¬BadMid(x))"
  },
  {
    "input": "Translate into first-order logic: Candace is either a low-scoring player or successfully shoots a high percentage of 3-pointers.",
    "output": "LowScore(candace) ⊕ ThreePointer(candace)"
  },
  {
    "input": "Translate into first-order logic: No low-scoring players are top players in the league.",
    "output": "∀x (LowScore(x) → ¬TopPlayer(x))"
  },
  {
    "input": "Translate into first-order logic: Basketball players are either top players in the league or successfully shoot a high percentage of 3-pointers.",
    "output": "∀x (TopPlayer(x) ∨ ThreePointer(x))"
  },
  {
    "input": "Translate into first-order logic: All players who successfully shoot a high percentage of 3-pointers are solid at shooting 2-pointers.",
    "output": "∀x (ThreePointer(x) → TwoPointer(x))"
  },
  {
    "input": "Translate into first-order logic: No players who are solid at shooting 2-pointers are bad at mid-range shots.",
    "output": "∀x (TwoPointer(x) → ¬BadMid(x))"
  },
  {
    "input": "Translate into first-order logic: Candace is either a low-scoring player or successfully shoots a high percentage of 3-pointers.",
    "output": "LowScore(candace) ⊕ ThreePointer(candace)"
  },
  {
    "input": "Translate into first-order logic: No low-scoring players are top players in the league.",
    "output": "∀x (LowScore(x) → ¬TopPlayer(x))"
  },
  {
    "input": "Translate into first-order logic: Basketball players are either top players in the league or successfully shoot a high percentage of 3-pointers.",
    "output": "∀x (TopPlayer(x) ∨ ThreePointer(x))"
  },
  {
    "input": "Translate into first-order logic: All players who successfully shoot a high percentage of 3-pointers are solid at shooting 2-pointers.",
    "output": "∀x (ThreePointer(x) → TwoPointer(x))"
  },
  {
    "input": "Translate into first-order logic: No players who are solid at shooting 2-pointers are bad at mid-range shots.",
    "output": "∀x (TwoPointer(x) → ¬BadMid(x))"
  },
  {
    "input": "Translate into first-order logic: Candace is either a low-scoring player or successfully shoots a high percentage of 3-pointers.",
    "output": "LowScore(candace) ⊕ ThreePointer(candace)"
  },
  {
    "input": "Translate into first-order logic: No plants are fungi.",
    "output": "∀x (Plant(x) → ¬Fungi(x))"
  },
  {
    "input": "Translate into first-order logic: Mushrooms are fungi.",
    "output": "∀x (Mushroom(x) → Fungi(x))"
  },
  {
    "input": "Translate into first-order logic: No road is clean.",
    "output": "∀x (Road(x) → ¬Clean(x))"
  },
  {
    "input": "Translate into first-order logic: And some streets are roads.",
    "output": "∃x (Street(x) ∧ Road(x))"
  },
  {
    "input": "Translate into first-order logic: New York City is on the East Coast.",
    "output": "On(newyorkcity, eastcoast)"
  },
  {
    "input": "Translate into first-order logic: Seattle is on the West Coast.",
    "output": "On(seattle, westcoast)"
  },
  {
    "input": "Translate into first-order logic: If a person from a city on the East coast is traveling to a city on the west coast, they will be on a long flight.",
    "output": "∀x ∀y ∀z ((TravelingFrom(x, y) ∧ On(y, eastcoast) ∧ TravelingTo(x, z) ∧ On(z, westcoast)) → OnLongFlight(x))"
  },
  {
    "input": "Translate into first-order logic: Most passengers on flights to Seattle from New York City are not in first class.",
    "output": "∃x (¬InFirstClass(x) ∧ TravelingFrom(x, newyorkcity) ∧ TravelingTo(x, seattle))"
  },
  {
    "input": "Translate into first-order logic: People on long flights are uncomfortable unless they're in first class",
    "output": "∀x (OnLongFlight(x) ∧ ¬InFirstClass(x) → Uncomfortable(x))"
  },
  {
    "input": "Translate into first-order logic: Musicians have very busy lives.",
    "output": "∀x (Musician(x) → Busy(x))"
  },
  {
    "input": "Translate into first-order logic: Singh Kaur is a musician and famous.",
    "output": "Musician(singhKaur) ∧ Famous(singhKaur)"
  },
  {
    "input": "Translate into first-order logic: If a musician is not famous, that musician will not make a lot of money.",
    "output": "∀x (Musician(x) ∧ ¬Famous(x) → ¬MakeMoney(x))"
  },
  {
    "input": "Translate into first-order logic: A musician can be a singer or a writer.",
    "output": "∃x (Musician(x) ∧ Singer(x) ∨ Writer(x))"
  },
  {
    "input": "Translate into first-order logic: Musicians have very busy lives.",
    "output": "∀x (Musician(x) → Busy(x))"
  },
  {
    "input": "Translate into first-order logic: Singh Kaur is a musician and famous.",
    "output": "Musician(singhKaur) ∧ Famous(singhKaur)"
  },
  {
    "input": "Translate into first-order logic: If a musician is not famous, that musician will not make a lot of money.",
    "output": "∀x (Musician(x) ∧ ¬Famous(x) → ¬MakeMoney(x))"
  },
  {
    "input": "Translate into first-order logic: A musician can be a singer or a writer.",
    "output": "∃x (Musician(x) ∧ Singer(x) ∨ Writer(x))"
  },
  {
    "input": "Translate into first-order logic: Musicians have very busy lives.",
    "output": "∀x (Musician(x) → Busy(x))"
  },
  {
    "input": "Translate into first-order logic: Singh Kaur is a musician and famous.",
    "output": "Musician(singhKaur) ∧ Famous(singhKaur)"
  },
  {
    "input": "Translate into first-order logic: If a musician is not famous, that musician will not make a lot of money.",
    "output": "∀x (Musician(x) ∧ ¬Famous(x) → ¬MakeMoney(x))"
  },
  {
    "input": "Translate into first-order logic: A musician can be a singer or a writer.",
    "output": "∃x (Musician(x) ∧ Singer(x) ∨ Writer(x))"
  },
  {
    "input": "Translate into first-order logic: Each building is tall.",
    "output": "∀x (Building(x) → ¬Tall(x))"
  },
  {
    "input": "Translate into first-order logic: Everything tall has  height.",
    "output": "∀x (Tall(x) → HasHeight(x))"
  },
  {
    "input": "Translate into first-order logic: A cat named Garfield, which is the main character of the film Garfield, is orange and fat and likes having lasagna.",
    "output": "Cat(garfield) ∧ MainCharacterGarfield(garfield) ∧ BeOrange(garfield) ∧ BeFat(garfield) ∧ LikeLasagna(garfield)"
  },
  {
    "input": "Translate into first-order logic: Garfield and Odie, who is another pet of Jon, share the same home.",
    "output": "Pet(garfield, jon) ∧ Pet(odie, jon) ∧ ShareHome(garfield, odie)"
  },
  {
    "input": "Translate into first-order logic: Garfield hates Odie.",
    "output": "Hate(garfield, odie)"
  },
  {
    "input": "Translate into first-order logic: A pet who hates the pet with whom he shares the same owner is childish and possessive.",
    "output": "∀x ∀y ∃z (Pet(x, z) ∧ Pet(y, z) ∧ Hate(x, y) → BeChildish(x) ∧ BePossessive(x))"
  },
  {
    "input": "Translate into first-order logic: Cats are pets.",
    "output": "∀x ∃y (Cat(x) → Pet(x, y))"
  },
  {
    "input": "Translate into first-order logic: All humans eat.",
    "output": "∀x (Human(x) → Eat(x))"
  },
  {
    "input": "Translate into first-order logic: If something eats, then it is not a plant.",
    "output": "∀x (Eat(x) → ¬Plant(x))"
  },
  {
    "input": "Translate into first-order logic: A thing is either plant or animal.",
    "output": "∀x (Plant(x) ∨ Animal(x))"
  },
  {
    "input": "Translate into first-order logic: All goats are animals.",
    "output": "∀x (Goat(x) → Animal(x))"
  },
  {
    "input": "Translate into first-order logic: No dirt is an animal.",
    "output": "∀x (Dirt(x) → ¬Animal(x))"
  },
  {
    "input": "Translate into first-order logic: Hulu is a goat or a human.",
    "output": "Goat(hulu) ∨ Human(hulu)"
  },
  {
    "input": "Translate into first-order logic: All humans eat.",
    "output": "∀x (Human(x) → Eat(x))"
  },
  {
    "input": "Translate into first-order logic: If something eats, then it is not a plant.",
    "output": "∀x (Eat(x) → ¬Plant(x))"
  },
  {
    "input": "Translate into first-order logic: A thing is either plant or animal.",
    "output": "∀x (Plant(x) ∨ Animal(x))"
  },
  {
    "input": "Translate into first-order logic: All goats are animals.",
    "output": "∀x (Goat(x) → Animal(x))"
  },
  {
    "input": "Translate into first-order logic: No dirt is an animal.",
    "output": "∀x (Dirt(x) → ¬Animal(x))"
  },
  {
    "input": "Translate into first-order logic: Hulu is a goat or a human.",
    "output": "Goat(hulu) ∨ Human(hulu)"
  },
  {
    "input": "Translate into first-order logic: All humans eat.",
    "output": "∀x (Human(x) → Eat(x))"
  },
  {
    "input": "Translate into first-order logic: If something eats, then it is not a plant.",
    "output": "∀x (Eat(x) → ¬Plant(x))"
  },
  {
    "input": "Translate into first-order logic: A thing is either plant or animal.",
    "output": "∀x (Plant(x) ∨ Animal(x))"
  },
  {
    "input": "Translate into first-order logic: All goats are animals.",
    "output": "∀x (Goat(x) → Animal(x))"
  },
  {
    "input": "Translate into first-order logic: No dirt is an animal.",
    "output": "∀x (Dirt(x) → ¬Animal(x))"
  },
  {
    "input": "Translate into first-order logic: Hulu is a goat or a human.",
    "output": "Goat(hulu) ∨ Human(hulu)"
  },
  {
    "input": "Translate into first-order logic: All humans eat.",
    "output": "∀x (Human(x) → Eat(x))"
  },
  {
    "input": "Translate into first-order logic: If something eats, then it is not a plant.",
    "output": "∀x (Eat(x) → ¬Plant(x))"
  },
  {
    "input": "Translate into first-order logic: A thing is either plant or animal.",
    "output": "∀x (Plant(x) ∨ Animal(x))"
  },
  {
    "input": "Translate into first-order logic: All goats are animals.",
    "output": "∀x (Goat(x) → Animal(x))"
  },
  {
    "input": "Translate into first-order logic: No dirt is an animal.",
    "output": "∀x (Dirt(x) → ¬Animal(x))"
  },
  {
    "input": "Translate into first-order logic: Hulu is a goat or a human.",
    "output": "Goat(hulu) ∨ Human(hulu)"
  },
  {
    "input": "Translate into first-order logic: All humans eat.",
    "output": "∀x (Human(x) → Eat(x))"
  },
  {
    "input": "Translate into first-order logic: If something eats, then it is not a plant.",
    "output": "∀x (Eat(x) → ¬Plant(x))"
  },
  {
    "input": "Translate into first-order logic: A thing is either plant or animal.",
    "output": "∀x (Plant(x) ∨ Animal(x))"
  },
  {
    "input": "Translate into first-order logic: All goats are animals.",
    "output": "∀x (Goat(x) → Animal(x))"
  },
  {
    "input": "Translate into first-order logic: No dirt is an animal.",
    "output": "∀x (Dirt(x) → ¬Animal(x))"
  },
  {
    "input": "Translate into first-order logic: Hulu is a goat or a human.",
    "output": "Goat(hulu) ∨ Human(hulu)"
  },
  {
    "input": "Translate into first-order logic: All humans eat.",
    "output": "∀x (Human(x) → Eat(x))"
  },
  {
    "input": "Translate into first-order logic: If something eats, then it is not a plant.",
    "output": "∀x (Eat(x) → ¬Plant(x))"
  },
  {
    "input": "Translate into first-order logic: A thing is either plant or animal.",
    "output": "∀x (Plant(x) ∨ Animal(x))"
  },
  {
    "input": "Translate into first-order logic: All goats are animals.",
    "output": "∀x (Goat(x) → Animal(x))"
  },
  {
    "input": "Translate into first-order logic: No dirt is an animal.",
    "output": "∀x (Dirt(x) → ¬Animal(x))"
  },
  {
    "input": "Translate into first-order logic: Hulu is a goat or a human.",
    "output": "Goat(hulu) ∨ Human(hulu)"
  },
  {
    "input": "Translate into first-order logic: A controlled substance is a drug.",
    "output": "∀x (ControlledSubstances(x) → Drugs(x))"
  },
  {
    "input": "Translate into first-order logic: There exist both harmful and beneficial controlled substances.",
    "output": "∃x ∃x (ControlledSubstances(x) ∧ ControlledSubstances(y) ∧ Beneficial(x) ∧ Harmful(y))"
  },
  {
    "input": "Translate into first-order logic: If a child is exposed to a controlled substance, he or she is in chemical endangerment.",
    "output": "∀x ∀y (ExposedToControlledSubstance(x, y) → ChemicalEndangerment(x))"
  },
  {
    "input": "Translate into first-order logic: Chemical Endangerment is harmful.",
    "output": "∀x (ChemicalEndangerment(x) → Harmful(x))"
  },
  {
    "input": "Translate into first-order logic: The Controlled Substances Act was an act passed in 1971.",
    "output": "PassedIn(controlledSubstancesAct, year1971) ∧ Act(controlledSubstancesAct)"
  },
  {
    "input": "Translate into first-order logic: Some Acts prevent harmful things.",
    "output": "∃x (Act(x) ∧ PreventsHarm(x))"
  },
  {
    "input": "Translate into first-order logic: A controlled substance is a drug.",
    "output": "∀x (ControlledSubstances(x) → Drugs(x))"
  },
  {
    "input": "Translate into first-order logic: There exist both harmful and beneficial controlled substances.",
    "output": "∃x ∃x (ControlledSubstances(x) ∧ ControlledSubstances(y) ∧ Beneficial(x) ∧ Harmful(y))"
  },
  {
    "input": "Translate into first-order logic: If a child is exposed to a controlled substance, he or she is in chemical endangerment.",
    "output": "∀x ∀y (ExposedToControlledSubstance(x, y) → ChemicalEndangerment(x))"
  },
  {
    "input": "Translate into first-order logic: Chemical Endangerment is harmful.",
    "output": "∀x (ChemicalEndangerment(x) → Harmful(x))"
  },
  {
    "input": "Translate into first-order logic: The Controlled Substances Act was an act passed in 1971.",
    "output": "PassedIn(controlledSubstancesAct, year1971) ∧ Act(controlledSubstancesAct)"
  },
  {
    "input": "Translate into first-order logic: Some Acts prevent harmful things.",
    "output": "∃x (Act(x) ∧ PreventsHarm(x))"
  },
  {
    "input": "Translate into first-order logic: A controlled substance is a drug.",
    "output": "∀x (ControlledSubstances(x) → Drugs(x))"
  },
  {
    "input": "Translate into first-order logic: There exist both harmful and beneficial controlled substances.",
    "output": "∃x ∃x (ControlledSubstances(x) ∧ ControlledSubstances(y) ∧ Beneficial(x) ∧ Harmful(y))"
  },
  {
    "input": "Translate into first-order logic: If a child is exposed to a controlled substance, he or she is in chemical endangerment.",
    "output": "∀x ∀y (ExposedToControlledSubstance(x, y) → ChemicalEndangerment(x))"
  },
  {
    "input": "Translate into first-order logic: Chemical Endangerment is harmful.",
    "output": "∀x (ChemicalEndangerment(x) → Harmful(x))"
  },
  {
    "input": "Translate into first-order logic: The Controlled Substances Act was an act passed in 1971.",
    "output": "PassedIn(controlledSubstancesAct, year1971) ∧ Act(controlledSubstancesAct)"
  },
  {
    "input": "Translate into first-order logic: Some Acts prevent harmful things.",
    "output": "∃x (Act(x) ∧ PreventsHarm(x))"
  },
  {
    "input": "Translate into first-order logic: No people who work at corporate jobs are starting a new company.",
    "output": "∀x (WorkAtCorporateJobs(x) → ¬StartingANewCompany(x))"
  },
  {
    "input": "Translate into first-order logic: All entrepreneurs are starting a new company.",
    "output": " ∀x (Entrepreneurs(x) → StartingANewCompany(x))"
  },
  {
    "input": "Translate into first-order logic: All risk-averse people are people who work at corporate jobs.",
    "output": " ∀x (Risk-averse(x) → WorkAtCorporateJobs(x))"
  },
  {
    "input": "Translate into first-order logic: All people who hate working for others are entrepreneurs.",
    "output": " ∀x (HateWorkingForOthers(x) → Entrepreneurs(x))"
  },
  {
    "input": "Translate into first-order logic: If Mark Zuckerberg is neither an entrepreneur nor a person who hates working for others, then Mark Zuckerberg is not a risk-averse person.",
    "output": " ¬Entrepreneurs(markZuckerberg) ∨ ¬HateWorkingForOthers(markZuckerberg) → ¬Risk-averse(markZuckerberg)"
  },
  {
    "input": "Translate into first-order logic: No people who work at corporate jobs are starting a new company.",
    "output": "∀x (WorkAtCorporateJobs(x) → ¬StartingANewCompany(x))"
  },
  {
    "input": "Translate into first-order logic: All entrepreneurs are starting a new company.",
    "output": " ∀x (Entrepreneurs(x) → StartingANewCompany(x))"
  },
  {
    "input": "Translate into first-order logic: All risk-averse people are people who work at corporate jobs.",
    "output": " ∀x (Risk-averse(x) → WorkAtCorporateJobs(x))"
  },
  {
    "input": "Translate into first-order logic: All people who hate working for others are entrepreneurs.",
    "output": " ∀x (HateWorkingForOthers(x) → Entrepreneurs(x))"
  },
  {
    "input": "Translate into first-order logic: If Mark Zuckerberg is neither an entrepreneur nor a person who hates working for others, then Mark Zuckerberg is not a risk-averse person.",
    "output": " ¬Entrepreneurs(markZuckerberg) ∨ ¬HateWorkingForOthers(markZuckerberg) → ¬Risk-averse(markZuckerberg)"
  },
  {
    "input": "Translate into first-order logic: No people who work at corporate jobs are starting a new company.",
    "output": "∀x (WorkAtCorporateJobs(x) → ¬StartingANewCompany(x))"
  },
  {
    "input": "Translate into first-order logic: All entrepreneurs are starting a new company.",
    "output": " ∀x (Entrepreneurs(x) → StartingANewCompany(x))"
  },
  {
    "input": "Translate into first-order logic: All risk-averse people are people who work at corporate jobs.",
    "output": " ∀x (Risk-averse(x) → WorkAtCorporateJobs(x))"
  },
  {
    "input": "Translate into first-order logic: All people who hate working for others are entrepreneurs.",
    "output": " ∀x (HateWorkingForOthers(x) → Entrepreneurs(x))"
  },
  {
    "input": "Translate into first-order logic: If Mark Zuckerberg is neither an entrepreneur nor a person who hates working for others, then Mark Zuckerberg is not a risk-averse person.",
    "output": " ¬Entrepreneurs(markZuckerberg) ∨ ¬HateWorkingForOthers(markZuckerberg) → ¬Risk-averse(markZuckerberg)"
  },
  {
    "input": "Translate into first-order logic: There are two kitchens in the house: the upstairs kitchen and the downstairs kitchen.",
    "output": "∀x (Kitchen(x) → Up(x) ⊕ Down(x))"
  },
  {
    "input": "Translate into first-order logic: When someone is cooking in the downstairs kitchen, the first floor becomes smokey unless the air conditioner is running.",
    "output": "(Cook(downstairs) ∧ ¬Run(ac)) → Smokey(firstFloor)"
  },
  {
    "input": "Translate into first-order logic: If the air conditioner is running and someone is cooking in the downstairs kitchen, all the smoke travels to the second floor.",
    "output": "(Cook(downstairs) ∧ Run(ac)) → Smokey(secondFloor)"
  },
  {
    "input": "Translate into first-order logic: There are two kitchens in the house: the upstairs kitchen and the downstairs kitchen.",
    "output": "∀x (Kitchen(x) → Up(x) ⊕ Down(x))"
  },
  {
    "input": "Translate into first-order logic: When someone is cooking in the downstairs kitchen, the first floor becomes smokey unless the air conditioner is running.",
    "output": "(Cook(downstairs) ∧ ¬Run(ac)) → Smokey(firstFloor)"
  },
  {
    "input": "Translate into first-order logic: If the air conditioner is running and someone is cooking in the downstairs kitchen, all the smoke travels to the second floor.",
    "output": "(Cook(downstairs) ∧ Run(ac)) → Smokey(secondFloor)"
  },
  {
    "input": "Translate into first-order logic: There are two kitchens in the house: the upstairs kitchen and the downstairs kitchen.",
    "output": "∀x (Kitchen(x) → Up(x) ⊕ Down(x))"
  },
  {
    "input": "Translate into first-order logic: When someone is cooking in the downstairs kitchen, the first floor becomes smokey unless the air conditioner is running.",
    "output": "(Cook(downstairs) ∧ ¬Run(ac)) → Smokey(firstFloor)"
  },
  {
    "input": "Translate into first-order logic: If the air conditioner is running and someone is cooking in the downstairs kitchen, all the smoke travels to the second floor.",
    "output": "(Cook(downstairs) ∧ Run(ac)) → Smokey(secondFloor)"
  },
  {
    "input": "Translate into first-order logic: New York City is Located in the United States of America.",
    "output": "Locate(nyc, usa)"
  },
  {
    "input": "Translate into first-order logic: United States of America is part of North America.",
    "output": "Locate(usa, northAmerica)"
  },
  {
    "input": "Translate into first-order logic: North America is in the western hemisphere of the earth.",
    "output": "Locate(northAmerica, westHemisphere)"
  },
  {
    "input": "Translate into first-order logic: New York City is a highly developed city.",
    "output": "HighlyDeveloped(nyc)"
  },
  {
    "input": "Translate into first-order logic: If place A is located in place B and place B is located in place C, then place A is located in place C.",
    "output": "∀x ∀y ∀z ((Locate(x, y) ∧ Locate(y, z)) → Locate(x, z))"
  },
  {
    "input": "Translate into first-order logic: New York City is Located in the United States of America.",
    "output": "Locate(nyc, usa)"
  },
  {
    "input": "Translate into first-order logic: United States of America is part of North America.",
    "output": "Locate(usa, northAmerica)"
  },
  {
    "input": "Translate into first-order logic: North America is in the western hemisphere of the earth.",
    "output": "Locate(northAmerica, westHemisphere)"
  },
  {
    "input": "Translate into first-order logic: New York City is a highly developed city.",
    "output": "HighlyDeveloped(nyc)"
  },
  {
    "input": "Translate into first-order logic: If place A is located in place B and place B is located in place C, then place A is located in place C.",
    "output": "∀x ∀y ∀z ((Locate(x, y) ∧ Locate(y, z)) → Locate(x, z))"
  },
  {
    "input": "Translate into first-order logic: New York City is Located in the United States of America.",
    "output": "Locate(nyc, usa)"
  },
  {
    "input": "Translate into first-order logic: United States of America is part of North America.",
    "output": "Locate(usa, northAmerica)"
  },
  {
    "input": "Translate into first-order logic: North America is in the western hemisphere of the earth.",
    "output": "Locate(northAmerica, westHemisphere)"
  },
  {
    "input": "Translate into first-order logic: New York City is a highly developed city.",
    "output": "HighlyDeveloped(nyc)"
  },
  {
    "input": "Translate into first-order logic: If place A is located in place B and place B is located in place C, then place A is located in place C.",
    "output": "∀x ∀y ∀z ((Locate(x, y) ∧ Locate(y, z)) → Locate(x, z))"
  },
  {
    "input": "Translate into first-order logic: Callus 4 is a poem that was written by the ancient Roman writer Catullus.",
    "output": "Poem(callus4) ∧ WrittenBy(callus4, catullus) ∧ Roman(catullus)"
  },
  {
    "input": "Translate into first-order logic: Callus 4 is a story about the retirement of a well-traveled ship.",
    "output": "RetirementShip(callus4)"
  },
  {
    "input": "Translate into first-order logic: There is a strong analogy of human aging in the poem Callus 4.",
    "output": "Poem(callus4) → AgingAnalogy(callus4)"
  },
  {
    "input": "Translate into first-order logic: Callus 4 is written in an unusual iambic trimeter to convey a sense of speed over the waves.",
    "output": "Poem(callus4) → Lambic(callus4) ∧ Waves(callus4)"
  },
  {
    "input": "Translate into first-order logic: Callus 4 is a poem that was written by the ancient Roman writer Catullus.",
    "output": "Poem(callus4) ∧ WrittenBy(callus4, catullus) ∧ Roman(catullus)"
  },
  {
    "input": "Translate into first-order logic: Callus 4 is a story about the retirement of a well-traveled ship.",
    "output": "RetirementShip(callus4)"
  },
  {
    "input": "Translate into first-order logic: There is a strong analogy of human aging in the poem Callus 4.",
    "output": "Poem(callus4) → AgingAnalogy(callus4)"
  },
  {
    "input": "Translate into first-order logic: Callus 4 is written in an unusual iambic trimeter to convey a sense of speed over the waves.",
    "output": "Poem(callus4) → Lambic(callus4) ∧ Waves(callus4)"
  },
  {
    "input": "Translate into first-order logic: Callus 4 is a poem that was written by the ancient Roman writer Catullus.",
    "output": "Poem(callus4) ∧ WrittenBy(callus4, catullus) ∧ Roman(catullus)"
  },
  {
    "input": "Translate into first-order logic: Callus 4 is a story about the retirement of a well-traveled ship.",
    "output": "RetirementShip(callus4)"
  },
  {
    "input": "Translate into first-order logic: There is a strong analogy of human aging in the poem Callus 4.",
    "output": "Poem(callus4) → AgingAnalogy(callus4)"
  },
  {
    "input": "Translate into first-order logic: Callus 4 is written in an unusual iambic trimeter to convey a sense of speed over the waves.",
    "output": "Poem(callus4) → Lambic(callus4) ∧ Waves(callus4)"
  },
  {
    "input": "Translate into first-order logic: Westworld is an American science fiction-thriller TV series.",
    "output": "TVSeries(westworld) ∧ American(westworld) ∧ ScienceFictionThriller(westworld)"
  },
  {
    "input": "Translate into first-order logic: In 2016, a new television series named Westworld debuted on HBO.",
    "output": "Debut(westworld, year2016)"
  },
  {
    "input": "Translate into first-order logic: The TV series Westworld is adapted from the original film in 1973, which was written and directed by Michael Crichton.",
    "output": "∃x (Adapt(westworld, x) ∧ Produce(x, year1973) ∧ Write(michael, x) ∧ Direct(michael, x))"
  },
  {
    "input": "Translate into first-order logic: The 1973 film Westworld is about robots that malfunction and begin killing the human visitors.",
    "output": "About(westworld, robots)"
  },
  {
    "input": "Translate into first-order logic: Westworld is an American science fiction-thriller TV series.",
    "output": "TVSeries(westworld) ∧ American(westworld) ∧ ScienceFictionThriller(westworld)"
  },
  {
    "input": "Translate into first-order logic: In 2016, a new television series named Westworld debuted on HBO.",
    "output": "Debut(westworld, year2016)"
  },
  {
    "input": "Translate into first-order logic: The TV series Westworld is adapted from the original film in 1973, which was written and directed by Michael Crichton.",
    "output": "∃x (Adapt(westworld, x) ∧ Produce(x, year1973) ∧ Write(michael, x) ∧ Direct(michael, x))"
  },
  {
    "input": "Translate into first-order logic: The 1973 film Westworld is about robots that malfunction and begin killing the human visitors.",
    "output": "About(westworld, robots)"
  },
  {
    "input": "Translate into first-order logic: The 2008 Summer Olympics were held in Beijing, China.",
    "output": "HeldIn(summer2008olympics, beijingchina)"
  },
  {
    "input": "Translate into first-order logic: The 2008 Summer Olympics were the second Summer Olympic Games to be held in a communist state.",
    "output": "SecondToBe(summer2008olympics, heldincommuniststate)"
  },
  {
    "input": "Translate into first-order logic: China won the most gold medals (48) in the 2008 Summer Olympics.",
    "output": "Won(china, mostgoldmedals)"
  },
  {
    "input": "Translate into first-order logic: The United States placed second in the gold medal tally but won the highest number of medals overall (112) in the 2008 Summer Olympics.",
    "output": "Placed(unitedstates, secondingoldmedals) ∧ Won(unitedstates, highestnumberofmedals)"
  },
  {
    "input": "Translate into first-order logic: The third place in the gold medal tally was achieved by Russia in the 2008 Summer Olympics.",
    "output": "Placed(russia, thirdingoldmedals)"
  },
  {
    "input": "Translate into first-order logic: If a country places third in gold medals, then they had fewer gold medals than the team that won the most gold medals.",
    "output": "∀x ∀y (Placed(x, thirdingoldmedals) ∧ Won(y, mostgoldmedals) → FewerGoldMedalsThan(x, y))"
  },
  {
    "input": "Translate into first-order logic: 87 countries won at least one medal during the 2008 Games.",
    "output": "∃x (Country(x) ∧ Won(x, medal))"
  },
  {
    "input": "Translate into first-order logic: The 2008 Summer Olympics were held in Beijing, China.",
    "output": "HeldIn(summer2008olympics, beijingchina)"
  },
  {
    "input": "Translate into first-order logic: The 2008 Summer Olympics were the second Summer Olympic Games to be held in a communist state.",
    "output": "SecondToBe(summer2008olympics, heldincommuniststate)"
  },
  {
    "input": "Translate into first-order logic: China won the most gold medals (48) in the 2008 Summer Olympics.",
    "output": "Won(china, mostgoldmedals)"
  },
  {
    "input": "Translate into first-order logic: The United States placed second in the gold medal tally but won the highest number of medals overall (112) in the 2008 Summer Olympics.",
    "output": "Placed(unitedstates, secondingoldmedals) ∧ Won(unitedstates, highestnumberofmedals)"
  },
  {
    "input": "Translate into first-order logic: The third place in the gold medal tally was achieved by Russia in the 2008 Summer Olympics.",
    "output": "Placed(russia, thirdingoldmedals)"
  },
  {
    "input": "Translate into first-order logic: If a country places third in gold medals, then they had fewer gold medals than the team that won the most gold medals.",
    "output": "∀x ∀y (Placed(x, thirdingoldmedals) ∧ Won(y, mostgoldmedals) → FewerGoldMedalsThan(x, y))"
  },
  {
    "input": "Translate into first-order logic: 87 countries won at least one medal during the 2008 Games.",
    "output": "∃x (Country(x) ∧ Won(x, medal))"
  },
  {
    "input": "Translate into first-order logic: The 2008 Summer Olympics were held in Beijing, China.",
    "output": "HeldIn(summer2008olympics, beijingchina)"
  },
  {
    "input": "Translate into first-order logic: The 2008 Summer Olympics were the second Summer Olympic Games to be held in a communist state.",
    "output": "SecondToBe(summer2008olympics, heldincommuniststate)"
  },
  {
    "input": "Translate into first-order logic: China won the most gold medals (48) in the 2008 Summer Olympics.",
    "output": "Won(china, mostgoldmedals)"
  },
  {
    "input": "Translate into first-order logic: The United States placed second in the gold medal tally but won the highest number of medals overall (112) in the 2008 Summer Olympics.",
    "output": "Placed(unitedstates, secondingoldmedals) ∧ Won(unitedstates, highestnumberofmedals)"
  },
  {
    "input": "Translate into first-order logic: The third place in the gold medal tally was achieved by Russia in the 2008 Summer Olympics.",
    "output": "Placed(russia, thirdingoldmedals)"
  },
  {
    "input": "Translate into first-order logic: If a country places third in gold medals, then they had fewer gold medals than the team that won the most gold medals.",
    "output": "∀x ∀y (Placed(x, thirdingoldmedals) ∧ Won(y, mostgoldmedals) → FewerGoldMedalsThan(x, y))"
  },
  {
    "input": "Translate into first-order logic: 87 countries won at least one medal during the 2008 Games.",
    "output": "∃x (Country(x) ∧ Won(x, medal))"
  },
  {
    "input": "Translate into first-order logic: Xiufeng, Xiangshan, Diecai, Qixing are districts in the city of Guilin.",
    "output": "DistrictIn(xiufeng, guilin) ∧ DistrictIn(xiangshan, guilin) ∧ DistrictIn(diecai, guilin) ∧ DistrictIn(qixing, guilin) ∧ City(guilin)"
  },
  {
    "input": "Translate into first-order logic: Yangshuo is not a district in Guilin.",
    "output": "¬DistrictIn(yangshuo, guilin)"
  },
  {
    "input": "Translate into first-order logic: Xiufeng, Xiangshan, Diecai, Qixing are districts in the city of Guilin.",
    "output": "DistrictIn(xiufeng, guilin) ∧ DistrictIn(xiangshan, guilin) ∧ DistrictIn(diecai, guilin) ∧ DistrictIn(qixing, guilin) ∧ City(guilin)"
  },
  {
    "input": "Translate into first-order logic: Yangshuo is not a district in Guilin.",
    "output": "¬DistrictIn(yangshuo, guilin)"
  },
  {
    "input": "Translate into first-order logic: Xiufeng, Xiangshan, Diecai, Qixing are districts in the city of Guilin.",
    "output": "DistrictIn(xiufeng, guilin) ∧ DistrictIn(xiangshan, guilin) ∧ DistrictIn(diecai, guilin) ∧ DistrictIn(qixing, guilin) ∧ City(guilin)"
  },
  {
    "input": "Translate into first-order logic: Yangshuo is not a district in Guilin.",
    "output": "¬DistrictIn(yangshuo, guilin)"
  },
  {
    "input": "Translate into first-order logic: All people who grow their own fresh vegetables in their home garden also have ample space.",
    "output": "∀x (Garden(x) → Space(x))"
  },
  {
    "input": "Translate into first-order logic: If people are young working professionals who live in large cities, then they do not have ample space.",
    "output": "∀x (Professional(x) → ¬Space(x))"
  },
  {
    "input": "Translate into first-order logic: If people order takeout from delivery services often, then they grow their own fresh vegetables in their home garden.",
    "output": "∀x (Takeout(x) → Garden(x))"
  },
  {
    "input": "Translate into first-order logic: If people enjoy going out often to restaurants with friends, then they order takeout from delivery services often.",
    "output": "∀x (GoingOut(x) → Takeout(x))"
  },
  {
    "input": "Translate into first-order logic: If people regularly tout the benefits of homegrown and homecooked meals over fast food, then they enjoy going out often to restaurants with friends.",
    "output": "∀x (Homecooked(x) → GoingOut(x))"
  },
  {
    "input": "Translate into first-order logic: Michael grows his own fresh vegetables in his home garden or regularly touts the benefits of homegrown and homecooked meals over fast food.",
    "output": "Garden(michael) ∨ Homecooked(michael)"
  },
  {
    "input": "Translate into first-order logic: All people who grow their own fresh vegetables in their home garden also have ample space.",
    "output": "∀x (Garden(x) → Space(x))"
  },
  {
    "input": "Translate into first-order logic: If people are young working professionals who live in large cities, then they do not have ample space.",
    "output": "∀x (Professional(x) → ¬Space(x))"
  },
  {
    "input": "Translate into first-order logic: If people order takeout from delivery services often, then they grow their own fresh vegetables in their home garden.",
    "output": "∀x (Takeout(x) → Garden(x))"
  },
  {
    "input": "Translate into first-order logic: If people enjoy going out often to restaurants with friends, then they order takeout from delivery services often.",
    "output": "∀x (GoingOut(x) → Takeout(x))"
  },
  {
    "input": "Translate into first-order logic: If people regularly tout the benefits of homegrown and homecooked meals over fast food, then they enjoy going out often to restaurants with friends.",
    "output": "∀x (Homecooked(x) → GoingOut(x))"
  },
  {
    "input": "Translate into first-order logic: Michael grows his own fresh vegetables in his home garden or regularly touts the benefits of homegrown and homecooked meals over fast food.",
    "output": "Garden(michael) ∨ Homecooked(michael)"
  },
  {
    "input": "Translate into first-order logic: All people who grow their own fresh vegetables in their home garden also have ample space.",
    "output": "∀x (Garden(x) → Space(x))"
  },
  {
    "input": "Translate into first-order logic: If people are young working professionals who live in large cities, then they do not have ample space.",
    "output": "∀x (Professional(x) → ¬Space(x))"
  },
  {
    "input": "Translate into first-order logic: If people order takeout from delivery services often, then they grow their own fresh vegetables in their home garden.",
    "output": "∀x (Takeout(x) → Garden(x))"
  },
  {
    "input": "Translate into first-order logic: If people enjoy going out often to restaurants with friends, then they order takeout from delivery services often.",
    "output": "∀x (GoingOut(x) → Takeout(x))"
  },
  {
    "input": "Translate into first-order logic: If people regularly tout the benefits of homegrown and homecooked meals over fast food, then they enjoy going out often to restaurants with friends.",
    "output": "∀x (Homecooked(x) → GoingOut(x))"
  },
  {
    "input": "Translate into first-order logic: Michael grows his own fresh vegetables in his home garden or regularly touts the benefits of homegrown and homecooked meals over fast food.",
    "output": "Garden(michael) ∨ Homecooked(michael)"
  },
  {
    "input": "Translate into first-order logic: All devices belonging to the company are connected to Google Home.",
    "output": "∀x (Company(x) → GoogleHome(x))"
  },
  {
    "input": "Translate into first-order logic: All devices belonging to employees are connected to the company's wifi.",
    "output": "∀x (Employee(x) → Wifi(x))"
  },
  {
    "input": "Translate into first-order logic: All devices connected to Google Home are controlled by the managers.",
    "output": "∀x (GoogleHome(x) → Controlled(x))"
  },
  {
    "input": "Translate into first-order logic: All devices that connect to the company's wifi are easy to operate.",
    "output": "∀x (Wifi(x) → EasyToOperate(x))"
  },
  {
    "input": "Translate into first-order logic: IPod1 belongs to employees.",
    "output": "Employee(iPod1)"
  },
  {
    "input": "Translate into first-order logic: All devices belonging to the company are connected to Google Home.",
    "output": "∀x (Company(x) → GoogleHome(x))"
  },
  {
    "input": "Translate into first-order logic: All devices belonging to employees are connected to the company's wifi.",
    "output": "∀x (Employee(x) → Wifi(x))"
  },
  {
    "input": "Translate into first-order logic: All devices connected to Google Home are controlled by the managers.",
    "output": "∀x (GoogleHome(x) → Controlled(x))"
  },
  {
    "input": "Translate into first-order logic: All devices that connect to the company's wifi are easy to operate.",
    "output": "∀x (Wifi(x) → EasyToOperate(x))"
  },
  {
    "input": "Translate into first-order logic: IPod1 belongs to employees.",
    "output": "Employee(iPod1)"
  },
  {
    "input": "Translate into first-order logic: All devices belonging to the company are connected to Google Home.",
    "output": "∀x (Company(x) → GoogleHome(x))"
  },
  {
    "input": "Translate into first-order logic: All devices belonging to employees are connected to the company's wifi.",
    "output": "∀x (Employee(x) → Wifi(x))"
  },
  {
    "input": "Translate into first-order logic: All devices connected to Google Home are controlled by the managers.",
    "output": "∀x (GoogleHome(x) → Controlled(x))"
  },
  {
    "input": "Translate into first-order logic: All devices that connect to the company's wifi are easy to operate.",
    "output": "∀x (Wifi(x) → EasyToOperate(x))"
  },
  {
    "input": "Translate into first-order logic: IPod1 belongs to employees.",
    "output": "Employee(iPod1)"
  },
  {
    "input": "Translate into first-order logic: No touring musicians are permanent members of an orchestra.",
    "output": "∀x (Orchestra(x) → ¬Touring(x))"
  },
  {
    "input": "Translate into first-order logic: Musicians are either permanent members of an orchestra or have a unique musical voice or style.",
    "output": "∀x (Orchestra(x) ⊕ Unique(x))"
  },
  {
    "input": "Translate into first-order logic: All musicians who have a unique musical voice or style are interesting as individual performers.",
    "output": "∀x (Unique(x) → Interesting(x))"
  },
  {
    "input": "Translate into first-order logic: All musicians who are interesting as individual performers are capable of attracting large audiences.",
    "output": "∀x (Interesting(x) → Capable(x))"
  },
  {
    "input": "Translate into first-order logic: If Ryan is interesting as an individual performer and has a unique musical voice or style, then Ryan is either a touring soloist musician and capable of attracting large audiences, or neither a touring soloist musician nor capable of attracting large audiences.",
    "output": "(Interesting(ryan) ∧ Unique(ryan)) → ¬(Touring(ryan) ⊕ Capable(ryan))"
  },
  {
    "input": "Translate into first-order logic: No touring musicians are permanent members of an orchestra.",
    "output": "∀x (Orchestra(x) → ¬Touring(x))"
  },
  {
    "input": "Translate into first-order logic: Musicians are either permanent members of an orchestra or have a unique musical voice or style.",
    "output": "∀x (Orchestra(x) ⊕ Unique(x))"
  },
  {
    "input": "Translate into first-order logic: All musicians who have a unique musical voice or style are interesting as individual performers.",
    "output": "∀x (Unique(x) → Interesting(x))"
  },
  {
    "input": "Translate into first-order logic: All musicians who are interesting as individual performers are capable of attracting large audiences.",
    "output": "∀x (Interesting(x) → Capable(x))"
  },
  {
    "input": "Translate into first-order logic: If Ryan is interesting as an individual performer and has a unique musical voice or style, then Ryan is either a touring soloist musician and capable of attracting large audiences, or neither a touring soloist musician nor capable of attracting large audiences.",
    "output": "(Interesting(ryan) ∧ Unique(ryan)) → ¬(Touring(ryan) ⊕ Capable(ryan))"
  },
  {
    "input": "Translate into first-order logic: No touring musicians are permanent members of an orchestra.",
    "output": "∀x (Orchestra(x) → ¬Touring(x))"
  },
  {
    "input": "Translate into first-order logic: Musicians are either permanent members of an orchestra or have a unique musical voice or style.",
    "output": "∀x (Orchestra(x) ⊕ Unique(x))"
  },
  {
    "input": "Translate into first-order logic: All musicians who have a unique musical voice or style are interesting as individual performers.",
    "output": "∀x (Unique(x) → Interesting(x))"
  },
  {
    "input": "Translate into first-order logic: All musicians who are interesting as individual performers are capable of attracting large audiences.",
    "output": "∀x (Interesting(x) → Capable(x))"
  },
  {
    "input": "Translate into first-order logic: If Ryan is interesting as an individual performer and has a unique musical voice or style, then Ryan is either a touring soloist musician and capable of attracting large audiences, or neither a touring soloist musician nor capable of attracting large audiences.",
    "output": "(Interesting(ryan) ∧ Unique(ryan)) → ¬(Touring(ryan) ⊕ Capable(ryan))"
  },
  {
    "input": "Translate into first-order logic: If someone yells, then they are not cool.",
    "output": "∀x (Yell(x) → ¬Cool(x))"
  },
  {
    "input": "Translate into first-order logic: If someone is angry, then they yell.",
    "output": "∀x (Angry(x) → Yell(x))"
  },
  {
    "input": "Translate into first-order logic: If someone flies, then they are cool.",
    "output": "∀x (Fly(x) → Cool(x))"
  },
  {
    "input": "Translate into first-order logic: Every person that knows magic can fly.",
    "output": "∀x (KnowMagic(x) → Fly(x))"
  },
  {
    "input": "Translate into first-order logic: All wizards know magic.",
    "output": "∀x (Wizard(x) → KnowMagic(x))"
  },
  {
    "input": "Translate into first-order logic: Harry either yells and flies, or neither yells nor flies.",
    "output": "(Yell(harry) ∧ Fly(harry)) ⊕ (¬Yell(harry) ∧ ¬Fly(harry))"
  },
  {
    "input": "Translate into first-order logic: Potter is a wizard and flies.",
    "output": "Wizard(potter) ∧ Fly(potter)"
  },
  {
    "input": "Translate into first-order logic: If someone yells, then they are not cool.",
    "output": "∀x (Yell(x) → ¬Cool(x))"
  },
  {
    "input": "Translate into first-order logic: If someone is angry, then they yell.",
    "output": "∀x (Angry(x) → Yell(x))"
  },
  {
    "input": "Translate into first-order logic: If someone flies, then they are cool.",
    "output": "∀x (Fly(x) → Cool(x))"
  },
  {
    "input": "Translate into first-order logic: Every person that knows magic can fly.",
    "output": "∀x (KnowMagic(x) → Fly(x))"
  },
  {
    "input": "Translate into first-order logic: All wizards know magic.",
    "output": "∀x (Wizard(x) → KnowMagic(x))"
  },
  {
    "input": "Translate into first-order logic: Harry either yells and flies, or neither yells nor flies.",
    "output": "(Yell(harry) ∧ Fly(harry)) ⊕ (¬Yell(harry) ∧ ¬Fly(harry))"
  },
  {
    "input": "Translate into first-order logic: Potter is a wizard and flies.",
    "output": "Wizard(potter) ∧ Fly(potter)"
  },
  {
    "input": "Translate into first-order logic: If someone yells, then they are not cool.",
    "output": "∀x (Yell(x) → ¬Cool(x))"
  },
  {
    "input": "Translate into first-order logic: If someone is angry, then they yell.",
    "output": "∀x (Angry(x) → Yell(x))"
  },
  {
    "input": "Translate into first-order logic: If someone flies, then they are cool.",
    "output": "∀x (Fly(x) → Cool(x))"
  },
  {
    "input": "Translate into first-order logic: Every person that knows magic can fly.",
    "output": "∀x (KnowMagic(x) → Fly(x))"
  },
  {
    "input": "Translate into first-order logic: All wizards know magic.",
    "output": "∀x (Wizard(x) → KnowMagic(x))"
  },
  {
    "input": "Translate into first-order logic: Harry either yells and flies, or neither yells nor flies.",
    "output": "(Yell(harry) ∧ Fly(harry)) ⊕ (¬Yell(harry) ∧ ¬Fly(harry))"
  },
  {
    "input": "Translate into first-order logic: Potter is a wizard and flies.",
    "output": "Wizard(potter) ∧ Fly(potter)"
  },
  {
    "input": "Translate into first-order logic: If someone yells, then they are not cool.",
    "output": "∀x (Yell(x) → ¬Cool(x))"
  },
  {
    "input": "Translate into first-order logic: If someone is angry, then they yell.",
    "output": "∀x (Angry(x) → Yell(x))"
  },
  {
    "input": "Translate into first-order logic: If someone flies, then they are cool.",
    "output": "∀x (Fly(x) → Cool(x))"
  },
  {
    "input": "Translate into first-order logic: Every person that knows magic can fly.",
    "output": "∀x (KnowMagic(x) → Fly(x))"
  },
  {
    "input": "Translate into first-order logic: All wizards know magic.",
    "output": "∀x (Wizard(x) → KnowMagic(x))"
  },
  {
    "input": "Translate into first-order logic: Harry either yells and flies, or neither yells nor flies.",
    "output": "(Yell(harry) ∧ Fly(harry)) ⊕ (¬Yell(harry) ∧ ¬Fly(harry))"
  },
  {
    "input": "Translate into first-order logic: Potter is a wizard and flies.",
    "output": "Wizard(potter) ∧ Fly(potter)"
  },
  {
    "input": "Translate into first-order logic: Products are either produced in China or the US.",
    "output": "∀x (China(x) ⊕ US(x))"
  },
  {
    "input": "Translate into first-order logic: All produced in China are labeled.",
    "output": "∀x (China(x) → Labeled(x))"
  },
  {
    "input": "Translate into first-order logic: All produced in the US are sold in the US.",
    "output": "∀x (US(x) → SoldInUS(x))"
  },
  {
    "input": "Translate into first-order logic: If labeled, then the product is cheaper.",
    "output": "∀x (Labeled(x) → Cheaper(x))"
  },
  {
    "input": "Translate into first-order logic: All sold in the US are sold in Walmart.",
    "output": "∀x (SoldInUS(x) → SoldInWalmart(x))"
  },
  {
    "input": "Translate into first-order logic: All displayed on the homepage are sold in Walmart.",
    "output": "∀x (DisplayedInHomepage(x) → SoldInWalmart(x))"
  },
  {
    "input": "Translate into first-order logic: No products returned by customers are sold in Walmart.",
    "output": "∀x (ReturnedByCustomer(x) → ¬SoldInWalmart(x))"
  },
  {
    "input": "Translate into first-order logic: G-910 is either displayed on the homepage or cheaper.",
    "output": "¬(DisplayedInHomepage(g910) ⊕ Cheaper(g910))"
  },
  {
    "input": "Translate into first-order logic: Products are either produced in China or the US.",
    "output": "∀x (China(x) ⊕ US(x))"
  },
  {
    "input": "Translate into first-order logic: All produced in China are labeled.",
    "output": "∀x (China(x) → Labeled(x))"
  },
  {
    "input": "Translate into first-order logic: All produced in the US are sold in the US.",
    "output": "∀x (US(x) → SoldInUS(x))"
  },
  {
    "input": "Translate into first-order logic: If labeled, then the product is cheaper.",
    "output": "∀x (Labeled(x) → Cheaper(x))"
  },
  {
    "input": "Translate into first-order logic: All sold in the US are sold in Walmart.",
    "output": "∀x (SoldInUS(x) → SoldInWalmart(x))"
  },
  {
    "input": "Translate into first-order logic: All displayed on the homepage are sold in Walmart.",
    "output": "∀x (DisplayedInHomepage(x) → SoldInWalmart(x))"
  },
  {
    "input": "Translate into first-order logic: No products returned by customers are sold in Walmart.",
    "output": "∀x (ReturnedByCustomer(x) → ¬SoldInWalmart(x))"
  },
  {
    "input": "Translate into first-order logic: G-910 is either displayed on the homepage or cheaper.",
    "output": "¬(DisplayedInHomepage(g910) ⊕ Cheaper(g910))"
  },
  {
    "input": "Translate into first-order logic: Products are either produced in China or the US.",
    "output": "∀x (China(x) ⊕ US(x))"
  },
  {
    "input": "Translate into first-order logic: All produced in China are labeled.",
    "output": "∀x (China(x) → Labeled(x))"
  },
  {
    "input": "Translate into first-order logic: All produced in the US are sold in the US.",
    "output": "∀x (US(x) → SoldInUS(x))"
  },
  {
    "input": "Translate into first-order logic: If labeled, then the product is cheaper.",
    "output": "∀x (Labeled(x) → Cheaper(x))"
  },
  {
    "input": "Translate into first-order logic: All sold in the US are sold in Walmart.",
    "output": "∀x (SoldInUS(x) → SoldInWalmart(x))"
  },
  {
    "input": "Translate into first-order logic: All displayed on the homepage are sold in Walmart.",
    "output": "∀x (DisplayedInHomepage(x) → SoldInWalmart(x))"
  },
  {
    "input": "Translate into first-order logic: No products returned by customers are sold in Walmart.",
    "output": "∀x (ReturnedByCustomer(x) → ¬SoldInWalmart(x))"
  },
  {
    "input": "Translate into first-order logic: G-910 is either displayed on the homepage or cheaper.",
    "output": "¬(DisplayedInHomepage(g910) ⊕ Cheaper(g910))"
  },
  {
    "input": "Translate into first-order logic: Products are either produced in China or the US.",
    "output": "∀x (China(x) ⊕ US(x))"
  },
  {
    "input": "Translate into first-order logic: All produced in China are labeled.",
    "output": "∀x (China(x) → Labeled(x))"
  },
  {
    "input": "Translate into first-order logic: All produced in the US are sold in the US.",
    "output": "∀x (US(x) → SoldInUS(x))"
  },
  {
    "input": "Translate into first-order logic: If labeled, then the product is cheaper.",
    "output": "∀x (Labeled(x) → Cheaper(x))"
  },
  {
    "input": "Translate into first-order logic: All sold in the US are sold in Walmart.",
    "output": "∀x (SoldInUS(x) → SoldInWalmart(x))"
  },
  {
    "input": "Translate into first-order logic: All displayed on the homepage are sold in Walmart.",
    "output": "∀x (DisplayedInHomepage(x) → SoldInWalmart(x))"
  },
  {
    "input": "Translate into first-order logic: No products returned by customers are sold in Walmart.",
    "output": "∀x (ReturnedByCustomer(x) → ¬SoldInWalmart(x))"
  },
  {
    "input": "Translate into first-order logic: G-910 is either displayed on the homepage or cheaper.",
    "output": "¬(DisplayedInHomepage(g910) ⊕ Cheaper(g910))"
  },
  {
    "input": "Translate into first-order logic: Products are either produced in China or the US.",
    "output": "∀x (China(x) ⊕ US(x))"
  },
  {
    "input": "Translate into first-order logic: All produced in China are labeled.",
    "output": "∀x (China(x) → Labeled(x))"
  },
  {
    "input": "Translate into first-order logic: All produced in the US are sold in the US.",
    "output": "∀x (US(x) → SoldInUS(x))"
  },
  {
    "input": "Translate into first-order logic: If labeled, then the product is cheaper.",
    "output": "∀x (Labeled(x) → Cheaper(x))"
  },
  {
    "input": "Translate into first-order logic: All sold in the US are sold in Walmart.",
    "output": "∀x (SoldInUS(x) → SoldInWalmart(x))"
  },
  {
    "input": "Translate into first-order logic: All displayed on the homepage are sold in Walmart.",
    "output": "∀x (DisplayedInHomepage(x) → SoldInWalmart(x))"
  },
  {
    "input": "Translate into first-order logic: No products returned by customers are sold in Walmart.",
    "output": "∀x (ReturnedByCustomer(x) → ¬SoldInWalmart(x))"
  },
  {
    "input": "Translate into first-order logic: G-910 is either displayed on the homepage or cheaper.",
    "output": "¬(DisplayedInHomepage(g910) ⊕ Cheaper(g910))"
  },
  {
    "input": "Translate into first-order logic: People either order a lot of Amazon packages or are environmentally conscious.",
    "output": "∀x (Amazon(x) ⊕ Environmental(x))"
  },
  {
    "input": "Translate into first-order logic: If people order a lot of Amazon packages, then they get a lot of daily mail delivered.",
    "output": "∀x (Amazon(x) → DailyMail(x))"
  },
  {
    "input": "Translate into first-order logic: If people are environmentally conscious, then they have solar panels in their homes.",
    "output": "∀x (Environmental(x) → Solar(x))"
  },
  {
    "input": "Translate into first-order logic: If people get a lot of daily mail delivered, then they are very involved with their neighborhood.",
    "output": "∀x (DailyMail(x) → Neighborhood(x))"
  },
  {
    "input": "Translate into first-order logic: If people have solar panels in their homes, then they save a lot of money.",
    "output": "∀x (Solar(x) → SaveMoney(x))"
  },
  {
    "input": "Translate into first-order logic: If Marcy either gets a lot of mail and is very involved with her neighborhood or if she does not order a lot of Amazon packages nor is very involved with her neighborhood, then Marcy does not both get a lot of daily mail and order a lot of Amazon packages.",
    "output": "¬(DailyMail(marcy) ⊕ Neighborhood(marcy)) → (¬DailyMail(marcy) ∨ ¬Amazon(marcy))"
  },
  {
    "input": "Translate into first-order logic: People either order a lot of Amazon packages or are environmentally conscious.",
    "output": "∀x (Amazon(x) ⊕ Environmental(x))"
  },
  {
    "input": "Translate into first-order logic: If people order a lot of Amazon packages, then they get a lot of daily mail delivered.",
    "output": "∀x (Amazon(x) → DailyMail(x))"
  },
  {
    "input": "Translate into first-order logic: If people are environmentally conscious, then they have solar panels in their homes.",
    "output": "∀x (Environmental(x) → Solar(x))"
  },
  {
    "input": "Translate into first-order logic: If people get a lot of daily mail delivered, then they are very involved with their neighborhood.",
    "output": "∀x (DailyMail(x) → Neighborhood(x))"
  },
  {
    "input": "Translate into first-order logic: If people have solar panels in their homes, then they save a lot of money.",
    "output": "∀x (Solar(x) → SaveMoney(x))"
  },
  {
    "input": "Translate into first-order logic: If Marcy either gets a lot of mail and is very involved with her neighborhood or if she does not order a lot of Amazon packages nor is very involved with her neighborhood, then Marcy does not both get a lot of daily mail and order a lot of Amazon packages.",
    "output": "¬(DailyMail(marcy) ⊕ Neighborhood(marcy)) → (¬DailyMail(marcy) ∨ ¬Amazon(marcy))"
  },
  {
    "input": "Translate into first-order logic: Indonesia is a country.",
    "output": "Country(indonesia)"
  },
  {
    "input": "Translate into first-order logic: In Indonesia, the prosecutor only personally investigates cases of some special crimes.",
    "output": "∃x ∃y (Country(indonesia) ∧ Prosecutor(x) ∧ Crime(y) → InvestigatePersonally(x, y))"
  },
  {
    "input": "Translate into first-order logic: Corruption is a type of crime.",
    "output": "Crime(corruption)"
  },
  {
    "input": "Translate into first-order logic: Once the police complete investigations of a crime, they hand the evidence to the prosecutor.",
    "output": "∀x ∀y (Crime(y) ∧ PoliceCompInves(y) ∧ Prosecutor(x) → Evidence(y) ∧ HandToProsecutor(x, y))"
  },
  {
    "input": "Translate into first-order logic: Evidence can be either satisfactory or unsatisfactory.",
    "output": "∀x (Crime(x) ∧ Evidence(x) ∧ (Satisfactory(x) ⊕ Unsatisfactory(x)))"
  },
  {
    "input": "Translate into first-order logic: If the police hand the evidence to the prosecutor and the evidence is satisfactory, the prosecutor will prosecute the offender in an appropriate court.",
    "output": "∀x ∀y (Evidence(y) ∧ HandToProsecutor(x, y) ∧ Satisfactory(y) → ProsecuteTheOffender(x, y))"
  },
  {
    "input": "Translate into first-order logic: Indonesia is a country.",
    "output": "Country(indonesia)"
  },
  {
    "input": "Translate into first-order logic: In Indonesia, the prosecutor only personally investigates cases of some special crimes.",
    "output": "∃x ∃y (Country(indonesia) ∧ Prosecutor(x) ∧ Crime(y) → InvestigatePersonally(x, y))"
  },
  {
    "input": "Translate into first-order logic: Corruption is a type of crime.",
    "output": "Crime(corruption)"
  },
  {
    "input": "Translate into first-order logic: Once the police complete investigations of a crime, they hand the evidence to the prosecutor.",
    "output": "∀x ∀y (Crime(y) ∧ PoliceCompInves(y) ∧ Prosecutor(x) → Evidence(y) ∧ HandToProsecutor(x, y))"
  },
  {
    "input": "Translate into first-order logic: Evidence can be either satisfactory or unsatisfactory.",
    "output": "∀x (Crime(x) ∧ Evidence(x) ∧ (Satisfactory(x) ⊕ Unsatisfactory(x)))"
  },
  {
    "input": "Translate into first-order logic: If the police hand the evidence to the prosecutor and the evidence is satisfactory, the prosecutor will prosecute the offender in an appropriate court.",
    "output": "∀x ∀y (Evidence(y) ∧ HandToProsecutor(x, y) ∧ Satisfactory(y) → ProsecuteTheOffender(x, y))"
  },
  {
    "input": "Translate into first-order logic: Indonesia is a country.",
    "output": "Country(indonesia)"
  },
  {
    "input": "Translate into first-order logic: In Indonesia, the prosecutor only personally investigates cases of some special crimes.",
    "output": "∃x ∃y (Country(indonesia) ∧ Prosecutor(x) ∧ Crime(y) → InvestigatePersonally(x, y))"
  },
  {
    "input": "Translate into first-order logic: Corruption is a type of crime.",
    "output": "Crime(corruption)"
  },
  {
    "input": "Translate into first-order logic: Once the police complete investigations of a crime, they hand the evidence to the prosecutor.",
    "output": "∀x ∀y (Crime(y) ∧ PoliceCompInves(y) ∧ Prosecutor(x) → Evidence(y) ∧ HandToProsecutor(x, y))"
  },
  {
    "input": "Translate into first-order logic: Evidence can be either satisfactory or unsatisfactory.",
    "output": "∀x (Crime(x) ∧ Evidence(x) ∧ (Satisfactory(x) ⊕ Unsatisfactory(x)))"
  },
  {
    "input": "Translate into first-order logic: If the police hand the evidence to the prosecutor and the evidence is satisfactory, the prosecutor will prosecute the offender in an appropriate court.",
    "output": "∀x ∀y (Evidence(y) ∧ HandToProsecutor(x, y) ∧ Satisfactory(y) → ProsecuteTheOffender(x, y))"
  },
  {
    "input": "Translate into first-order logic: No watch that is battery-powered is automatic.",
    "output": "∀x (BatteryPoweredWatch(x) → ¬AutomaticWatch(x))"
  },
  {
    "input": "Translate into first-order logic: All digital watches are battery-powered.",
    "output": "∀x (DigitalWatch(x) → BatteryPoweredWatch(x))"
  },
  {
    "input": "Translate into first-order logic: Some mechanical watches are automatic.",
    "output": "∃x (MechanicalWatch(x) ∧ AutomaticWatch(x))"
  },
  {
    "input": "Translate into first-order logic: All smart watches are digital.",
    "output": "∀x (SmartWatch(x) → DigitalWatch(x))"
  },
  {
    "input": "Translate into first-order logic: Moonwatch is not a digital watch or an automatic.",
    "output": "¬DigitalWatch(moonwatch) ⊕ AutomaticWatch(moonwatch)"
  },
  {
    "input": "Translate into first-order logic: No watch that is battery-powered is automatic.",
    "output": "∀x (BatteryPoweredWatch(x) → ¬AutomaticWatch(x))"
  },
  {
    "input": "Translate into first-order logic: All digital watches are battery-powered.",
    "output": "∀x (DigitalWatch(x) → BatteryPoweredWatch(x))"
  },
  {
    "input": "Translate into first-order logic: Some mechanical watches are automatic.",
    "output": "∃x (MechanicalWatch(x) ∧ AutomaticWatch(x))"
  },
  {
    "input": "Translate into first-order logic: All smart watches are digital.",
    "output": "∀x (SmartWatch(x) → DigitalWatch(x))"
  },
  {
    "input": "Translate into first-order logic: Moonwatch is not a digital watch or an automatic.",
    "output": "¬DigitalWatch(moonwatch) ⊕ AutomaticWatch(moonwatch)"
  },
  {
    "input": "Translate into first-order logic: No watch that is battery-powered is automatic.",
    "output": "∀x (BatteryPoweredWatch(x) → ¬AutomaticWatch(x))"
  },
  {
    "input": "Translate into first-order logic: All digital watches are battery-powered.",
    "output": "∀x (DigitalWatch(x) → BatteryPoweredWatch(x))"
  },
  {
    "input": "Translate into first-order logic: Some mechanical watches are automatic.",
    "output": "∃x (MechanicalWatch(x) ∧ AutomaticWatch(x))"
  },
  {
    "input": "Translate into first-order logic: All smart watches are digital.",
    "output": "∀x (SmartWatch(x) → DigitalWatch(x))"
  },
  {
    "input": "Translate into first-order logic: Moonwatch is not a digital watch or an automatic.",
    "output": "¬DigitalWatch(moonwatch) ⊕ AutomaticWatch(moonwatch)"
  },
  {
    "input": "Translate into first-order logic: No watch that is battery-powered is automatic.",
    "output": "∀x (BatteryPoweredWatch(x) → ¬AutomaticWatch(x))"
  },
  {
    "input": "Translate into first-order logic: All digital watches are battery-powered.",
    "output": "∀x (DigitalWatch(x) → BatteryPoweredWatch(x))"
  },
  {
    "input": "Translate into first-order logic: Some mechanical watches are automatic.",
    "output": "∃x (MechanicalWatch(x) ∧ AutomaticWatch(x))"
  },
  {
    "input": "Translate into first-order logic: All smart watches are digital.",
    "output": "∀x (SmartWatch(x) → DigitalWatch(x))"
  },
  {
    "input": "Translate into first-order logic: Moonwatch is not a digital watch or an automatic.",
    "output": "¬DigitalWatch(moonwatch) ⊕ AutomaticWatch(moonwatch)"
  },
  {
    "input": "Translate into first-order logic: If a person can distinguish the taste of different condiments, then he/she can also use different condiments to cook.",
    "output": "∀x (People(x) ∧ DistinguishCondiments(x) → UseDiffCondiments(x)) ∧ (∃x (People(x) ∧ ¬DistinguishCondiments(x) ∧ UseDiffCondiments(x))) ∧ ¬(∀x (People(x) ∧ DistinguishCondiments(x)))"
  },
  {
    "input": "Translate into first-order logic: People who have the talent of cooking can distinguish the taste of different condiments.",
    "output": "∀x (People(x) ∧ TalentCooking(x) → DistinguishCondiments(x))"
  },
  {
    "input": "Translate into first-order logic: Only people with the talent of cooking can make delicious meals.",
    "output": "∀x ∀y (MakeMeal(x, y) ∧ Delicious(y) ∧ People(x) → TalentCooking(x)) "
  },
  {
    "input": "Translate into first-order logic: If the meal is popular at the party, then it is delicious.",
    "output": "∀x ∀y (MakeMeal(x, y) ∧ People(x) ∧ Popular(y) → Delicious(y))"
  },
  {
    "input": "Translate into first-order logic: John can make meals which are popular at the party.",
    "output": "∃x (People(john) ∧ MakeMeal(john, x) ∧ Popular(x) ∧ People(peter) ∧ ¬UseDiffCondiments(peter))"
  },
  {
    "input": "Translate into first-order logic: Effective monetary policy is possible with successful inflation control and a strong national currency.",
    "output": "∀x (EffMonPolicy(x) → InfControl(x) ∧ StongCurr(x))"
  },
  {
    "input": "Translate into first-order logic: A country cannot simultaneously regulate the exchange rate and successfully control inflation.",
    "output": "¬(∀x (InfControl(x) ∧ ExRate(x)))"
  },
  {
    "input": "Translate into first-order logic: The introduction of an embargo on foreign trade goods in a country leads to a sharp decrease in exports.",
    "output": "∀x (Embargo(x) → ExportFall(x))"
  },
  {
    "input": "Translate into first-order logic: If exports fall sharply, the national currency cannot be in this country.",
    "output": "∀x (ExportFall(x) → ¬StongCurr(x))"
  },
  {
    "input": "Translate into first-order logic: Regulation of the exchange rate is required to have a strong national currency.",
    "output": "∀x (ExRate(x) → StongCurr(x))"
  },
  {
    "input": "Translate into first-order logic: There is an embargo on Russian foreign trade goods.",
    "output": "Embargo(russia)"
  },
  {
    "input": "Translate into first-order logic: Video Gag is a French television series that airs weekly.",
    "output": "∀x (VideoGag(x) → FrenchTelevision(x) ∧ AirsWeekly(x))"
  },
  {
    "input": "Translate into first-order logic: Video Gag airs on the French broadcast channel TF1.",
    "output": "∀x (VideoGag(x) → ChannelTF1(x))"
  },
  {
    "input": "Translate into first-order logic: If viewers send in funny videos to the French broadcast channel, then Video Gag airs them on television.",
    "output": "∀x (FunnyVideos(x) → AirsWeekly(x))"
  },
  {
    "input": "Translate into first-order logic: All videos aired on Video Gag are in French.",
    "output": "∀x (VideoGag(x) → AirsWeekly(x) ∧ French(x))"
  },
  {
    "input": "Translate into first-order logic: Video Gag is a French television series that airs weekly.",
    "output": "∀x (VideoGag(x) → FrenchTelevision(x) ∧ AirsWeekly(x))"
  },
  {
    "input": "Translate into first-order logic: Video Gag airs on the French broadcast channel TF1.",
    "output": "∀x (VideoGag(x) → ChannelTF1(x))"
  },
  {
    "input": "Translate into first-order logic: If viewers send in funny videos to the French broadcast channel, then Video Gag airs them on television.",
    "output": "∀x (FunnyVideos(x) → AirsWeekly(x))"
  },
  {
    "input": "Translate into first-order logic: All videos aired on Video Gag are in French.",
    "output": "∀x (VideoGag(x) → AirsWeekly(x) ∧ French(x))"
  },
  {
    "input": "Translate into first-order logic: All phones are things.",
    "output": "∀x (Phone(x) → Thing(x))"
  },
  {
    "input": "Translate into first-order logic: All cellphones are phones.",
    "output": "∀x (Cellphone(x) → Phone(x))"
  },
  {
    "input": "Translate into first-order logic: All iPhones are cellphones.",
    "output": "∀x (Iphone(x) → Cellphone(x))"
  },
  {
    "input": "Translate into first-order logic: All engineers are workers.",
    "output": "∀x (Engineer(x) → Worker(x))"
  },
  {
    "input": "Translate into first-order logic: All workers are human.",
    "output": "∀x (Worker(x) → Human(x))"
  },
  {
    "input": "Translate into first-order logic: Jack is either an engineer or a worker.",
    "output": "Engineer(jack) ⊕ Worker(jack) "
  },
  {
    "input": "Translate into first-order logic: Jack is is either a human or a phone.",
    "output": "Human(jack) ⊕ Phone(jack)"
  },
  {
    "input": "Translate into first-order logic: All phones are things.",
    "output": "∀x (Phone(x) → Thing(x))"
  },
  {
    "input": "Translate into first-order logic: All cellphones are phones.",
    "output": "∀x (Cellphone(x) → Phone(x))"
  },
  {
    "input": "Translate into first-order logic: All iPhones are cellphones.",
    "output": "∀x (Iphone(x) → Cellphone(x))"
  },
  {
    "input": "Translate into first-order logic: All engineers are workers.",
    "output": "∀x (Engineer(x) → Worker(x))"
  },
  {
    "input": "Translate into first-order logic: All workers are human.",
    "output": "∀x (Worker(x) → Human(x))"
  },
  {
    "input": "Translate into first-order logic: Jack is either an engineer or a worker.",
    "output": "Engineer(jack) ⊕ Worker(jack) "
  },
  {
    "input": "Translate into first-order logic: Jack is is either a human or a phone.",
    "output": "Human(jack) ⊕ Phone(jack)"
  },
  {
    "input": "Translate into first-order logic: All phones are things.",
    "output": "∀x (Phone(x) → Thing(x))"
  },
  {
    "input": "Translate into first-order logic: All cellphones are phones.",
    "output": "∀x (Cellphone(x) → Phone(x))"
  },
  {
    "input": "Translate into first-order logic: All iPhones are cellphones.",
    "output": "∀x (Iphone(x) → Cellphone(x))"
  },
  {
    "input": "Translate into first-order logic: All engineers are workers.",
    "output": "∀x (Engineer(x) → Worker(x))"
  },
  {
    "input": "Translate into first-order logic: All workers are human.",
    "output": "∀x (Worker(x) → Human(x))"
  },
  {
    "input": "Translate into first-order logic: Jack is either an engineer or a worker.",
    "output": "Engineer(jack) ⊕ Worker(jack) "
  },
  {
    "input": "Translate into first-order logic: Jack is is either a human or a phone.",
    "output": "Human(jack) ⊕ Phone(jack)"
  },
  {
    "input": "Translate into first-order logic: All phones are things.",
    "output": "∀x (Phone(x) → Thing(x))"
  },
  {
    "input": "Translate into first-order logic: All cellphones are phones.",
    "output": "∀x (Cellphone(x) → Phone(x))"
  },
  {
    "input": "Translate into first-order logic: All iPhones are cellphones.",
    "output": "∀x (Iphone(x) → Cellphone(x))"
  },
  {
    "input": "Translate into first-order logic: All engineers are workers.",
    "output": "∀x (Engineer(x) → Worker(x))"
  },
  {
    "input": "Translate into first-order logic: All workers are human.",
    "output": "∀x (Worker(x) → Human(x))"
  },
  {
    "input": "Translate into first-order logic: Jack is either an engineer or a worker.",
    "output": "Engineer(jack) ⊕ Worker(jack) "
  },
  {
    "input": "Translate into first-order logic: Jack is is either a human or a phone.",
    "output": "Human(jack) ⊕ Phone(jack)"
  },
  {
    "input": "Translate into first-order logic: All iPhones are electronic.",
    "output": "∀x (IPhone(x) → Electronic(x))"
  },
  {
    "input": "Translate into first-order logic: Some phones are iPhones.",
    "output": "∃x (Phone(x) ∧ IPhone(x))"
  },
  {
    "input": "Translate into first-order logic: Metropolitan Museum of Art is a museum in NYC.",
    "output": "Museum(metropolitanMuseumofArt) ∧ InNYC(metropolitanMuseumofArt)"
  },
  {
    "input": "Translate into first-order logic: Whitney Museum of American Art is a museum in NYC.",
    "output": "Museum(whitneyMuseumofAmericanArt) ∧ InNYC(whitneyMuseumofAmericanArt)"
  },
  {
    "input": "Translate into first-order logic: Museum of Modern Art (MoMA) is a museum if NYC.",
    "output": "Museum(museumofModernArt) ∧ InNYC(museumofModernArt)"
  },
  {
    "input": "Translate into first-order logic: Metropolitan Museum of Art includes Bytantine and Islamic Art.",
    "output": "Include(metropolitanMuseumofArt, byzantineArt) ∧ Include(metropolitanMuseumofArt, islamicArt)"
  },
  {
    "input": "Translate into first-order logic: Whitney Museum of American Art includes American art.",
    "output": "Include(whitneyMuseumofAmericanArt, americanArt)"
  },
  {
    "input": "Translate into first-order logic: Metropolitan Museum of Art is a museum in NYC.",
    "output": "Museum(metropolitanMuseumofArt) ∧ InNYC(metropolitanMuseumofArt)"
  },
  {
    "input": "Translate into first-order logic: Whitney Museum of American Art is a museum in NYC.",
    "output": "Museum(whitneyMuseumofAmericanArt) ∧ InNYC(whitneyMuseumofAmericanArt)"
  },
  {
    "input": "Translate into first-order logic: Museum of Modern Art (MoMA) is a museum if NYC.",
    "output": "Museum(museumofModernArt) ∧ InNYC(museumofModernArt)"
  },
  {
    "input": "Translate into first-order logic: Metropolitan Museum of Art includes Bytantine and Islamic Art.",
    "output": "Include(metropolitanMuseumofArt, byzantineArt) ∧ Include(metropolitanMuseumofArt, islamicArt)"
  },
  {
    "input": "Translate into first-order logic: Whitney Museum of American Art includes American art.",
    "output": "Include(whitneyMuseumofAmericanArt, americanArt)"
  },
  {
    "input": "Translate into first-order logic: Metropolitan Museum of Art is a museum in NYC.",
    "output": "Museum(metropolitanMuseumofArt) ∧ InNYC(metropolitanMuseumofArt)"
  },
  {
    "input": "Translate into first-order logic: Whitney Museum of American Art is a museum in NYC.",
    "output": "Museum(whitneyMuseumofAmericanArt) ∧ InNYC(whitneyMuseumofAmericanArt)"
  },
  {
    "input": "Translate into first-order logic: Museum of Modern Art (MoMA) is a museum if NYC.",
    "output": "Museum(museumofModernArt) ∧ InNYC(museumofModernArt)"
  },
  {
    "input": "Translate into first-order logic: Metropolitan Museum of Art includes Bytantine and Islamic Art.",
    "output": "Include(metropolitanMuseumofArt, byzantineArt) ∧ Include(metropolitanMuseumofArt, islamicArt)"
  },
  {
    "input": "Translate into first-order logic: Whitney Museum of American Art includes American art.",
    "output": "Include(whitneyMuseumofAmericanArt, americanArt)"
  },
  {
    "input": "Translate into first-order logic: A person either likes eating cheese or is a francophile.",
    "output": "∀x (Spanish(x) ∨ Francophile(x))"
  },
  {
    "input": "Translate into first-order logic: No francophiles are people who like Spain as their favorite country.",
    "output": "∀x (Francophile(x) → ¬SpainFav(x))"
  },
  {
    "input": "Translate into first-order logic: A person likes Spain as their favorite country or likes eating cheese.",
    "output": "∀x (SpainFav(x) ∨ Cheese(x))"
  },
  {
    "input": "Translate into first-order logic: Benji is not a person who likes eating cheese and a person who studies Spanish.",
    "output": "¬(Cheese(benji) ∧ Spanish(benji))"
  },
  {
    "input": "Translate into first-order logic: If Benji is neither a person who studies Spanish nor a person that studies French, then Benji is a person who studies Spanish or a person that studies French.",
    "output": "¬(Spanish(benji) ∨ French(benji)) → ¬(Cheese(benji) ⊕ French(benji))"
  },
  {
    "input": "Translate into first-order logic: A person either likes eating cheese or is a francophile.",
    "output": "∀x (Spanish(x) ∨ Francophile(x))"
  },
  {
    "input": "Translate into first-order logic: No francophiles are people who like Spain as their favorite country.",
    "output": "∀x (Francophile(x) → ¬SpainFav(x))"
  },
  {
    "input": "Translate into first-order logic: A person likes Spain as their favorite country or likes eating cheese.",
    "output": "∀x (SpainFav(x) ∨ Cheese(x))"
  },
  {
    "input": "Translate into first-order logic: Benji is not a person who likes eating cheese and a person who studies Spanish.",
    "output": "¬(Cheese(benji) ∧ Spanish(benji))"
  },
  {
    "input": "Translate into first-order logic: If Benji is neither a person who studies Spanish nor a person that studies French, then Benji is a person who studies Spanish or a person that studies French.",
    "output": "¬(Spanish(benji) ∨ French(benji)) → ¬(Cheese(benji) ⊕ French(benji))"
  },
  {
    "input": "Translate into first-order logic: A person either likes eating cheese or is a francophile.",
    "output": "∀x (Spanish(x) ∨ Francophile(x))"
  },
  {
    "input": "Translate into first-order logic: No francophiles are people who like Spain as their favorite country.",
    "output": "∀x (Francophile(x) → ¬SpainFav(x))"
  },
  {
    "input": "Translate into first-order logic: A person likes Spain as their favorite country or likes eating cheese.",
    "output": "∀x (SpainFav(x) ∨ Cheese(x))"
  },
  {
    "input": "Translate into first-order logic: Benji is not a person who likes eating cheese and a person who studies Spanish.",
    "output": "¬(Cheese(benji) ∧ Spanish(benji))"
  },
  {
    "input": "Translate into first-order logic: If Benji is neither a person who studies Spanish nor a person that studies French, then Benji is a person who studies Spanish or a person that studies French.",
    "output": "¬(Spanish(benji) ∨ French(benji)) → ¬(Cheese(benji) ⊕ French(benji))"
  },
  {
    "input": "Translate into first-order logic: Gasteren is village located in the province of Drenthe.",
    "output": "Village(gasteren) ∧ Province(drenthe) ∧ LocatedIn(gasteren, drenthe)"
  },
  {
    "input": "Translate into first-order logic: Drenthe is a Dutch province.",
    "output": "Province(drenthe) ∧ Dutch(drenthe)"
  },
  {
    "input": "Translate into first-order logic: No cities are villages.",
    "output": "∀x (City(x) → ¬Village(x))"
  },
  {
    "input": "Translate into first-order logic: The population of a village in Drenthe was 155 people.",
    "output": "∃x (Population155(x) ∧ Village(x) ∧ LocatedIn(x, drenthe))"
  },
  {
    "input": "Translate into first-order logic: Gasteren is village located in the province of Drenthe.",
    "output": "Village(gasteren) ∧ Province(drenthe) ∧ LocatedIn(gasteren, drenthe)"
  },
  {
    "input": "Translate into first-order logic: Drenthe is a Dutch province.",
    "output": "Province(drenthe) ∧ Dutch(drenthe)"
  },
  {
    "input": "Translate into first-order logic: No cities are villages.",
    "output": "∀x (City(x) → ¬Village(x))"
  },
  {
    "input": "Translate into first-order logic: The population of a village in Drenthe was 155 people.",
    "output": "∃x (Population155(x) ∧ Village(x) ∧ LocatedIn(x, drenthe))"
  },
  {
    "input": "Translate into first-order logic: Gasteren is village located in the province of Drenthe.",
    "output": "Village(gasteren) ∧ Province(drenthe) ∧ LocatedIn(gasteren, drenthe)"
  },
  {
    "input": "Translate into first-order logic: Drenthe is a Dutch province.",
    "output": "Province(drenthe) ∧ Dutch(drenthe)"
  },
  {
    "input": "Translate into first-order logic: No cities are villages.",
    "output": "∀x (City(x) → ¬Village(x))"
  },
  {
    "input": "Translate into first-order logic: The population of a village in Drenthe was 155 people.",
    "output": "∃x (Population155(x) ∧ Village(x) ∧ LocatedIn(x, drenthe))"
  },
  {
    "input": "Translate into first-order logic: The only types of mammals that lay eggs are platypuses and echidnas.",
    "output": "∀x ((Mammal(x) ∧ LayEgg(x)) → (Platypuses(x) ⊕ Echidnas(x)))"
  },
  {
    "input": "Translate into first-order logic: Platypuses are not hyrax.",
    "output": "∀x (Platypuses(x) → ¬Hyrax(x))"
  },
  {
    "input": "Translate into first-order logic: Echidnas are not hyrax.",
    "output": "∀x (Echidnas(x) → ¬Hyrax(x))"
  },
  {
    "input": "Translate into first-order logic: No mammals are invertebrates.",
    "output": "∀x (Mammal(x) → ¬Invertebrate(x))"
  },
  {
    "input": "Translate into first-order logic: All animals are either vertebrates or invertebrates.",
    "output": "∀x (Animal(x) → Invertebrate(x) ⊕ Vertebrate(x))"
  },
  {
    "input": "Translate into first-order logic: Mammals are animals.",
    "output": "∀x (Mammal(x) → Animal(x))"
  },
  {
    "input": "Translate into first-order logic: Hyraxes are mammals.",
    "output": "∀x (Hyrax(x) → Mammal(x))"
  },
  {
    "input": "Translate into first-order logic: Grebes lay eggs.",
    "output": "∀x (Grebes(x) → LayEgg(x))"
  },
  {
    "input": "Translate into first-order logic: Grebes are not platypuses and also not echidnas.",
    "output": "∀x (Grebes(x) → (¬Platypuses(x) ∧ ¬Echidnas(x)))"
  },
  {
    "input": "Translate into first-order logic: The only types of mammals that lay eggs are platypuses and echidnas.",
    "output": "∀x ((Mammal(x) ∧ LayEgg(x)) → (Platypuses(x) ⊕ Echidnas(x)))"
  },
  {
    "input": "Translate into first-order logic: Platypuses are not hyrax.",
    "output": "∀x (Platypuses(x) → ¬Hyrax(x))"
  },
  {
    "input": "Translate into first-order logic: Echidnas are not hyrax.",
    "output": "∀x (Echidnas(x) → ¬Hyrax(x))"
  },
  {
    "input": "Translate into first-order logic: No mammals are invertebrates.",
    "output": "∀x (Mammal(x) → ¬Invertebrate(x))"
  },
  {
    "input": "Translate into first-order logic: All animals are either vertebrates or invertebrates.",
    "output": "∀x (Animal(x) → Invertebrate(x) ⊕ Vertebrate(x))"
  },
  {
    "input": "Translate into first-order logic: Mammals are animals.",
    "output": "∀x (Mammal(x) → Animal(x))"
  },
  {
    "input": "Translate into first-order logic: Hyraxes are mammals.",
    "output": "∀x (Hyrax(x) → Mammal(x))"
  },
  {
    "input": "Translate into first-order logic: Grebes lay eggs.",
    "output": "∀x (Grebes(x) → LayEgg(x))"
  },
  {
    "input": "Translate into first-order logic: Grebes are not platypuses and also not echidnas.",
    "output": "∀x (Grebes(x) → (¬Platypuses(x) ∧ ¬Echidnas(x)))"
  },
  {
    "input": "Translate into first-order logic: The only types of mammals that lay eggs are platypuses and echidnas.",
    "output": "∀x ((Mammal(x) ∧ LayEgg(x)) → (Platypuses(x) ⊕ Echidnas(x)))"
  },
  {
    "input": "Translate into first-order logic: Platypuses are not hyrax.",
    "output": "∀x (Platypuses(x) → ¬Hyrax(x))"
  },
  {
    "input": "Translate into first-order logic: Echidnas are not hyrax.",
    "output": "∀x (Echidnas(x) → ¬Hyrax(x))"
  },
  {
    "input": "Translate into first-order logic: No mammals are invertebrates.",
    "output": "∀x (Mammal(x) → ¬Invertebrate(x))"
  },
  {
    "input": "Translate into first-order logic: All animals are either vertebrates or invertebrates.",
    "output": "∀x (Animal(x) → Invertebrate(x) ⊕ Vertebrate(x))"
  },
  {
    "input": "Translate into first-order logic: Mammals are animals.",
    "output": "∀x (Mammal(x) → Animal(x))"
  },
  {
    "input": "Translate into first-order logic: Hyraxes are mammals.",
    "output": "∀x (Hyrax(x) → Mammal(x))"
  },
  {
    "input": "Translate into first-order logic: Grebes lay eggs.",
    "output": "∀x (Grebes(x) → LayEgg(x))"
  },
  {
    "input": "Translate into first-order logic: Grebes are not platypuses and also not echidnas.",
    "output": "∀x (Grebes(x) → (¬Platypuses(x) ∧ ¬Echidnas(x)))"
  },
  {
    "input": "Translate into first-order logic: Bobby Flynn is a singer-songwriter.",
    "output": "Singer(bobbyFlynn) ∧ SongWriter(bobbyFlynn)"
  },
  {
    "input": "Translate into first-order logic: Bobby Flynn finished 7th while competing on Australian Idol.",
    "output": "Finished7th(bobbyFlynn) ∧ CompetedOnAustralianIdol(bobbyFlynn)"
  },
  {
    "input": "Translate into first-order logic: Australian Idol competitors are Australian citizens.",
    "output": "∀x (CompetedOnAustralianIdol(x) → AustralianCitizen(x))"
  },
  {
    "input": "Translate into first-order logic: The Omega Three band made a nationwide tour in 2007.",
    "output": "MadeNationWideTour2007(theOmegaThreeBand) "
  },
  {
    "input": "Translate into first-order logic: Bobby Flynn is a member of The Omega Three band.",
    "output": "IsMember(bobbyFlynn, theOmegaThreeBand)"
  },
  {
    "input": "Translate into first-order logic: Bobby Flynn was born in Queensland.",
    "output": "BornIn(bobbyFlynn, queensland)"
  },
  {
    "input": "Translate into first-order logic: Bobby Flynn is a singer-songwriter.",
    "output": "Singer(bobbyFlynn) ∧ SongWriter(bobbyFlynn)"
  },
  {
    "input": "Translate into first-order logic: Bobby Flynn finished 7th while competing on Australian Idol.",
    "output": "Finished7th(bobbyFlynn) ∧ CompetedOnAustralianIdol(bobbyFlynn)"
  },
  {
    "input": "Translate into first-order logic: Australian Idol competitors are Australian citizens.",
    "output": "∀x (CompetedOnAustralianIdol(x) → AustralianCitizen(x))"
  },
  {
    "input": "Translate into first-order logic: The Omega Three band made a nationwide tour in 2007.",
    "output": "MadeNationWideTour2007(theOmegaThreeBand) "
  },
  {
    "input": "Translate into first-order logic: Bobby Flynn is a member of The Omega Three band.",
    "output": "IsMember(bobbyFlynn, theOmegaThreeBand)"
  },
  {
    "input": "Translate into first-order logic: Bobby Flynn was born in Queensland.",
    "output": "BornIn(bobbyFlynn, queensland)"
  },
  {
    "input": "Translate into first-order logic: Bobby Flynn is a singer-songwriter.",
    "output": "Singer(bobbyFlynn) ∧ SongWriter(bobbyFlynn)"
  },
  {
    "input": "Translate into first-order logic: Bobby Flynn finished 7th while competing on Australian Idol.",
    "output": "Finished7th(bobbyFlynn) ∧ CompetedOnAustralianIdol(bobbyFlynn)"
  },
  {
    "input": "Translate into first-order logic: Australian Idol competitors are Australian citizens.",
    "output": "∀x (CompetedOnAustralianIdol(x) → AustralianCitizen(x))"
  },
  {
    "input": "Translate into first-order logic: The Omega Three band made a nationwide tour in 2007.",
    "output": "MadeNationWideTour2007(theOmegaThreeBand) "
  },
  {
    "input": "Translate into first-order logic: Bobby Flynn is a member of The Omega Three band.",
    "output": "IsMember(bobbyFlynn, theOmegaThreeBand)"
  },
  {
    "input": "Translate into first-order logic: Bobby Flynn was born in Queensland.",
    "output": "BornIn(bobbyFlynn, queensland)"
  },
  {
    "input": "Translate into first-order logic: All proteins are organic compounds.",
    "output": "∀x (Protein(x) → OrganicCompound(x))"
  },
  {
    "input": "Translate into first-order logic: All enzymes are organic compounds.",
    "output": "∀x (Enzyme(x) → OrganicCompound(x))"
  },
  {
    "input": "Translate into first-order logic: One American screenwriter and producer is Maggie Friedman.",
    "output": "American(maggiefriedman) ∧ Screenwriter(maggiefriedman) ∧ Producer(maggiefriedman)"
  },
  {
    "input": "Translate into first-order logic: Maggie Friedman was the showrunner and executive producer of the lifetime television series Witches of East End.",
    "output": "ShowRunnerOf(maggiefriedman, witchesofeastend) ∧ ExecutiveProducerOf(maggiefriedman, witchesofeastend) ∧ LifetimeTelevisionSeries(maggiefriedman)"
  },
  {
    "input": "Translate into first-order logic: Witches of East End is a fantasy-drama series.",
    "output": "Fantasy-Drama(witchesofeastend) ∧ Series(witchesofeastend)"
  },
  {
    "input": "Translate into first-order logic: Maggie Friedman produced and developed Eastwick.",
    "output": "Produced(maggiefriedman, eastwick) ∧ Developed(maggiefriedman, eastwick)"
  },
  {
    "input": "Translate into first-order logic: Eastwick is a series by ABC.",
    "output": "Series(eastwick) ∧ By(eastwick, abc)"
  },
  {
    "input": "Translate into first-order logic: One American screenwriter and producer is Maggie Friedman.",
    "output": "American(maggiefriedman) ∧ Screenwriter(maggiefriedman) ∧ Producer(maggiefriedman)"
  },
  {
    "input": "Translate into first-order logic: Maggie Friedman was the showrunner and executive producer of the lifetime television series Witches of East End.",
    "output": "ShowRunnerOf(maggiefriedman, witchesofeastend) ∧ ExecutiveProducerOf(maggiefriedman, witchesofeastend) ∧ LifetimeTelevisionSeries(maggiefriedman)"
  },
  {
    "input": "Translate into first-order logic: Witches of East End is a fantasy-drama series.",
    "output": "Fantasy-Drama(witchesofeastend) ∧ Series(witchesofeastend)"
  },
  {
    "input": "Translate into first-order logic: Maggie Friedman produced and developed Eastwick.",
    "output": "Produced(maggiefriedman, eastwick) ∧ Developed(maggiefriedman, eastwick)"
  },
  {
    "input": "Translate into first-order logic: Eastwick is a series by ABC.",
    "output": "Series(eastwick) ∧ By(eastwick, abc)"
  },
  {
    "input": "Translate into first-order logic: One American screenwriter and producer is Maggie Friedman.",
    "output": "American(maggiefriedman) ∧ Screenwriter(maggiefriedman) ∧ Producer(maggiefriedman)"
  },
  {
    "input": "Translate into first-order logic: Maggie Friedman was the showrunner and executive producer of the lifetime television series Witches of East End.",
    "output": "ShowRunnerOf(maggiefriedman, witchesofeastend) ∧ ExecutiveProducerOf(maggiefriedman, witchesofeastend) ∧ LifetimeTelevisionSeries(maggiefriedman)"
  },
  {
    "input": "Translate into first-order logic: Witches of East End is a fantasy-drama series.",
    "output": "Fantasy-Drama(witchesofeastend) ∧ Series(witchesofeastend)"
  },
  {
    "input": "Translate into first-order logic: Maggie Friedman produced and developed Eastwick.",
    "output": "Produced(maggiefriedman, eastwick) ∧ Developed(maggiefriedman, eastwick)"
  },
  {
    "input": "Translate into first-order logic: Eastwick is a series by ABC.",
    "output": "Series(eastwick) ∧ By(eastwick, abc)"
  },
  {
    "input": "Translate into first-order logic: Evangelos Eleftheriou is a Greek electrical engineer.",
    "output": "Greek(evangeloseleftheriou) ∧ ElectricalEngineer(evangeloseleftheriou)"
  },
  {
    "input": "Translate into first-order logic: Evangelos Eleftheriou worked for IBM in Zurich.",
    "output": "WorkedFor(evangeloseleftheriou, ibm) ∧ WorkedIn(evangeloseleftheriou, zurich)"
  },
  {
    "input": "Translate into first-order logic: If a company has employees working for them somewhere, then they have an office there.",
    "output": "∀x ∀x ∀z (Company(x) ∧ WorkedFor(y, x) ∧ WorkedIn(y, z) → HasOfficeIn(x, z))"
  },
  {
    "input": "Translate into first-order logic: IBM is a company.",
    "output": "Company(ibm)"
  },
  {
    "input": "Translate into first-order logic: Evangelos Eleftheriou is a Greek electrical engineer.",
    "output": "Greek(evangeloseleftheriou) ∧ ElectricalEngineer(evangeloseleftheriou)"
  },
  {
    "input": "Translate into first-order logic: Evangelos Eleftheriou worked for IBM in Zurich.",
    "output": "WorkedFor(evangeloseleftheriou, ibm) ∧ WorkedIn(evangeloseleftheriou, zurich)"
  },
  {
    "input": "Translate into first-order logic: If a company has employees working for them somewhere, then they have an office there.",
    "output": "∀x ∀x ∀z (Company(x) ∧ WorkedFor(y, x) ∧ WorkedIn(y, z) → HasOfficeIn(x, z))"
  },
  {
    "input": "Translate into first-order logic: IBM is a company.",
    "output": "Company(ibm)"
  },
  {
    "input": "Translate into first-order logic: Before releasing their single, \"Hooray! Hooray! It's a Holi-Holiday!\", Boney M. had had seven consecutive German #1 singles.",
    "output": "∃x (Song(x) ∧ By(x, boneym) ∧ N1GermanSingle(x))"
  },
  {
    "input": "Translate into first-order logic: \"Hooray! Hooray! It's a Holi-Holiday!\" was a big hit all over Europe.",
    "output": "Song(hooray) ∧ HitEurope(hooray)"
  },
  {
    "input": "Translate into first-order logic: Nevertheless, \"Hooray! Hooray! It's a Holi-Holiday!\" broke Boney M's streak of consecutive German #1 singles.",
    "output": "Song(hooray) ∧ ¬N1GermanSingle(hooray)"
  },
  {
    "input": "Translate into first-order logic: A song that peaks below #1 on the german charts is also a song that is not the #1 single",
    "output": "∀x (PeaksBelowN1(x) ↔ ¬N1GermanSingle(x))"
  },
  {
    "input": "Translate into first-order logic: Before releasing their single, \"Hooray! Hooray! It's a Holi-Holiday!\", Boney M. had had seven consecutive German #1 singles.",
    "output": "∃x (Song(x) ∧ By(x, boneym) ∧ N1GermanSingle(x))"
  },
  {
    "input": "Translate into first-order logic: \"Hooray! Hooray! It's a Holi-Holiday!\" was a big hit all over Europe.",
    "output": "Song(hooray) ∧ HitEurope(hooray)"
  },
  {
    "input": "Translate into first-order logic: Nevertheless, \"Hooray! Hooray! It's a Holi-Holiday!\" broke Boney M's streak of consecutive German #1 singles.",
    "output": "Song(hooray) ∧ ¬N1GermanSingle(hooray)"
  },
  {
    "input": "Translate into first-order logic: A song that peaks below #1 on the german charts is also a song that is not the #1 single",
    "output": "∀x (PeaksBelowN1(x) ↔ ¬N1GermanSingle(x))"
  },
  {
    "input": "Translate into first-order logic: Before releasing their single, \"Hooray! Hooray! It's a Holi-Holiday!\", Boney M. had had seven consecutive German #1 singles.",
    "output": "∃x (Song(x) ∧ By(x, boneym) ∧ N1GermanSingle(x))"
  },
  {
    "input": "Translate into first-order logic: \"Hooray! Hooray! It's a Holi-Holiday!\" was a big hit all over Europe.",
    "output": "Song(hooray) ∧ HitEurope(hooray)"
  },
  {
    "input": "Translate into first-order logic: Nevertheless, \"Hooray! Hooray! It's a Holi-Holiday!\" broke Boney M's streak of consecutive German #1 singles.",
    "output": "Song(hooray) ∧ ¬N1GermanSingle(hooray)"
  },
  {
    "input": "Translate into first-order logic: A song that peaks below #1 on the german charts is also a song that is not the #1 single",
    "output": "∀x (PeaksBelowN1(x) ↔ ¬N1GermanSingle(x))"
  },
  {
    "input": "Translate into first-order logic: Every chef can cook.",
    "output": "∀x (Chef(x) → Cook(x))"
  },
  {
    "input": "Translate into first-order logic: Some people who aren’t chefs can cook.",
    "output": "∃x (¬Chef(x) ∧ Cook(x))"
  },
  {
    "input": "Translate into first-order logic: People who cook can make scrambled eggs and pasta.",
    "output": "∀x (Cook(x) → (MakeScrambledEggs(x) ∧ MakePasta(x)))"
  },
  {
    "input": "Translate into first-order logic: If someone can make cookies and muffins, they are a baker.",
    "output": "∀x (MakeCookies(x) ∧ MakeMuffins(x) → Baker(x))"
  },
  {
    "input": "Translate into first-order logic: Bakers who can also make scrambled eggs can make a good breakfast.",
    "output": "∀x ((Baker(x) ∧ MakeScrambledEggs(x)) → MakeGoodBreakfast(x))"
  },
  {
    "input": "Translate into first-order logic: Luke can make cookies, scrambled eggs, and muffins, but not pasta.",
    "output": "MakeCookies(luke) ∧ MakeScrambledEggs(luke) ∧ MakeMuffins(luke) ∧ ¬MakePasta(luke)"
  },
  {
    "input": "Translate into first-order logic: Every chef can cook.",
    "output": "∀x (Chef(x) → Cook(x))"
  },
  {
    "input": "Translate into first-order logic: Some people who aren’t chefs can cook.",
    "output": "∃x (¬Chef(x) ∧ Cook(x))"
  },
  {
    "input": "Translate into first-order logic: People who cook can make scrambled eggs and pasta.",
    "output": "∀x (Cook(x) → (MakeScrambledEggs(x) ∧ MakePasta(x)))"
  },
  {
    "input": "Translate into first-order logic: If someone can make cookies and muffins, they are a baker.",
    "output": "∀x (MakeCookies(x) ∧ MakeMuffins(x) → Baker(x))"
  },
  {
    "input": "Translate into first-order logic: Bakers who can also make scrambled eggs can make a good breakfast.",
    "output": "∀x ((Baker(x) ∧ MakeScrambledEggs(x)) → MakeGoodBreakfast(x))"
  },
  {
    "input": "Translate into first-order logic: Luke can make cookies, scrambled eggs, and muffins, but not pasta.",
    "output": "MakeCookies(luke) ∧ MakeScrambledEggs(luke) ∧ MakeMuffins(luke) ∧ ¬MakePasta(luke)"
  },
  {
    "input": "Translate into first-order logic: ETS develops various standardized tests primarily in the United States for K-12 and higher education.",
    "output": "∃x (Develops(ets, x) ∧ StandardizedTest(x) ∧ In(x, unitedstates) ∧ For(x, k-12andhighereducation))"
  },
  {
    "input": "Translate into first-order logic: ETS administers international tests including the TOEFL, TOEIC, GRE and subject tests in more than 180 countries.",
    "output": "∃x (Administers(ets, x) ∧ InternationalTest(x) ∧ (TOEFL(x) ∨ TOEIC(x) ∨ GRE(x) ∨ SubjectTests(x)))"
  },
  {
    "input": "Translate into first-order logic: Many of the assessments ETS develops are associated with entry to the US tertiary and quaternary education institutions.",
    "output": "∃x (Develops(ets, x) ∧ AssociatedWith(x, entrytouseducationinstitutions))"
  },
  {
    "input": "Translate into first-order logic: ETS also develops K-12 statewide assessments used for accountability testing in many states.",
    "output": "∃x (Develops(ets, x) ∧ StateWideAssesment(x) ∧ UsedFor(x, accountabilitytesting))"
  },
  {
    "input": "Translate into first-order logic: ETS develops various standardized tests primarily in the United States for K-12 and higher education.",
    "output": "∃x (Develops(ets, x) ∧ StandardizedTest(x) ∧ In(x, unitedstates) ∧ For(x, k-12andhighereducation))"
  },
  {
    "input": "Translate into first-order logic: ETS administers international tests including the TOEFL, TOEIC, GRE and subject tests in more than 180 countries.",
    "output": "∃x (Administers(ets, x) ∧ InternationalTest(x) ∧ (TOEFL(x) ∨ TOEIC(x) ∨ GRE(x) ∨ SubjectTests(x)))"
  },
  {
    "input": "Translate into first-order logic: Many of the assessments ETS develops are associated with entry to the US tertiary and quaternary education institutions.",
    "output": "∃x (Develops(ets, x) ∧ AssociatedWith(x, entrytouseducationinstitutions))"
  },
  {
    "input": "Translate into first-order logic: ETS also develops K-12 statewide assessments used for accountability testing in many states.",
    "output": "∃x (Develops(ets, x) ∧ StateWideAssesment(x) ∧ UsedFor(x, accountabilitytesting))"
  },
  {
    "input": "Translate into first-order logic: ETS develops various standardized tests primarily in the United States for K-12 and higher education.",
    "output": "∃x (Develops(ets, x) ∧ StandardizedTest(x) ∧ In(x, unitedstates) ∧ For(x, k-12andhighereducation))"
  },
  {
    "input": "Translate into first-order logic: ETS administers international tests including the TOEFL, TOEIC, GRE and subject tests in more than 180 countries.",
    "output": "∃x (Administers(ets, x) ∧ InternationalTest(x) ∧ (TOEFL(x) ∨ TOEIC(x) ∨ GRE(x) ∨ SubjectTests(x)))"
  },
  {
    "input": "Translate into first-order logic: Many of the assessments ETS develops are associated with entry to the US tertiary and quaternary education institutions.",
    "output": "∃x (Develops(ets, x) ∧ AssociatedWith(x, entrytouseducationinstitutions))"
  },
  {
    "input": "Translate into first-order logic: ETS also develops K-12 statewide assessments used for accountability testing in many states.",
    "output": "∃x (Develops(ets, x) ∧ StateWideAssesment(x) ∧ UsedFor(x, accountabilitytesting))"
  },
  {
    "input": "Translate into first-order logic: All people who enjoy eating gelato ice cream would enjoy a vacation to Italy.",
    "output": "∀x (Gelato(x) → Italy(x))"
  },
  {
    "input": "Translate into first-order logic: There are no people who can resist the hallmark delectable drinks and desserts that are famed in Italy.",
    "output": "∀x (¬Resist(x))"
  },
  {
    "input": "Translate into first-order logic: People either enjoy eating gelato ice cream or love to travel and vacation often.",
    "output": "∀x (Gelato(x) ∨ Travel(x))"
  },
  {
    "input": "Translate into first-order logic: If people often take study abroad semesters to Europe, then they do not regret their college experiences.",
    "output": "∀x (Europe(x) → ¬Regret(x))"
  },
  {
    "input": "Translate into first-order logic: If people love to travel and vacation often, then they often take study abroad semesters to Europe.",
    "output": "∀x (Travel(x) → Europe(x))"
  },
  {
    "input": "Translate into first-order logic: Robert either enjoys eating gelato ice cream and loves to travel and vacation often, or he neither enjoys eating gelato ice cream nor loves to travel and vacation often.",
    "output": "(Gelato(robert) ∧ Travel(robert)) ∨ (¬Gelato(robert) ∧ ¬Travel(robert))"
  },
  {
    "input": "Translate into first-order logic: All people who enjoy eating gelato ice cream would enjoy a vacation to Italy.",
    "output": "∀x (Gelato(x) → Italy(x))"
  },
  {
    "input": "Translate into first-order logic: There are no people who can resist the hallmark delectable drinks and desserts that are famed in Italy.",
    "output": "∀x (¬Resist(x))"
  },
  {
    "input": "Translate into first-order logic: People either enjoy eating gelato ice cream or love to travel and vacation often.",
    "output": "∀x (Gelato(x) ∨ Travel(x))"
  },
  {
    "input": "Translate into first-order logic: If people often take study abroad semesters to Europe, then they do not regret their college experiences.",
    "output": "∀x (Europe(x) → ¬Regret(x))"
  },
  {
    "input": "Translate into first-order logic: If people love to travel and vacation often, then they often take study abroad semesters to Europe.",
    "output": "∀x (Travel(x) → Europe(x))"
  },
  {
    "input": "Translate into first-order logic: Robert either enjoys eating gelato ice cream and loves to travel and vacation often, or he neither enjoys eating gelato ice cream nor loves to travel and vacation often.",
    "output": "(Gelato(robert) ∧ Travel(robert)) ∨ (¬Gelato(robert) ∧ ¬Travel(robert))"
  },
  {
    "input": "Translate into first-order logic: All people who enjoy eating gelato ice cream would enjoy a vacation to Italy.",
    "output": "∀x (Gelato(x) → Italy(x))"
  },
  {
    "input": "Translate into first-order logic: There are no people who can resist the hallmark delectable drinks and desserts that are famed in Italy.",
    "output": "∀x (¬Resist(x))"
  },
  {
    "input": "Translate into first-order logic: People either enjoy eating gelato ice cream or love to travel and vacation often.",
    "output": "∀x (Gelato(x) ∨ Travel(x))"
  },
  {
    "input": "Translate into first-order logic: If people often take study abroad semesters to Europe, then they do not regret their college experiences.",
    "output": "∀x (Europe(x) → ¬Regret(x))"
  },
  {
    "input": "Translate into first-order logic: If people love to travel and vacation often, then they often take study abroad semesters to Europe.",
    "output": "∀x (Travel(x) → Europe(x))"
  },
  {
    "input": "Translate into first-order logic: Robert either enjoys eating gelato ice cream and loves to travel and vacation often, or he neither enjoys eating gelato ice cream nor loves to travel and vacation often.",
    "output": "(Gelato(robert) ∧ Travel(robert)) ∨ (¬Gelato(robert) ∧ ¬Travel(robert))"
  },
  {
    "input": "Translate into first-order logic: To get a student visa, you must be full-time enrolled in an academic program.",
    "output": "∀x (StudentVisa(x) → FullTimeAcademic(x))"
  },
  {
    "input": "Translate into first-order logic: Those who are full-time enrolled in an academic program can not work full-time.",
    "output": "∀x (FullTimeAcademic(x) → ¬WorkFullTime(x))"
  },
  {
    "input": "Translate into first-order logic: Everyone who wants to study abroad needs to have a student visa.",
    "output": "∀x (StudyAbroad(x) → StudentVisa(x))"
  },
  {
    "input": "Translate into first-order logic: All PhD graduates can work full time.",
    "output": "∀x (PhdGraduate(x) → WorkFullTime(x))"
  },
  {
    "input": "Translate into first-order logic: If Tom does not want to study abroad, he is full-time enrolled in an educational program.",
    "output": "¬StudyAbroad(tom) → FullTimeAcademic(tom)"
  },
  {
    "input": "Translate into first-order logic: To get a student visa, you must be full-time enrolled in an academic program.",
    "output": "∀x (StudentVisa(x) → FullTimeAcademic(x))"
  },
  {
    "input": "Translate into first-order logic: Those who are full-time enrolled in an academic program can not work full-time.",
    "output": "∀x (FullTimeAcademic(x) → ¬WorkFullTime(x))"
  },
  {
    "input": "Translate into first-order logic: Everyone who wants to study abroad needs to have a student visa.",
    "output": "∀x (StudyAbroad(x) → StudentVisa(x))"
  },
  {
    "input": "Translate into first-order logic: All PhD graduates can work full time.",
    "output": "∀x (PhdGraduate(x) → WorkFullTime(x))"
  },
  {
    "input": "Translate into first-order logic: If Tom does not want to study abroad, he is full-time enrolled in an educational program.",
    "output": "¬StudyAbroad(tom) → FullTimeAcademic(tom)"
  },
  {
    "input": "Translate into first-order logic: To get a student visa, you must be full-time enrolled in an academic program.",
    "output": "∀x (StudentVisa(x) → FullTimeAcademic(x))"
  },
  {
    "input": "Translate into first-order logic: Those who are full-time enrolled in an academic program can not work full-time.",
    "output": "∀x (FullTimeAcademic(x) → ¬WorkFullTime(x))"
  },
  {
    "input": "Translate into first-order logic: Everyone who wants to study abroad needs to have a student visa.",
    "output": "∀x (StudyAbroad(x) → StudentVisa(x))"
  },
  {
    "input": "Translate into first-order logic: All PhD graduates can work full time.",
    "output": "∀x (PhdGraduate(x) → WorkFullTime(x))"
  },
  {
    "input": "Translate into first-order logic: If Tom does not want to study abroad, he is full-time enrolled in an educational program.",
    "output": "¬StudyAbroad(tom) → FullTimeAcademic(tom)"
  },
  {
    "input": "Translate into first-order logic: The installment sales method is the approach to recognize revenue under the US GAAP.",
    "output": "∀x (UsesGAAP(x) → UsesInstallmentMethod(x))"
  },
  {
    "input": "Translate into first-order logic: In accrual accounting, revenues are recognized when they are realized.",
    "output": "∀x (UsesAccruralAccounting(x) → RecognizedWhen(revenues, realized))"
  },
  {
    "input": "Translate into first-order logic: In cash accounting, revenues are recognized when cash is received.",
    "output": "∀x (UsesCashAccounting(x) → RecognizedWhen(revenues, cashrecieved))"
  },
  {
    "input": "Translate into first-order logic: The US GAAP is the accounting standard developed and used by the US Securities and Exchange Commission.",
    "output": "DevelopedBy(usgaap, ussecuritiesandexchangecommission) ∧ UsesGAAP(ussecuritiesandexchangecommission)"
  },
  {
    "input": "Translate into first-order logic: Sally works for the US Securities and Exchange Commission.",
    "output": "WorksFor(sally, ussecuritiesandexchangecommission)"
  },
  {
    "input": "Translate into first-order logic: The installment sales method is the approach to recognize revenue under the US GAAP.",
    "output": "∀x (UsesGAAP(x) → UsesInstallmentMethod(x))"
  },
  {
    "input": "Translate into first-order logic: In accrual accounting, revenues are recognized when they are realized.",
    "output": "∀x (UsesAccruralAccounting(x) → RecognizedWhen(revenues, realized))"
  },
  {
    "input": "Translate into first-order logic: In cash accounting, revenues are recognized when cash is received.",
    "output": "∀x (UsesCashAccounting(x) → RecognizedWhen(revenues, cashrecieved))"
  },
  {
    "input": "Translate into first-order logic: The US GAAP is the accounting standard developed and used by the US Securities and Exchange Commission.",
    "output": "DevelopedBy(usgaap, ussecuritiesandexchangecommission) ∧ UsesGAAP(ussecuritiesandexchangecommission)"
  },
  {
    "input": "Translate into first-order logic: Sally works for the US Securities and Exchange Commission.",
    "output": "WorksFor(sally, ussecuritiesandexchangecommission)"
  },
  {
    "input": "Translate into first-order logic: The installment sales method is the approach to recognize revenue under the US GAAP.",
    "output": "∀x (UsesGAAP(x) → UsesInstallmentMethod(x))"
  },
  {
    "input": "Translate into first-order logic: In accrual accounting, revenues are recognized when they are realized.",
    "output": "∀x (UsesAccruralAccounting(x) → RecognizedWhen(revenues, realized))"
  },
  {
    "input": "Translate into first-order logic: In cash accounting, revenues are recognized when cash is received.",
    "output": "∀x (UsesCashAccounting(x) → RecognizedWhen(revenues, cashrecieved))"
  },
  {
    "input": "Translate into first-order logic: The US GAAP is the accounting standard developed and used by the US Securities and Exchange Commission.",
    "output": "DevelopedBy(usgaap, ussecuritiesandexchangecommission) ∧ UsesGAAP(ussecuritiesandexchangecommission)"
  },
  {
    "input": "Translate into first-order logic: Sally works for the US Securities and Exchange Commission.",
    "output": "WorksFor(sally, ussecuritiesandexchangecommission)"
  },
  {
    "input": "Translate into first-order logic: All people who are respected by others are people who contribute to the country.",
    "output": "∀x (Respected(x) → ContributeToCountry(x))"
  },
  {
    "input": "Translate into first-order logic: If a person is respected by others, then he/she contributes to the country.",
    "output": "∀x (Respected(x) → ContributeToCountry(x))"
  },
  {
    "input": "Translate into first-order logic: All people available to have a visit without any fees are those respected by others.",
    "output": "∀x (HaveVisitWithoutAnyFees(x) → Respected(x))"
  },
  {
    "input": "Translate into first-order logic: All Customers who once served in the army are available to have a visit without any fees.",
    "output": "∀x (Army(x) → HaveVisitWithoutAnyFees(x))"
  },
  {
    "input": "Translate into first-order logic: All people who once were sentenced for thief stayed in prison for some time.",
    "output": "∀x (Thief(x) → Prison(x))"
  },
  {
    "input": "Translate into first-order logic: All people who once stayed in prison for some time have a bad record in the local state.",
    "output": "∀x (Prison(x) → BadRecord(x))"
  },
  {
    "input": "Translate into first-order logic: James was either once sentenced for thief or stayed in prison for some time.",
    "output": "Thief(james) ⊕ Prison(james) "
  },
  {
    "input": "Translate into first-order logic: James is either with a bad record in the local state or respected by others.",
    "output": "BadRecord(james) ⊕ Respected(james)"
  },
  {
    "input": "Translate into first-order logic: All people who are respected by others are people who contribute to the country.",
    "output": "∀x (Respected(x) → ContributeToCountry(x))"
  },
  {
    "input": "Translate into first-order logic: If a person is respected by others, then he/she contributes to the country.",
    "output": "∀x (Respected(x) → ContributeToCountry(x))"
  },
  {
    "input": "Translate into first-order logic: All people available to have a visit without any fees are those respected by others.",
    "output": "∀x (HaveVisitWithoutAnyFees(x) → Respected(x))"
  },
  {
    "input": "Translate into first-order logic: All Customers who once served in the army are available to have a visit without any fees.",
    "output": "∀x (Army(x) → HaveVisitWithoutAnyFees(x))"
  },
  {
    "input": "Translate into first-order logic: All people who once were sentenced for thief stayed in prison for some time.",
    "output": "∀x (Thief(x) → Prison(x))"
  },
  {
    "input": "Translate into first-order logic: All people who once stayed in prison for some time have a bad record in the local state.",
    "output": "∀x (Prison(x) → BadRecord(x))"
  },
  {
    "input": "Translate into first-order logic: James was either once sentenced for thief or stayed in prison for some time.",
    "output": "Thief(james) ⊕ Prison(james) "
  },
  {
    "input": "Translate into first-order logic: James is either with a bad record in the local state or respected by others.",
    "output": "BadRecord(james) ⊕ Respected(james)"
  },
  {
    "input": "Translate into first-order logic: All people who are respected by others are people who contribute to the country.",
    "output": "∀x (Respected(x) → ContributeToCountry(x))"
  },
  {
    "input": "Translate into first-order logic: If a person is respected by others, then he/she contributes to the country.",
    "output": "∀x (Respected(x) → ContributeToCountry(x))"
  },
  {
    "input": "Translate into first-order logic: All people available to have a visit without any fees are those respected by others.",
    "output": "∀x (HaveVisitWithoutAnyFees(x) → Respected(x))"
  },
  {
    "input": "Translate into first-order logic: All Customers who once served in the army are available to have a visit without any fees.",
    "output": "∀x (Army(x) → HaveVisitWithoutAnyFees(x))"
  },
  {
    "input": "Translate into first-order logic: All people who once were sentenced for thief stayed in prison for some time.",
    "output": "∀x (Thief(x) → Prison(x))"
  },
  {
    "input": "Translate into first-order logic: All people who once stayed in prison for some time have a bad record in the local state.",
    "output": "∀x (Prison(x) → BadRecord(x))"
  },
  {
    "input": "Translate into first-order logic: James was either once sentenced for thief or stayed in prison for some time.",
    "output": "Thief(james) ⊕ Prison(james) "
  },
  {
    "input": "Translate into first-order logic: James is either with a bad record in the local state or respected by others.",
    "output": "BadRecord(james) ⊕ Respected(james)"
  },
  {
    "input": "Translate into first-order logic: All people who are respected by others are people who contribute to the country.",
    "output": "∀x (Respected(x) → ContributeToCountry(x))"
  },
  {
    "input": "Translate into first-order logic: If a person is respected by others, then he/she contributes to the country.",
    "output": "∀x (Respected(x) → ContributeToCountry(x))"
  },
  {
    "input": "Translate into first-order logic: All people available to have a visit without any fees are those respected by others.",
    "output": "∀x (HaveVisitWithoutAnyFees(x) → Respected(x))"
  },
  {
    "input": "Translate into first-order logic: All Customers who once served in the army are available to have a visit without any fees.",
    "output": "∀x (Army(x) → HaveVisitWithoutAnyFees(x))"
  },
  {
    "input": "Translate into first-order logic: All people who once were sentenced for thief stayed in prison for some time.",
    "output": "∀x (Thief(x) → Prison(x))"
  },
  {
    "input": "Translate into first-order logic: All people who once stayed in prison for some time have a bad record in the local state.",
    "output": "∀x (Prison(x) → BadRecord(x))"
  },
  {
    "input": "Translate into first-order logic: James was either once sentenced for thief or stayed in prison for some time.",
    "output": "Thief(james) ⊕ Prison(james) "
  },
  {
    "input": "Translate into first-order logic: James is either with a bad record in the local state or respected by others.",
    "output": "BadRecord(james) ⊕ Respected(james)"
  },
  {
    "input": "Translate into first-order logic: The Croton River watershed is the drainage basin of the Croton River.",
    "output": "DrainageBasinOf(crotonriverwatershed, crotonriver)"
  },
  {
    "input": "Translate into first-order logic: The Croton River is in southwestern New York.",
    "output": "In(crotonriver, southwesternnewyork)"
  },
  {
    "input": "Translate into first-order logic: Water from the Croton River watershed flows to the Bronx.",
    "output": "∃x (Water(x) ∧ From(x, crotonriverwatershed) ∧ FlowsTo(x, bronx))"
  },
  {
    "input": "Translate into first-order logic: The Bronx is in New York.",
    "output": "In(bronx, newyork)"
  },
  {
    "input": "Translate into first-order logic: The Croton River watershed is the drainage basin of the Croton River.",
    "output": "DrainageBasinOf(crotonriverwatershed, crotonriver)"
  },
  {
    "input": "Translate into first-order logic: The Croton River is in southwestern New York.",
    "output": "In(crotonriver, southwesternnewyork)"
  },
  {
    "input": "Translate into first-order logic: Water from the Croton River watershed flows to the Bronx.",
    "output": "∃x (Water(x) ∧ From(x, crotonriverwatershed) ∧ FlowsTo(x, bronx))"
  },
  {
    "input": "Translate into first-order logic: The Bronx is in New York.",
    "output": "In(bronx, newyork)"
  },
  {
    "input": "Translate into first-order logic: The Croton River watershed is the drainage basin of the Croton River.",
    "output": "DrainageBasinOf(crotonriverwatershed, crotonriver)"
  },
  {
    "input": "Translate into first-order logic: The Croton River is in southwestern New York.",
    "output": "In(crotonriver, southwesternnewyork)"
  },
  {
    "input": "Translate into first-order logic: Water from the Croton River watershed flows to the Bronx.",
    "output": "∃x (Water(x) ∧ From(x, crotonriverwatershed) ∧ FlowsTo(x, bronx))"
  },
  {
    "input": "Translate into first-order logic: The Bronx is in New York.",
    "output": "In(bronx, newyork)"
  },
  {
    "input": "Translate into first-order logic: All nuclear-powered submarines are warships.",
    "output": "∀x (NuclearPoweredSubmarine(x) → Warship(x))"
  },
  {
    "input": "Translate into first-order logic: No nuclear-powered submarines are commercial vessels.",
    "output": "∀x (NuclearPoweredSubmarine(x) → ¬CommercialVessel(x))"
  },
  {
    "input": "Translate into first-order logic: If a album is written by a rock band, then the genre of the album is rock.",
    "output": "∀x ∀y ∀z (AlbumByBand(x, y) ∧ RockBand(y, z) → Genre(x, rock))"
  },
  {
    "input": "Translate into first-order logic: If a band writes a album winning an award, then this band wins this award.",
    "output": "∀x ∀y ∀z (AlbumByBand(x, y) ∧ AlbumAward(x, z) → RockBandAward(y, z))"
  },
  {
    "input": "Translate into first-order logic: Trouble at the Henhouse is an album by The Tragically Hip.",
    "output": "AlbumByBand(trouble_at_the_Henhouse, the_Tragically_Hip)"
  },
  {
    "input": "Translate into first-order logic: The Tragically Hip is a Canadian rock band.",
    "output": "RockBand(the_Tragically_Hip, canada)"
  },
  {
    "input": "Translate into first-order logic: The song \"Butts Wigglin'\" is in Trouble at the Henhouse.",
    "output": "SongInAlbum(butts_Wigglin, trouble_at_the_Henhouse)"
  },
  {
    "input": "Translate into first-order logic: Trouble at the Henhouse won the Album of the Year award.",
    "output": "AlbumAward(trouble_at_the_Henhouse, the_Album_of_the_Year)"
  },
  {
    "input": "Translate into first-order logic: A song in Trouble at the Henhouse appeared in a film.",
    "output": "∃x (SongInFilm(x) ∧ SongInAlbum(x, trouble_at_the_Henhouse))"
  },
  {
    "input": "Translate into first-order logic: If a album is written by a rock band, then the genre of the album is rock.",
    "output": "∀x ∀y ∀z (AlbumByBand(x, y) ∧ RockBand(y, z) → Genre(x, rock))"
  },
  {
    "input": "Translate into first-order logic: If a band writes a album winning an award, then this band wins this award.",
    "output": "∀x ∀y ∀z (AlbumByBand(x, y) ∧ AlbumAward(x, z) → RockBandAward(y, z))"
  },
  {
    "input": "Translate into first-order logic: Trouble at the Henhouse is an album by The Tragically Hip.",
    "output": "AlbumByBand(trouble_at_the_Henhouse, the_Tragically_Hip)"
  },
  {
    "input": "Translate into first-order logic: The Tragically Hip is a Canadian rock band.",
    "output": "RockBand(the_Tragically_Hip, canada)"
  },
  {
    "input": "Translate into first-order logic: The song \"Butts Wigglin'\" is in Trouble at the Henhouse.",
    "output": "SongInAlbum(butts_Wigglin, trouble_at_the_Henhouse)"
  },
  {
    "input": "Translate into first-order logic: Trouble at the Henhouse won the Album of the Year award.",
    "output": "AlbumAward(trouble_at_the_Henhouse, the_Album_of_the_Year)"
  },
  {
    "input": "Translate into first-order logic: A song in Trouble at the Henhouse appeared in a film.",
    "output": "∃x (SongInFilm(x) ∧ SongInAlbum(x, trouble_at_the_Henhouse))"
  },
  {
    "input": "Translate into first-order logic: If a album is written by a rock band, then the genre of the album is rock.",
    "output": "∀x ∀y ∀z (AlbumByBand(x, y) ∧ RockBand(y, z) → Genre(x, rock))"
  },
  {
    "input": "Translate into first-order logic: If a band writes a album winning an award, then this band wins this award.",
    "output": "∀x ∀y ∀z (AlbumByBand(x, y) ∧ AlbumAward(x, z) → RockBandAward(y, z))"
  },
  {
    "input": "Translate into first-order logic: Trouble at the Henhouse is an album by The Tragically Hip.",
    "output": "AlbumByBand(trouble_at_the_Henhouse, the_Tragically_Hip)"
  },
  {
    "input": "Translate into first-order logic: The Tragically Hip is a Canadian rock band.",
    "output": "RockBand(the_Tragically_Hip, canada)"
  },
  {
    "input": "Translate into first-order logic: The song \"Butts Wigglin'\" is in Trouble at the Henhouse.",
    "output": "SongInAlbum(butts_Wigglin, trouble_at_the_Henhouse)"
  },
  {
    "input": "Translate into first-order logic: Trouble at the Henhouse won the Album of the Year award.",
    "output": "AlbumAward(trouble_at_the_Henhouse, the_Album_of_the_Year)"
  },
  {
    "input": "Translate into first-order logic: A song in Trouble at the Henhouse appeared in a film.",
    "output": "∃x (SongInFilm(x) ∧ SongInAlbum(x, trouble_at_the_Henhouse))"
  },
  {
    "input": "Translate into first-order logic: Daniel is a software engineer and he works at Palantir Technologies.",
    "output": "SoftwareEngineer(daniel) ∧ WorksAt(daniel, palantirTechnologies)"
  },
  {
    "input": "Translate into first-order logic: Daniel studied bioengineering during his undergraduate at Rice University.",
    "output": " StudiedBioengineering(daniel, riceUniversity)"
  },
  {
    "input": "Translate into first-order logic: Daniel’s older sister works at Meta as a technical sourcer.",
    "output": " WorksAtMeta(danielsOlderSister) ∧ TechnicalSourcer(danielsOlderSister)"
  },
  {
    "input": "Translate into first-order logic: Daniel’s dad and older sister both graduated from Stanford University.",
    "output": " GraduatedFromStanfordUniversity(danielsOlderSister) ∧ GraduatedFromStanfordUniversity(danielsDad)"
  },
  {
    "input": "Translate into first-order logic: Daniel’s dad is a doctor practicing internal medicine at a veteran’s hospital in Minneapolis",
    "output": " DoctorPracticingInternalMedicine(danielsDad, veteransHospitalInMinneapolis)"
  },
  {
    "input": "Translate into first-order logic: Daniel is a software engineer and he works at Palantir Technologies.",
    "output": "SoftwareEngineer(daniel) ∧ WorksAt(daniel, palantirTechnologies)"
  },
  {
    "input": "Translate into first-order logic: Daniel studied bioengineering during his undergraduate at Rice University.",
    "output": " StudiedBioengineering(daniel, riceUniversity)"
  },
  {
    "input": "Translate into first-order logic: Daniel’s older sister works at Meta as a technical sourcer.",
    "output": " WorksAtMeta(danielsOlderSister) ∧ TechnicalSourcer(danielsOlderSister)"
  },
  {
    "input": "Translate into first-order logic: Daniel’s dad and older sister both graduated from Stanford University.",
    "output": " GraduatedFromStanfordUniversity(danielsOlderSister) ∧ GraduatedFromStanfordUniversity(danielsDad)"
  },
  {
    "input": "Translate into first-order logic: Daniel’s dad is a doctor practicing internal medicine at a veteran’s hospital in Minneapolis",
    "output": " DoctorPracticingInternalMedicine(danielsDad, veteransHospitalInMinneapolis)"
  },
  {
    "input": "Translate into first-order logic: Daniel is a software engineer and he works at Palantir Technologies.",
    "output": "SoftwareEngineer(daniel) ∧ WorksAt(daniel, palantirTechnologies)"
  },
  {
    "input": "Translate into first-order logic: Daniel studied bioengineering during his undergraduate at Rice University.",
    "output": " StudiedBioengineering(daniel, riceUniversity)"
  },
  {
    "input": "Translate into first-order logic: Daniel’s older sister works at Meta as a technical sourcer.",
    "output": " WorksAtMeta(danielsOlderSister) ∧ TechnicalSourcer(danielsOlderSister)"
  },
  {
    "input": "Translate into first-order logic: Daniel’s dad and older sister both graduated from Stanford University.",
    "output": " GraduatedFromStanfordUniversity(danielsOlderSister) ∧ GraduatedFromStanfordUniversity(danielsDad)"
  },
  {
    "input": "Translate into first-order logic: Daniel’s dad is a doctor practicing internal medicine at a veteran’s hospital in Minneapolis",
    "output": " DoctorPracticingInternalMedicine(danielsDad, veteransHospitalInMinneapolis)"
  },
  {
    "input": "Translate into first-order logic: All commerical aircraft are produced by either Boeing or Airbus.",
    "output": "∀x (CommercialAircraft(x) → ProducedBy(x, boeing) ⊕ ProducedBy(x, airbus))"
  },
  {
    "input": "Translate into first-order logic: All American Airlines jets are commerical aircraft.",
    "output": "∀x (AmericanAirlinesAircraft(x) → CommercialAircraft(x))"
  },
  {
    "input": "Translate into first-order logic: Airbus made more in revenue than Boeing last year.",
    "output": "MoreinRevenue(airbus, boeing)"
  },
  {
    "input": "Translate into first-order logic: All commerical aircraft are produced by either Boeing or Airbus.",
    "output": "∀x (CommercialAircraft(x) → ProducedBy(x, boeing) ⊕ ProducedBy(x, airbus))"
  },
  {
    "input": "Translate into first-order logic: All American Airlines jets are commerical aircraft.",
    "output": "∀x (AmericanAirlinesAircraft(x) → CommercialAircraft(x))"
  },
  {
    "input": "Translate into first-order logic: Airbus made more in revenue than Boeing last year.",
    "output": "MoreinRevenue(airbus, boeing)"
  },
  {
    "input": "Translate into first-order logic: All commerical aircraft are produced by either Boeing or Airbus.",
    "output": "∀x (CommercialAircraft(x) → ProducedBy(x, boeing) ⊕ ProducedBy(x, airbus))"
  },
  {
    "input": "Translate into first-order logic: All American Airlines jets are commerical aircraft.",
    "output": "∀x (AmericanAirlinesAircraft(x) → CommercialAircraft(x))"
  },
  {
    "input": "Translate into first-order logic: Airbus made more in revenue than Boeing last year.",
    "output": "MoreinRevenue(airbus, boeing)"
  },
  {
    "input": "Translate into first-order logic: All commerical aircraft are produced by either Boeing or Airbus.",
    "output": "∀x (CommercialAircraft(x) → ProducedBy(x, boeing) ⊕ ProducedBy(x, airbus))"
  },
  {
    "input": "Translate into first-order logic: All American Airlines jets are commerical aircraft.",
    "output": "∀x (AmericanAirlinesAircraft(x) → CommercialAircraft(x))"
  },
  {
    "input": "Translate into first-order logic: Airbus made more in revenue than Boeing last year.",
    "output": "MoreinRevenue(airbus, boeing)"
  },
  {
    "input": "Translate into first-order logic: Luzon is an island in the Philippines.",
    "output": "Island(luzon) ∧ In(luzon, philippines)"
  },
  {
    "input": "Translate into first-order logic: In December 1999, an earthquake struck Luzon.",
    "output": "∃x (Earthquake(x) ∧ StruckIn(x, december1999) ∧ Struck(x, luzon))"
  },
  {
    "input": "Translate into first-order logic: People died in the December 1999 earthquake in Luzon.",
    "output": "∃x (Earthquake(x) ∧ StruckIn(x, december1999) ∧ Struck(x, luzon) ∧ Killed(x))"
  },
  {
    "input": "Translate into first-order logic: Luzon is an island in the Philippines.",
    "output": "Island(luzon) ∧ In(luzon, philippines)"
  },
  {
    "input": "Translate into first-order logic: In December 1999, an earthquake struck Luzon.",
    "output": "∃x (Earthquake(x) ∧ StruckIn(x, december1999) ∧ Struck(x, luzon))"
  },
  {
    "input": "Translate into first-order logic: People died in the December 1999 earthquake in Luzon.",
    "output": "∃x (Earthquake(x) ∧ StruckIn(x, december1999) ∧ Struck(x, luzon) ∧ Killed(x))"
  },
  {
    "input": "Translate into first-order logic: Luzon is an island in the Philippines.",
    "output": "Island(luzon) ∧ In(luzon, philippines)"
  },
  {
    "input": "Translate into first-order logic: In December 1999, an earthquake struck Luzon.",
    "output": "∃x (Earthquake(x) ∧ StruckIn(x, december1999) ∧ Struck(x, luzon))"
  },
  {
    "input": "Translate into first-order logic: People died in the December 1999 earthquake in Luzon.",
    "output": "∃x (Earthquake(x) ∧ StruckIn(x, december1999) ∧ Struck(x, luzon) ∧ Killed(x))"
  },
  {
    "input": "Translate into first-order logic: People either invest in the public stock market regularly or enjoy gambling regularly.",
    "output": "∀x (Invests(x) ∨ Gambling(x))"
  },
  {
    "input": "Translate into first-order logic: If people invest in the public stock market regularly, then they read the Wall Street Journal and other newspapers regularly to keep updated on financial metrics.",
    "output": "∀x (Invests(x) → Newspapers(x))"
  },
  {
    "input": "Translate into first-order logic: All people who enjoy gambling regularly spend a lot of money at casinos and other betting games.",
    "output": "∀x (Gambling(x) → Casinos(x))"
  },
  {
    "input": "Translate into first-order logic: People who spend a lot of money at casinos and other betting games visit the Las Vegas Strip regularly.",
    "output": "∀x (Casinos(x) → LasVegas(x))"
  },
  {
    "input": "Translate into first-order logic: People who spend a lot of money at casinos and other betting games have a lot of disposable income to spend.",
    "output": "∀x (Casinos(x) → DisposableIncome(x))"
  },
  {
    "input": "Translate into first-order logic: If Matt invests in the public stock market regularly, then Matt neither has a lot of disposable income to spend nor invests in the public stock market regularly.",
    "output": "Invests(matt) → ¬DisposableIncome(matt) ∧ ¬Invests(matt)"
  },
  {
    "input": "Translate into first-order logic: People either invest in the public stock market regularly or enjoy gambling regularly.",
    "output": "∀x (Invests(x) ∨ Gambling(x))"
  },
  {
    "input": "Translate into first-order logic: If people invest in the public stock market regularly, then they read the Wall Street Journal and other newspapers regularly to keep updated on financial metrics.",
    "output": "∀x (Invests(x) → Newspapers(x))"
  },
  {
    "input": "Translate into first-order logic: All people who enjoy gambling regularly spend a lot of money at casinos and other betting games.",
    "output": "∀x (Gambling(x) → Casinos(x))"
  },
  {
    "input": "Translate into first-order logic: People who spend a lot of money at casinos and other betting games visit the Las Vegas Strip regularly.",
    "output": "∀x (Casinos(x) → LasVegas(x))"
  },
  {
    "input": "Translate into first-order logic: People who spend a lot of money at casinos and other betting games have a lot of disposable income to spend.",
    "output": "∀x (Casinos(x) → DisposableIncome(x))"
  },
  {
    "input": "Translate into first-order logic: If Matt invests in the public stock market regularly, then Matt neither has a lot of disposable income to spend nor invests in the public stock market regularly.",
    "output": "Invests(matt) → ¬DisposableIncome(matt) ∧ ¬Invests(matt)"
  },
  {
    "input": "Translate into first-order logic: People either invest in the public stock market regularly or enjoy gambling regularly.",
    "output": "∀x (Invests(x) ∨ Gambling(x))"
  },
  {
    "input": "Translate into first-order logic: If people invest in the public stock market regularly, then they read the Wall Street Journal and other newspapers regularly to keep updated on financial metrics.",
    "output": "∀x (Invests(x) → Newspapers(x))"
  },
  {
    "input": "Translate into first-order logic: All people who enjoy gambling regularly spend a lot of money at casinos and other betting games.",
    "output": "∀x (Gambling(x) → Casinos(x))"
  },
  {
    "input": "Translate into first-order logic: People who spend a lot of money at casinos and other betting games visit the Las Vegas Strip regularly.",
    "output": "∀x (Casinos(x) → LasVegas(x))"
  },
  {
    "input": "Translate into first-order logic: People who spend a lot of money at casinos and other betting games have a lot of disposable income to spend.",
    "output": "∀x (Casinos(x) → DisposableIncome(x))"
  },
  {
    "input": "Translate into first-order logic: If Matt invests in the public stock market regularly, then Matt neither has a lot of disposable income to spend nor invests in the public stock market regularly.",
    "output": "Invests(matt) → ¬DisposableIncome(matt) ∧ ¬Invests(matt)"
  },
  {
    "input": "Translate into first-order logic: All students learning piano can strike the right notes.",
    "output": "∀x (Student(x) ∧ LearningPiano(x) → StrikeRightNotes(x))"
  },
  {
    "input": "Translate into first-order logic: All students who can strike the right note can get the rhythms right.",
    "output": "∀x (Student(x) ∧ StrikeRightNotes(x) → GetRhythmRight(x))"
  },
  {
    "input": "Translate into first-order logic: If a student can get the rhythms right, he will start working on coordination between the left and the right hands.",
    "output": "∀x (Student(x) ∧ GetRhythmRight(x) → StartCoordination(x))"
  },
  {
    "input": "Translate into first-order logic: Some students who start working on coordination between the left and the right hands become good at it. The other students find it challenging.",
    "output": "∀x (Student(x) ∧ StartCoordination(x) → GoodAtCoordination(x) ⊕ FindCoordinationChallenging(x))"
  },
  {
    "input": "Translate into first-order logic: If John can strike the right notes, get the rhythms right and is good at coordination between right and left hands, then he puts emotions into his playing.",
    "output": "StrikeRightNotes(john) ∧ GetRhythmRight(john) ∧ GoodAtCoordination(john) → PutEmotion(john)"
  },
  {
    "input": "Translate into first-order logic: John is a student learning piano.",
    "output": "Student(john) ∧ LearningPiano(john)"
  },
  {
    "input": "Translate into first-order logic: John does not find coordination between the left and the right hands challenging.",
    "output": "¬FindCoordinationChallenging(john)"
  },
  {
    "input": "Translate into first-order logic: All students learning piano can strike the right notes.",
    "output": "∀x (Student(x) ∧ LearningPiano(x) → StrikeRightNotes(x))"
  },
  {
    "input": "Translate into first-order logic: All students who can strike the right note can get the rhythms right.",
    "output": "∀x (Student(x) ∧ StrikeRightNotes(x) → GetRhythmRight(x))"
  },
  {
    "input": "Translate into first-order logic: If a student can get the rhythms right, he will start working on coordination between the left and the right hands.",
    "output": "∀x (Student(x) ∧ GetRhythmRight(x) → StartCoordination(x))"
  },
  {
    "input": "Translate into first-order logic: Some students who start working on coordination between the left and the right hands become good at it. The other students find it challenging.",
    "output": "∀x (Student(x) ∧ StartCoordination(x) → GoodAtCoordination(x) ⊕ FindCoordinationChallenging(x))"
  },
  {
    "input": "Translate into first-order logic: If John can strike the right notes, get the rhythms right and is good at coordination between right and left hands, then he puts emotions into his playing.",
    "output": "StrikeRightNotes(john) ∧ GetRhythmRight(john) ∧ GoodAtCoordination(john) → PutEmotion(john)"
  },
  {
    "input": "Translate into first-order logic: John is a student learning piano.",
    "output": "Student(john) ∧ LearningPiano(john)"
  },
  {
    "input": "Translate into first-order logic: John does not find coordination between the left and the right hands challenging.",
    "output": "¬FindCoordinationChallenging(john)"
  },
  {
    "input": "Translate into first-order logic: Barbara Ann Marshall is a former swimmer and former world record-holder.",
    "output": "FormerSwimmer(barbaraannmarshall) ∧ FormerWorldRecordHolder(barbaraannmarshall)"
  },
  {
    "input": "Translate into first-order logic: Barbara Ann Marshall participated in the 1972 Summer Olympics.",
    "output": "ParticipatedIn(barbaraannmarshall, summer1972olympics)"
  },
  {
    "input": "Translate into first-order logic: Barbara Ann Marshall's home country is the United States.",
    "output": "HomeCountry(barbaraannmarshall, unitedstates)"
  },
  {
    "input": "Translate into first-order logic: All people who compete in the 1972 Summer Olympics represent their home country.",
    "output": "∀x ∃y (ParticipatedIn(x, summer1972olympics) ∧ HomeCountry(x, y) → Represented(x, y))"
  },
  {
    "input": "Translate into first-order logic: Barbara Ann Marshall participated in the preliminary heat in the freestyle relay.",
    "output": "ParticipatedIn(barbaraannmarshall, preliminaryheatfreestylerelay)"
  },
  {
    "input": "Translate into first-order logic: Barbara Ann Marshall did not participate in the event final of the 1972 Summer Olympics freestyle relay.",
    "output": "¬ParticipatedIn(barbaraannmarshall, finalheatfreestylerelay)"
  },
  {
    "input": "Translate into first-order logic: Only relay swimmers who participated in the event final received medals.",
    "output": "∀x ((RelaySwimmer(x) ∧ ¬ParticipatedIn(x, finalheatfreerelay)) ↔ ¬Recieved(x, medal)))"
  },
  {
    "input": "Translate into first-order logic: Barbara Ann Marshall is a former swimmer and former world record-holder.",
    "output": "FormerSwimmer(barbaraannmarshall) ∧ FormerWorldRecordHolder(barbaraannmarshall)"
  },
  {
    "input": "Translate into first-order logic: Barbara Ann Marshall participated in the 1972 Summer Olympics.",
    "output": "ParticipatedIn(barbaraannmarshall, summer1972olympics)"
  },
  {
    "input": "Translate into first-order logic: Barbara Ann Marshall's home country is the United States.",
    "output": "HomeCountry(barbaraannmarshall, unitedstates)"
  },
  {
    "input": "Translate into first-order logic: All people who compete in the 1972 Summer Olympics represent their home country.",
    "output": "∀x ∃y (ParticipatedIn(x, summer1972olympics) ∧ HomeCountry(x, y) → Represented(x, y))"
  },
  {
    "input": "Translate into first-order logic: Barbara Ann Marshall participated in the preliminary heat in the freestyle relay.",
    "output": "ParticipatedIn(barbaraannmarshall, preliminaryheatfreestylerelay)"
  },
  {
    "input": "Translate into first-order logic: Barbara Ann Marshall did not participate in the event final of the 1972 Summer Olympics freestyle relay.",
    "output": "¬ParticipatedIn(barbaraannmarshall, finalheatfreestylerelay)"
  },
  {
    "input": "Translate into first-order logic: Only relay swimmers who participated in the event final received medals.",
    "output": "∀x ((RelaySwimmer(x) ∧ ¬ParticipatedIn(x, finalheatfreerelay)) ↔ ¬Recieved(x, medal)))"
  },
  {
    "input": "Translate into first-order logic: A game is played with three stages: red stage, yellow stage, and green stage.",
    "output": "∃x (Player(x))"
  },
  {
    "input": "Translate into first-order logic: Each player begins at the red stage.",
    "output": "∀x (Player(x) → StartRed(x))"
  },
  {
    "input": "Translate into first-order logic: All players must reach the yellow stage before they can reach the green stage.",
    "output": "∀x (Player(x) → YellowToGreen(x))"
  },
  {
    "input": "Translate into first-order logic: The yellow stage comes after the red stage.",
    "output": "∀x (Player(x) → RedToYellow(x))"
  },
  {
    "input": "Translate into first-order logic: All players must proceed one stage at a time.",
    "output": "∀x (Player(x) → ¬RedToGreen(x))"
  },
  {
    "input": "Translate into first-order logic: A game is played with three stages: red stage, yellow stage, and green stage.",
    "output": "∃x (Player(x))"
  },
  {
    "input": "Translate into first-order logic: Each player begins at the red stage.",
    "output": "∀x (Player(x) → StartRed(x))"
  },
  {
    "input": "Translate into first-order logic: All players must reach the yellow stage before they can reach the green stage.",
    "output": "∀x (Player(x) → YellowToGreen(x))"
  },
  {
    "input": "Translate into first-order logic: The yellow stage comes after the red stage.",
    "output": "∀x (Player(x) → RedToYellow(x))"
  },
  {
    "input": "Translate into first-order logic: All players must proceed one stage at a time.",
    "output": "∀x (Player(x) → ¬RedToGreen(x))"
  },
  {
    "input": "Translate into first-order logic: A game is played with three stages: red stage, yellow stage, and green stage.",
    "output": "∃x (Player(x))"
  },
  {
    "input": "Translate into first-order logic: Each player begins at the red stage.",
    "output": "∀x (Player(x) → StartRed(x))"
  },
  {
    "input": "Translate into first-order logic: All players must reach the yellow stage before they can reach the green stage.",
    "output": "∀x (Player(x) → YellowToGreen(x))"
  },
  {
    "input": "Translate into first-order logic: The yellow stage comes after the red stage.",
    "output": "∀x (Player(x) → RedToYellow(x))"
  },
  {
    "input": "Translate into first-order logic: All players must proceed one stage at a time.",
    "output": "∀x (Player(x) → ¬RedToGreen(x))"
  },
  {
    "input": "Translate into first-order logic: People either value physical touch as an especially important love language or value words of affirmation as an especially important love language.",
    "output": "∀x (Physical(x) ∨ Words(x))"
  },
  {
    "input": "Translate into first-order logic: If a person values physical touch as an especially important love language, then they are good with pets.",
    "output": "∀x (Physical(x) → GoodWithPets(x))"
  },
  {
    "input": "Translate into first-order logic: No people that are good with pets are scared of animals.",
    "output": "∀x (GoodWithPets(x) → ¬ScaredOfAnimals(x))"
  },
  {
    "input": "Translate into first-order logic: People are either scared of animals or love animals.",
    "output": "∀x (ScaredOfAnimals(x) ∨ LoveAnimals(x))"
  },
  {
    "input": "Translate into first-order logic: Adam is either a person who values physical touch as an especially important love language or a person who loves animals.",
    "output": "Physical(adam) ⊕ LoveAnimals(adam)"
  },
  {
    "input": "Translate into first-order logic: People either value physical touch as an especially important love language or value words of affirmation as an especially important love language.",
    "output": "∀x (Physical(x) ∨ Words(x))"
  },
  {
    "input": "Translate into first-order logic: If a person values physical touch as an especially important love language, then they are good with pets.",
    "output": "∀x (Physical(x) → GoodWithPets(x))"
  },
  {
    "input": "Translate into first-order logic: No people that are good with pets are scared of animals.",
    "output": "∀x (GoodWithPets(x) → ¬ScaredOfAnimals(x))"
  },
  {
    "input": "Translate into first-order logic: People are either scared of animals or love animals.",
    "output": "∀x (ScaredOfAnimals(x) ∨ LoveAnimals(x))"
  },
  {
    "input": "Translate into first-order logic: Adam is either a person who values physical touch as an especially important love language or a person who loves animals.",
    "output": "Physical(adam) ⊕ LoveAnimals(adam)"
  },
  {
    "input": "Translate into first-order logic: People either value physical touch as an especially important love language or value words of affirmation as an especially important love language.",
    "output": "∀x (Physical(x) ∨ Words(x))"
  },
  {
    "input": "Translate into first-order logic: If a person values physical touch as an especially important love language, then they are good with pets.",
    "output": "∀x (Physical(x) → GoodWithPets(x))"
  },
  {
    "input": "Translate into first-order logic: No people that are good with pets are scared of animals.",
    "output": "∀x (GoodWithPets(x) → ¬ScaredOfAnimals(x))"
  },
  {
    "input": "Translate into first-order logic: People are either scared of animals or love animals.",
    "output": "∀x (ScaredOfAnimals(x) ∨ LoveAnimals(x))"
  },
  {
    "input": "Translate into first-order logic: Adam is either a person who values physical touch as an especially important love language or a person who loves animals.",
    "output": "Physical(adam) ⊕ LoveAnimals(adam)"
  },
  {
    "input": "Translate into first-order logic: People either value physical touch as an especially important love language or value words of affirmation as an especially important love language.",
    "output": "∀x (Physical(x) ∨ Words(x))"
  },
  {
    "input": "Translate into first-order logic: If a person values physical touch as an especially important love language, then they are good with pets.",
    "output": "∀x (Physical(x) → GoodWithPets(x))"
  },
  {
    "input": "Translate into first-order logic: No people that are good with pets are scared of animals.",
    "output": "∀x (GoodWithPets(x) → ¬ScaredOfAnimals(x))"
  },
  {
    "input": "Translate into first-order logic: People are either scared of animals or love animals.",
    "output": "∀x (ScaredOfAnimals(x) ∨ LoveAnimals(x))"
  },
  {
    "input": "Translate into first-order logic: Adam is either a person who values physical touch as an especially important love language or a person who loves animals.",
    "output": "Physical(adam) ⊕ LoveAnimals(adam)"
  },
  {
    "input": "Translate into first-order logic: People either value physical touch as an especially important love language or value words of affirmation as an especially important love language.",
    "output": "∀x (Physical(x) ∨ Words(x))"
  },
  {
    "input": "Translate into first-order logic: If a person values physical touch as an especially important love language, then they are good with pets.",
    "output": "∀x (Physical(x) → GoodWithPets(x))"
  },
  {
    "input": "Translate into first-order logic: No people that are good with pets are scared of animals.",
    "output": "∀x (GoodWithPets(x) → ¬ScaredOfAnimals(x))"
  },
  {
    "input": "Translate into first-order logic: People are either scared of animals or love animals.",
    "output": "∀x (ScaredOfAnimals(x) ∨ LoveAnimals(x))"
  },
  {
    "input": "Translate into first-order logic: Adam is either a person who values physical touch as an especially important love language or a person who loves animals.",
    "output": "Physical(adam) ⊕ LoveAnimals(adam)"
  },
  {
    "input": "Translate into first-order logic: All birds have wings.",
    "output": "∀x (Bird(x) → Winged(x))"
  },
  {
    "input": "Translate into first-order logic: No animal with wings is a reptile.",
    "output": "∀x (Winged(x) → ¬Reptile(x))"
  },
  {
    "input": "Translate into first-order logic: Some animals that fly are birds.",
    "output": "∃x (Fly(x) ∧ Bird(x))"
  },
  {
    "input": "Translate into first-order logic: If something is an iguana, then it is a reptile.",
    "output": "∀x (Iguana(x) → Reptile(x))"
  },
  {
    "input": "Translate into first-order logic: John is neither an iguana nor a bird.",
    "output": "¬Iguana(john) ⊕ Bird(john)"
  },
  {
    "input": "Translate into first-order logic: All birds have wings.",
    "output": "∀x (Bird(x) → Winged(x))"
  },
  {
    "input": "Translate into first-order logic: No animal with wings is a reptile.",
    "output": "∀x (Winged(x) → ¬Reptile(x))"
  },
  {
    "input": "Translate into first-order logic: Some animals that fly are birds.",
    "output": "∃x (Fly(x) ∧ Bird(x))"
  },
  {
    "input": "Translate into first-order logic: If something is an iguana, then it is a reptile.",
    "output": "∀x (Iguana(x) → Reptile(x))"
  },
  {
    "input": "Translate into first-order logic: John is neither an iguana nor a bird.",
    "output": "¬Iguana(john) ⊕ Bird(john)"
  },
  {
    "input": "Translate into first-order logic: All birds have wings.",
    "output": "∀x (Bird(x) → Winged(x))"
  },
  {
    "input": "Translate into first-order logic: No animal with wings is a reptile.",
    "output": "∀x (Winged(x) → ¬Reptile(x))"
  },
  {
    "input": "Translate into first-order logic: Some animals that fly are birds.",
    "output": "∃x (Fly(x) ∧ Bird(x))"
  },
  {
    "input": "Translate into first-order logic: If something is an iguana, then it is a reptile.",
    "output": "∀x (Iguana(x) → Reptile(x))"
  },
  {
    "input": "Translate into first-order logic: John is neither an iguana nor a bird.",
    "output": "¬Iguana(john) ⊕ Bird(john)"
  },
  {
    "input": "Translate into first-order logic: EndGame is a movie released in 2006.",
    "output": "Movie(endGame) ∧ Released(endGame, year2006)"
  },
  {
    "input": "Translate into first-order logic: EndGame was set in Washington.",
    "output": "Set(endGame, washington)"
  },
  {
    "input": "Translate into first-order logic: EndGame was filmed outside of Washington.",
    "output": "FilmedOutside(endGame, washington)"
  },
  {
    "input": "Translate into first-order logic: Some movies are filmed in New York.",
    "output": "∃x (FilmedIn(x, newYork))"
  },
  {
    "input": "Translate into first-order logic: Andy Chang directed EndGame.",
    "output": "Directed(andyChang, endGame)"
  },
  {
    "input": "Translate into first-order logic: Andy Chang is from Hong Kong.",
    "output": "From(andyChang, hongKong)"
  },
  {
    "input": "Translate into first-order logic: EndGame is a movie released in 2006.",
    "output": "Movie(endGame) ∧ Released(endGame, year2006)"
  },
  {
    "input": "Translate into first-order logic: EndGame was set in Washington.",
    "output": "Set(endGame, washington)"
  },
  {
    "input": "Translate into first-order logic: EndGame was filmed outside of Washington.",
    "output": "FilmedOutside(endGame, washington)"
  },
  {
    "input": "Translate into first-order logic: Some movies are filmed in New York.",
    "output": "∃x (FilmedIn(x, newYork))"
  },
  {
    "input": "Translate into first-order logic: Andy Chang directed EndGame.",
    "output": "Directed(andyChang, endGame)"
  },
  {
    "input": "Translate into first-order logic: Andy Chang is from Hong Kong.",
    "output": "From(andyChang, hongKong)"
  },
  {
    "input": "Translate into first-order logic: EndGame is a movie released in 2006.",
    "output": "Movie(endGame) ∧ Released(endGame, year2006)"
  },
  {
    "input": "Translate into first-order logic: EndGame was set in Washington.",
    "output": "Set(endGame, washington)"
  },
  {
    "input": "Translate into first-order logic: EndGame was filmed outside of Washington.",
    "output": "FilmedOutside(endGame, washington)"
  },
  {
    "input": "Translate into first-order logic: Some movies are filmed in New York.",
    "output": "∃x (FilmedIn(x, newYork))"
  },
  {
    "input": "Translate into first-order logic: Andy Chang directed EndGame.",
    "output": "Directed(andyChang, endGame)"
  },
  {
    "input": "Translate into first-order logic: Andy Chang is from Hong Kong.",
    "output": "From(andyChang, hongKong)"
  },
  {
    "input": "Translate into first-order logic: Six, seven and eight are real numbers.",
    "output": "RealNum(six) ∧ RealNum(seven) ∧ RealNum(eight)"
  },
  {
    "input": "Translate into first-order logic: If a real number equals another real number adding one, the first number is larger.",
    "output": "∀x ∀y (RealNum(x) ∧ RealNum(y) ∧ EqualAddOne(x, y) → Larger(x, y))"
  },
  {
    "input": "Translate into first-order logic: If the number x is larger than number y, then y is not larger than x.",
    "output": "∀x ∀y (Larger(x, y) ↔ ¬Larger(y, x))"
  },
  {
    "input": "Translate into first-order logic: Seven equals six plus one.",
    "output": "EqualAddOne(seven, six)"
  },
  {
    "input": "Translate into first-order logic: Eight equals seven plus one.",
    "output": "EqualAddOne(eight, seven)"
  },
  {
    "input": "Translate into first-order logic: Two is positive.",
    "output": "Positive(two)"
  },
  {
    "input": "Translate into first-order logic: If a number is positive, then the double of it is also positive.",
    "output": "∀x ∀y ((Positive(x) ∧ EqualDouble(y, x)) → Positive(y))"
  },
  {
    "input": "Translate into first-order logic: Eight is the double of four.",
    "output": "EqualDouble(eight, four)"
  },
  {
    "input": "Translate into first-order logic: Four is the double of two.",
    "output": "EqualDouble(four, two)"
  },
  {
    "input": "Translate into first-order logic: Six, seven and eight are real numbers.",
    "output": "RealNum(six) ∧ RealNum(seven) ∧ RealNum(eight)"
  },
  {
    "input": "Translate into first-order logic: If a real number equals another real number adding one, the first number is larger.",
    "output": "∀x ∀y (RealNum(x) ∧ RealNum(y) ∧ EqualAddOne(x, y) → Larger(x, y))"
  },
  {
    "input": "Translate into first-order logic: If the number x is larger than number y, then y is not larger than x.",
    "output": "∀x ∀y (Larger(x, y) ↔ ¬Larger(y, x))"
  },
  {
    "input": "Translate into first-order logic: Seven equals six plus one.",
    "output": "EqualAddOne(seven, six)"
  },
  {
    "input": "Translate into first-order logic: Eight equals seven plus one.",
    "output": "EqualAddOne(eight, seven)"
  },
  {
    "input": "Translate into first-order logic: Two is positive.",
    "output": "Positive(two)"
  },
  {
    "input": "Translate into first-order logic: If a number is positive, then the double of it is also positive.",
    "output": "∀x ∀y ((Positive(x) ∧ EqualDouble(y, x)) → Positive(y))"
  },
  {
    "input": "Translate into first-order logic: Eight is the double of four.",
    "output": "EqualDouble(eight, four)"
  },
  {
    "input": "Translate into first-order logic: Four is the double of two.",
    "output": "EqualDouble(four, two)"
  },
  {
    "input": "Translate into first-order logic: Six, seven and eight are real numbers.",
    "output": "RealNum(six) ∧ RealNum(seven) ∧ RealNum(eight)"
  },
  {
    "input": "Translate into first-order logic: If a real number equals another real number adding one, the first number is larger.",
    "output": "∀x ∀y (RealNum(x) ∧ RealNum(y) ∧ EqualAddOne(x, y) → Larger(x, y))"
  },
  {
    "input": "Translate into first-order logic: If the number x is larger than number y, then y is not larger than x.",
    "output": "∀x ∀y (Larger(x, y) ↔ ¬Larger(y, x))"
  },
  {
    "input": "Translate into first-order logic: Seven equals six plus one.",
    "output": "EqualAddOne(seven, six)"
  },
  {
    "input": "Translate into first-order logic: Eight equals seven plus one.",
    "output": "EqualAddOne(eight, seven)"
  },
  {
    "input": "Translate into first-order logic: Two is positive.",
    "output": "Positive(two)"
  },
  {
    "input": "Translate into first-order logic: If a number is positive, then the double of it is also positive.",
    "output": "∀x ∀y ((Positive(x) ∧ EqualDouble(y, x)) → Positive(y))"
  },
  {
    "input": "Translate into first-order logic: Eight is the double of four.",
    "output": "EqualDouble(eight, four)"
  },
  {
    "input": "Translate into first-order logic: Four is the double of two.",
    "output": "EqualDouble(four, two)"
  },
  {
    "input": "Translate into first-order logic: A dog never tells the truth.",
    "output": "∀x (Dog(x) → NeverTellsTruth(x))"
  },
  {
    "input": "Translate into first-order logic: Some poker players are dogs.",
    "output": "∃x (PokerPlayer(x) ∧ Dog(x))"
  },
  {
    "input": "Translate into first-order logic: All Asians are human.",
    "output": "∀x ( Asian(x)→  Human(x))"
  },
  {
    "input": "Translate into first-order logic: All Chinese are Asian.",
    "output": "∀x ( Chinese(x)→  Asian(x))"
  },
  {
    "input": "Translate into first-order logic: A man is either Chinese or British.",
    "output": "∀x ( Chinese(x) ∨  British(x))"
  },
  {
    "input": "Translate into first-order logic: All British are European.",
    "output": "∀x ( British(x)→  European(x))"
  },
  {
    "input": "Translate into first-order logic: All Spanish are European.",
    "output": "∀x ( Spanish(x)→  European(x))"
  },
  {
    "input": "Translate into first-order logic: No Indian is European.",
    "output": "∀x ( Indian(x)→ ¬ European(x))"
  },
  {
    "input": "Translate into first-order logic: Jessee is either both an Indian and a human, or neither an Indian nor a human.",
    "output": "( Indian(jesse) ∧ Human(jesse)) ⊕ (¬ Indian(jesse) ∧ ¬ Human(jesse))"
  },
  {
    "input": "Translate into first-order logic: All Asians are human.",
    "output": "∀x ( Asian(x)→  Human(x))"
  },
  {
    "input": "Translate into first-order logic: All Chinese are Asian.",
    "output": "∀x ( Chinese(x)→  Asian(x))"
  },
  {
    "input": "Translate into first-order logic: A man is either Chinese or British.",
    "output": "∀x ( Chinese(x) ∨  British(x))"
  },
  {
    "input": "Translate into first-order logic: All British are European.",
    "output": "∀x ( British(x)→  European(x))"
  },
  {
    "input": "Translate into first-order logic: All Spanish are European.",
    "output": "∀x ( Spanish(x)→  European(x))"
  },
  {
    "input": "Translate into first-order logic: No Indian is European.",
    "output": "∀x ( Indian(x)→ ¬ European(x))"
  },
  {
    "input": "Translate into first-order logic: Jessee is either both an Indian and a human, or neither an Indian nor a human.",
    "output": "( Indian(jesse) ∧ Human(jesse)) ⊕ (¬ Indian(jesse) ∧ ¬ Human(jesse))"
  },
  {
    "input": "Translate into first-order logic: All Asians are human.",
    "output": "∀x ( Asian(x)→  Human(x))"
  },
  {
    "input": "Translate into first-order logic: All Chinese are Asian.",
    "output": "∀x ( Chinese(x)→  Asian(x))"
  },
  {
    "input": "Translate into first-order logic: A man is either Chinese or British.",
    "output": "∀x ( Chinese(x) ∨  British(x))"
  },
  {
    "input": "Translate into first-order logic: All British are European.",
    "output": "∀x ( British(x)→  European(x))"
  },
  {
    "input": "Translate into first-order logic: All Spanish are European.",
    "output": "∀x ( Spanish(x)→  European(x))"
  },
  {
    "input": "Translate into first-order logic: No Indian is European.",
    "output": "∀x ( Indian(x)→ ¬ European(x))"
  },
  {
    "input": "Translate into first-order logic: Jessee is either both an Indian and a human, or neither an Indian nor a human.",
    "output": "( Indian(jesse) ∧ Human(jesse)) ⊕ (¬ Indian(jesse) ∧ ¬ Human(jesse))"
  },
  {
    "input": "Translate into first-order logic: No people who never admit a mistake are good teachers.",
    "output": "∀x (NeverAdmitMistakes(x) → ¬GoodTeacher(x))"
  },
  {
    "input": "Translate into first-order logic: Some well-informed people are people who never admit a mistake.",
    "output": "∃x (WellInformed(x) ∧ NeverAdmitMistakes(x))"
  },
  {
    "input": "Translate into first-order logic: Philatelic literature is divided into the following categories: Stamp catalogues, Periodicals, Auction catalogues, Books, Bibliographies, and Background Material",
    "output": "∀x (PhilatelicLit(x) → (Stamp(x) ∨ Periodical(x) ∨ Auction(x) ∨ Book(x) ∨ Bibliography(x) ∨ Background(x)))"
  },
  {
    "input": "Translate into first-order logic: Mort is not a Stamp catalogue.",
    "output": "¬Stamp(mort)"
  },
  {
    "input": "Translate into first-order logic: Mort is not a periodical, auction catalogue, bibliography, or background material.",
    "output": "¬(Periodical(mort) ∨ Auction(mort) ∨ Bibliography(mort) ∨ Background(mort))"
  },
  {
    "input": "Translate into first-order logic: Mort is a piece of Philatelic literature.",
    "output": "PhilatelicLit(mort)"
  },
  {
    "input": "Translate into first-order logic: Philatelic literature is divided into the following categories: Stamp catalogues, Periodicals, Auction catalogues, Books, Bibliographies, and Background Material",
    "output": "∀x (PhilatelicLit(x) → (Stamp(x) ∨ Periodical(x) ∨ Auction(x) ∨ Book(x) ∨ Bibliography(x) ∨ Background(x)))"
  },
  {
    "input": "Translate into first-order logic: Mort is not a Stamp catalogue.",
    "output": "¬Stamp(mort)"
  },
  {
    "input": "Translate into first-order logic: Mort is not a periodical, auction catalogue, bibliography, or background material.",
    "output": "¬(Periodical(mort) ∨ Auction(mort) ∨ Bibliography(mort) ∨ Background(mort))"
  },
  {
    "input": "Translate into first-order logic: Mort is a piece of Philatelic literature.",
    "output": "PhilatelicLit(mort)"
  },
  {
    "input": "Translate into first-order logic: Philatelic literature is divided into the following categories: Stamp catalogues, Periodicals, Auction catalogues, Books, Bibliographies, and Background Material",
    "output": "∀x (PhilatelicLit(x) → (Stamp(x) ∨ Periodical(x) ∨ Auction(x) ∨ Book(x) ∨ Bibliography(x) ∨ Background(x)))"
  },
  {
    "input": "Translate into first-order logic: Mort is not a Stamp catalogue.",
    "output": "¬Stamp(mort)"
  },
  {
    "input": "Translate into first-order logic: Mort is not a periodical, auction catalogue, bibliography, or background material.",
    "output": "¬(Periodical(mort) ∨ Auction(mort) ∨ Bibliography(mort) ∨ Background(mort))"
  },
  {
    "input": "Translate into first-order logic: Mort is a piece of Philatelic literature.",
    "output": "PhilatelicLit(mort)"
  },
  {
    "input": "Translate into first-order logic: Adventures of Rusty is a drama film and children's film.",
    "output": "DramaFilm(adventuresofrusty) ∧ ChildrensFilm(adventuresofrusty)"
  },
  {
    "input": "Translate into first-order logic: Columbia Pictures produced Adventures of Rusty",
    "output": "Produced(columbiapictures, adventuresofrusty)"
  },
  {
    "input": "Translate into first-order logic: Tintin was produced by Paramount.",
    "output": "Produced(paramount, tintin)"
  },
  {
    "input": "Translate into first-order logic: Tintin is an adventure film.",
    "output": "AdventureFilm(tintin)"
  },
  {
    "input": "Translate into first-order logic: Adventures of Rusty is a drama film and children's film.",
    "output": "DramaFilm(adventuresofrusty) ∧ ChildrensFilm(adventuresofrusty)"
  },
  {
    "input": "Translate into first-order logic: Columbia Pictures produced Adventures of Rusty",
    "output": "Produced(columbiapictures, adventuresofrusty)"
  },
  {
    "input": "Translate into first-order logic: Tintin was produced by Paramount.",
    "output": "Produced(paramount, tintin)"
  },
  {
    "input": "Translate into first-order logic: Tintin is an adventure film.",
    "output": "AdventureFilm(tintin)"
  },
  {
    "input": "Translate into first-order logic: Adventures of Rusty is a drama film and children's film.",
    "output": "DramaFilm(adventuresofrusty) ∧ ChildrensFilm(adventuresofrusty)"
  },
  {
    "input": "Translate into first-order logic: Columbia Pictures produced Adventures of Rusty",
    "output": "Produced(columbiapictures, adventuresofrusty)"
  },
  {
    "input": "Translate into first-order logic: Tintin was produced by Paramount.",
    "output": "Produced(paramount, tintin)"
  },
  {
    "input": "Translate into first-order logic: Tintin is an adventure film.",
    "output": "AdventureFilm(tintin)"
  },
  {
    "input": "Translate into first-order logic: Adventures of Rusty is a drama film and children's film.",
    "output": "DramaFilm(adventuresofrusty) ∧ ChildrensFilm(adventuresofrusty)"
  },
  {
    "input": "Translate into first-order logic: Columbia Pictures produced Adventures of Rusty",
    "output": "Produced(columbiapictures, adventuresofrusty)"
  },
  {
    "input": "Translate into first-order logic: Tintin was produced by Paramount.",
    "output": "Produced(paramount, tintin)"
  },
  {
    "input": "Translate into first-order logic: Tintin is an adventure film.",
    "output": "AdventureFilm(tintin)"
  },
  {
    "input": "Translate into first-order logic: Deng Xiaoping served as the paramount leader of the People's Republic of China (PRC).",
    "output": "ParamountLeaderOf(dengxiaoping, prc)"
  },
  {
    "input": "Translate into first-order logic: Deng Xiaoping was praised for his reaffirmation of the reform program in his Southern Tour of 1992 as well as the reversion of Hong Kong to Chinese control in 1997 and the return of Macau in 1999.",
    "output": "PraisedFor(dengxiaoping, reaffirmationofreformprogram) ∧ PraisedFor(dengxiaoping, reversionofhongkong) ∧ PraisedFor(dengxiaoping, returnofmacau)"
  },
  {
    "input": "Translate into first-order logic: As the party's Secretary-General under Mao and Vice Premier in he 1950s, Deng Xiaoping presided over the Anti-Rightist Campaign launched by Mao.",
    "output": "PartysSecretaryGeneral(dengxiaoping) ∧ Under(dengxiaoping, mao) ∧ VicePremier(dengxiaoping) ∧ PresidedOver(dengxiaoping, antirightistcampaign) ∧ LaunchedBy(antirightistcampaign, mao)"
  },
  {
    "input": "Translate into first-order logic: Deng Xiaoping became instrumental in China's economic reconstruction following the disastrous Great Leap Forward (1958–1960).",
    "output": "InstrumentalIn(dengxiaoping, chinaseconomicreconstruction) ∧ Following(chinaseconomicreconstruction, greatleapforward) ∧ Disastrous(greatleapforward)"
  },
  {
    "input": "Translate into first-order logic: Mao Zedong died in 1976.",
    "output": "DiedIn(mao, y1976)"
  },
  {
    "input": "Translate into first-order logic: After Mao Zedong's death, Deng Xiaoping gradually rose to supreme power.",
    "output": "GraduallyRoseTo(dengxiaoping, supremepower)"
  },
  {
    "input": "Translate into first-order logic: Deng Xiaoping served as the paramount leader of the People's Republic of China (PRC).",
    "output": "ParamountLeaderOf(dengxiaoping, prc)"
  },
  {
    "input": "Translate into first-order logic: Deng Xiaoping was praised for his reaffirmation of the reform program in his Southern Tour of 1992 as well as the reversion of Hong Kong to Chinese control in 1997 and the return of Macau in 1999.",
    "output": "PraisedFor(dengxiaoping, reaffirmationofreformprogram) ∧ PraisedFor(dengxiaoping, reversionofhongkong) ∧ PraisedFor(dengxiaoping, returnofmacau)"
  },
  {
    "input": "Translate into first-order logic: As the party's Secretary-General under Mao and Vice Premier in he 1950s, Deng Xiaoping presided over the Anti-Rightist Campaign launched by Mao.",
    "output": "PartysSecretaryGeneral(dengxiaoping) ∧ Under(dengxiaoping, mao) ∧ VicePremier(dengxiaoping) ∧ PresidedOver(dengxiaoping, antirightistcampaign) ∧ LaunchedBy(antirightistcampaign, mao)"
  },
  {
    "input": "Translate into first-order logic: Deng Xiaoping became instrumental in China's economic reconstruction following the disastrous Great Leap Forward (1958–1960).",
    "output": "InstrumentalIn(dengxiaoping, chinaseconomicreconstruction) ∧ Following(chinaseconomicreconstruction, greatleapforward) ∧ Disastrous(greatleapforward)"
  },
  {
    "input": "Translate into first-order logic: Mao Zedong died in 1976.",
    "output": "DiedIn(mao, y1976)"
  },
  {
    "input": "Translate into first-order logic: After Mao Zedong's death, Deng Xiaoping gradually rose to supreme power.",
    "output": "GraduallyRoseTo(dengxiaoping, supremepower)"
  },
  {
    "input": "Translate into first-order logic: Deng Xiaoping served as the paramount leader of the People's Republic of China (PRC).",
    "output": "ParamountLeaderOf(dengxiaoping, prc)"
  },
  {
    "input": "Translate into first-order logic: Deng Xiaoping was praised for his reaffirmation of the reform program in his Southern Tour of 1992 as well as the reversion of Hong Kong to Chinese control in 1997 and the return of Macau in 1999.",
    "output": "PraisedFor(dengxiaoping, reaffirmationofreformprogram) ∧ PraisedFor(dengxiaoping, reversionofhongkong) ∧ PraisedFor(dengxiaoping, returnofmacau)"
  },
  {
    "input": "Translate into first-order logic: As the party's Secretary-General under Mao and Vice Premier in he 1950s, Deng Xiaoping presided over the Anti-Rightist Campaign launched by Mao.",
    "output": "PartysSecretaryGeneral(dengxiaoping) ∧ Under(dengxiaoping, mao) ∧ VicePremier(dengxiaoping) ∧ PresidedOver(dengxiaoping, antirightistcampaign) ∧ LaunchedBy(antirightistcampaign, mao)"
  },
  {
    "input": "Translate into first-order logic: Deng Xiaoping became instrumental in China's economic reconstruction following the disastrous Great Leap Forward (1958–1960).",
    "output": "InstrumentalIn(dengxiaoping, chinaseconomicreconstruction) ∧ Following(chinaseconomicreconstruction, greatleapforward) ∧ Disastrous(greatleapforward)"
  },
  {
    "input": "Translate into first-order logic: Mao Zedong died in 1976.",
    "output": "DiedIn(mao, y1976)"
  },
  {
    "input": "Translate into first-order logic: After Mao Zedong's death, Deng Xiaoping gradually rose to supreme power.",
    "output": "GraduallyRoseTo(dengxiaoping, supremepower)"
  },
  {
    "input": "Translate into first-order logic: All imaginative processes are produced in human brains.",
    "output": "∀x (ImaginativeProcess(x) → ProducedInHumanBrains(x))"
  },
  {
    "input": "Translate into first-order logic: All science-fiction is from an imaginative process.",
    "output": " ∀x (Science-fiction(x) → ImaginativeProcess(x)) "
  },
  {
    "input": "Translate into first-order logic: Either science-fiction or fact.",
    "output": " ∀x (Science-fiction(x) ∨ Fact(x))"
  },
  {
    "input": "Translate into first-order logic: No facts are proven to be false.",
    "output": " ∀x (Fact(x) → ¬ProvedToBeFalse(x)) "
  },
  {
    "input": "Translate into first-order logic: Dune is a science-fiction or proven to be false.",
    "output": " Science-fiction(dune) ∨ ProvedToBeFalse(dune)"
  },
  {
    "input": "Translate into first-order logic: All imaginative processes are produced in human brains.",
    "output": "∀x (ImaginativeProcess(x) → ProducedInHumanBrains(x))"
  },
  {
    "input": "Translate into first-order logic: All science-fiction is from an imaginative process.",
    "output": " ∀x (Science-fiction(x) → ImaginativeProcess(x)) "
  },
  {
    "input": "Translate into first-order logic: Either science-fiction or fact.",
    "output": " ∀x (Science-fiction(x) ∨ Fact(x))"
  },
  {
    "input": "Translate into first-order logic: No facts are proven to be false.",
    "output": " ∀x (Fact(x) → ¬ProvedToBeFalse(x)) "
  },
  {
    "input": "Translate into first-order logic: Dune is a science-fiction or proven to be false.",
    "output": " Science-fiction(dune) ∨ ProvedToBeFalse(dune)"
  },
  {
    "input": "Translate into first-order logic: All imaginative processes are produced in human brains.",
    "output": "∀x (ImaginativeProcess(x) → ProducedInHumanBrains(x))"
  },
  {
    "input": "Translate into first-order logic: All science-fiction is from an imaginative process.",
    "output": " ∀x (Science-fiction(x) → ImaginativeProcess(x)) "
  },
  {
    "input": "Translate into first-order logic: Either science-fiction or fact.",
    "output": " ∀x (Science-fiction(x) ∨ Fact(x))"
  },
  {
    "input": "Translate into first-order logic: No facts are proven to be false.",
    "output": " ∀x (Fact(x) → ¬ProvedToBeFalse(x)) "
  },
  {
    "input": "Translate into first-order logic: Dune is a science-fiction or proven to be false.",
    "output": " Science-fiction(dune) ∨ ProvedToBeFalse(dune)"
  },
  {
    "input": "Translate into first-order logic: All imaginative processes are produced in human brains.",
    "output": "∀x (ImaginativeProcess(x) → ProducedInHumanBrains(x))"
  },
  {
    "input": "Translate into first-order logic: All science-fiction is from an imaginative process.",
    "output": " ∀x (Science-fiction(x) → ImaginativeProcess(x)) "
  },
  {
    "input": "Translate into first-order logic: Either science-fiction or fact.",
    "output": " ∀x (Science-fiction(x) ∨ Fact(x))"
  },
  {
    "input": "Translate into first-order logic: No facts are proven to be false.",
    "output": " ∀x (Fact(x) → ¬ProvedToBeFalse(x)) "
  },
  {
    "input": "Translate into first-order logic: Dune is a science-fiction or proven to be false.",
    "output": " Science-fiction(dune) ∨ ProvedToBeFalse(dune)"
  },
  {
    "input": "Translate into first-order logic: All imaginative processes are produced in human brains.",
    "output": "∀x (ImaginativeProcess(x) → ProducedInHumanBrains(x))"
  },
  {
    "input": "Translate into first-order logic: All science-fiction is from an imaginative process.",
    "output": " ∀x (Science-fiction(x) → ImaginativeProcess(x)) "
  },
  {
    "input": "Translate into first-order logic: Either science-fiction or fact.",
    "output": " ∀x (Science-fiction(x) ∨ Fact(x))"
  },
  {
    "input": "Translate into first-order logic: No facts are proven to be false.",
    "output": " ∀x (Fact(x) → ¬ProvedToBeFalse(x)) "
  },
  {
    "input": "Translate into first-order logic: Dune is a science-fiction or proven to be false.",
    "output": " Science-fiction(dune) ∨ ProvedToBeFalse(dune)"
  },
  {
    "input": "Translate into first-order logic: All imaginative processes are produced in human brains.",
    "output": "∀x (ImaginativeProcess(x) → ProducedInHumanBrains(x))"
  },
  {
    "input": "Translate into first-order logic: All science-fiction is from an imaginative process.",
    "output": " ∀x (Science-fiction(x) → ImaginativeProcess(x)) "
  },
  {
    "input": "Translate into first-order logic: Either science-fiction or fact.",
    "output": " ∀x (Science-fiction(x) ∨ Fact(x))"
  },
  {
    "input": "Translate into first-order logic: No facts are proven to be false.",
    "output": " ∀x (Fact(x) → ¬ProvedToBeFalse(x)) "
  },
  {
    "input": "Translate into first-order logic: Dune is a science-fiction or proven to be false.",
    "output": " Science-fiction(dune) ∨ ProvedToBeFalse(dune)"
  },
  {
    "input": "Translate into first-order logic: All imaginative processes are produced in human brains.",
    "output": "∀x (ImaginativeProcess(x) → ProducedInHumanBrains(x))"
  },
  {
    "input": "Translate into first-order logic: All science-fiction is from an imaginative process.",
    "output": " ∀x (Science-fiction(x) → ImaginativeProcess(x)) "
  },
  {
    "input": "Translate into first-order logic: Either science-fiction or fact.",
    "output": " ∀x (Science-fiction(x) ∨ Fact(x))"
  },
  {
    "input": "Translate into first-order logic: No facts are proven to be false.",
    "output": " ∀x (Fact(x) → ¬ProvedToBeFalse(x)) "
  },
  {
    "input": "Translate into first-order logic: Dune is a science-fiction or proven to be false.",
    "output": " Science-fiction(dune) ∨ ProvedToBeFalse(dune)"
  },
  {
    "input": "Translate into first-order logic: All imaginative processes are produced in human brains.",
    "output": "∀x (ImaginativeProcess(x) → ProducedInHumanBrains(x))"
  },
  {
    "input": "Translate into first-order logic: All science-fiction is from an imaginative process.",
    "output": " ∀x (Science-fiction(x) → ImaginativeProcess(x)) "
  },
  {
    "input": "Translate into first-order logic: Either science-fiction or fact.",
    "output": " ∀x (Science-fiction(x) ∨ Fact(x))"
  },
  {
    "input": "Translate into first-order logic: No facts are proven to be false.",
    "output": " ∀x (Fact(x) → ¬ProvedToBeFalse(x)) "
  },
  {
    "input": "Translate into first-order logic: Dune is a science-fiction or proven to be false.",
    "output": " Science-fiction(dune) ∨ ProvedToBeFalse(dune)"
  },
  {
    "input": "Translate into first-order logic: All imaginative processes are produced in human brains.",
    "output": "∀x (ImaginativeProcess(x) → ProducedInHumanBrains(x))"
  },
  {
    "input": "Translate into first-order logic: All science-fiction is from an imaginative process.",
    "output": " ∀x (Science-fiction(x) → ImaginativeProcess(x)) "
  },
  {
    "input": "Translate into first-order logic: Either science-fiction or fact.",
    "output": " ∀x (Science-fiction(x) ∨ Fact(x))"
  },
  {
    "input": "Translate into first-order logic: No facts are proven to be false.",
    "output": " ∀x (Fact(x) → ¬ProvedToBeFalse(x)) "
  },
  {
    "input": "Translate into first-order logic: Dune is a science-fiction or proven to be false.",
    "output": " Science-fiction(dune) ∨ ProvedToBeFalse(dune)"
  },
  {
    "input": "Translate into first-order logic: All imaginative processes are produced in human brains.",
    "output": "∀x (ImaginativeProcess(x) → ProducedInHumanBrains(x))"
  },
  {
    "input": "Translate into first-order logic: All science-fiction is from an imaginative process.",
    "output": " ∀x (Science-fiction(x) → ImaginativeProcess(x)) "
  },
  {
    "input": "Translate into first-order logic: Either science-fiction or fact.",
    "output": " ∀x (Science-fiction(x) ∨ Fact(x))"
  },
  {
    "input": "Translate into first-order logic: No facts are proven to be false.",
    "output": " ∀x (Fact(x) → ¬ProvedToBeFalse(x)) "
  },
  {
    "input": "Translate into first-order logic: Dune is a science-fiction or proven to be false.",
    "output": " Science-fiction(dune) ∨ ProvedToBeFalse(dune)"
  },
  {
    "input": "Translate into first-order logic: An American superhero comes from either DC universe or Marvel universe.",
    "output": "∀x (Superhero(x) ∧ American(x) → (ComeFrom(x, dc universe) ⊕ ComeFrom(x, marvel universe))) "
  },
  {
    "input": "Translate into first-order logic: Captain America is a superhero.",
    "output": " Superhero(captain america) "
  },
  {
    "input": "Translate into first-order logic: Captain America is an American.",
    "output": " American(captain america) "
  },
  {
    "input": "Translate into first-order logic: Captain America does not come from DC universe.",
    "output": " ¬ComeFrom(captain america, dc universe) "
  },
  {
    "input": "Translate into first-order logic: If a superhero is American, he speaks English.",
    "output": " ∀x (Superhero(x) ∧ American(x) → Speak(x, english)) "
  },
  {
    "input": "Translate into first-order logic: A superhero speaks English or Spanish.",
    "output": " ∀x (Superhero(x) → (Speak(x, english) ∨ Speak(x, spanish)))"
  },
  {
    "input": "Translate into first-order logic: An American superhero comes from either DC universe or Marvel universe.",
    "output": "∀x (Superhero(x) ∧ American(x) → (ComeFrom(x, dc universe) ⊕ ComeFrom(x, marvel universe))) "
  },
  {
    "input": "Translate into first-order logic: Captain America is a superhero.",
    "output": " Superhero(captain america) "
  },
  {
    "input": "Translate into first-order logic: Captain America is an American.",
    "output": " American(captain america) "
  },
  {
    "input": "Translate into first-order logic: Captain America does not come from DC universe.",
    "output": " ¬ComeFrom(captain america, dc universe) "
  },
  {
    "input": "Translate into first-order logic: If a superhero is American, he speaks English.",
    "output": " ∀x (Superhero(x) ∧ American(x) → Speak(x, english)) "
  },
  {
    "input": "Translate into first-order logic: A superhero speaks English or Spanish.",
    "output": " ∀x (Superhero(x) → (Speak(x, english) ∨ Speak(x, spanish)))"
  },
  {
    "input": "Translate into first-order logic: An American superhero comes from either DC universe or Marvel universe.",
    "output": "∀x (Superhero(x) ∧ American(x) → (ComeFrom(x, dc universe) ⊕ ComeFrom(x, marvel universe))) "
  },
  {
    "input": "Translate into first-order logic: Captain America is a superhero.",
    "output": " Superhero(captain america) "
  },
  {
    "input": "Translate into first-order logic: Captain America is an American.",
    "output": " American(captain america) "
  },
  {
    "input": "Translate into first-order logic: Captain America does not come from DC universe.",
    "output": " ¬ComeFrom(captain america, dc universe) "
  },
  {
    "input": "Translate into first-order logic: If a superhero is American, he speaks English.",
    "output": " ∀x (Superhero(x) ∧ American(x) → Speak(x, english)) "
  },
  {
    "input": "Translate into first-order logic: A superhero speaks English or Spanish.",
    "output": " ∀x (Superhero(x) → (Speak(x, english) ∨ Speak(x, spanish)))"
  },
  {
    "input": "Translate into first-order logic: Robert Zimmer was born in Germany.",
    "output": "BornInGermany(robertZimmer)"
  },
  {
    "input": "Translate into first-order logic: Robert Zimmer is an essayist.",
    "output": "IsEssayist(robertZimmer)"
  },
  {
    "input": "Translate into first-order logic: Robert Zimmer was born in 1953.",
    "output": "BornIn(robertZimmer, year1953)"
  },
  {
    "input": "Translate into first-order logic: Every essayist is a writer.",
    "output": "∀x (IsEssayist(x) → IsWriter(x))"
  },
  {
    "input": "Translate into first-order logic: Every person born in Germany is German.",
    "output": "∀x (BornInGermany(x) → IsGerman(x))"
  },
  {
    "input": "Translate into first-order logic: Robert Zimmer was born in Germany.",
    "output": "BornInGermany(robertZimmer)"
  },
  {
    "input": "Translate into first-order logic: Robert Zimmer is an essayist.",
    "output": "IsEssayist(robertZimmer)"
  },
  {
    "input": "Translate into first-order logic: Robert Zimmer was born in 1953.",
    "output": "BornIn(robertZimmer, year1953)"
  },
  {
    "input": "Translate into first-order logic: Every essayist is a writer.",
    "output": "∀x (IsEssayist(x) → IsWriter(x))"
  },
  {
    "input": "Translate into first-order logic: Every person born in Germany is German.",
    "output": "∀x (BornInGermany(x) → IsGerman(x))"
  },
  {
    "input": "Translate into first-order logic: Robert Zimmer was born in Germany.",
    "output": "BornInGermany(robertZimmer)"
  },
  {
    "input": "Translate into first-order logic: Robert Zimmer is an essayist.",
    "output": "IsEssayist(robertZimmer)"
  },
  {
    "input": "Translate into first-order logic: Robert Zimmer was born in 1953.",
    "output": "BornIn(robertZimmer, year1953)"
  },
  {
    "input": "Translate into first-order logic: Every essayist is a writer.",
    "output": "∀x (IsEssayist(x) → IsWriter(x))"
  },
  {
    "input": "Translate into first-order logic: Every person born in Germany is German.",
    "output": "∀x (BornInGermany(x) → IsGerman(x))"
  },
  {
    "input": "Translate into first-order logic: All people who repay their loans on time have a high credit score.",
    "output": "∀x (Repay(x) → HighCreditScore(x))"
  },
  {
    "input": "Translate into first-order logic: Some people with high credit scores and high salaries are approved for mortgages.",
    "output": "∃x ((HighCreditScore(x) ∧ HighSalary(x)) → Mortgage(x))"
  },
  {
    "input": "Translate into first-order logic: John has a high salary.",
    "output": "HighSalary(john)"
  },
  {
    "input": "Translate into first-order logic: All students are members of the university.",
    "output": "∀x (Student(x) → MemberOfUniversity(x))"
  },
  {
    "input": "Translate into first-order logic: All graduate students are students.",
    "output": "∀x (GraduateStudent(x) → Student(x))"
  },
  {
    "input": "Translate into first-order logic: All PhD students are graduate students.",
    "output": "∀x (PhDStudent(x) → GraduateStudent(x))"
  },
  {
    "input": "Translate into first-order logic: Some PhD students have high IQs.",
    "output": "∃x (PhDStudent(x) ∧ HighIQ(x))"
  },
  {
    "input": "Translate into first-order logic: If John is not a PhD student, then he is not a member of the university.",
    "output": "¬PhDStudent(john) → ¬MemberOfUniversity(john)"
  },
  {
    "input": "Translate into first-order logic: If John has a high IQ, then he is a PhD student or a graduate student.",
    "output": "HighIQ(john) → PhDStudent(john) ⊕ GraduateStudent(john)"
  },
  {
    "input": "Translate into first-order logic: All students are members of the university.",
    "output": "∀x (Student(x) → MemberOfUniversity(x))"
  },
  {
    "input": "Translate into first-order logic: All graduate students are students.",
    "output": "∀x (GraduateStudent(x) → Student(x))"
  },
  {
    "input": "Translate into first-order logic: All PhD students are graduate students.",
    "output": "∀x (PhDStudent(x) → GraduateStudent(x))"
  },
  {
    "input": "Translate into first-order logic: Some PhD students have high IQs.",
    "output": "∃x (PhDStudent(x) ∧ HighIQ(x))"
  },
  {
    "input": "Translate into first-order logic: If John is not a PhD student, then he is not a member of the university.",
    "output": "¬PhDStudent(john) → ¬MemberOfUniversity(john)"
  },
  {
    "input": "Translate into first-order logic: If John has a high IQ, then he is a PhD student or a graduate student.",
    "output": "HighIQ(john) → PhDStudent(john) ⊕ GraduateStudent(john)"
  },
  {
    "input": "Translate into first-order logic: All students are members of the university.",
    "output": "∀x (Student(x) → MemberOfUniversity(x))"
  },
  {
    "input": "Translate into first-order logic: All graduate students are students.",
    "output": "∀x (GraduateStudent(x) → Student(x))"
  },
  {
    "input": "Translate into first-order logic: All PhD students are graduate students.",
    "output": "∀x (PhDStudent(x) → GraduateStudent(x))"
  },
  {
    "input": "Translate into first-order logic: Some PhD students have high IQs.",
    "output": "∃x (PhDStudent(x) ∧ HighIQ(x))"
  },
  {
    "input": "Translate into first-order logic: If John is not a PhD student, then he is not a member of the university.",
    "output": "¬PhDStudent(john) → ¬MemberOfUniversity(john)"
  },
  {
    "input": "Translate into first-order logic: If John has a high IQ, then he is a PhD student or a graduate student.",
    "output": "HighIQ(john) → PhDStudent(john) ⊕ GraduateStudent(john)"
  },
  {
    "input": "Translate into first-order logic: Belgium, France and Germany are European countries.",
    "output": "EuropeanCountry(belgium) ∨ EuropeanCountry(france) ∨ EuropeanCountry(germany)"
  },
  {
    "input": "Translate into first-order logic: Paris is the capital of France.",
    "output": "CapitalOf(paris, france)"
  },
  {
    "input": "Translate into first-order logic: The Eiffel Tower is one of the main tourist attractions located in Paris.",
    "output": "TouristAttraction(eiffelTower) ∧ LocatedIn(eiffelTower, paris)"
  },
  {
    "input": "Translate into first-order logic: Some people who live in Belgium speak French.",
    "output": "∃x (LiveIn(x, belgium) → Speak(x, french))"
  },
  {
    "input": "Translate into first-order logic: If John goes to Europe, he will see some tourist attractions.",
    "output": "∃x (GoTo(john, europe) → (See(john, x) ∧ TouristAttraction(x)))"
  },
  {
    "input": "Translate into first-order logic: John speaks French.",
    "output": "Speak(john, french)"
  },
  {
    "input": "Translate into first-order logic: Belgium, France and Germany are European countries.",
    "output": "EuropeanCountry(belgium) ∨ EuropeanCountry(france) ∨ EuropeanCountry(germany)"
  },
  {
    "input": "Translate into first-order logic: Paris is the capital of France.",
    "output": "CapitalOf(paris, france)"
  },
  {
    "input": "Translate into first-order logic: The Eiffel Tower is one of the main tourist attractions located in Paris.",
    "output": "TouristAttraction(eiffelTower) ∧ LocatedIn(eiffelTower, paris)"
  },
  {
    "input": "Translate into first-order logic: Some people who live in Belgium speak French.",
    "output": "∃x (LiveIn(x, belgium) → Speak(x, french))"
  },
  {
    "input": "Translate into first-order logic: If John goes to Europe, he will see some tourist attractions.",
    "output": "∃x (GoTo(john, europe) → (See(john, x) ∧ TouristAttraction(x)))"
  },
  {
    "input": "Translate into first-order logic: John speaks French.",
    "output": "Speak(john, french)"
  },
  {
    "input": "Translate into first-order logic: Belgium, France and Germany are European countries.",
    "output": "EuropeanCountry(belgium) ∨ EuropeanCountry(france) ∨ EuropeanCountry(germany)"
  },
  {
    "input": "Translate into first-order logic: Paris is the capital of France.",
    "output": "CapitalOf(paris, france)"
  },
  {
    "input": "Translate into first-order logic: The Eiffel Tower is one of the main tourist attractions located in Paris.",
    "output": "TouristAttraction(eiffelTower) ∧ LocatedIn(eiffelTower, paris)"
  },
  {
    "input": "Translate into first-order logic: Some people who live in Belgium speak French.",
    "output": "∃x (LiveIn(x, belgium) → Speak(x, french))"
  },
  {
    "input": "Translate into first-order logic: If John goes to Europe, he will see some tourist attractions.",
    "output": "∃x (GoTo(john, europe) → (See(john, x) ∧ TouristAttraction(x)))"
  },
  {
    "input": "Translate into first-order logic: John speaks French.",
    "output": "Speak(john, french)"
  },
  {
    "input": "Translate into first-order logic: All sports cars are loud.",
    "output": "∀x (SportsCar(x) → LoudCar(x))"
  },
  {
    "input": "Translate into first-order logic: No loud cars are electric.",
    "output": "∀x (LoudCar(x) → ¬ElectricCar(x))"
  },
  {
    "input": "Translate into first-order logic: If a car is a Ferrari, then it is a sports car.",
    "output": "∀x (Ferrari(x) → SportsCar(x))"
  },
  {
    "input": "Translate into first-order logic: All cars made in Maranello are Ferrari",
    "output": "∀x (MadeInMaranello(x) → Ferrari(x))"
  },
  {
    "input": "Translate into first-order logic: If Prius is neither a sports car nor a loud car, then Prius is a Maranello-made car or a loud car.",
    "output": "∀x (¬SportsCar(prius) ∨ ¬LoudCar(prius) → MadeInMaranello(prius) ∨ LoudCar(prius))"
  },
  {
    "input": "Translate into first-order logic: All sports cars are loud.",
    "output": "∀x (SportsCar(x) → LoudCar(x))"
  },
  {
    "input": "Translate into first-order logic: No loud cars are electric.",
    "output": "∀x (LoudCar(x) → ¬ElectricCar(x))"
  },
  {
    "input": "Translate into first-order logic: If a car is a Ferrari, then it is a sports car.",
    "output": "∀x (Ferrari(x) → SportsCar(x))"
  },
  {
    "input": "Translate into first-order logic: All cars made in Maranello are Ferrari",
    "output": "∀x (MadeInMaranello(x) → Ferrari(x))"
  },
  {
    "input": "Translate into first-order logic: If Prius is neither a sports car nor a loud car, then Prius is a Maranello-made car or a loud car.",
    "output": "∀x (¬SportsCar(prius) ∨ ¬LoudCar(prius) → MadeInMaranello(prius) ∨ LoudCar(prius))"
  },
  {
    "input": "Translate into first-order logic: All sports cars are loud.",
    "output": "∀x (SportsCar(x) → LoudCar(x))"
  },
  {
    "input": "Translate into first-order logic: No loud cars are electric.",
    "output": "∀x (LoudCar(x) → ¬ElectricCar(x))"
  },
  {
    "input": "Translate into first-order logic: If a car is a Ferrari, then it is a sports car.",
    "output": "∀x (Ferrari(x) → SportsCar(x))"
  },
  {
    "input": "Translate into first-order logic: All cars made in Maranello are Ferrari",
    "output": "∀x (MadeInMaranello(x) → Ferrari(x))"
  },
  {
    "input": "Translate into first-order logic: If Prius is neither a sports car nor a loud car, then Prius is a Maranello-made car or a loud car.",
    "output": "∀x (¬SportsCar(prius) ∨ ¬LoudCar(prius) → MadeInMaranello(prius) ∨ LoudCar(prius))"
  },
  {
    "input": "Translate into first-order logic: All sports cars are loud.",
    "output": "∀x (SportsCar(x) → LoudCar(x))"
  },
  {
    "input": "Translate into first-order logic: No loud cars are electric.",
    "output": "∀x (LoudCar(x) → ¬ElectricCar(x))"
  },
  {
    "input": "Translate into first-order logic: If a car is a Ferrari, then it is a sports car.",
    "output": "∀x (Ferrari(x) → SportsCar(x))"
  },
  {
    "input": "Translate into first-order logic: All cars made in Maranello are Ferrari",
    "output": "∀x (MadeInMaranello(x) → Ferrari(x))"
  },
  {
    "input": "Translate into first-order logic: If Prius is neither a sports car nor a loud car, then Prius is a Maranello-made car or a loud car.",
    "output": "∀x (¬SportsCar(prius) ∨ ¬LoudCar(prius) → MadeInMaranello(prius) ∨ LoudCar(prius))"
  },
  {
    "input": "Translate into first-order logic: If something is a plant, then it is not a cute animal.",
    "output": "∀x (Plant(x) → ¬CuteAnimal(x))"
  },
  {
    "input": "Translate into first-order logic: All flowers are plants.",
    "output": "∀x (Flower(x) → Plant(x))"
  },
  {
    "input": "Translate into first-order logic: Every kitten is a cute animal.",
    "output": "∀x (Kitten(x) → CuteAnimal(x))"
  },
  {
    "input": "Translate into first-order logic: If something is grown in a garden, then it is a flower.",
    "output": "∀x (GrownInGarden(x) → Flower(x))"
  },
  {
    "input": "Translate into first-order logic: Piper is a kitten or a cute animal.",
    "output": "Kitten(piper) ∨ CuteAnimal(piper)"
  },
  {
    "input": "Translate into first-order logic: If something is a plant, then it is not a cute animal.",
    "output": "∀x (Plant(x) → ¬CuteAnimal(x))"
  },
  {
    "input": "Translate into first-order logic: All flowers are plants.",
    "output": "∀x (Flower(x) → Plant(x))"
  },
  {
    "input": "Translate into first-order logic: Every kitten is a cute animal.",
    "output": "∀x (Kitten(x) → CuteAnimal(x))"
  },
  {
    "input": "Translate into first-order logic: If something is grown in a garden, then it is a flower.",
    "output": "∀x (GrownInGarden(x) → Flower(x))"
  },
  {
    "input": "Translate into first-order logic: Piper is a kitten or a cute animal.",
    "output": "Kitten(piper) ∨ CuteAnimal(piper)"
  },
  {
    "input": "Translate into first-order logic: If something is a plant, then it is not a cute animal.",
    "output": "∀x (Plant(x) → ¬CuteAnimal(x))"
  },
  {
    "input": "Translate into first-order logic: All flowers are plants.",
    "output": "∀x (Flower(x) → Plant(x))"
  },
  {
    "input": "Translate into first-order logic: Every kitten is a cute animal.",
    "output": "∀x (Kitten(x) → CuteAnimal(x))"
  },
  {
    "input": "Translate into first-order logic: If something is grown in a garden, then it is a flower.",
    "output": "∀x (GrownInGarden(x) → Flower(x))"
  },
  {
    "input": "Translate into first-order logic: Piper is a kitten or a cute animal.",
    "output": "Kitten(piper) ∨ CuteAnimal(piper)"
  },
  {
    "input": "Translate into first-order logic: Guam has participated in the Winter Olympics.",
    "output": "ParticipatedIn(guam, winterolympics)"
  },
  {
    "input": "Translate into first-order logic: In 1988, the Winter Olympics were held in Calgary.",
    "output": "Year(y1988) → BeHeld(winterolympics, calgary)"
  },
  {
    "input": "Translate into first-order logic: Guam sent an athlete to the Calgary Winter Olympics.",
    "output": "BeHeld(winterolympics, calgary) → SendAthletes(guam)"
  },
  {
    "input": "Translate into first-order logic: If Guan sent an athlete to the Calgary Winter Olympics, then it participated in the Calgary Winter Olympics.",
    "output": "SendAthletes(guam) → ParticipatedIn(guam, winterolympics)"
  },
  {
    "input": "Translate into first-order logic: Judd Bankert is the only athlete from Guam who has ever competed in the Winter Olympics.",
    "output": "BeFrom(bankert, guam) ∧ ParticipatedIn(bankert, winterolympics)"
  },
  {
    "input": "Translate into first-order logic: Guam has participated in the Winter Olympics.",
    "output": "ParticipatedIn(guam, winterolympics)"
  },
  {
    "input": "Translate into first-order logic: In 1988, the Winter Olympics were held in Calgary.",
    "output": "Year(y1988) → BeHeld(winterolympics, calgary)"
  },
  {
    "input": "Translate into first-order logic: Guam sent an athlete to the Calgary Winter Olympics.",
    "output": "BeHeld(winterolympics, calgary) → SendAthletes(guam)"
  },
  {
    "input": "Translate into first-order logic: If Guan sent an athlete to the Calgary Winter Olympics, then it participated in the Calgary Winter Olympics.",
    "output": "SendAthletes(guam) → ParticipatedIn(guam, winterolympics)"
  },
  {
    "input": "Translate into first-order logic: Judd Bankert is the only athlete from Guam who has ever competed in the Winter Olympics.",
    "output": "BeFrom(bankert, guam) ∧ ParticipatedIn(bankert, winterolympics)"
  },
  {
    "input": "Translate into first-order logic: Michael O'Donnell is a British physician, journalist, author and broadcaster.",
    "output": "British(michael) ∧ Physician(michael) ∧ Journalist(michael) ∧ Author(michael) ∧ Broadcaster(michael)"
  },
  {
    "input": "Translate into first-order logic: One of the word-setters of My Word! was Michael O'Donnell.",
    "output": "WordSetter(michael)"
  },
  {
    "input": "Translate into first-order logic: The magazine World Medicine was edited by Michael O'Donnell.",
    "output": "Magazine(worldmedicine) ∧ EditedBy(worldmedicine, michael)"
  },
  {
    "input": "Translate into first-order logic: Michael O'Donnell was born in Yorkshire as the son of a general practitioner.",
    "output": "∃x (BornIn(michael, yorkshire) ∧ Son(michael, x) ∧ GeneralPractitioner(x))"
  },
  {
    "input": "Translate into first-order logic: Michael O'Donnell is a British physician, journalist, author and broadcaster.",
    "output": "British(michael) ∧ Physician(michael) ∧ Journalist(michael) ∧ Author(michael) ∧ Broadcaster(michael)"
  },
  {
    "input": "Translate into first-order logic: One of the word-setters of My Word! was Michael O'Donnell.",
    "output": "WordSetter(michael)"
  },
  {
    "input": "Translate into first-order logic: The magazine World Medicine was edited by Michael O'Donnell.",
    "output": "Magazine(worldmedicine) ∧ EditedBy(worldmedicine, michael)"
  },
  {
    "input": "Translate into first-order logic: Michael O'Donnell was born in Yorkshire as the son of a general practitioner.",
    "output": "∃x (BornIn(michael, yorkshire) ∧ Son(michael, x) ∧ GeneralPractitioner(x))"
  },
  {
    "input": "Translate into first-order logic: Michael O'Donnell is a British physician, journalist, author and broadcaster.",
    "output": "British(michael) ∧ Physician(michael) ∧ Journalist(michael) ∧ Author(michael) ∧ Broadcaster(michael)"
  },
  {
    "input": "Translate into first-order logic: One of the word-setters of My Word! was Michael O'Donnell.",
    "output": "WordSetter(michael)"
  },
  {
    "input": "Translate into first-order logic: The magazine World Medicine was edited by Michael O'Donnell.",
    "output": "Magazine(worldmedicine) ∧ EditedBy(worldmedicine, michael)"
  },
  {
    "input": "Translate into first-order logic: Michael O'Donnell was born in Yorkshire as the son of a general practitioner.",
    "output": "∃x (BornIn(michael, yorkshire) ∧ Son(michael, x) ∧ GeneralPractitioner(x))"
  },
  {
    "input": "Translate into first-order logic: Michael O'Donnell is a British physician, journalist, author and broadcaster.",
    "output": "British(michael) ∧ Physician(michael) ∧ Journalist(michael) ∧ Author(michael) ∧ Broadcaster(michael)"
  },
  {
    "input": "Translate into first-order logic: One of the word-setters of My Word! was Michael O'Donnell.",
    "output": "WordSetter(michael)"
  },
  {
    "input": "Translate into first-order logic: The magazine World Medicine was edited by Michael O'Donnell.",
    "output": "Magazine(worldmedicine) ∧ EditedBy(worldmedicine, michael)"
  },
  {
    "input": "Translate into first-order logic: Michael O'Donnell was born in Yorkshire as the son of a general practitioner.",
    "output": "∃x (BornIn(michael, yorkshire) ∧ Son(michael, x) ∧ GeneralPractitioner(x))"
  },
  {
    "input": "Translate into first-order logic: Michael O'Donnell is a British physician, journalist, author and broadcaster.",
    "output": "British(michael) ∧ Physician(michael) ∧ Journalist(michael) ∧ Author(michael) ∧ Broadcaster(michael)"
  },
  {
    "input": "Translate into first-order logic: One of the word-setters of My Word! was Michael O'Donnell.",
    "output": "WordSetter(michael)"
  },
  {
    "input": "Translate into first-order logic: The magazine World Medicine was edited by Michael O'Donnell.",
    "output": "Magazine(worldmedicine) ∧ EditedBy(worldmedicine, michael)"
  },
  {
    "input": "Translate into first-order logic: Michael O'Donnell was born in Yorkshire as the son of a general practitioner.",
    "output": "∃x (BornIn(michael, yorkshire) ∧ Son(michael, x) ∧ GeneralPractitioner(x))"
  },
  {
    "input": "Translate into first-order logic: No homework is fun.",
    "output": "∀x (Homework(x) → ¬IsFun(x))"
  },
  {
    "input": "Translate into first-order logic: Some reading is homework.",
    "output": "∃x (IsReading(x) ∧ Homework(x))"
  },
  {
    "input": "Translate into first-order logic: If violence is good, it is justified.",
    "output": "∀x ((Violence(x) ∧ Good(x)) → Justified(x))"
  },
  {
    "input": "Translate into first-order logic: If something is justified, it is lawful.",
    "output": "∀x (Justified(x) → Lawful(x))"
  },
  {
    "input": "Translate into first-order logic: All people who have a horse ranch regularly ride horses for pleasure and sport.",
    "output": "∀x (Ranch(x) → RegularlyRide(x))"
  },
  {
    "input": "Translate into first-order logic: All people who have a lot of disposable income have a horse ranch.",
    "output": "∀x (DisposableIncome(x) → Ranch(x))"
  },
  {
    "input": "Translate into first-order logic: If people compete in horse dressage shows, then they have a lot of disposable income.",
    "output": "∀x (Compete(x) → DisposableIncome(x))"
  },
  {
    "input": "Translate into first-order logic: If people compete in horse dressage shows, then they have invested in high-quality equestrian gear and equipment.",
    "output": "∀x (Compete(x) → Invested(x))"
  },
  {
    "input": "Translate into first-order logic: If people regularly ride horses for pleasure and sport, then they do not live in cramped residential buildings.",
    "output": "∀x (RegularlyRide(x) → ¬Cramped(x))"
  },
  {
    "input": "Translate into first-order logic: Manny either has a horse ranch and lives in cramped residential buildings, or he neither has a horse ranch nor lives in cramped residential buildings.",
    "output": "(Ranch(manny) ∧ Cramped(manny)) ⊕ (¬Ranch(manny) ∧ ¬Cramped(manny))"
  },
  {
    "input": "Translate into first-order logic: All people who have a horse ranch regularly ride horses for pleasure and sport.",
    "output": "∀x (Ranch(x) → RegularlyRide(x))"
  },
  {
    "input": "Translate into first-order logic: All people who have a lot of disposable income have a horse ranch.",
    "output": "∀x (DisposableIncome(x) → Ranch(x))"
  },
  {
    "input": "Translate into first-order logic: If people compete in horse dressage shows, then they have a lot of disposable income.",
    "output": "∀x (Compete(x) → DisposableIncome(x))"
  },
  {
    "input": "Translate into first-order logic: If people compete in horse dressage shows, then they have invested in high-quality equestrian gear and equipment.",
    "output": "∀x (Compete(x) → Invested(x))"
  },
  {
    "input": "Translate into first-order logic: If people regularly ride horses for pleasure and sport, then they do not live in cramped residential buildings.",
    "output": "∀x (RegularlyRide(x) → ¬Cramped(x))"
  },
  {
    "input": "Translate into first-order logic: Manny either has a horse ranch and lives in cramped residential buildings, or he neither has a horse ranch nor lives in cramped residential buildings.",
    "output": "(Ranch(manny) ∧ Cramped(manny)) ⊕ (¬Ranch(manny) ∧ ¬Cramped(manny))"
  },
  {
    "input": "Translate into first-order logic: All people who have a horse ranch regularly ride horses for pleasure and sport.",
    "output": "∀x (Ranch(x) → RegularlyRide(x))"
  },
  {
    "input": "Translate into first-order logic: All people who have a lot of disposable income have a horse ranch.",
    "output": "∀x (DisposableIncome(x) → Ranch(x))"
  },
  {
    "input": "Translate into first-order logic: If people compete in horse dressage shows, then they have a lot of disposable income.",
    "output": "∀x (Compete(x) → DisposableIncome(x))"
  },
  {
    "input": "Translate into first-order logic: If people compete in horse dressage shows, then they have invested in high-quality equestrian gear and equipment.",
    "output": "∀x (Compete(x) → Invested(x))"
  },
  {
    "input": "Translate into first-order logic: If people regularly ride horses for pleasure and sport, then they do not live in cramped residential buildings.",
    "output": "∀x (RegularlyRide(x) → ¬Cramped(x))"
  },
  {
    "input": "Translate into first-order logic: Manny either has a horse ranch and lives in cramped residential buildings, or he neither has a horse ranch nor lives in cramped residential buildings.",
    "output": "(Ranch(manny) ∧ Cramped(manny)) ⊕ (¬Ranch(manny) ∧ ¬Cramped(manny))"
  },
  {
    "input": "Translate into first-order logic: A roundel is a rounded artillery fortification.",
    "output": "∀x (Roundel(x) → Rounded(x) ∧ ArtilleryFortification(x))"
  },
  {
    "input": "Translate into first-order logic: A roundel is not higher than adjacent walls.",
    "output": "∀x ∀y (Roundel(x) ∧ AdjacentWall(y) → ¬Higher(x, y))"
  },
  {
    "input": "Translate into first-order logic: Cannons can be deployed on artillery fortifications.",
    "output": "∀x (ArtilleryFortification(x) → DeployCannons(x))"
  },
  {
    "input": "Translate into first-order logic: Roundels are the oldest artillery fortifications.",
    "output": "∀x ∀y (Roundel(x) ∧ ArtilleryFortification(x) ∧ ArtilleryFortification(y) → Older(x, y))"
  },
  {
    "input": "Translate into first-order logic: Battery towers are an artillery fortification.",
    "output": "∀x (BatteryTower(x) → ArtilleryFortification(x))"
  },
  {
    "input": "Translate into first-order logic: A roundel is a rounded artillery fortification.",
    "output": "∀x (Roundel(x) → Rounded(x) ∧ ArtilleryFortification(x))"
  },
  {
    "input": "Translate into first-order logic: A roundel is not higher than adjacent walls.",
    "output": "∀x ∀y (Roundel(x) ∧ AdjacentWall(y) → ¬Higher(x, y))"
  },
  {
    "input": "Translate into first-order logic: Cannons can be deployed on artillery fortifications.",
    "output": "∀x (ArtilleryFortification(x) → DeployCannons(x))"
  },
  {
    "input": "Translate into first-order logic: Roundels are the oldest artillery fortifications.",
    "output": "∀x ∀y (Roundel(x) ∧ ArtilleryFortification(x) ∧ ArtilleryFortification(y) → Older(x, y))"
  },
  {
    "input": "Translate into first-order logic: Battery towers are an artillery fortification.",
    "output": "∀x (BatteryTower(x) → ArtilleryFortification(x))"
  },
  {
    "input": "Translate into first-order logic: A roundel is a rounded artillery fortification.",
    "output": "∀x (Roundel(x) → Rounded(x) ∧ ArtilleryFortification(x))"
  },
  {
    "input": "Translate into first-order logic: A roundel is not higher than adjacent walls.",
    "output": "∀x ∀y (Roundel(x) ∧ AdjacentWall(y) → ¬Higher(x, y))"
  },
  {
    "input": "Translate into first-order logic: Cannons can be deployed on artillery fortifications.",
    "output": "∀x (ArtilleryFortification(x) → DeployCannons(x))"
  },
  {
    "input": "Translate into first-order logic: Roundels are the oldest artillery fortifications.",
    "output": "∀x ∀y (Roundel(x) ∧ ArtilleryFortification(x) ∧ ArtilleryFortification(y) → Older(x, y))"
  },
  {
    "input": "Translate into first-order logic: Battery towers are an artillery fortification.",
    "output": "∀x (BatteryTower(x) → ArtilleryFortification(x))"
  },
  {
    "input": "Translate into first-order logic: A roundel is a rounded artillery fortification.",
    "output": "∀x (Roundel(x) → Rounded(x) ∧ ArtilleryFortification(x))"
  },
  {
    "input": "Translate into first-order logic: A roundel is not higher than adjacent walls.",
    "output": "∀x ∀y (Roundel(x) ∧ AdjacentWall(y) → ¬Higher(x, y))"
  },
  {
    "input": "Translate into first-order logic: Cannons can be deployed on artillery fortifications.",
    "output": "∀x (ArtilleryFortification(x) → DeployCannons(x))"
  },
  {
    "input": "Translate into first-order logic: Roundels are the oldest artillery fortifications.",
    "output": "∀x ∀y (Roundel(x) ∧ ArtilleryFortification(x) ∧ ArtilleryFortification(y) → Older(x, y))"
  },
  {
    "input": "Translate into first-order logic: Battery towers are an artillery fortification.",
    "output": "∀x (BatteryTower(x) → ArtilleryFortification(x))"
  },
  {
    "input": "Translate into first-order logic: All tissues are soft.",
    "output": "∀x (Tissue(x) → Soft(x))"
  },
  {
    "input": "Translate into first-order logic: Some papers are tissues.",
    "output": "∃x (Paper(x) ∧ Tissue(x))"
  },
  {
    "input": "Translate into first-order logic: All volunteers receive intangible benefits for their work.",
    "output": "∀x (Volunteer(x) → GetIntangibleBenefits(x))"
  },
  {
    "input": "Translate into first-order logic: Volunteers work regularly or on an as-needed basis.",
    "output": "∀x (Volunteer(x) → WorkRegularly(x) ∨ WorkAsNeeded(x))"
  },
  {
    "input": "Translate into first-order logic: Some volunteers are trained.",
    "output": "∃x (Volunteer(x) → Trained(x))"
  },
  {
    "input": "Translate into first-order logic: Volunteers work in groups or individually.",
    "output": "∀x (Volunteer(x) → (WorkInGroup(x) ∨ WorkIndividually(x)))"
  },
  {
    "input": "Translate into first-order logic: Environmental volunteers contribute toward environmental management or conservation.",
    "output": "∀x (Volunteer(x) ∧ Environmental(x) → (ContributeTo(x, environmentalmanagement) ∨ ContributeTo(x, environmentalconservation)))"
  },
  {
    "input": "Translate into first-order logic: Participating in natural disaster response is an example of volunteers working in groups on an as-needed basis.",
    "output": "∃x (Volunteer(x) ∧ ContributeTo(x, naturaldisasterresponse) → WorkInGroup(x) ∧ WorkAsNeeded(x))"
  },
  {
    "input": "Translate into first-order logic: All volunteers receive intangible benefits for their work.",
    "output": "∀x (Volunteer(x) → GetIntangibleBenefits(x))"
  },
  {
    "input": "Translate into first-order logic: Volunteers work regularly or on an as-needed basis.",
    "output": "∀x (Volunteer(x) → WorkRegularly(x) ∨ WorkAsNeeded(x))"
  },
  {
    "input": "Translate into first-order logic: Some volunteers are trained.",
    "output": "∃x (Volunteer(x) → Trained(x))"
  },
  {
    "input": "Translate into first-order logic: Volunteers work in groups or individually.",
    "output": "∀x (Volunteer(x) → (WorkInGroup(x) ∨ WorkIndividually(x)))"
  },
  {
    "input": "Translate into first-order logic: Environmental volunteers contribute toward environmental management or conservation.",
    "output": "∀x (Volunteer(x) ∧ Environmental(x) → (ContributeTo(x, environmentalmanagement) ∨ ContributeTo(x, environmentalconservation)))"
  },
  {
    "input": "Translate into first-order logic: Participating in natural disaster response is an example of volunteers working in groups on an as-needed basis.",
    "output": "∃x (Volunteer(x) ∧ ContributeTo(x, naturaldisasterresponse) → WorkInGroup(x) ∧ WorkAsNeeded(x))"
  },
  {
    "input": "Translate into first-order logic: All volunteers receive intangible benefits for their work.",
    "output": "∀x (Volunteer(x) → GetIntangibleBenefits(x))"
  },
  {
    "input": "Translate into first-order logic: Volunteers work regularly or on an as-needed basis.",
    "output": "∀x (Volunteer(x) → WorkRegularly(x) ∨ WorkAsNeeded(x))"
  },
  {
    "input": "Translate into first-order logic: Some volunteers are trained.",
    "output": "∃x (Volunteer(x) → Trained(x))"
  },
  {
    "input": "Translate into first-order logic: Volunteers work in groups or individually.",
    "output": "∀x (Volunteer(x) → (WorkInGroup(x) ∨ WorkIndividually(x)))"
  },
  {
    "input": "Translate into first-order logic: Environmental volunteers contribute toward environmental management or conservation.",
    "output": "∀x (Volunteer(x) ∧ Environmental(x) → (ContributeTo(x, environmentalmanagement) ∨ ContributeTo(x, environmentalconservation)))"
  },
  {
    "input": "Translate into first-order logic: Participating in natural disaster response is an example of volunteers working in groups on an as-needed basis.",
    "output": "∃x (Volunteer(x) ∧ ContributeTo(x, naturaldisasterresponse) → WorkInGroup(x) ∧ WorkAsNeeded(x))"
  },
  {
    "input": "Translate into first-order logic: All people who are very consistent and enjoy sticking to their regular routines do not like surprises.",
    "output": "∀x (Consistent(x) → NoSurprises(x))"
  },
  {
    "input": "Translate into first-order logic: If people wear flannel shirts every day, then they are very consistent and enjoy sticking to their regular routines.",
    "output": "∀x (Flannel(x) → Consistent(x))"
  },
  {
    "input": "Translate into first-order logic: If people do not like shopping for clothes and other materialistic goods, then they wear flannel shirts every day.",
    "output": "∀x (NoShopping(x) → Flannel(x))"
  },
  {
    "input": "Translate into first-order logic: All old people living in stable homes do not like surprises.",
    "output": "∀x (Old(x) → NoSurprises(x))"
  },
  {
    "input": "Translate into first-order logic: If people have very high energy and are impulsive, then they like surprises.",
    "output": "∀x (Impulsive(x) → ¬NoSurprises(x))"
  },
  {
    "input": "Translate into first-order logic: If Mike is not a person who wears flannel shirts every day and has very high energy and is impulsive, then Mike either is very consistent and enjoys sticking to his regular routines or does not like surprises.",
    "output": "¬(NoSurprises(mike) ∧ Impulsive(mike)) → Consistent(mike) ⊕ NoSurprises(mike)"
  },
  {
    "input": "Translate into first-order logic: All people who are very consistent and enjoy sticking to their regular routines do not like surprises.",
    "output": "∀x (Consistent(x) → NoSurprises(x))"
  },
  {
    "input": "Translate into first-order logic: If people wear flannel shirts every day, then they are very consistent and enjoy sticking to their regular routines.",
    "output": "∀x (Flannel(x) → Consistent(x))"
  },
  {
    "input": "Translate into first-order logic: If people do not like shopping for clothes and other materialistic goods, then they wear flannel shirts every day.",
    "output": "∀x (NoShopping(x) → Flannel(x))"
  },
  {
    "input": "Translate into first-order logic: All old people living in stable homes do not like surprises.",
    "output": "∀x (Old(x) → NoSurprises(x))"
  },
  {
    "input": "Translate into first-order logic: If people have very high energy and are impulsive, then they like surprises.",
    "output": "∀x (Impulsive(x) → ¬NoSurprises(x))"
  },
  {
    "input": "Translate into first-order logic: If Mike is not a person who wears flannel shirts every day and has very high energy and is impulsive, then Mike either is very consistent and enjoys sticking to his regular routines or does not like surprises.",
    "output": "¬(NoSurprises(mike) ∧ Impulsive(mike)) → Consistent(mike) ⊕ NoSurprises(mike)"
  },
  {
    "input": "Translate into first-order logic: All people who are very consistent and enjoy sticking to their regular routines do not like surprises.",
    "output": "∀x (Consistent(x) → NoSurprises(x))"
  },
  {
    "input": "Translate into first-order logic: If people wear flannel shirts every day, then they are very consistent and enjoy sticking to their regular routines.",
    "output": "∀x (Flannel(x) → Consistent(x))"
  },
  {
    "input": "Translate into first-order logic: If people do not like shopping for clothes and other materialistic goods, then they wear flannel shirts every day.",
    "output": "∀x (NoShopping(x) → Flannel(x))"
  },
  {
    "input": "Translate into first-order logic: All old people living in stable homes do not like surprises.",
    "output": "∀x (Old(x) → NoSurprises(x))"
  },
  {
    "input": "Translate into first-order logic: If people have very high energy and are impulsive, then they like surprises.",
    "output": "∀x (Impulsive(x) → ¬NoSurprises(x))"
  },
  {
    "input": "Translate into first-order logic: If Mike is not a person who wears flannel shirts every day and has very high energy and is impulsive, then Mike either is very consistent and enjoys sticking to his regular routines or does not like surprises.",
    "output": "¬(NoSurprises(mike) ∧ Impulsive(mike)) → Consistent(mike) ⊕ NoSurprises(mike)"
  },
  {
    "input": "Translate into first-order logic: Adam owns cars.",
    "output": "∃x (Owns(adam, x))"
  },
  {
    "input": "Translate into first-order logic: Adam has a favorite car.",
    "output": "∃x (Favorite(adam, x))"
  },
  {
    "input": "Translate into first-order logic: Among the cars he owns, Adam's favorite car is European.",
    "output": "∀x ((Owns(adam, x) ∧ Favorite(adam, x)) → European(x))"
  },
  {
    "input": "Translate into first-order logic: Adam broke his favorite car.",
    "output": "∀x ((Owns(adam, x) ∧ Favorite(adam, x)) → Broke(adam, x))"
  },
  {
    "input": "Translate into first-order logic: Adam owns cars.",
    "output": "∃x (Owns(adam, x))"
  },
  {
    "input": "Translate into first-order logic: Adam has a favorite car.",
    "output": "∃x (Favorite(adam, x))"
  },
  {
    "input": "Translate into first-order logic: Among the cars he owns, Adam's favorite car is European.",
    "output": "∀x ((Owns(adam, x) ∧ Favorite(adam, x)) → European(x))"
  },
  {
    "input": "Translate into first-order logic: Adam broke his favorite car.",
    "output": "∀x ((Owns(adam, x) ∧ Favorite(adam, x)) → Broke(adam, x))"
  },
  {
    "input": "Translate into first-order logic: No buildings in New Haven are higher than 400 meters.",
    "output": "∀x (NewHaven(x) → ¬High(x))"
  },
  {
    "input": "Translate into first-order logic: All buildings managed by Yale Housing are in New Haven.",
    "output": "∀x (YaleHousing(x) → NewHaven(x))"
  },
  {
    "input": "Translate into first-order logic: All buildings in Manhattan are higher than 400 meters.",
    "output": "∀x (Manhattan(x) → High(x))"
  },
  {
    "input": "Translate into first-order logic: All buildings owned by Bloomberg are in Manhattan.",
    "output": "∀x (Bloomberg(x) → Manhattan(x))"
  },
  {
    "input": "Translate into first-order logic: All buildings with the Bloomberg logo are buildings owned by Bloomberg.",
    "output": "∀x (BloombergLogo(x) → Bloomberg(x))"
  },
  {
    "input": "Translate into first-order logic: Tower A is neither in New Haven nor in Manhattan.",
    "output": "¬(NewHaven(towera) ⊕ Manhattan(towera))"
  },
  {
    "input": "Translate into first-order logic: Tower B is a building with the Bloomberg logo and in Manhattan.",
    "output": "BloombergLogo(towerb) ∧ Manhattan(towerb)"
  },
  {
    "input": "Translate into first-order logic: No buildings in New Haven are higher than 400 meters.",
    "output": "∀x (NewHaven(x) → ¬High(x))"
  },
  {
    "input": "Translate into first-order logic: All buildings managed by Yale Housing are in New Haven.",
    "output": "∀x (YaleHousing(x) → NewHaven(x))"
  },
  {
    "input": "Translate into first-order logic: All buildings in Manhattan are higher than 400 meters.",
    "output": "∀x (Manhattan(x) → High(x))"
  },
  {
    "input": "Translate into first-order logic: All buildings owned by Bloomberg are in Manhattan.",
    "output": "∀x (Bloomberg(x) → Manhattan(x))"
  },
  {
    "input": "Translate into first-order logic: All buildings with the Bloomberg logo are buildings owned by Bloomberg.",
    "output": "∀x (BloombergLogo(x) → Bloomberg(x))"
  },
  {
    "input": "Translate into first-order logic: Tower A is neither in New Haven nor in Manhattan.",
    "output": "¬(NewHaven(towera) ⊕ Manhattan(towera))"
  },
  {
    "input": "Translate into first-order logic: Tower B is a building with the Bloomberg logo and in Manhattan.",
    "output": "BloombergLogo(towerb) ∧ Manhattan(towerb)"
  },
  {
    "input": "Translate into first-order logic: No buildings in New Haven are higher than 400 meters.",
    "output": "∀x (NewHaven(x) → ¬High(x))"
  },
  {
    "input": "Translate into first-order logic: All buildings managed by Yale Housing are in New Haven.",
    "output": "∀x (YaleHousing(x) → NewHaven(x))"
  },
  {
    "input": "Translate into first-order logic: All buildings in Manhattan are higher than 400 meters.",
    "output": "∀x (Manhattan(x) → High(x))"
  },
  {
    "input": "Translate into first-order logic: All buildings owned by Bloomberg are in Manhattan.",
    "output": "∀x (Bloomberg(x) → Manhattan(x))"
  },
  {
    "input": "Translate into first-order logic: All buildings with the Bloomberg logo are buildings owned by Bloomberg.",
    "output": "∀x (BloombergLogo(x) → Bloomberg(x))"
  },
  {
    "input": "Translate into first-order logic: Tower A is neither in New Haven nor in Manhattan.",
    "output": "¬(NewHaven(towera) ⊕ Manhattan(towera))"
  },
  {
    "input": "Translate into first-order logic: Tower B is a building with the Bloomberg logo and in Manhattan.",
    "output": "BloombergLogo(towerb) ∧ Manhattan(towerb)"
  },
  {
    "input": "Translate into first-order logic: No buildings in New Haven are higher than 400 meters.",
    "output": "∀x (NewHaven(x) → ¬High(x))"
  },
  {
    "input": "Translate into first-order logic: All buildings managed by Yale Housing are in New Haven.",
    "output": "∀x (YaleHousing(x) → NewHaven(x))"
  },
  {
    "input": "Translate into first-order logic: All buildings in Manhattan are higher than 400 meters.",
    "output": "∀x (Manhattan(x) → High(x))"
  },
  {
    "input": "Translate into first-order logic: All buildings owned by Bloomberg are in Manhattan.",
    "output": "∀x (Bloomberg(x) → Manhattan(x))"
  },
  {
    "input": "Translate into first-order logic: All buildings with the Bloomberg logo are buildings owned by Bloomberg.",
    "output": "∀x (BloombergLogo(x) → Bloomberg(x))"
  },
  {
    "input": "Translate into first-order logic: Tower A is neither in New Haven nor in Manhattan.",
    "output": "¬(NewHaven(towera) ⊕ Manhattan(towera))"
  },
  {
    "input": "Translate into first-order logic: Tower B is a building with the Bloomberg logo and in Manhattan.",
    "output": "BloombergLogo(towerb) ∧ Manhattan(towerb)"
  },
  {
    "input": "Translate into first-order logic: No fish are birds.",
    "output": "∀x (Fish(x) → ¬Bird(x))"
  },
  {
    "input": "Translate into first-order logic: Everything that is an osprey is a bird.",
    "output": "∀x (Osprey(x) → Bird(x))"
  },
  {
    "input": "Translate into first-order logic: If something is a carp, then it is a fish.",
    "output": "∀x (Carp(x) → Fish(x))"
  },
  {
    "input": "Translate into first-order logic: All goldfish are carp.",
    "output": "∀x (Goldfish(x) → Carp(x))"
  },
  {
    "input": "Translate into first-order logic: If Bubbles is either an osprey or a goldfish, then Bubbles is not a fish.",
    "output": "Osprey(bubbles) ⊕ Carp(bubbles) → ¬Fish(bubbles)"
  },
  {
    "input": "Translate into first-order logic: No fish are birds.",
    "output": "∀x (Fish(x) → ¬Bird(x))"
  },
  {
    "input": "Translate into first-order logic: Everything that is an osprey is a bird.",
    "output": "∀x (Osprey(x) → Bird(x))"
  },
  {
    "input": "Translate into first-order logic: If something is a carp, then it is a fish.",
    "output": "∀x (Carp(x) → Fish(x))"
  },
  {
    "input": "Translate into first-order logic: All goldfish are carp.",
    "output": "∀x (Goldfish(x) → Carp(x))"
  },
  {
    "input": "Translate into first-order logic: If Bubbles is either an osprey or a goldfish, then Bubbles is not a fish.",
    "output": "Osprey(bubbles) ⊕ Carp(bubbles) → ¬Fish(bubbles)"
  },
  {
    "input": "Translate into first-order logic: No fish are birds.",
    "output": "∀x (Fish(x) → ¬Bird(x))"
  },
  {
    "input": "Translate into first-order logic: Everything that is an osprey is a bird.",
    "output": "∀x (Osprey(x) → Bird(x))"
  },
  {
    "input": "Translate into first-order logic: If something is a carp, then it is a fish.",
    "output": "∀x (Carp(x) → Fish(x))"
  },
  {
    "input": "Translate into first-order logic: All goldfish are carp.",
    "output": "∀x (Goldfish(x) → Carp(x))"
  },
  {
    "input": "Translate into first-order logic: If Bubbles is either an osprey or a goldfish, then Bubbles is not a fish.",
    "output": "Osprey(bubbles) ⊕ Carp(bubbles) → ¬Fish(bubbles)"
  },
  {
    "input": "Translate into first-order logic: Mr. and Mrs. Smith make a travel plan, they want to go to a city in California or Florida, and where neither of them has ever been.",
    "output": "∀x (WantToGo(x) → (California(x) ∨ Florida(x)) ∧ (NeverGo(x)))"
  },
  {
    "input": "Translate into first-order logic: Cities in California that they are interested in are San Francisco, Los Angeles, and San Diego.",
    "output": "∀x (((SanFrancisco(x) ∨ LosAngeles(x) ∨ SanDiego(x)) ∧ California(x)) → WantToGo(x))"
  },
  {
    "input": "Translate into first-order logic: Cities in Florida that they are interested in are Orlando and Miami.",
    "output": "∀x ((Orlando(x) ∨ Miami(x)) ∧ Florida(x)) → WantToGo(x))"
  },
  {
    "input": "Translate into first-order logic: Mr. Smith has been to two cities in California.",
    "output": "CaliforniaCityVisited(mr.smith, two)"
  },
  {
    "input": "Translate into first-order logic: Mrs. Smith has been to one city in Florida.",
    "output": "FloridaCityVisited(mrs.smith, one)"
  },
  {
    "input": "Translate into first-order logic: Mr. and Mrs. Smith make a travel plan, they want to go to a city in California or Florida, and where neither of them has ever been.",
    "output": "∀x (WantToGo(x) → (California(x) ∨ Florida(x)) ∧ (NeverGo(x)))"
  },
  {
    "input": "Translate into first-order logic: Cities in California that they are interested in are San Francisco, Los Angeles, and San Diego.",
    "output": "∀x (((SanFrancisco(x) ∨ LosAngeles(x) ∨ SanDiego(x)) ∧ California(x)) → WantToGo(x))"
  },
  {
    "input": "Translate into first-order logic: Cities in Florida that they are interested in are Orlando and Miami.",
    "output": "∀x ((Orlando(x) ∨ Miami(x)) ∧ Florida(x)) → WantToGo(x))"
  },
  {
    "input": "Translate into first-order logic: Mr. Smith has been to two cities in California.",
    "output": "CaliforniaCityVisited(mr.smith, two)"
  },
  {
    "input": "Translate into first-order logic: Mrs. Smith has been to one city in Florida.",
    "output": "FloridaCityVisited(mrs.smith, one)"
  },
  {
    "input": "Translate into first-order logic: Mr. and Mrs. Smith make a travel plan, they want to go to a city in California or Florida, and where neither of them has ever been.",
    "output": "∀x (WantToGo(x) → (California(x) ∨ Florida(x)) ∧ (NeverGo(x)))"
  },
  {
    "input": "Translate into first-order logic: Cities in California that they are interested in are San Francisco, Los Angeles, and San Diego.",
    "output": "∀x (((SanFrancisco(x) ∨ LosAngeles(x) ∨ SanDiego(x)) ∧ California(x)) → WantToGo(x))"
  },
  {
    "input": "Translate into first-order logic: Cities in Florida that they are interested in are Orlando and Miami.",
    "output": "∀x ((Orlando(x) ∨ Miami(x)) ∧ Florida(x)) → WantToGo(x))"
  },
  {
    "input": "Translate into first-order logic: Mr. Smith has been to two cities in California.",
    "output": "CaliforniaCityVisited(mr.smith, two)"
  },
  {
    "input": "Translate into first-order logic: Mrs. Smith has been to one city in Florida.",
    "output": "FloridaCityVisited(mrs.smith, one)"
  },
  {
    "input": "Translate into first-order logic: Everything is either big or small.",
    "output": "∀x (Big(x) ⊕ Small(x))"
  },
  {
    "input": "Translate into first-order logic: All big things are heavy.",
    "output": "∀x (Big(x) → Heavy(x))"
  },
  {
    "input": "Translate into first-order logic: All small things are light.",
    "output": "∀x (Small(x) → Light(x))"
  },
  {
    "input": "Translate into first-order logic: All heavy things are still.",
    "output": "∀x (Heavy(x) → Still(x))"
  },
  {
    "input": "Translate into first-order logic: All light things are unstable.",
    "output": "∀x (Light(x) → Unstable(x))"
  },
  {
    "input": "Translate into first-order logic: All unstable things are changing.",
    "output": "∀x (Unstable(x) → Changing(x))"
  },
  {
    "input": "Translate into first-order logic: All unstable things are kinetic.",
    "output": "∀x (Unstable(x) → Kinetic(x))"
  },
  {
    "input": "Translate into first-order logic: A bird is not both heavy and still.",
    "output": "¬(Heavy(bird) ∧ Still(bird))"
  },
  {
    "input": "Translate into first-order logic: Everything is either big or small.",
    "output": "∀x (Big(x) ⊕ Small(x))"
  },
  {
    "input": "Translate into first-order logic: All big things are heavy.",
    "output": "∀x (Big(x) → Heavy(x))"
  },
  {
    "input": "Translate into first-order logic: All small things are light.",
    "output": "∀x (Small(x) → Light(x))"
  },
  {
    "input": "Translate into first-order logic: All heavy things are still.",
    "output": "∀x (Heavy(x) → Still(x))"
  },
  {
    "input": "Translate into first-order logic: All light things are unstable.",
    "output": "∀x (Light(x) → Unstable(x))"
  },
  {
    "input": "Translate into first-order logic: All unstable things are changing.",
    "output": "∀x (Unstable(x) → Changing(x))"
  },
  {
    "input": "Translate into first-order logic: All unstable things are kinetic.",
    "output": "∀x (Unstable(x) → Kinetic(x))"
  },
  {
    "input": "Translate into first-order logic: A bird is not both heavy and still.",
    "output": "¬(Heavy(bird) ∧ Still(bird))"
  },
  {
    "input": "Translate into first-order logic: Everything is either big or small.",
    "output": "∀x (Big(x) ⊕ Small(x))"
  },
  {
    "input": "Translate into first-order logic: All big things are heavy.",
    "output": "∀x (Big(x) → Heavy(x))"
  },
  {
    "input": "Translate into first-order logic: All small things are light.",
    "output": "∀x (Small(x) → Light(x))"
  },
  {
    "input": "Translate into first-order logic: All heavy things are still.",
    "output": "∀x (Heavy(x) → Still(x))"
  },
  {
    "input": "Translate into first-order logic: All light things are unstable.",
    "output": "∀x (Light(x) → Unstable(x))"
  },
  {
    "input": "Translate into first-order logic: All unstable things are changing.",
    "output": "∀x (Unstable(x) → Changing(x))"
  },
  {
    "input": "Translate into first-order logic: All unstable things are kinetic.",
    "output": "∀x (Unstable(x) → Kinetic(x))"
  },
  {
    "input": "Translate into first-order logic: A bird is not both heavy and still.",
    "output": "¬(Heavy(bird) ∧ Still(bird))"
  },
  {
    "input": "Translate into first-order logic: Everything is either big or small.",
    "output": "∀x (Big(x) ⊕ Small(x))"
  },
  {
    "input": "Translate into first-order logic: All big things are heavy.",
    "output": "∀x (Big(x) → Heavy(x))"
  },
  {
    "input": "Translate into first-order logic: All small things are light.",
    "output": "∀x (Small(x) → Light(x))"
  },
  {
    "input": "Translate into first-order logic: All heavy things are still.",
    "output": "∀x (Heavy(x) → Still(x))"
  },
  {
    "input": "Translate into first-order logic: All light things are unstable.",
    "output": "∀x (Light(x) → Unstable(x))"
  },
  {
    "input": "Translate into first-order logic: All unstable things are changing.",
    "output": "∀x (Unstable(x) → Changing(x))"
  },
  {
    "input": "Translate into first-order logic: All unstable things are kinetic.",
    "output": "∀x (Unstable(x) → Kinetic(x))"
  },
  {
    "input": "Translate into first-order logic: A bird is not both heavy and still.",
    "output": "¬(Heavy(bird) ∧ Still(bird))"
  },
  {
    "input": "Translate into first-order logic: Everything is either big or small.",
    "output": "∀x (Big(x) ⊕ Small(x))"
  },
  {
    "input": "Translate into first-order logic: All big things are heavy.",
    "output": "∀x (Big(x) → Heavy(x))"
  },
  {
    "input": "Translate into first-order logic: All small things are light.",
    "output": "∀x (Small(x) → Light(x))"
  },
  {
    "input": "Translate into first-order logic: All heavy things are still.",
    "output": "∀x (Heavy(x) → Still(x))"
  },
  {
    "input": "Translate into first-order logic: All light things are unstable.",
    "output": "∀x (Light(x) → Unstable(x))"
  },
  {
    "input": "Translate into first-order logic: All unstable things are changing.",
    "output": "∀x (Unstable(x) → Changing(x))"
  },
  {
    "input": "Translate into first-order logic: All unstable things are kinetic.",
    "output": "∀x (Unstable(x) → Kinetic(x))"
  },
  {
    "input": "Translate into first-order logic: A bird is not both heavy and still.",
    "output": "¬(Heavy(bird) ∧ Still(bird))"
  },
  {
    "input": "Translate into first-order logic: Everything is either big or small.",
    "output": "∀x (Big(x) ⊕ Small(x))"
  },
  {
    "input": "Translate into first-order logic: All big things are heavy.",
    "output": "∀x (Big(x) → Heavy(x))"
  },
  {
    "input": "Translate into first-order logic: All small things are light.",
    "output": "∀x (Small(x) → Light(x))"
  },
  {
    "input": "Translate into first-order logic: All heavy things are still.",
    "output": "∀x (Heavy(x) → Still(x))"
  },
  {
    "input": "Translate into first-order logic: All light things are unstable.",
    "output": "∀x (Light(x) → Unstable(x))"
  },
  {
    "input": "Translate into first-order logic: All unstable things are changing.",
    "output": "∀x (Unstable(x) → Changing(x))"
  },
  {
    "input": "Translate into first-order logic: All unstable things are kinetic.",
    "output": "∀x (Unstable(x) → Kinetic(x))"
  },
  {
    "input": "Translate into first-order logic: A bird is not both heavy and still.",
    "output": "¬(Heavy(bird) ∧ Still(bird))"
  },
  {
    "input": "Translate into first-order logic: DI Ray is a police procedural television series.",
    "output": "TelevisionSeries(diRay)"
  },
  {
    "input": "Translate into first-order logic: DI Ray was created and written by Maya Sondhi.",
    "output": "Create(maya, diRay) ∧ Write(maya, diRay)"
  },
  {
    "input": "Translate into first-order logic: DI Ray was produced by Jed Mercurio.",
    "output": "Produce(jed, diRay)"
  },
  {
    "input": "Translate into first-order logic: Maya Sondhi and Jed Mercurio are both British.",
    "output": "British(maya) ∧ British(jed) "
  },
  {
    "input": "Translate into first-order logic: DI Ray is a police procedural television series.",
    "output": "TelevisionSeries(diRay)"
  },
  {
    "input": "Translate into first-order logic: DI Ray was created and written by Maya Sondhi.",
    "output": "Create(maya, diRay) ∧ Write(maya, diRay)"
  },
  {
    "input": "Translate into first-order logic: DI Ray was produced by Jed Mercurio.",
    "output": "Produce(jed, diRay)"
  },
  {
    "input": "Translate into first-order logic: Maya Sondhi and Jed Mercurio are both British.",
    "output": "British(maya) ∧ British(jed) "
  },
  {
    "input": "Translate into first-order logic: All men are human.",
    "output": "∀x (Man(x) → Human(x))"
  },
  {
    "input": "Translate into first-order logic: All gentlemen are men.",
    "output": "∀x (Gentleman(x) → Man(x))"
  },
  {
    "input": "Translate into first-order logic: All lawyers are gentlemen.",
    "output": "∀x (Lawyer(x) → Gentleman(x))"
  },
  {
    "input": "Translate into first-order logic: All women are human.",
    "output": "∀x (Woman(x) → Human(x))"
  },
  {
    "input": "Translate into first-order logic: No sheep are human.",
    "output": "∀x (Sheep(x) → ¬Human(x))"
  },
  {
    "input": "Translate into first-order logic: If Mike is not both a human and a sheep, then Mike is either a man or a human.",
    "output": "(¬Human(mike) ∨ ¬Sheep(mike)) → Man(mike) ⊕ Human(mike)"
  },
  {
    "input": "Translate into first-order logic: All men are human.",
    "output": "∀x (Man(x) → Human(x))"
  },
  {
    "input": "Translate into first-order logic: All gentlemen are men.",
    "output": "∀x (Gentleman(x) → Man(x))"
  },
  {
    "input": "Translate into first-order logic: All lawyers are gentlemen.",
    "output": "∀x (Lawyer(x) → Gentleman(x))"
  },
  {
    "input": "Translate into first-order logic: All women are human.",
    "output": "∀x (Woman(x) → Human(x))"
  },
  {
    "input": "Translate into first-order logic: No sheep are human.",
    "output": "∀x (Sheep(x) → ¬Human(x))"
  },
  {
    "input": "Translate into first-order logic: If Mike is not both a human and a sheep, then Mike is either a man or a human.",
    "output": "(¬Human(mike) ∨ ¬Sheep(mike)) → Man(mike) ⊕ Human(mike)"
  },
  {
    "input": "Translate into first-order logic: All men are human.",
    "output": "∀x (Man(x) → Human(x))"
  },
  {
    "input": "Translate into first-order logic: All gentlemen are men.",
    "output": "∀x (Gentleman(x) → Man(x))"
  },
  {
    "input": "Translate into first-order logic: All lawyers are gentlemen.",
    "output": "∀x (Lawyer(x) → Gentleman(x))"
  },
  {
    "input": "Translate into first-order logic: All women are human.",
    "output": "∀x (Woman(x) → Human(x))"
  },
  {
    "input": "Translate into first-order logic: No sheep are human.",
    "output": "∀x (Sheep(x) → ¬Human(x))"
  },
  {
    "input": "Translate into first-order logic: If Mike is not both a human and a sheep, then Mike is either a man or a human.",
    "output": "(¬Human(mike) ∨ ¬Sheep(mike)) → Man(mike) ⊕ Human(mike)"
  },
  {
    "input": "Translate into first-order logic: Some defenders are centerback.",
    "output": "∃x (Defender(x) ∧ Centerback(x))"
  },
  {
    "input": "Translate into first-order logic: All defenders are soccer players.",
    "output": "∀x (Defender(x) → SoccerPlayer(x))"
  },
  {
    "input": "Translate into first-order logic: No soccer players are professional basketball players.",
    "output": "¬(∃x (SoccerPlayer(x) ∧ ProfessionalBasketballPlayer(x)))"
  },
  {
    "input": "Translate into first-order logic: All NBA players are professional basketball players.",
    "output": "∀x (NBAPlayer(x) → ProfessionalBasketballPlayer(x))"
  },
  {
    "input": "Translate into first-order logic: Stephen Curry is an NBA player.",
    "output": "NBAPlayer(stephencurry)"
  },
  {
    "input": "Translate into first-order logic: Some defenders are centerback.",
    "output": "∃x (Defender(x) ∧ Centerback(x))"
  },
  {
    "input": "Translate into first-order logic: All defenders are soccer players.",
    "output": "∀x (Defender(x) → SoccerPlayer(x))"
  },
  {
    "input": "Translate into first-order logic: No soccer players are professional basketball players.",
    "output": "¬(∃x (SoccerPlayer(x) ∧ ProfessionalBasketballPlayer(x)))"
  },
  {
    "input": "Translate into first-order logic: All NBA players are professional basketball players.",
    "output": "∀x (NBAPlayer(x) → ProfessionalBasketballPlayer(x))"
  },
  {
    "input": "Translate into first-order logic: Stephen Curry is an NBA player.",
    "output": "NBAPlayer(stephencurry)"
  },
  {
    "input": "Translate into first-order logic: Some defenders are centerback.",
    "output": "∃x (Defender(x) ∧ Centerback(x))"
  },
  {
    "input": "Translate into first-order logic: All defenders are soccer players.",
    "output": "∀x (Defender(x) → SoccerPlayer(x))"
  },
  {
    "input": "Translate into first-order logic: No soccer players are professional basketball players.",
    "output": "¬(∃x (SoccerPlayer(x) ∧ ProfessionalBasketballPlayer(x)))"
  },
  {
    "input": "Translate into first-order logic: All NBA players are professional basketball players.",
    "output": "∀x (NBAPlayer(x) → ProfessionalBasketballPlayer(x))"
  },
  {
    "input": "Translate into first-order logic: Stephen Curry is an NBA player.",
    "output": "NBAPlayer(stephencurry)"
  },
  {
    "input": "Translate into first-order logic: If a person doesn't have enough money to buy a product, then that person can't buy it.",
    "output": "∀x ∀y (Person(x) ∧ Product(y) ∧ ¬HaveEnoughMoneyFor(x, y) → ¬Buy(x, y))"
  },
  {
    "input": "Translate into first-order logic: Monitors are products.",
    "output": "∀x (Monitor(x) → Product(x))"
  },
  {
    "input": "Translate into first-order logic: 4k monitors are more expensive than 1080 monitors and 2k monitors.",
    "output": "∀x ∀y ∀z (Monitor(x) ∧ Monitor(y) ∧ Monitor(z) ∧ FourK(x) ∧ OneOEightO(y) ∧ TwoK(z) → MoreExpensive(x, y) ∧ MoreExpensive(x, z))"
  },
  {
    "input": "Translate into first-order logic: John is a person.",
    "output": "Person(john)"
  },
  {
    "input": "Translate into first-order logic: John doesn't have enough money to buy a 2k monitor.",
    "output": "∀x (Monitor(x) ∧ TwoK(x) → ¬HaveEnoughMoneyFor(john, x))"
  },
  {
    "input": "Translate into first-order logic: If a person doesn't have enough money to buy a product, then that person can't buy it.",
    "output": "∀x ∀y (Person(x) ∧ Product(y) ∧ ¬HaveEnoughMoneyFor(x, y) → ¬Buy(x, y))"
  },
  {
    "input": "Translate into first-order logic: Monitors are products.",
    "output": "∀x (Monitor(x) → Product(x))"
  },
  {
    "input": "Translate into first-order logic: 4k monitors are more expensive than 1080 monitors and 2k monitors.",
    "output": "∀x ∀y ∀z (Monitor(x) ∧ Monitor(y) ∧ Monitor(z) ∧ FourK(x) ∧ OneOEightO(y) ∧ TwoK(z) → MoreExpensive(x, y) ∧ MoreExpensive(x, z))"
  },
  {
    "input": "Translate into first-order logic: John is a person.",
    "output": "Person(john)"
  },
  {
    "input": "Translate into first-order logic: John doesn't have enough money to buy a 2k monitor.",
    "output": "∀x (Monitor(x) ∧ TwoK(x) → ¬HaveEnoughMoneyFor(john, x))"
  },
  {
    "input": "Translate into first-order logic: All artificial satellites are important scientific achievements.",
    "output": "∀x (ArtificialSatellite(x) → ImportantScientificAchievement(x))"
  },
  {
    "input": "Translate into first-order logic: Some artificial satellites are not U.S. inventions.",
    "output": "∃x (ArtificialSatellite(x) ∧ ¬USInvention(x))"
  },
  {
    "input": "Translate into first-order logic: Some cats are not pets.",
    "output": "∃x (Cat(x) ∧ ¬Pet(x))"
  },
  {
    "input": "Translate into first-order logic: All cats are mammals.",
    "output": "∀x (Cat(x) → Mammal(x))"
  },
  {
    "input": "Translate into first-order logic: If people visit a coffee shop at least three times a week, then they are addicted to coffee or other caffeinated drinks.",
    "output": "∀x (CoffeeShop(x) → CaffeineAddict(x))"
  },
  {
    "input": "Translate into first-order logic: People either visit a coffee shop at least three times a week or order takeout at least once a day.",
    "output": "∀x (CoffeeShop(x) ∨ Takeout(x))"
  },
  {
    "input": "Translate into first-order logic: If people make a lot of their own food at home using recipes and online guides, then they order takeout at least once a day.",
    "output": "∀x (MakeFood(x) → Takeout(x))"
  },
  {
    "input": "Translate into first-order logic: If people own at least one coffeemaker and one blender in their home, then they do not order takeout at least once a day.",
    "output": "∀x (KitchenAppliance(x) → ¬Takeout(x))"
  },
  {
    "input": "Translate into first-order logic: All people who lead very busy lives that include 12-hour work hours make a lot of their own food at home using recipes and online guides.",
    "output": "∀x (Busy(x) → MakeFood(x))"
  },
  {
    "input": "Translate into first-order logic: Sam is either both addicted to coffee or other caffeinated drinks or leads very busy lives that include 12-hour work hours, or she is neither addicted to coffee and other caffeinated drinks nor leads very busy lives that include 12-hour work hours",
    "output": "(CaffeineAddict(sam) ∧ Busy(sam)) ⊕ (¬CaffeineAddict(sam) ∧ ¬Busy(sam))"
  },
  {
    "input": "Translate into first-order logic: If people visit a coffee shop at least three times a week, then they are addicted to coffee or other caffeinated drinks.",
    "output": "∀x (CoffeeShop(x) → CaffeineAddict(x))"
  },
  {
    "input": "Translate into first-order logic: People either visit a coffee shop at least three times a week or order takeout at least once a day.",
    "output": "∀x (CoffeeShop(x) ∨ Takeout(x))"
  },
  {
    "input": "Translate into first-order logic: If people make a lot of their own food at home using recipes and online guides, then they order takeout at least once a day.",
    "output": "∀x (MakeFood(x) → Takeout(x))"
  },
  {
    "input": "Translate into first-order logic: If people own at least one coffeemaker and one blender in their home, then they do not order takeout at least once a day.",
    "output": "∀x (KitchenAppliance(x) → ¬Takeout(x))"
  },
  {
    "input": "Translate into first-order logic: All people who lead very busy lives that include 12-hour work hours make a lot of their own food at home using recipes and online guides.",
    "output": "∀x (Busy(x) → MakeFood(x))"
  },
  {
    "input": "Translate into first-order logic: Sam is either both addicted to coffee or other caffeinated drinks or leads very busy lives that include 12-hour work hours, or she is neither addicted to coffee and other caffeinated drinks nor leads very busy lives that include 12-hour work hours",
    "output": "(CaffeineAddict(sam) ∧ Busy(sam)) ⊕ (¬CaffeineAddict(sam) ∧ ¬Busy(sam))"
  },
  {
    "input": "Translate into first-order logic: If people visit a coffee shop at least three times a week, then they are addicted to coffee or other caffeinated drinks.",
    "output": "∀x (CoffeeShop(x) → CaffeineAddict(x))"
  },
  {
    "input": "Translate into first-order logic: People either visit a coffee shop at least three times a week or order takeout at least once a day.",
    "output": "∀x (CoffeeShop(x) ∨ Takeout(x))"
  },
  {
    "input": "Translate into first-order logic: If people make a lot of their own food at home using recipes and online guides, then they order takeout at least once a day.",
    "output": "∀x (MakeFood(x) → Takeout(x))"
  },
  {
    "input": "Translate into first-order logic: If people own at least one coffeemaker and one blender in their home, then they do not order takeout at least once a day.",
    "output": "∀x (KitchenAppliance(x) → ¬Takeout(x))"
  },
  {
    "input": "Translate into first-order logic: All people who lead very busy lives that include 12-hour work hours make a lot of their own food at home using recipes and online guides.",
    "output": "∀x (Busy(x) → MakeFood(x))"
  },
  {
    "input": "Translate into first-order logic: Sam is either both addicted to coffee or other caffeinated drinks or leads very busy lives that include 12-hour work hours, or she is neither addicted to coffee and other caffeinated drinks nor leads very busy lives that include 12-hour work hours",
    "output": "(CaffeineAddict(sam) ∧ Busy(sam)) ⊕ (¬CaffeineAddict(sam) ∧ ¬Busy(sam))"
  },
  {
    "input": "Translate into first-order logic: No professional basketball players are soccer players.",
    "output": "¬(∃x (SoccerPlayer(x) ∧ ProfessionalBasketballPlayer(x)))"
  },
  {
    "input": "Translate into first-order logic: All NBA players are professional basketball players.",
    "output": "∀x (NBAPlayer(x) → ProfessionalBasketballPlayer(x))"
  },
  {
    "input": "Translate into first-order logic: All defenders are soccer players.",
    "output": "∀x (Defender(x) → SoccerPlayer(x))"
  },
  {
    "input": "Translate into first-order logic: All centerbacks are defenders.",
    "output": "∀x (Centerback(x) → Defender(x))"
  },
  {
    "input": "Translate into first-order logic: Roger Federer is not an NBA player or a defender.",
    "output": "¬(NBAPlayer(rogerfederer) ⊕ Defender(rogerfederer))"
  },
  {
    "input": "Translate into first-order logic: No professional basketball players are soccer players.",
    "output": "¬(∃x (SoccerPlayer(x) ∧ ProfessionalBasketballPlayer(x)))"
  },
  {
    "input": "Translate into first-order logic: All NBA players are professional basketball players.",
    "output": "∀x (NBAPlayer(x) → ProfessionalBasketballPlayer(x))"
  },
  {
    "input": "Translate into first-order logic: All defenders are soccer players.",
    "output": "∀x (Defender(x) → SoccerPlayer(x))"
  },
  {
    "input": "Translate into first-order logic: All centerbacks are defenders.",
    "output": "∀x (Centerback(x) → Defender(x))"
  },
  {
    "input": "Translate into first-order logic: Roger Federer is not an NBA player or a defender.",
    "output": "¬(NBAPlayer(rogerfederer) ⊕ Defender(rogerfederer))"
  },
  {
    "input": "Translate into first-order logic: No professional basketball players are soccer players.",
    "output": "¬(∃x (SoccerPlayer(x) ∧ ProfessionalBasketballPlayer(x)))"
  },
  {
    "input": "Translate into first-order logic: All NBA players are professional basketball players.",
    "output": "∀x (NBAPlayer(x) → ProfessionalBasketballPlayer(x))"
  },
  {
    "input": "Translate into first-order logic: All defenders are soccer players.",
    "output": "∀x (Defender(x) → SoccerPlayer(x))"
  },
  {
    "input": "Translate into first-order logic: All centerbacks are defenders.",
    "output": "∀x (Centerback(x) → Defender(x))"
  },
  {
    "input": "Translate into first-order logic: Roger Federer is not an NBA player or a defender.",
    "output": "¬(NBAPlayer(rogerfederer) ⊕ Defender(rogerfederer))"
  },
  {
    "input": "Translate into first-order logic: Some teachers working at a pool are not nice.",
    "output": "∃x (TeacherWorkingAtPool(x) ∧ ¬Nice(x))"
  },
  {
    "input": "Translate into first-order logic: All teachers working at pools are pool managers.",
    "output": "∀x (TeacherWorkingAtPool(x) → PoolManager(x))"
  },
  {
    "input": "Translate into first-order logic: All pool managers are lifeguards.",
    "output": "∀x (PoolManager(x) → Lifeguard(x))"
  },
  {
    "input": "Translate into first-order logic: If someone is a lifeguard, then they work at a pool.",
    "output": "∀x (Lifeguard(x) → WorkAtPool(x))"
  },
  {
    "input": "Translate into first-order logic: Mary does not work at a pool.",
    "output": "¬WorkAtPool(mary))"
  },
  {
    "input": "Translate into first-order logic: Some teachers working at a pool are not nice.",
    "output": "∃x (TeacherWorkingAtPool(x) ∧ ¬Nice(x))"
  },
  {
    "input": "Translate into first-order logic: All teachers working at pools are pool managers.",
    "output": "∀x (TeacherWorkingAtPool(x) → PoolManager(x))"
  },
  {
    "input": "Translate into first-order logic: All pool managers are lifeguards.",
    "output": "∀x (PoolManager(x) → Lifeguard(x))"
  },
  {
    "input": "Translate into first-order logic: If someone is a lifeguard, then they work at a pool.",
    "output": "∀x (Lifeguard(x) → WorkAtPool(x))"
  },
  {
    "input": "Translate into first-order logic: Mary does not work at a pool.",
    "output": "¬WorkAtPool(mary))"
  },
  {
    "input": "Translate into first-order logic: Some teachers working at a pool are not nice.",
    "output": "∃x (TeacherWorkingAtPool(x) ∧ ¬Nice(x))"
  },
  {
    "input": "Translate into first-order logic: All teachers working at pools are pool managers.",
    "output": "∀x (TeacherWorkingAtPool(x) → PoolManager(x))"
  },
  {
    "input": "Translate into first-order logic: All pool managers are lifeguards.",
    "output": "∀x (PoolManager(x) → Lifeguard(x))"
  },
  {
    "input": "Translate into first-order logic: If someone is a lifeguard, then they work at a pool.",
    "output": "∀x (Lifeguard(x) → WorkAtPool(x))"
  },
  {
    "input": "Translate into first-order logic: Mary does not work at a pool.",
    "output": "¬WorkAtPool(mary))"
  },
  {
    "input": "Translate into first-order logic: Not all art pieces require talent.",
    "output": "∃x (ArtPiece(x) ∧ ¬RequiresTalent(x))"
  },
  {
    "input": "Translate into first-order logic: Everything that requires talent requires practice.",
    "output": "∀x (RequiresTalent(x) → RequiresPractice(x))"
  },
  {
    "input": "Translate into first-order logic: Bernarda Bryson Shahn was a painter and lithographer.",
    "output": "Painter(bernardaBrysonShahn) ∧ Lithographer(bernardaBrysonShahn) "
  },
  {
    "input": "Translate into first-order logic: Bernarda Bryson Shahn was born in Athens, Ohio.",
    "output": "BornIn(bernardaBrysonShahn, athensOhio)"
  },
  {
    "input": "Translate into first-order logic: Bernarda Bryson Shahn was married to Ben Shahn.",
    "output": "MarriedTo(bernardaBrysonShahn, benShahn)"
  },
  {
    "input": "Translate into first-order logic: People born in Athens, Ohio are Americans.",
    "output": "∀x (BornIn(x, athensOhio) → American(x))"
  },
  {
    "input": "Translate into first-order logic: Bernarda Bryson Shahn was a painter and lithographer.",
    "output": "Painter(bernardaBrysonShahn) ∧ Lithographer(bernardaBrysonShahn) "
  },
  {
    "input": "Translate into first-order logic: Bernarda Bryson Shahn was born in Athens, Ohio.",
    "output": "BornIn(bernardaBrysonShahn, athensOhio)"
  },
  {
    "input": "Translate into first-order logic: Bernarda Bryson Shahn was married to Ben Shahn.",
    "output": "MarriedTo(bernardaBrysonShahn, benShahn)"
  },
  {
    "input": "Translate into first-order logic: People born in Athens, Ohio are Americans.",
    "output": "∀x (BornIn(x, athensOhio) → American(x))"
  },
  {
    "input": "Translate into first-order logic: Bernarda Bryson Shahn was a painter and lithographer.",
    "output": "Painter(bernardaBrysonShahn) ∧ Lithographer(bernardaBrysonShahn) "
  },
  {
    "input": "Translate into first-order logic: Bernarda Bryson Shahn was born in Athens, Ohio.",
    "output": "BornIn(bernardaBrysonShahn, athensOhio)"
  },
  {
    "input": "Translate into first-order logic: Bernarda Bryson Shahn was married to Ben Shahn.",
    "output": "MarriedTo(bernardaBrysonShahn, benShahn)"
  },
  {
    "input": "Translate into first-order logic: People born in Athens, Ohio are Americans.",
    "output": "∀x (BornIn(x, athensOhio) → American(x))"
  },
  {
    "input": "Translate into first-order logic: If people upgrade to the newest iPhone model every year, then they are not saving money for a down payment on a new house.",
    "output": "∀x (Iphone(x) → ¬House(x))"
  },
  {
    "input": "Translate into first-order logic: If people enjoy reading about tech specs and keeping up to date on the latest technology, then they upgrade to the newest iPhone model every year.",
    "output": "∀x (Tech(x) → Iphone(x))"
  },
  {
    "input": "Translate into first-order logic: People either are saving money for a down payment on a new house or they live in apartments in big metropolitan cities.",
    "output": "∀x (House(x) ∨ Apartment(x))"
  },
  {
    "input": "Translate into first-order logic: If people live with at least one roommate then they do not own at least one pet.",
    "output": "∀x (Roommate(x) → ¬Pet(x))"
  },
  {
    "input": "Translate into first-order logic: All people who own at least one pet live with at least one roommate.",
    "output": "∀x (Apartment(x) → Roommate(x))"
  },
  {
    "input": "Translate into first-order logic: If Emma does not both own at least one pet and live in apartments in big metropolitan cities, then Emma either owns at least one pet and lives in an apartment in big metropolitan cities, or she neither owns a pet nor lives in an apartment in big metropolitan cities.",
    "output": "¬(Pet(emma) ∧ Apartment(emma)) → ((Pet(emma) ∧ Apartment(emma)) ∨ (¬Pet(emma) ∧ ¬Apartment(emma)))"
  },
  {
    "input": "Translate into first-order logic: If people upgrade to the newest iPhone model every year, then they are not saving money for a down payment on a new house.",
    "output": "∀x (Iphone(x) → ¬House(x))"
  },
  {
    "input": "Translate into first-order logic: If people enjoy reading about tech specs and keeping up to date on the latest technology, then they upgrade to the newest iPhone model every year.",
    "output": "∀x (Tech(x) → Iphone(x))"
  },
  {
    "input": "Translate into first-order logic: People either are saving money for a down payment on a new house or they live in apartments in big metropolitan cities.",
    "output": "∀x (House(x) ∨ Apartment(x))"
  },
  {
    "input": "Translate into first-order logic: If people live with at least one roommate then they do not own at least one pet.",
    "output": "∀x (Roommate(x) → ¬Pet(x))"
  },
  {
    "input": "Translate into first-order logic: All people who own at least one pet live with at least one roommate.",
    "output": "∀x (Apartment(x) → Roommate(x))"
  },
  {
    "input": "Translate into first-order logic: If Emma does not both own at least one pet and live in apartments in big metropolitan cities, then Emma either owns at least one pet and lives in an apartment in big metropolitan cities, or she neither owns a pet nor lives in an apartment in big metropolitan cities.",
    "output": "¬(Pet(emma) ∧ Apartment(emma)) → ((Pet(emma) ∧ Apartment(emma)) ∨ (¬Pet(emma) ∧ ¬Apartment(emma)))"
  },
  {
    "input": "Translate into first-order logic: If you are on the payroll, then you are being paid by the school.",
    "output": "∀x (OnPayroll(x) → PaidBySchool(x))"
  },
  {
    "input": "Translate into first-order logic: If someone has a job at a school, then they are on the payroll.",
    "output": "∀x (JobAtSchool(x) → OnPayroll(x))"
  },
  {
    "input": "Translate into first-order logic: All faculty members have a job at a school.",
    "output": "∀x (FacultyMember(x) → JobAtSchool(x))"
  },
  {
    "input": "Translate into first-order logic: One can either be a faculty member or a teacher.",
    "output": "∀x (FacultyMember(x) ∨ Teacher(x))"
  },
  {
    "input": "Translate into first-order logic: Every teacher has students.",
    "output": "∀x (Teacher(x) → HasStudents(x))"
  },
  {
    "input": "Translate into first-order logic: If Nancy is a teacher, then they are on the payroll.",
    "output": "Teacher(nancy) → OnPayroll(nancy)"
  },
  {
    "input": "Translate into first-order logic: If Nancy is not a teacher, then they are not paid by the school.",
    "output": "¬Teacher(nancy) → ¬OnPayroll(nancy)"
  },
  {
    "input": "Translate into first-order logic: If you are on the payroll, then you are being paid by the school.",
    "output": "∀x (OnPayroll(x) → PaidBySchool(x))"
  },
  {
    "input": "Translate into first-order logic: If someone has a job at a school, then they are on the payroll.",
    "output": "∀x (JobAtSchool(x) → OnPayroll(x))"
  },
  {
    "input": "Translate into first-order logic: All faculty members have a job at a school.",
    "output": "∀x (FacultyMember(x) → JobAtSchool(x))"
  },
  {
    "input": "Translate into first-order logic: One can either be a faculty member or a teacher.",
    "output": "∀x (FacultyMember(x) ∨ Teacher(x))"
  },
  {
    "input": "Translate into first-order logic: Every teacher has students.",
    "output": "∀x (Teacher(x) → HasStudents(x))"
  },
  {
    "input": "Translate into first-order logic: If Nancy is a teacher, then they are on the payroll.",
    "output": "Teacher(nancy) → OnPayroll(nancy)"
  },
  {
    "input": "Translate into first-order logic: If Nancy is not a teacher, then they are not paid by the school.",
    "output": "¬Teacher(nancy) → ¬OnPayroll(nancy)"
  },
  {
    "input": "Translate into first-order logic: If you are on the payroll, then you are being paid by the school.",
    "output": "∀x (OnPayroll(x) → PaidBySchool(x))"
  },
  {
    "input": "Translate into first-order logic: If someone has a job at a school, then they are on the payroll.",
    "output": "∀x (JobAtSchool(x) → OnPayroll(x))"
  },
  {
    "input": "Translate into first-order logic: All faculty members have a job at a school.",
    "output": "∀x (FacultyMember(x) → JobAtSchool(x))"
  },
  {
    "input": "Translate into first-order logic: One can either be a faculty member or a teacher.",
    "output": "∀x (FacultyMember(x) ∨ Teacher(x))"
  },
  {
    "input": "Translate into first-order logic: Every teacher has students.",
    "output": "∀x (Teacher(x) → HasStudents(x))"
  },
  {
    "input": "Translate into first-order logic: If Nancy is a teacher, then they are on the payroll.",
    "output": "Teacher(nancy) → OnPayroll(nancy)"
  },
  {
    "input": "Translate into first-order logic: If Nancy is not a teacher, then they are not paid by the school.",
    "output": "¬Teacher(nancy) → ¬OnPayroll(nancy)"
  },
  {
    "input": "Translate into first-order logic: Kangaroo is an animal.",
    "output": "∀x (Kangaroo(x) → Animal(x))"
  },
  {
    "input": "Translate into first-order logic: No Kangaroos live in Germany.",
    "output": "∀x (Kangaroo(x) → ¬LiveIn(x, germany))"
  },
  {
    "input": "Translate into first-order logic: If Jane saves enough money for the summer, she will fly to Germany.",
    "output": "EnoughMoney(jane) → FlyTo(jane, germany)"
  },
  {
    "input": "Translate into first-order logic: If Jane flies to Germany, she will go to the Berlin Zoo.",
    "output": "FlyTo(jane, germany) → GoTo(jane, berlinzoo) "
  },
  {
    "input": "Translate into first-order logic: If someone goes to the Berlin Zoo, they will see some of the animals that live in Germany.",
    "output": "∀x ∃y (GoTo(x, berlinzoo) ∧ Animal(y) → MaySee(y, x, berlinzoo))"
  },
  {
    "input": "Translate into first-order logic: If a class has prerequisites the student must take the prerequisites to take the class.",
    "output": "∀x ∀y ((Prereq(x, y) ∧ Taken(x)) ↔ CanTake(y))"
  },
  {
    "input": "Translate into first-order logic: If a class has no prerequisites, then the student can take the class",
    "output": "∀x ∀y (¬Prereq(x, y) → CanTake(y))"
  },
  {
    "input": "Translate into first-order logic: CPSC 201 and CPSC 223 are prerequisites for CPSC 323.",
    "output": "Prereq(cpsc201, cpsc323) ∧ Prereq(cpsc223, cpsc323)"
  },
  {
    "input": "Translate into first-order logic: Intro Microeconomics is the only prerequisite for Intermediate Microeconomics.",
    "output": "(Prereq(intromicro, intermediatemicro) ∧ Taken(intromicro)) → CanTake(intermediatemicro)"
  },
  {
    "input": "Translate into first-order logic: Intro Geology has no prerequisites.",
    "output": "∀x (¬Prereq(x, introgeology))"
  },
  {
    "input": "Translate into first-order logic: If a class has prerequisites the student must take the prerequisites to take the class.",
    "output": "∀x ∀y ((Prereq(x, y) ∧ Taken(x)) ↔ CanTake(y))"
  },
  {
    "input": "Translate into first-order logic: If a class has no prerequisites, then the student can take the class",
    "output": "∀x ∀y (¬Prereq(x, y) → CanTake(y))"
  },
  {
    "input": "Translate into first-order logic: CPSC 201 and CPSC 223 are prerequisites for CPSC 323.",
    "output": "Prereq(cpsc201, cpsc323) ∧ Prereq(cpsc223, cpsc323)"
  },
  {
    "input": "Translate into first-order logic: Intro Microeconomics is the only prerequisite for Intermediate Microeconomics.",
    "output": "(Prereq(intromicro, intermediatemicro) ∧ Taken(intromicro)) → CanTake(intermediatemicro)"
  },
  {
    "input": "Translate into first-order logic: Intro Geology has no prerequisites.",
    "output": "∀x (¬Prereq(x, introgeology))"
  },
  {
    "input": "Translate into first-order logic: If a class has prerequisites the student must take the prerequisites to take the class.",
    "output": "∀x ∀y ((Prereq(x, y) ∧ Taken(x)) ↔ CanTake(y))"
  },
  {
    "input": "Translate into first-order logic: If a class has no prerequisites, then the student can take the class",
    "output": "∀x ∀y (¬Prereq(x, y) → CanTake(y))"
  },
  {
    "input": "Translate into first-order logic: CPSC 201 and CPSC 223 are prerequisites for CPSC 323.",
    "output": "Prereq(cpsc201, cpsc323) ∧ Prereq(cpsc223, cpsc323)"
  },
  {
    "input": "Translate into first-order logic: Intro Microeconomics is the only prerequisite for Intermediate Microeconomics.",
    "output": "(Prereq(intromicro, intermediatemicro) ∧ Taken(intromicro)) → CanTake(intermediatemicro)"
  },
  {
    "input": "Translate into first-order logic: Intro Geology has no prerequisites.",
    "output": "∀x (¬Prereq(x, introgeology))"
  },
  {
    "input": "Translate into first-order logic: If a class has prerequisites the student must take the prerequisites to take the class.",
    "output": "∀x ∀y ((Prereq(x, y) ∧ Taken(x)) ↔ CanTake(y))"
  },
  {
    "input": "Translate into first-order logic: If a class has no prerequisites, then the student can take the class",
    "output": "∀x ∀y (¬Prereq(x, y) → CanTake(y))"
  },
  {
    "input": "Translate into first-order logic: CPSC 201 and CPSC 223 are prerequisites for CPSC 323.",
    "output": "Prereq(cpsc201, cpsc323) ∧ Prereq(cpsc223, cpsc323)"
  },
  {
    "input": "Translate into first-order logic: Intro Microeconomics is the only prerequisite for Intermediate Microeconomics.",
    "output": "(Prereq(intromicro, intermediatemicro) ∧ Taken(intromicro)) → CanTake(intermediatemicro)"
  },
  {
    "input": "Translate into first-order logic: Intro Geology has no prerequisites.",
    "output": "∀x (¬Prereq(x, introgeology))"
  },
  {
    "input": "Translate into first-order logic: A heptalogy, is a compound literary or narrative work that is made up of seven distinct works.",
    "output": "∀x (SevenDistinctWorks(x) → Heptalogy(x))"
  },
  {
    "input": "Translate into first-order logic: The Harry Potter series consists of 7 distinct works.",
    "output": "SevenDistinctWorks(harryPotter)"
  },
  {
    "input": "Translate into first-order logic: The Chronicles of Narnia consists of 7 distinct works.",
    "output": "SevenDistinctWorks(chroniclesofNarnia)"
  },
  {
    "input": "Translate into first-order logic: A heptalogy, is a compound literary or narrative work that is made up of seven distinct works.",
    "output": "∀x (SevenDistinctWorks(x) → Heptalogy(x))"
  },
  {
    "input": "Translate into first-order logic: The Harry Potter series consists of 7 distinct works.",
    "output": "SevenDistinctWorks(harryPotter)"
  },
  {
    "input": "Translate into first-order logic: The Chronicles of Narnia consists of 7 distinct works.",
    "output": "SevenDistinctWorks(chroniclesofNarnia)"
  },
  {
    "input": "Translate into first-order logic: A heptalogy, is a compound literary or narrative work that is made up of seven distinct works.",
    "output": "∀x (SevenDistinctWorks(x) → Heptalogy(x))"
  },
  {
    "input": "Translate into first-order logic: The Harry Potter series consists of 7 distinct works.",
    "output": "SevenDistinctWorks(harryPotter)"
  },
  {
    "input": "Translate into first-order logic: The Chronicles of Narnia consists of 7 distinct works.",
    "output": "SevenDistinctWorks(chroniclesofNarnia)"
  },
  {
    "input": "Translate into first-order logic: All people who attend Renaissance fairs regularly enjoy dressing up in old-fashioned and historical period clothing.",
    "output": "∀x (RenaissanceFair(x) → DressingUp(x))"
  },
  {
    "input": "Translate into first-order logic: If people are fascinated by the history of the Renaissance and other past eras, then they attend Renaissance fairs regularly.",
    "output": "∀x (HistoryRenaissance(x) → RenaissanceFair(x))"
  },
  {
    "input": "Translate into first-order logic: People are either fascinated by the history of the Renaissance and other past eras, or are not nostalgic academics who enjoy learning.",
    "output": "∀x (HistoryRenaissance(x) ∨ NotAcademics(x))"
  },
  {
    "input": "Translate into first-order logic: If people are focused on the future and industry professions, then they are not nostalgic academics who enjoy learning.",
    "output": "∀x (Industry(x) → NotAcademics(x))"
  },
  {
    "input": "Translate into first-order logic: If people are historical professors who are passionate about their job and subject, then they are nostalgic academics who enjoy learning.",
    "output": "∀x (HistoryProf(x) → ¬NotAcademics(x))"
  },
  {
    "input": "Translate into first-order logic: If Clyde is not focused on the future and industry professions, then he is neither focused on the future and industry professions nor enjoys dressing up in old-fashioned and historical period clothing.",
    "output": "¬Industry(clyde) → ¬(Industry(clyde) ∨ DressingUp(clyde))"
  },
  {
    "input": "Translate into first-order logic: All people who attend Renaissance fairs regularly enjoy dressing up in old-fashioned and historical period clothing.",
    "output": "∀x (RenaissanceFair(x) → DressingUp(x))"
  },
  {
    "input": "Translate into first-order logic: If people are fascinated by the history of the Renaissance and other past eras, then they attend Renaissance fairs regularly.",
    "output": "∀x (HistoryRenaissance(x) → RenaissanceFair(x))"
  },
  {
    "input": "Translate into first-order logic: People are either fascinated by the history of the Renaissance and other past eras, or are not nostalgic academics who enjoy learning.",
    "output": "∀x (HistoryRenaissance(x) ∨ NotAcademics(x))"
  },
  {
    "input": "Translate into first-order logic: If people are focused on the future and industry professions, then they are not nostalgic academics who enjoy learning.",
    "output": "∀x (Industry(x) → NotAcademics(x))"
  },
  {
    "input": "Translate into first-order logic: If people are historical professors who are passionate about their job and subject, then they are nostalgic academics who enjoy learning.",
    "output": "∀x (HistoryProf(x) → ¬NotAcademics(x))"
  },
  {
    "input": "Translate into first-order logic: If Clyde is not focused on the future and industry professions, then he is neither focused on the future and industry professions nor enjoys dressing up in old-fashioned and historical period clothing.",
    "output": "¬Industry(clyde) → ¬(Industry(clyde) ∨ DressingUp(clyde))"
  },
  {
    "input": "Translate into first-order logic: All people who attend Renaissance fairs regularly enjoy dressing up in old-fashioned and historical period clothing.",
    "output": "∀x (RenaissanceFair(x) → DressingUp(x))"
  },
  {
    "input": "Translate into first-order logic: If people are fascinated by the history of the Renaissance and other past eras, then they attend Renaissance fairs regularly.",
    "output": "∀x (HistoryRenaissance(x) → RenaissanceFair(x))"
  },
  {
    "input": "Translate into first-order logic: People are either fascinated by the history of the Renaissance and other past eras, or are not nostalgic academics who enjoy learning.",
    "output": "∀x (HistoryRenaissance(x) ∨ NotAcademics(x))"
  },
  {
    "input": "Translate into first-order logic: If people are focused on the future and industry professions, then they are not nostalgic academics who enjoy learning.",
    "output": "∀x (Industry(x) → NotAcademics(x))"
  },
  {
    "input": "Translate into first-order logic: If people are historical professors who are passionate about their job and subject, then they are nostalgic academics who enjoy learning.",
    "output": "∀x (HistoryProf(x) → ¬NotAcademics(x))"
  },
  {
    "input": "Translate into first-order logic: If Clyde is not focused on the future and industry professions, then he is neither focused on the future and industry professions nor enjoys dressing up in old-fashioned and historical period clothing.",
    "output": "¬Industry(clyde) → ¬(Industry(clyde) ∨ DressingUp(clyde))"
  },
  {
    "input": "Translate into first-order logic: No sports cars are vehicles intended to be driven at moderate speeds.",
    "output": "∀x (SportsCar(x) → ¬IntendedToBeDrivenAtModerateSpeeds(x))"
  },
  {
    "input": "Translate into first-order logic: All automobiles designed for family use are vehicles intended to be driven at moderate speeds.",
    "output": "∀x (ForFamilyUse(x) → IntendedToBeDrivenAtModerateSpeeds(x))"
  },
  {
    "input": "Translate into first-order logic: If people work well in teams in their workplace, then they get along with all their colleagues at their work.",
    "output": "∀x (WorkTeams(x) → Colleagues(x))"
  },
  {
    "input": "Translate into first-order logic: If people come to work every day with a positive attitude, then they work well in teams in their workplace.",
    "output": "∀x (PositiveAttitude(x) → WorkTeams(x))"
  },
  {
    "input": "Translate into first-order logic: People either come into work every day with a positive attitude or are always tired every morning.",
    "output": "∀x (PositiveAttitude(x) ⊕ Tired(x)) ∧ (∀x (Tired(x) → BossPromotions(x)))"
  },
  {
    "input": "Translate into first-order logic: If people get many promotions from their boss at work, then they receive negative feedback from teams at work.",
    "output": "∀x (BossPromotions(x) → ¬NegativeFeedback(x))"
  },
  {
    "input": "Translate into first-order logic: Kat is either both a person who works well in teams in their workplace and is always tired every morning, or she neither works well in teams in their workplace nor is always tired every morning.",
    "output": "(WorkTeams(kat) ∧ Tired(kat)) ∨ ¬WorkTeams(kat) ∧ ¬Tired(kat))"
  },
  {
    "input": "Translate into first-order logic: If people work well in teams in their workplace, then they get along with all their colleagues at their work.",
    "output": "∀x (WorkTeams(x) → Colleagues(x))"
  },
  {
    "input": "Translate into first-order logic: If people come to work every day with a positive attitude, then they work well in teams in their workplace.",
    "output": "∀x (PositiveAttitude(x) → WorkTeams(x))"
  },
  {
    "input": "Translate into first-order logic: People either come into work every day with a positive attitude or are always tired every morning.",
    "output": "∀x (PositiveAttitude(x) ⊕ Tired(x)) ∧ (∀x (Tired(x) → BossPromotions(x)))"
  },
  {
    "input": "Translate into first-order logic: If people get many promotions from their boss at work, then they receive negative feedback from teams at work.",
    "output": "∀x (BossPromotions(x) → ¬NegativeFeedback(x))"
  },
  {
    "input": "Translate into first-order logic: Kat is either both a person who works well in teams in their workplace and is always tired every morning, or she neither works well in teams in their workplace nor is always tired every morning.",
    "output": "(WorkTeams(kat) ∧ Tired(kat)) ∨ ¬WorkTeams(kat) ∧ ¬Tired(kat))"
  },
  {
    "input": "Translate into first-order logic: If people work well in teams in their workplace, then they get along with all their colleagues at their work.",
    "output": "∀x (WorkTeams(x) → Colleagues(x))"
  },
  {
    "input": "Translate into first-order logic: If people come to work every day with a positive attitude, then they work well in teams in their workplace.",
    "output": "∀x (PositiveAttitude(x) → WorkTeams(x))"
  },
  {
    "input": "Translate into first-order logic: People either come into work every day with a positive attitude or are always tired every morning.",
    "output": "∀x (PositiveAttitude(x) ⊕ Tired(x)) ∧ (∀x (Tired(x) → BossPromotions(x)))"
  },
  {
    "input": "Translate into first-order logic: If people get many promotions from their boss at work, then they receive negative feedback from teams at work.",
    "output": "∀x (BossPromotions(x) → ¬NegativeFeedback(x))"
  },
  {
    "input": "Translate into first-order logic: Kat is either both a person who works well in teams in their workplace and is always tired every morning, or she neither works well in teams in their workplace nor is always tired every morning.",
    "output": "(WorkTeams(kat) ∧ Tired(kat)) ∨ ¬WorkTeams(kat) ∧ ¬Tired(kat))"
  },
  {
    "input": "Translate into first-order logic: Drishti is open-source.",
    "output": "OpenSource(drishti)"
  },
  {
    "input": "Translate into first-order logic: Open-source software is free to modify.",
    "output": "∀x (OpenSource(x) → ModifyFree(x))"
  },
  {
    "input": "Translate into first-order logic: There are five grades including A+, A, B+, B, and C in English.",
    "output": "Grade(a+) ∨ Grade(a) ∨ Grade(b+) ∨ Grade(b) ∨ Grade(c)"
  },
  {
    "input": "Translate into first-order logic: If a student gets A+ in English, then his score is greater than 95.",
    "output": "∀x (GetGrade(x, a+) → GreaterThan95(x))"
  },
  {
    "input": "Translate into first-order logic: If a student gets A in English, then his score is in the range of 90-95.",
    "output": "∀x (GetGrade(x, a) → Range90to95(x))"
  },
  {
    "input": "Translate into first-order logic: Zhang got an A in English.",
    "output": "GetGrade(zhang, a)"
  },
  {
    "input": "Translate into first-order logic: Wang's English score is better than Zhang's.",
    "output": "Better(wang, zhang)"
  },
  {
    "input": "Translate into first-order logic: Wu's English score is lower than 90.",
    "output": "LowerThan90(wu)"
  },
  {
    "input": "Translate into first-order logic: There are five grades including A+, A, B+, B, and C in English.",
    "output": "Grade(a+) ∨ Grade(a) ∨ Grade(b+) ∨ Grade(b) ∨ Grade(c)"
  },
  {
    "input": "Translate into first-order logic: If a student gets A+ in English, then his score is greater than 95.",
    "output": "∀x (GetGrade(x, a+) → GreaterThan95(x))"
  },
  {
    "input": "Translate into first-order logic: If a student gets A in English, then his score is in the range of 90-95.",
    "output": "∀x (GetGrade(x, a) → Range90to95(x))"
  },
  {
    "input": "Translate into first-order logic: Zhang got an A in English.",
    "output": "GetGrade(zhang, a)"
  },
  {
    "input": "Translate into first-order logic: Wang's English score is better than Zhang's.",
    "output": "Better(wang, zhang)"
  },
  {
    "input": "Translate into first-order logic: Wu's English score is lower than 90.",
    "output": "LowerThan90(wu)"
  },
  {
    "input": "Translate into first-order logic: There are five grades including A+, A, B+, B, and C in English.",
    "output": "Grade(a+) ∨ Grade(a) ∨ Grade(b+) ∨ Grade(b) ∨ Grade(c)"
  },
  {
    "input": "Translate into first-order logic: If a student gets A+ in English, then his score is greater than 95.",
    "output": "∀x (GetGrade(x, a+) → GreaterThan95(x))"
  },
  {
    "input": "Translate into first-order logic: If a student gets A in English, then his score is in the range of 90-95.",
    "output": "∀x (GetGrade(x, a) → Range90to95(x))"
  },
  {
    "input": "Translate into first-order logic: Zhang got an A in English.",
    "output": "GetGrade(zhang, a)"
  },
  {
    "input": "Translate into first-order logic: Wang's English score is better than Zhang's.",
    "output": "Better(wang, zhang)"
  },
  {
    "input": "Translate into first-order logic: Wu's English score is lower than 90.",
    "output": "LowerThan90(wu)"
  },
  {
    "input": "Translate into first-order logic: Olivia doesn't prefer warm temperature during the day.",
    "output": "∀x (Day(x) → ¬PrefersWarmAt(olivia, x))"
  },
  {
    "input": "Translate into first-order logic: When Olivia sleeps, she prefers cool temperature.",
    "output": "∀x (SleepingDuring(olivia, x) → PrefersCoolAt(olivia, x))"
  },
  {
    "input": "Translate into first-order logic: Olivia sleeps during the night.",
    "output": "∀x (SleepingDuring(olivia, x) → Night(x))"
  },
  {
    "input": "Translate into first-order logic: Olivia works during the day.",
    "output": "∀x (WorkingDuring(olivia, x) → Day(x))"
  },
  {
    "input": "Translate into first-order logic: Olivia either works or sleeps.",
    "output": "∀x (WorkingDuring(olivia, x) ∨ SleepingDuring(olivia, x))"
  },
  {
    "input": "Translate into first-order logic: The time is either the day or the night.",
    "output": "∀x (Day(x) ∨ Night(x))"
  },
  {
    "input": "Translate into first-order logic: Olivia either prefers warm temperature or prefers cool temperature.",
    "output": "∀x (PrefersWarmAt(olivia, x) ∨ PrefersCoolAt(olivia, x))"
  },
  {
    "input": "Translate into first-order logic: Taylor Swift gives a commencement speech in New York University in 2022.",
    "output": "Speech(taylorSwift, nyc)"
  },
  {
    "input": "Translate into first-order logic: Both Columbia University and New York University are located in Manhattan.",
    "output": "Manhattan(columbiaUniversity) ∧ Manhattan(nyc)"
  },
  {
    "input": "Translate into first-order logic: Taylor Swift has received three Grammy Album of the Year Awards.",
    "output": "HaveAlbum(taylorSwift)"
  },
  {
    "input": "Translate into first-order logic: Columbia University is one of the Ivy League schools.",
    "output": "IvyLeague(columbiaUniversity)"
  },
  {
    "input": "Translate into first-order logic: Taylor Swift gives a commencement speech in New York University in 2022.",
    "output": "Speech(taylorSwift, nyc)"
  },
  {
    "input": "Translate into first-order logic: Both Columbia University and New York University are located in Manhattan.",
    "output": "Manhattan(columbiaUniversity) ∧ Manhattan(nyc)"
  },
  {
    "input": "Translate into first-order logic: Taylor Swift has received three Grammy Album of the Year Awards.",
    "output": "HaveAlbum(taylorSwift)"
  },
  {
    "input": "Translate into first-order logic: Columbia University is one of the Ivy League schools.",
    "output": "IvyLeague(columbiaUniversity)"
  },
  {
    "input": "Translate into first-order logic: Customers either choose Plan A or Plan B.",
    "output": "∀x (PlanA(x) ∨ PlanB(x))"
  },
  {
    "input": "Translate into first-order logic: All who choose Plan B are rewarded with a $30 gift card.",
    "output": "∀x (PlanB(x) → Award(x))"
  },
  {
    "input": "Translate into first-order logic: There are no customers who do not choose any plans.",
    "output": "∀x (¬NoPlan(x))"
  },
  {
    "input": "Translate into first-order logic: No customers rewarded a $30 gift card are older than 80.",
    "output": "∀x (Award(x) → ¬OlderThan80(x))"
  },
  {
    "input": "Translate into first-order logic: Customers are either older than 80 or are currently studying at school.",
    "output": "∀x (OlderThan80(x) ∨ StudyAtSchool(x))"
  },
  {
    "input": "Translate into first-order logic: James is not a customer who is currently studying at school.",
    "output": "¬StudyAtSchool(james)"
  },
  {
    "input": "Translate into first-order logic: Customers either choose Plan A or Plan B.",
    "output": "∀x (PlanA(x) ∨ PlanB(x))"
  },
  {
    "input": "Translate into first-order logic: All who choose Plan B are rewarded with a $30 gift card.",
    "output": "∀x (PlanB(x) → Award(x))"
  },
  {
    "input": "Translate into first-order logic: There are no customers who do not choose any plans.",
    "output": "∀x (¬NoPlan(x))"
  },
  {
    "input": "Translate into first-order logic: No customers rewarded a $30 gift card are older than 80.",
    "output": "∀x (Award(x) → ¬OlderThan80(x))"
  },
  {
    "input": "Translate into first-order logic: Customers are either older than 80 or are currently studying at school.",
    "output": "∀x (OlderThan80(x) ∨ StudyAtSchool(x))"
  },
  {
    "input": "Translate into first-order logic: James is not a customer who is currently studying at school.",
    "output": "¬StudyAtSchool(james)"
  },
  {
    "input": "Translate into first-order logic: Customers either choose Plan A or Plan B.",
    "output": "∀x (PlanA(x) ∨ PlanB(x))"
  },
  {
    "input": "Translate into first-order logic: All who choose Plan B are rewarded with a $30 gift card.",
    "output": "∀x (PlanB(x) → Award(x))"
  },
  {
    "input": "Translate into first-order logic: There are no customers who do not choose any plans.",
    "output": "∀x (¬NoPlan(x))"
  },
  {
    "input": "Translate into first-order logic: No customers rewarded a $30 gift card are older than 80.",
    "output": "∀x (Award(x) → ¬OlderThan80(x))"
  },
  {
    "input": "Translate into first-order logic: Customers are either older than 80 or are currently studying at school.",
    "output": "∀x (OlderThan80(x) ∨ StudyAtSchool(x))"
  },
  {
    "input": "Translate into first-order logic: James is not a customer who is currently studying at school.",
    "output": "¬StudyAtSchool(james)"
  },
  {
    "input": "Translate into first-order logic: Detroit City is a horse.",
    "output": "Horse(detroitcity)"
  },
  {
    "input": "Translate into first-order logic: Some horses are racehorses.",
    "output": "∃x (Horse(x) ∧ Racehorse(x))"
  },
  {
    "input": "Translate into first-order logic: If a horse falls during a race, then it dies.",
    "output": "∀x (Horse(x) ∧ Racing(x) ∧ Falls(x) → Dead(x))"
  },
  {
    "input": "Translate into first-order logic: Detroit City fell during a race.",
    "output": "Racing(detroitcity) ∧ Falls(detroitcity)"
  },
  {
    "input": "Translate into first-order logic: A horse is a racehorse if it is in a race.",
    "output": "∀x (Horse(x) ∧ Racing(x) → Racehorse(x))"
  },
  {
    "input": "Translate into first-order logic: Detroit City is a horse.",
    "output": "Horse(detroitcity)"
  },
  {
    "input": "Translate into first-order logic: Some horses are racehorses.",
    "output": "∃x (Horse(x) ∧ Racehorse(x))"
  },
  {
    "input": "Translate into first-order logic: If a horse falls during a race, then it dies.",
    "output": "∀x (Horse(x) ∧ Racing(x) ∧ Falls(x) → Dead(x))"
  },
  {
    "input": "Translate into first-order logic: Detroit City fell during a race.",
    "output": "Racing(detroitcity) ∧ Falls(detroitcity)"
  },
  {
    "input": "Translate into first-order logic: A horse is a racehorse if it is in a race.",
    "output": "∀x (Horse(x) ∧ Racing(x) → Racehorse(x))"
  },
  {
    "input": "Translate into first-order logic: Detroit City is a horse.",
    "output": "Horse(detroitcity)"
  },
  {
    "input": "Translate into first-order logic: Some horses are racehorses.",
    "output": "∃x (Horse(x) ∧ Racehorse(x))"
  },
  {
    "input": "Translate into first-order logic: If a horse falls during a race, then it dies.",
    "output": "∀x (Horse(x) ∧ Racing(x) ∧ Falls(x) → Dead(x))"
  },
  {
    "input": "Translate into first-order logic: Detroit City fell during a race.",
    "output": "Racing(detroitcity) ∧ Falls(detroitcity)"
  },
  {
    "input": "Translate into first-order logic: A horse is a racehorse if it is in a race.",
    "output": "∀x (Horse(x) ∧ Racing(x) → Racehorse(x))"
  },
  {
    "input": "Translate into first-order logic: Frederick Monhoff was an architect, artist, and illustrator.",
    "output": "Architect(monhoff) ∧ Artist(monhoff) ∧ Illustrator(monhoff)"
  },
  {
    "input": "Translate into first-order logic: Frederick Monhoff was an American.",
    "output": "American(monhoff)"
  },
  {
    "input": "Translate into first-order logic: An artist is good at painting or music.",
    "output": "∀x (Artist(x) → GoodAt(x, painting) ∨ GoodAt(x, music))"
  },
  {
    "input": "Translate into first-order logic: All Americans speak English.",
    "output": "∀x (American(x) → Speak(x, english))"
  },
  {
    "input": "Translate into first-order logic: Frederick Monhoff was an architect, artist, and illustrator.",
    "output": "Architect(monhoff) ∧ Artist(monhoff) ∧ Illustrator(monhoff)"
  },
  {
    "input": "Translate into first-order logic: Frederick Monhoff was an American.",
    "output": "American(monhoff)"
  },
  {
    "input": "Translate into first-order logic: An artist is good at painting or music.",
    "output": "∀x (Artist(x) → GoodAt(x, painting) ∨ GoodAt(x, music))"
  },
  {
    "input": "Translate into first-order logic: All Americans speak English.",
    "output": "∀x (American(x) → Speak(x, english))"
  },
  {
    "input": "Translate into first-order logic: Miroslav Fiedler was a Czech mathematician.",
    "output": "Czech(miroslavfiedler) ∧ Mathematician(miroslavfiedler)"
  },
  {
    "input": "Translate into first-order logic: Miroslav Fiedler is known for his contributions to linear algebra and graph theory.",
    "output": "KnownFor(miroslavfiedler, contributionsToLinearAlgebraAndGraphTheory)"
  },
  {
    "input": "Translate into first-order logic: Miroslav Fiedler is honored by the Fiedler eigenvalue.",
    "output": "HonoredBy(miroslavfiedler, fiedlerEigenvalue)"
  },
  {
    "input": "Translate into first-order logic: Fiedler eigenvalue is the second smallest eigenvalue of the graph Laplacian.",
    "output": "TheSecondSmallestEigenvalueOf(fiedlerEigenvalue, theGraphLaplacian)"
  },
  {
    "input": "Translate into first-order logic: Miroslav Fiedler was a Czech mathematician.",
    "output": "Czech(miroslavfiedler) ∧ Mathematician(miroslavfiedler)"
  },
  {
    "input": "Translate into first-order logic: Miroslav Fiedler is known for his contributions to linear algebra and graph theory.",
    "output": "KnownFor(miroslavfiedler, contributionsToLinearAlgebraAndGraphTheory)"
  },
  {
    "input": "Translate into first-order logic: Miroslav Fiedler is honored by the Fiedler eigenvalue.",
    "output": "HonoredBy(miroslavfiedler, fiedlerEigenvalue)"
  },
  {
    "input": "Translate into first-order logic: Fiedler eigenvalue is the second smallest eigenvalue of the graph Laplacian.",
    "output": "TheSecondSmallestEigenvalueOf(fiedlerEigenvalue, theGraphLaplacian)"
  },
  {
    "input": "Translate into first-order logic: Miroslav Fiedler was a Czech mathematician.",
    "output": "Czech(miroslavfiedler) ∧ Mathematician(miroslavfiedler)"
  },
  {
    "input": "Translate into first-order logic: Miroslav Fiedler is known for his contributions to linear algebra and graph theory.",
    "output": "KnownFor(miroslavfiedler, contributionsToLinearAlgebraAndGraphTheory)"
  },
  {
    "input": "Translate into first-order logic: Miroslav Fiedler is honored by the Fiedler eigenvalue.",
    "output": "HonoredBy(miroslavfiedler, fiedlerEigenvalue)"
  },
  {
    "input": "Translate into first-order logic: Fiedler eigenvalue is the second smallest eigenvalue of the graph Laplacian.",
    "output": "TheSecondSmallestEigenvalueOf(fiedlerEigenvalue, theGraphLaplacian)"
  },
  {
    "input": "Translate into first-order logic: A laptop is a computer.",
    "output": "∀x (Laptop(x) → Computer(x))"
  },
  {
    "input": "Translate into first-order logic: You can play games on a computer.",
    "output": "∀x (Computer(x) → CanPlayGames(x))"
  },
  {
    "input": "Translate into first-order logic: A phone is not a computer.",
    "output": "∀x (Phone(x) → ¬Computer(x))"
  },
  {
    "input": "Translate into first-order logic: A laptop is a computer.",
    "output": "∀x (Laptop(x) → Computer(x))"
  },
  {
    "input": "Translate into first-order logic: You can play games on a computer.",
    "output": "∀x (Computer(x) → CanPlayGames(x))"
  },
  {
    "input": "Translate into first-order logic: A phone is not a computer.",
    "output": "∀x (Phone(x) → ¬Computer(x))"
  },
  {
    "input": "Translate into first-order logic: Walter Folger Brown was an American politician and lawyer, and served as the postmaster general.",
    "output": "AmericanPolitician(walterbrown) ∧ Lawyer(walterbrown) ∧ ServedAs(walterbrown, postamastergeneral)"
  },
  {
    "input": "Translate into first-order logic: Walter Folger Brown graduated from Harvard University with a Bachelors of Arts.",
    "output": "Graduated(walterbrown, harvard) ∧ GraduatedWith(walterbrown, bachelorsofart)"
  },
  {
    "input": "Translate into first-order logic: While they were both in Toledo, Walter Folger Brown's father practiced law with Walter Folger Brown.",
    "output": "In(walterbrown, toledo) ∧ In(walterbrownfather, toledo) ∧ PracticedLawTogether(walterbrownfather, walterbrown)"
  },
  {
    "input": "Translate into first-order logic: Katherin Hafer married Walter Folger Brown.",
    "output": "Married(ketherinhafer, walterbrown)"
  },
  {
    "input": "Translate into first-order logic: Walter Folger Brown was an American politician and lawyer, and served as the postmaster general.",
    "output": "AmericanPolitician(walterbrown) ∧ Lawyer(walterbrown) ∧ ServedAs(walterbrown, postamastergeneral)"
  },
  {
    "input": "Translate into first-order logic: Walter Folger Brown graduated from Harvard University with a Bachelors of Arts.",
    "output": "Graduated(walterbrown, harvard) ∧ GraduatedWith(walterbrown, bachelorsofart)"
  },
  {
    "input": "Translate into first-order logic: While they were both in Toledo, Walter Folger Brown's father practiced law with Walter Folger Brown.",
    "output": "In(walterbrown, toledo) ∧ In(walterbrownfather, toledo) ∧ PracticedLawTogether(walterbrownfather, walterbrown)"
  },
  {
    "input": "Translate into first-order logic: Katherin Hafer married Walter Folger Brown.",
    "output": "Married(ketherinhafer, walterbrown)"
  },
  {
    "input": "Translate into first-order logic: Walter Folger Brown was an American politician and lawyer, and served as the postmaster general.",
    "output": "AmericanPolitician(walterbrown) ∧ Lawyer(walterbrown) ∧ ServedAs(walterbrown, postamastergeneral)"
  },
  {
    "input": "Translate into first-order logic: Walter Folger Brown graduated from Harvard University with a Bachelors of Arts.",
    "output": "Graduated(walterbrown, harvard) ∧ GraduatedWith(walterbrown, bachelorsofart)"
  },
  {
    "input": "Translate into first-order logic: While they were both in Toledo, Walter Folger Brown's father practiced law with Walter Folger Brown.",
    "output": "In(walterbrown, toledo) ∧ In(walterbrownfather, toledo) ∧ PracticedLawTogether(walterbrownfather, walterbrown)"
  },
  {
    "input": "Translate into first-order logic: Katherin Hafer married Walter Folger Brown.",
    "output": "Married(ketherinhafer, walterbrown)"
  },
  {
    "input": "Translate into first-order logic: All products shipped from China are made in China.",
    "output": "∀x (ShipChina(x) → MadeInChina(x))"
  },
  {
    "input": "Translate into first-order logic: All products sold in JD are shipped from China.",
    "output": "∀x (SoldJD(x) → ShipChina(x))"
  },
  {
    "input": "Translate into first-order logic: All products commonly used in China are sold in JD.",
    "output": "∀x (CommonlyUsedChina(x) → SoldJD(x))"
  },
  {
    "input": "Translate into first-order logic: All products favored by young people are commonly used in China.",
    "output": "∀x (FavoredByYoungPeople(x) → CommonlyUsedChina(x))"
  },
  {
    "input": "Translate into first-order logic: MacBook is not made in China and is not commonly used in China.",
    "output": "¬(MadeInChina(macbook) ∧ CommonlyUsedChina(macbook))"
  },
  {
    "input": "Translate into first-order logic: All products shipped from China are made in China.",
    "output": "∀x (ShipChina(x) → MadeInChina(x))"
  },
  {
    "input": "Translate into first-order logic: All products sold in JD are shipped from China.",
    "output": "∀x (SoldJD(x) → ShipChina(x))"
  },
  {
    "input": "Translate into first-order logic: All products commonly used in China are sold in JD.",
    "output": "∀x (CommonlyUsedChina(x) → SoldJD(x))"
  },
  {
    "input": "Translate into first-order logic: All products favored by young people are commonly used in China.",
    "output": "∀x (FavoredByYoungPeople(x) → CommonlyUsedChina(x))"
  },
  {
    "input": "Translate into first-order logic: MacBook is not made in China and is not commonly used in China.",
    "output": "¬(MadeInChina(macbook) ∧ CommonlyUsedChina(macbook))"
  },
  {
    "input": "Translate into first-order logic: All products shipped from China are made in China.",
    "output": "∀x (ShipChina(x) → MadeInChina(x))"
  },
  {
    "input": "Translate into first-order logic: All products sold in JD are shipped from China.",
    "output": "∀x (SoldJD(x) → ShipChina(x))"
  },
  {
    "input": "Translate into first-order logic: All products commonly used in China are sold in JD.",
    "output": "∀x (CommonlyUsedChina(x) → SoldJD(x))"
  },
  {
    "input": "Translate into first-order logic: All products favored by young people are commonly used in China.",
    "output": "∀x (FavoredByYoungPeople(x) → CommonlyUsedChina(x))"
  },
  {
    "input": "Translate into first-order logic: MacBook is not made in China and is not commonly used in China.",
    "output": "¬(MadeInChina(macbook) ∧ CommonlyUsedChina(macbook))"
  },
  {
    "input": "Translate into first-order logic: All products shipped from China are made in China.",
    "output": "∀x (ShipChina(x) → MadeInChina(x))"
  },
  {
    "input": "Translate into first-order logic: All products sold in JD are shipped from China.",
    "output": "∀x (SoldJD(x) → ShipChina(x))"
  },
  {
    "input": "Translate into first-order logic: All products commonly used in China are sold in JD.",
    "output": "∀x (CommonlyUsedChina(x) → SoldJD(x))"
  },
  {
    "input": "Translate into first-order logic: All products favored by young people are commonly used in China.",
    "output": "∀x (FavoredByYoungPeople(x) → CommonlyUsedChina(x))"
  },
  {
    "input": "Translate into first-order logic: MacBook is not made in China and is not commonly used in China.",
    "output": "¬(MadeInChina(macbook) ∧ CommonlyUsedChina(macbook))"
  },
  {
    "input": "Translate into first-order logic: All products shipped from China are made in China.",
    "output": "∀x (ShipChina(x) → MadeInChina(x))"
  },
  {
    "input": "Translate into first-order logic: All products sold in JD are shipped from China.",
    "output": "∀x (SoldJD(x) → ShipChina(x))"
  },
  {
    "input": "Translate into first-order logic: All products commonly used in China are sold in JD.",
    "output": "∀x (CommonlyUsedChina(x) → SoldJD(x))"
  },
  {
    "input": "Translate into first-order logic: All products favored by young people are commonly used in China.",
    "output": "∀x (FavoredByYoungPeople(x) → CommonlyUsedChina(x))"
  },
  {
    "input": "Translate into first-order logic: MacBook is not made in China and is not commonly used in China.",
    "output": "¬(MadeInChina(macbook) ∧ CommonlyUsedChina(macbook))"
  },
  {
    "input": "Translate into first-order logic: Oxford Circus is a road junction connecting Oxford Street and Regent Street.",
    "output": "OxfordStreet(oxfordCircus) ∧ RegentStreet(oxfordCircus)"
  },
  {
    "input": "Translate into first-order logic: Oxford Street is in London.",
    "output": "∀x (OxfordStreet(x) → London(x))"
  },
  {
    "input": "Translate into first-order logic: John Nash designed the construction on Regent Street.",
    "output": "∃x (RegentStreet(x) ∧ Design(johnNash, x))"
  },
  {
    "input": "Translate into first-order logic: John Nash designed Oxford Circus.",
    "output": "Design(johnNash, oxfordCircus)"
  },
  {
    "input": "Translate into first-order logic: John Nash is an architect in British.",
    "output": "British(johnNash) ∧ Architect(johnNash)"
  },
  {
    "input": "Translate into first-order logic: Oxford Circus is the entrance to Oxford Circus tube station which is a part of the Central line in 1900.",
    "output": "CentralLine(oxfordCircus)"
  },
  {
    "input": "Translate into first-order logic: Oxford Circus is a road junction connecting Oxford Street and Regent Street.",
    "output": "OxfordStreet(oxfordCircus) ∧ RegentStreet(oxfordCircus)"
  },
  {
    "input": "Translate into first-order logic: Oxford Street is in London.",
    "output": "∀x (OxfordStreet(x) → London(x))"
  },
  {
    "input": "Translate into first-order logic: John Nash designed the construction on Regent Street.",
    "output": "∃x (RegentStreet(x) ∧ Design(johnNash, x))"
  },
  {
    "input": "Translate into first-order logic: John Nash designed Oxford Circus.",
    "output": "Design(johnNash, oxfordCircus)"
  },
  {
    "input": "Translate into first-order logic: John Nash is an architect in British.",
    "output": "British(johnNash) ∧ Architect(johnNash)"
  },
  {
    "input": "Translate into first-order logic: Oxford Circus is the entrance to Oxford Circus tube station which is a part of the Central line in 1900.",
    "output": "CentralLine(oxfordCircus)"
  },
  {
    "input": "Translate into first-order logic: Oxford Circus is a road junction connecting Oxford Street and Regent Street.",
    "output": "OxfordStreet(oxfordCircus) ∧ RegentStreet(oxfordCircus)"
  },
  {
    "input": "Translate into first-order logic: Oxford Street is in London.",
    "output": "∀x (OxfordStreet(x) → London(x))"
  },
  {
    "input": "Translate into first-order logic: John Nash designed the construction on Regent Street.",
    "output": "∃x (RegentStreet(x) ∧ Design(johnNash, x))"
  },
  {
    "input": "Translate into first-order logic: John Nash designed Oxford Circus.",
    "output": "Design(johnNash, oxfordCircus)"
  },
  {
    "input": "Translate into first-order logic: John Nash is an architect in British.",
    "output": "British(johnNash) ∧ Architect(johnNash)"
  },
  {
    "input": "Translate into first-order logic: Oxford Circus is the entrance to Oxford Circus tube station which is a part of the Central line in 1900.",
    "output": "CentralLine(oxfordCircus)"
  },
  {
    "input": "Translate into first-order logic: Oxford Circus is a road junction connecting Oxford Street and Regent Street.",
    "output": "OxfordStreet(oxfordCircus) ∧ RegentStreet(oxfordCircus)"
  },
  {
    "input": "Translate into first-order logic: Oxford Street is in London.",
    "output": "∀x (OxfordStreet(x) → London(x))"
  },
  {
    "input": "Translate into first-order logic: John Nash designed the construction on Regent Street.",
    "output": "∃x (RegentStreet(x) ∧ Design(johnNash, x))"
  },
  {
    "input": "Translate into first-order logic: John Nash designed Oxford Circus.",
    "output": "Design(johnNash, oxfordCircus)"
  },
  {
    "input": "Translate into first-order logic: John Nash is an architect in British.",
    "output": "British(johnNash) ∧ Architect(johnNash)"
  },
  {
    "input": "Translate into first-order logic: Oxford Circus is the entrance to Oxford Circus tube station which is a part of the Central line in 1900.",
    "output": "CentralLine(oxfordCircus)"
  },
  {
    "input": "Translate into first-order logic: An animal is either a cat or a dog.",
    "output": "∀x (Cat(x) ⊕ Dog(x))"
  },
  {
    "input": "Translate into first-order logic: All dogs bark.",
    "output": "∀x (Dog(x) → Bark(x))"
  },
  {
    "input": "Translate into first-order logic: Ghosts do not exist.",
    "output": "∀x (¬Ghost(x))"
  },
  {
    "input": "Translate into first-order logic: If something barks, then it is not alive.",
    "output": "∀x (Bark(x) → ¬Alive(x))"
  },
  {
    "input": "Translate into first-order logic: A thing is either alive or dead.",
    "output": "∀x (Alive(x) ⊕ Dead(x))"
  },
  {
    "input": "Translate into first-order logic: Jojo is not dead.",
    "output": "¬Dead(jojo)"
  },
  {
    "input": "Translate into first-order logic: An animal is either a cat or a dog.",
    "output": "∀x (Cat(x) ⊕ Dog(x))"
  },
  {
    "input": "Translate into first-order logic: All dogs bark.",
    "output": "∀x (Dog(x) → Bark(x))"
  },
  {
    "input": "Translate into first-order logic: Ghosts do not exist.",
    "output": "∀x (¬Ghost(x))"
  },
  {
    "input": "Translate into first-order logic: If something barks, then it is not alive.",
    "output": "∀x (Bark(x) → ¬Alive(x))"
  },
  {
    "input": "Translate into first-order logic: A thing is either alive or dead.",
    "output": "∀x (Alive(x) ⊕ Dead(x))"
  },
  {
    "input": "Translate into first-order logic: Jojo is not dead.",
    "output": "¬Dead(jojo)"
  },
  {
    "input": "Translate into first-order logic: An animal is either a cat or a dog.",
    "output": "∀x (Cat(x) ⊕ Dog(x))"
  },
  {
    "input": "Translate into first-order logic: All dogs bark.",
    "output": "∀x (Dog(x) → Bark(x))"
  },
  {
    "input": "Translate into first-order logic: Ghosts do not exist.",
    "output": "∀x (¬Ghost(x))"
  },
  {
    "input": "Translate into first-order logic: If something barks, then it is not alive.",
    "output": "∀x (Bark(x) → ¬Alive(x))"
  },
  {
    "input": "Translate into first-order logic: A thing is either alive or dead.",
    "output": "∀x (Alive(x) ⊕ Dead(x))"
  },
  {
    "input": "Translate into first-order logic: Jojo is not dead.",
    "output": "¬Dead(jojo)"
  },
  {
    "input": "Translate into first-order logic: All animals that are tigers are cats.",
    "output": "∀x (Tiger(x) → Cat(x))"
  },
  {
    "input": "Translate into first-order logic: No cats are dogs.",
    "output": "∀x (Cat(x) → ¬Dog(x))"
  },
  {
    "input": "Translate into first-order logic: All Bengal tigers are tigers.",
    "output": "∀x (BengalTiger(x) → Tiger(x))"
  },
  {
    "input": "Translate into first-order logic: Everything that is a husky is a dog.",
    "output": "∀x (Husky(x) → Dog(x))"
  },
  {
    "input": "Translate into first-order logic: Fido is either a Bengal tiger or a cat.",
    "output": "BengalTiger(fido) ∨ Cat(fido)"
  },
  {
    "input": "Translate into first-order logic: All animals that are tigers are cats.",
    "output": "∀x (Tiger(x) → Cat(x))"
  },
  {
    "input": "Translate into first-order logic: No cats are dogs.",
    "output": "∀x (Cat(x) → ¬Dog(x))"
  },
  {
    "input": "Translate into first-order logic: All Bengal tigers are tigers.",
    "output": "∀x (BengalTiger(x) → Tiger(x))"
  },
  {
    "input": "Translate into first-order logic: Everything that is a husky is a dog.",
    "output": "∀x (Husky(x) → Dog(x))"
  },
  {
    "input": "Translate into first-order logic: Fido is either a Bengal tiger or a cat.",
    "output": "BengalTiger(fido) ∨ Cat(fido)"
  },
  {
    "input": "Translate into first-order logic: All animals that are tigers are cats.",
    "output": "∀x (Tiger(x) → Cat(x))"
  },
  {
    "input": "Translate into first-order logic: No cats are dogs.",
    "output": "∀x (Cat(x) → ¬Dog(x))"
  },
  {
    "input": "Translate into first-order logic: All Bengal tigers are tigers.",
    "output": "∀x (BengalTiger(x) → Tiger(x))"
  },
  {
    "input": "Translate into first-order logic: Everything that is a husky is a dog.",
    "output": "∀x (Husky(x) → Dog(x))"
  },
  {
    "input": "Translate into first-order logic: Fido is either a Bengal tiger or a cat.",
    "output": "BengalTiger(fido) ∨ Cat(fido)"
  },
  {
    "input": "Translate into first-order logic: All animals that are tigers are cats.",
    "output": "∀x (Tiger(x) → Cat(x))"
  },
  {
    "input": "Translate into first-order logic: No cats are dogs.",
    "output": "∀x (Cat(x) → ¬Dog(x))"
  },
  {
    "input": "Translate into first-order logic: All Bengal tigers are tigers.",
    "output": "∀x (BengalTiger(x) → Tiger(x))"
  },
  {
    "input": "Translate into first-order logic: Everything that is a husky is a dog.",
    "output": "∀x (Husky(x) → Dog(x))"
  },
  {
    "input": "Translate into first-order logic: Fido is either a Bengal tiger or a cat.",
    "output": "BengalTiger(fido) ∨ Cat(fido)"
  },
  {
    "input": "Translate into first-order logic: If a city hold a Summer Olympics, and the city is a US city, then the Summer Olympics will be in the US.",
    "output": "∀x ∀y (SummerOlympicsCity(x, y) ∧ CityInCountry(y, us) → SummerOlympicsCountry(x, us))"
  },
  {
    "input": "Translate into first-order logic: If a city is in a state which is in US, the city is a US city.",
    "output": "∀x ∀y (CityInState(x, y) ∧ StateInCountry(y, us) → CityInCountry(x, us))"
  },
  {
    "input": "Translate into first-order logic: If a city in a state, and a Summer Olympics is in this city, then the Summer Olympics is in this state.",
    "output": "∀x ∀y ∀z (CityInState(x, y) ∧ SummerOlympicsCity(z, x) → SummerOlympicsState(z, y))"
  },
  {
    "input": "Translate into first-order logic: The 2028 Summer Olympics is scheduled to take place in Los Angeles(LA).",
    "output": "SummerOlympicsCity(y2028, la)"
  },
  {
    "input": "Translate into first-order logic: LA is a city in California(CA).",
    "output": "CityInState(la, ca)"
  },
  {
    "input": "Translate into first-order logic: Atlanta is a US city.",
    "output": "CityInCountry(atlanta, us)"
  },
  {
    "input": "Translate into first-order logic: Atlanta is in Georgia(CA).",
    "output": "StateInCountry(ca, us)"
  },
  {
    "input": "Translate into first-order logic: CA is a state in the United States.",
    "output": "CityInState(atlanta, ga)"
  },
  {
    "input": "Translate into first-order logic: Boxing, modern pentathlon, and weightlifting will be removed from The 2028 Summer Olympics.",
    "output": "¬InSummerOlympics(y2028, boxing) ∧ ¬InSummerOlympics(y2028, modern_pentathlon) ∧ ¬InSummerOlympics(y2028, weightlifting)"
  },
  {
    "input": "Translate into first-order logic: Atlanta in the United States hold the 1996 Summer Olympics.",
    "output": "SummerOlympicsCity(y1996, atlanta)"
  },
  {
    "input": "Translate into first-order logic: If a city hold a Summer Olympics, and the city is a US city, then the Summer Olympics will be in the US.",
    "output": "∀x ∀y (SummerOlympicsCity(x, y) ∧ CityInCountry(y, us) → SummerOlympicsCountry(x, us))"
  },
  {
    "input": "Translate into first-order logic: If a city is in a state which is in US, the city is a US city.",
    "output": "∀x ∀y (CityInState(x, y) ∧ StateInCountry(y, us) → CityInCountry(x, us))"
  },
  {
    "input": "Translate into first-order logic: If a city in a state, and a Summer Olympics is in this city, then the Summer Olympics is in this state.",
    "output": "∀x ∀y ∀z (CityInState(x, y) ∧ SummerOlympicsCity(z, x) → SummerOlympicsState(z, y))"
  },
  {
    "input": "Translate into first-order logic: The 2028 Summer Olympics is scheduled to take place in Los Angeles(LA).",
    "output": "SummerOlympicsCity(y2028, la)"
  },
  {
    "input": "Translate into first-order logic: LA is a city in California(CA).",
    "output": "CityInState(la, ca)"
  },
  {
    "input": "Translate into first-order logic: Atlanta is a US city.",
    "output": "CityInCountry(atlanta, us)"
  },
  {
    "input": "Translate into first-order logic: Atlanta is in Georgia(CA).",
    "output": "StateInCountry(ca, us)"
  },
  {
    "input": "Translate into first-order logic: CA is a state in the United States.",
    "output": "CityInState(atlanta, ga)"
  },
  {
    "input": "Translate into first-order logic: Boxing, modern pentathlon, and weightlifting will be removed from The 2028 Summer Olympics.",
    "output": "¬InSummerOlympics(y2028, boxing) ∧ ¬InSummerOlympics(y2028, modern_pentathlon) ∧ ¬InSummerOlympics(y2028, weightlifting)"
  },
  {
    "input": "Translate into first-order logic: Atlanta in the United States hold the 1996 Summer Olympics.",
    "output": "SummerOlympicsCity(y1996, atlanta)"
  },
  {
    "input": "Translate into first-order logic: If a city hold a Summer Olympics, and the city is a US city, then the Summer Olympics will be in the US.",
    "output": "∀x ∀y (SummerOlympicsCity(x, y) ∧ CityInCountry(y, us) → SummerOlympicsCountry(x, us))"
  },
  {
    "input": "Translate into first-order logic: If a city is in a state which is in US, the city is a US city.",
    "output": "∀x ∀y (CityInState(x, y) ∧ StateInCountry(y, us) → CityInCountry(x, us))"
  },
  {
    "input": "Translate into first-order logic: If a city in a state, and a Summer Olympics is in this city, then the Summer Olympics is in this state.",
    "output": "∀x ∀y ∀z (CityInState(x, y) ∧ SummerOlympicsCity(z, x) → SummerOlympicsState(z, y))"
  },
  {
    "input": "Translate into first-order logic: The 2028 Summer Olympics is scheduled to take place in Los Angeles(LA).",
    "output": "SummerOlympicsCity(y2028, la)"
  },
  {
    "input": "Translate into first-order logic: LA is a city in California(CA).",
    "output": "CityInState(la, ca)"
  },
  {
    "input": "Translate into first-order logic: Atlanta is a US city.",
    "output": "CityInCountry(atlanta, us)"
  },
  {
    "input": "Translate into first-order logic: Atlanta is in Georgia(CA).",
    "output": "StateInCountry(ca, us)"
  },
  {
    "input": "Translate into first-order logic: CA is a state in the United States.",
    "output": "CityInState(atlanta, ga)"
  },
  {
    "input": "Translate into first-order logic: Boxing, modern pentathlon, and weightlifting will be removed from The 2028 Summer Olympics.",
    "output": "¬InSummerOlympics(y2028, boxing) ∧ ¬InSummerOlympics(y2028, modern_pentathlon) ∧ ¬InSummerOlympics(y2028, weightlifting)"
  },
  {
    "input": "Translate into first-order logic: Atlanta in the United States hold the 1996 Summer Olympics.",
    "output": "SummerOlympicsCity(y1996, atlanta)"
  },
  {
    "input": "Translate into first-order logic: The taiga vole is a large vole found in northwestern North America.",
    "output": "Vole(taigaVole) ∧ Find(taigaVole, northAmerica)"
  },
  {
    "input": "Translate into first-order logic: Cats like playing with all voles.",
    "output": "∀x (Vole(x) → CatLikePlayingWith(x))"
  },
  {
    "input": "Translate into first-order logic: The taiga vole lives in the boreal taiga zone.",
    "output": "Live(taigaVole, borealTaigaZone)"
  },
  {
    "input": "Translate into first-order logic: The boreal taiga zone in North America is a cold place to live in.",
    "output": "∀x (Find(x, northAmerica) ∧ Live(x, borealTaigaZone) → LiveInColdPlace(x))"
  },
  {
    "input": "Translate into first-order logic: Taiga vole is typically much larger than most other North American voles, especially those from the genus Microtus.",
    "output": "Larger(taigaVole, microtusVole)"
  },
  {
    "input": "Translate into first-order logic: The taiga vole is a large vole found in northwestern North America.",
    "output": "Vole(taigaVole) ∧ Find(taigaVole, northAmerica)"
  },
  {
    "input": "Translate into first-order logic: Cats like playing with all voles.",
    "output": "∀x (Vole(x) → CatLikePlayingWith(x))"
  },
  {
    "input": "Translate into first-order logic: The taiga vole lives in the boreal taiga zone.",
    "output": "Live(taigaVole, borealTaigaZone)"
  },
  {
    "input": "Translate into first-order logic: The boreal taiga zone in North America is a cold place to live in.",
    "output": "∀x (Find(x, northAmerica) ∧ Live(x, borealTaigaZone) → LiveInColdPlace(x))"
  },
  {
    "input": "Translate into first-order logic: Taiga vole is typically much larger than most other North American voles, especially those from the genus Microtus.",
    "output": "Larger(taigaVole, microtusVole)"
  },
  {
    "input": "Translate into first-order logic: Either in women or in men.",
    "output": "∀x (Women(x) ∨ Men(x)) "
  },
  {
    "input": "Translate into first-order logic: No men have breast cancer.",
    "output": " ∀x (Men(x) → ¬BreastCancer(x))"
  },
  {
    "input": "Translate into first-order logic: Either breast cancer or non-breast cancer.",
    "output": " ∀x (BreastCancer (x) ∨ Non-BreastCancer(x)) "
  },
  {
    "input": "Translate into first-order logic: No type of cancer is without a tumor.",
    "output": " ∀x (ATypeOfCancer(x) → ¬WithoutTumor (x)) "
  },
  {
    "input": "Translate into first-order logic: All non-breast cancers are a type of cancer.",
    "output": " ∀x (Non-BreastCancer(x) → ATypeOfCancer(x)) "
  },
  {
    "input": "Translate into first-order logic: If adenocarcinoma is a type of cancer or without a tumor, then adenocarcinoma is in women or without a tumor.",
    "output": " ATypeOfCancer(adenocarcinoma) ∨ WithoutTumor(adenocarcinoma) → women(adenocarcinoma) ∨ WithoutTumor(adenocarcinoma)"
  },
  {
    "input": "Translate into first-order logic: Either in women or in men.",
    "output": "∀x (Women(x) ∨ Men(x)) "
  },
  {
    "input": "Translate into first-order logic: No men have breast cancer.",
    "output": " ∀x (Men(x) → ¬BreastCancer(x))"
  },
  {
    "input": "Translate into first-order logic: Either breast cancer or non-breast cancer.",
    "output": " ∀x (BreastCancer (x) ∨ Non-BreastCancer(x)) "
  },
  {
    "input": "Translate into first-order logic: No type of cancer is without a tumor.",
    "output": " ∀x (ATypeOfCancer(x) → ¬WithoutTumor (x)) "
  },
  {
    "input": "Translate into first-order logic: All non-breast cancers are a type of cancer.",
    "output": " ∀x (Non-BreastCancer(x) → ATypeOfCancer(x)) "
  },
  {
    "input": "Translate into first-order logic: If adenocarcinoma is a type of cancer or without a tumor, then adenocarcinoma is in women or without a tumor.",
    "output": " ATypeOfCancer(adenocarcinoma) ∨ WithoutTumor(adenocarcinoma) → women(adenocarcinoma) ∨ WithoutTumor(adenocarcinoma)"
  },
  {
    "input": "Translate into first-order logic: Either in women or in men.",
    "output": "∀x (Women(x) ∨ Men(x)) "
  },
  {
    "input": "Translate into first-order logic: No men have breast cancer.",
    "output": " ∀x (Men(x) → ¬BreastCancer(x))"
  },
  {
    "input": "Translate into first-order logic: Either breast cancer or non-breast cancer.",
    "output": " ∀x (BreastCancer (x) ∨ Non-BreastCancer(x)) "
  },
  {
    "input": "Translate into first-order logic: No type of cancer is without a tumor.",
    "output": " ∀x (ATypeOfCancer(x) → ¬WithoutTumor (x)) "
  },
  {
    "input": "Translate into first-order logic: All non-breast cancers are a type of cancer.",
    "output": " ∀x (Non-BreastCancer(x) → ATypeOfCancer(x)) "
  },
  {
    "input": "Translate into first-order logic: If adenocarcinoma is a type of cancer or without a tumor, then adenocarcinoma is in women or without a tumor.",
    "output": " ATypeOfCancer(adenocarcinoma) ∨ WithoutTumor(adenocarcinoma) → women(adenocarcinoma) ∨ WithoutTumor(adenocarcinoma)"
  },
  {
    "input": "Translate into first-order logic: Some monitors equipped in the lab are produced by the company named AOC.",
    "output": "∃x (Lab(x) ∧ AOC(x))"
  },
  {
    "input": "Translate into first-order logic: All monitors equipped in the lab are cheaper than their original prices.",
    "output": "∀x (Lab(x) → Cheaper(x))"
  },
  {
    "input": "Translate into first-order logic: If the monitor is cheaper than its original prices, then its resolution is 1080p.",
    "output": "∀x (Cheaper(x) → A1080p(x))"
  },
  {
    "input": "Translate into first-order logic: If a monitor is with a resolution of 1080p, then it does not support the type-c port.",
    "output": "∀x (A1080p(x) → ¬TypeC(x))"
  },
  {
    "input": "Translate into first-order logic: LG34 is equipped in the lab.",
    "output": "Lab(lg-34)"
  },
  {
    "input": "Translate into first-order logic: Some monitors equipped in the lab are produced by the company named AOC.",
    "output": "∃x (Lab(x) ∧ AOC(x))"
  },
  {
    "input": "Translate into first-order logic: All monitors equipped in the lab are cheaper than their original prices.",
    "output": "∀x (Lab(x) → Cheaper(x))"
  },
  {
    "input": "Translate into first-order logic: If the monitor is cheaper than its original prices, then its resolution is 1080p.",
    "output": "∀x (Cheaper(x) → A1080p(x))"
  },
  {
    "input": "Translate into first-order logic: If a monitor is with a resolution of 1080p, then it does not support the type-c port.",
    "output": "∀x (A1080p(x) → ¬TypeC(x))"
  },
  {
    "input": "Translate into first-order logic: LG34 is equipped in the lab.",
    "output": "Lab(lg-34)"
  },
  {
    "input": "Translate into first-order logic: Some monitors equipped in the lab are produced by the company named AOC.",
    "output": "∃x (Lab(x) ∧ AOC(x))"
  },
  {
    "input": "Translate into first-order logic: All monitors equipped in the lab are cheaper than their original prices.",
    "output": "∀x (Lab(x) → Cheaper(x))"
  },
  {
    "input": "Translate into first-order logic: If the monitor is cheaper than its original prices, then its resolution is 1080p.",
    "output": "∀x (Cheaper(x) → A1080p(x))"
  },
  {
    "input": "Translate into first-order logic: If a monitor is with a resolution of 1080p, then it does not support the type-c port.",
    "output": "∀x (A1080p(x) → ¬TypeC(x))"
  },
  {
    "input": "Translate into first-order logic: LG34 is equipped in the lab.",
    "output": "Lab(lg-34)"
  },
  {
    "input": "Translate into first-order logic: All fruits sold in Boston are shipped from Columbia.",
    "output": "∀x (SoldBoston(x) → ShippedFromColumbia(x))"
  },
  {
    "input": "Translate into first-order logic: Some fruits sold in New Haven are shipped from Mexico.",
    "output": "∃x (SoldNewHaven(x) ∧ ShippedFromMexico(x))"
  },
  {
    "input": "Translate into first-order logic: No fruits shipped from Columbia are fruits sold in New York.",
    "output": "∀x (ShippedFromColumbia(x) → ¬SoldNewYork(x))"
  },
  {
    "input": "Translate into first-order logic: Avocadoe are a kind of fruit sold in New York or New York.",
    "output": "SoldNewYork(avocado) ∨ SoldBoston(avocado)"
  },
  {
    "input": "Translate into first-order logic: Avocadoe are either shipped from Columbia and sold in New Haven, or neither shipped from Columbia nor sold in New Haven.",
    "output": "¬(ShippedFromColumbia(avocado) ⊕ SoldNewHaven(avocado))"
  },
  {
    "input": "Translate into first-order logic: All fruits sold in Boston are shipped from Columbia.",
    "output": "∀x (SoldBoston(x) → ShippedFromColumbia(x))"
  },
  {
    "input": "Translate into first-order logic: Some fruits sold in New Haven are shipped from Mexico.",
    "output": "∃x (SoldNewHaven(x) ∧ ShippedFromMexico(x))"
  },
  {
    "input": "Translate into first-order logic: No fruits shipped from Columbia are fruits sold in New York.",
    "output": "∀x (ShippedFromColumbia(x) → ¬SoldNewYork(x))"
  },
  {
    "input": "Translate into first-order logic: Avocadoe are a kind of fruit sold in New York or New York.",
    "output": "SoldNewYork(avocado) ∨ SoldBoston(avocado)"
  },
  {
    "input": "Translate into first-order logic: Avocadoe are either shipped from Columbia and sold in New Haven, or neither shipped from Columbia nor sold in New Haven.",
    "output": "¬(ShippedFromColumbia(avocado) ⊕ SoldNewHaven(avocado))"
  },
  {
    "input": "Translate into first-order logic: All fruits sold in Boston are shipped from Columbia.",
    "output": "∀x (SoldBoston(x) → ShippedFromColumbia(x))"
  },
  {
    "input": "Translate into first-order logic: Some fruits sold in New Haven are shipped from Mexico.",
    "output": "∃x (SoldNewHaven(x) ∧ ShippedFromMexico(x))"
  },
  {
    "input": "Translate into first-order logic: No fruits shipped from Columbia are fruits sold in New York.",
    "output": "∀x (ShippedFromColumbia(x) → ¬SoldNewYork(x))"
  },
  {
    "input": "Translate into first-order logic: Avocadoe are a kind of fruit sold in New York or New York.",
    "output": "SoldNewYork(avocado) ∨ SoldBoston(avocado)"
  },
  {
    "input": "Translate into first-order logic: Avocadoe are either shipped from Columbia and sold in New Haven, or neither shipped from Columbia nor sold in New Haven.",
    "output": "¬(ShippedFromColumbia(avocado) ⊕ SoldNewHaven(avocado))"
  },
  {
    "input": "Translate into first-order logic: All fruits sold in Boston are shipped from Columbia.",
    "output": "∀x (SoldBoston(x) → ShippedFromColumbia(x))"
  },
  {
    "input": "Translate into first-order logic: Some fruits sold in New Haven are shipped from Mexico.",
    "output": "∃x (SoldNewHaven(x) ∧ ShippedFromMexico(x))"
  },
  {
    "input": "Translate into first-order logic: No fruits shipped from Columbia are fruits sold in New York.",
    "output": "∀x (ShippedFromColumbia(x) → ¬SoldNewYork(x))"
  },
  {
    "input": "Translate into first-order logic: Avocadoe are a kind of fruit sold in New York or New York.",
    "output": "SoldNewYork(avocado) ∨ SoldBoston(avocado)"
  },
  {
    "input": "Translate into first-order logic: Avocadoe are either shipped from Columbia and sold in New Haven, or neither shipped from Columbia nor sold in New Haven.",
    "output": "¬(ShippedFromColumbia(avocado) ⊕ SoldNewHaven(avocado))"
  },
  {
    "input": "Translate into first-order logic: Some monitors equipped in the library are produced by AOC.",
    "output": "∃x (Library(x) ∧ AOC(x))"
  },
  {
    "input": "Translate into first-order logic: All monitors equipped in the library are cheaper than 800 dollars.",
    "output": "∀x (Library(x) → Cheap(x))"
  },
  {
    "input": "Translate into first-order logic: All monitors cheaper than 800 dollars are with a resolution of 1080p.",
    "output": "∀x (Cheap(x) → A1080p(x))"
  },
  {
    "input": "Translate into first-order logic: If a monitor has a resolution of 1080p, then it does not support the type-c port.",
    "output": "∀x (A1080p(x) → ¬TypeC(x))"
  },
  {
    "input": "Translate into first-order logic: A-2017 supports the type-c port.",
    "output": "TypeC(a-2017)"
  },
  {
    "input": "Translate into first-order logic: Some monitors equipped in the library are produced by AOC.",
    "output": "∃x (Library(x) ∧ AOC(x))"
  },
  {
    "input": "Translate into first-order logic: All monitors equipped in the library are cheaper than 800 dollars.",
    "output": "∀x (Library(x) → Cheap(x))"
  },
  {
    "input": "Translate into first-order logic: All monitors cheaper than 800 dollars are with a resolution of 1080p.",
    "output": "∀x (Cheap(x) → A1080p(x))"
  },
  {
    "input": "Translate into first-order logic: If a monitor has a resolution of 1080p, then it does not support the type-c port.",
    "output": "∀x (A1080p(x) → ¬TypeC(x))"
  },
  {
    "input": "Translate into first-order logic: A-2017 supports the type-c port.",
    "output": "TypeC(a-2017)"
  },
  {
    "input": "Translate into first-order logic: Some monitors equipped in the library are produced by AOC.",
    "output": "∃x (Library(x) ∧ AOC(x))"
  },
  {
    "input": "Translate into first-order logic: All monitors equipped in the library are cheaper than 800 dollars.",
    "output": "∀x (Library(x) → Cheap(x))"
  },
  {
    "input": "Translate into first-order logic: All monitors cheaper than 800 dollars are with a resolution of 1080p.",
    "output": "∀x (Cheap(x) → A1080p(x))"
  },
  {
    "input": "Translate into first-order logic: If a monitor has a resolution of 1080p, then it does not support the type-c port.",
    "output": "∀x (A1080p(x) → ¬TypeC(x))"
  },
  {
    "input": "Translate into first-order logic: A-2017 supports the type-c port.",
    "output": "TypeC(a-2017)"
  },
  {
    "input": "Translate into first-order logic: Sūduva Marijampolė holds the Lithuanian Supercup.",
    "output": "Hold(suduva, thelithuaniansupercup)"
  },
  {
    "input": "Translate into first-order logic: Sūduva Marijampolė is a soccer team.",
    "output": "SoccerTeam(suduva)"
  },
  {
    "input": "Translate into first-order logic: Ainderby Quernhow is a village and civil parish in the Hambleton District.",
    "output": "∀x (AinderbyQuernhow(x) → Village(x) ∧ CivilParish(x) ∧ Hambleton(x))"
  },
  {
    "input": "Translate into first-order logic: Hambleton District is in North Yorkshire.",
    "output": "∀x (Hambleton(x) → NorthYorkshire(x))"
  },
  {
    "input": "Translate into first-order logic: North Yorkshire is in England.",
    "output": "∀x (NorthYorkshire(x) → England(x))"
  },
  {
    "input": "Translate into first-order logic: Ainderby Quernhow is a village and civil parish in the Hambleton District.",
    "output": "∀x (AinderbyQuernhow(x) → Village(x) ∧ CivilParish(x) ∧ Hambleton(x))"
  },
  {
    "input": "Translate into first-order logic: Hambleton District is in North Yorkshire.",
    "output": "∀x (Hambleton(x) → NorthYorkshire(x))"
  },
  {
    "input": "Translate into first-order logic: North Yorkshire is in England.",
    "output": "∀x (NorthYorkshire(x) → England(x))"
  },
  {
    "input": "Translate into first-order logic: Douglas Adams is an author who created the book collection called The Salmon of Doubt.",
    "output": "Author(douglasAdams) ∧ Book(theSalmonOfDoubt)"
  },
  {
    "input": "Translate into first-order logic: The Salmon of Doubt is about life experiences and technology.",
    "output": "AboutLifeExperience(theSalmonOfDoubt) ∧ AboutTechnology(theSalmonOfDoubt)"
  },
  {
    "input": "Translate into first-order logic: All authors are writers.",
    "output": "∀x (Author(x) → Writer(x))"
  },
  {
    "input": "Translate into first-order logic: Writers create innovative ideas.",
    "output": "∀x (Writer(x) → CreateInnovativeIdea(x))"
  },
  {
    "input": "Translate into first-order logic: Some books that contain innovative ideas are about technology.",
    "output": "∃x (ContainInnovativeIdea(x) ∧ AboutTechnology(x))"
  },
  {
    "input": "Translate into first-order logic: Douglas Adams is an author who created the book collection called The Salmon of Doubt.",
    "output": "Author(douglasAdams) ∧ Book(theSalmonOfDoubt)"
  },
  {
    "input": "Translate into first-order logic: The Salmon of Doubt is about life experiences and technology.",
    "output": "AboutLifeExperience(theSalmonOfDoubt) ∧ AboutTechnology(theSalmonOfDoubt)"
  },
  {
    "input": "Translate into first-order logic: All authors are writers.",
    "output": "∀x (Author(x) → Writer(x))"
  },
  {
    "input": "Translate into first-order logic: Writers create innovative ideas.",
    "output": "∀x (Writer(x) → CreateInnovativeIdea(x))"
  },
  {
    "input": "Translate into first-order logic: Some books that contain innovative ideas are about technology.",
    "output": "∃x (ContainInnovativeIdea(x) ∧ AboutTechnology(x))"
  },
  {
    "input": "Translate into first-order logic: Douglas Adams is an author who created the book collection called The Salmon of Doubt.",
    "output": "Author(douglasAdams) ∧ Book(theSalmonOfDoubt)"
  },
  {
    "input": "Translate into first-order logic: The Salmon of Doubt is about life experiences and technology.",
    "output": "AboutLifeExperience(theSalmonOfDoubt) ∧ AboutTechnology(theSalmonOfDoubt)"
  },
  {
    "input": "Translate into first-order logic: All authors are writers.",
    "output": "∀x (Author(x) → Writer(x))"
  },
  {
    "input": "Translate into first-order logic: Writers create innovative ideas.",
    "output": "∀x (Writer(x) → CreateInnovativeIdea(x))"
  },
  {
    "input": "Translate into first-order logic: Some books that contain innovative ideas are about technology.",
    "output": "∃x (ContainInnovativeIdea(x) ∧ AboutTechnology(x))"
  },
  {
    "input": "Translate into first-order logic: No disposable products can help slow down global warming.",
    "output": "∀x (DisposableProducts(x) → ¬HelpSlowDownGlobalWarming(x))"
  },
  {
    "input": "Translate into first-order logic: All eco-friendly brands can help slow down global warming.",
    "output": " ∀x (Eco-friendlyBrand(x) → HelpSlowDownGlobalWarming(x))"
  },
  {
    "input": "Translate into first-order logic: All sustainable fashion brands are eco-friendly brands.",
    "output": " ∀x (SustainableFashionBrand(x) → Eco-friendlyBrand(x))"
  },
  {
    "input": "Translate into first-order logic: All fast fashion products are disposable products.",
    "output": " ∀x (FastFashionProducts(x) → DisposableProducts(x)) "
  },
  {
    "input": "Translate into first-order logic: If Reformation is not helping slow down global warming, then Reformation is an eco-friendly brand or a sustainable fashion brand.",
    "output": " ¬HelpSlowDownGlobalWarming(reformation) → Eco-friendlyBrand(reformation) ∨ SustainableFashionBrand(reformation)"
  },
  {
    "input": "Translate into first-order logic: No disposable products can help slow down global warming.",
    "output": "∀x (DisposableProducts(x) → ¬HelpSlowDownGlobalWarming(x))"
  },
  {
    "input": "Translate into first-order logic: All eco-friendly brands can help slow down global warming.",
    "output": " ∀x (Eco-friendlyBrand(x) → HelpSlowDownGlobalWarming(x))"
  },
  {
    "input": "Translate into first-order logic: All sustainable fashion brands are eco-friendly brands.",
    "output": " ∀x (SustainableFashionBrand(x) → Eco-friendlyBrand(x))"
  },
  {
    "input": "Translate into first-order logic: All fast fashion products are disposable products.",
    "output": " ∀x (FastFashionProducts(x) → DisposableProducts(x)) "
  },
  {
    "input": "Translate into first-order logic: If Reformation is not helping slow down global warming, then Reformation is an eco-friendly brand or a sustainable fashion brand.",
    "output": " ¬HelpSlowDownGlobalWarming(reformation) → Eco-friendlyBrand(reformation) ∨ SustainableFashionBrand(reformation)"
  },
  {
    "input": "Translate into first-order logic: No disposable products can help slow down global warming.",
    "output": "∀x (DisposableProducts(x) → ¬HelpSlowDownGlobalWarming(x))"
  },
  {
    "input": "Translate into first-order logic: All eco-friendly brands can help slow down global warming.",
    "output": " ∀x (Eco-friendlyBrand(x) → HelpSlowDownGlobalWarming(x))"
  },
  {
    "input": "Translate into first-order logic: All sustainable fashion brands are eco-friendly brands.",
    "output": " ∀x (SustainableFashionBrand(x) → Eco-friendlyBrand(x))"
  },
  {
    "input": "Translate into first-order logic: All fast fashion products are disposable products.",
    "output": " ∀x (FastFashionProducts(x) → DisposableProducts(x)) "
  },
  {
    "input": "Translate into first-order logic: If Reformation is not helping slow down global warming, then Reformation is an eco-friendly brand or a sustainable fashion brand.",
    "output": " ¬HelpSlowDownGlobalWarming(reformation) → Eco-friendlyBrand(reformation) ∨ SustainableFashionBrand(reformation)"
  },
  {
    "input": "Translate into first-order logic: No disposable products can help slow down global warming.",
    "output": "∀x (DisposableProducts(x) → ¬HelpSlowDownGlobalWarming(x))"
  },
  {
    "input": "Translate into first-order logic: All eco-friendly brands can help slow down global warming.",
    "output": " ∀x (Eco-friendlyBrand(x) → HelpSlowDownGlobalWarming(x))"
  },
  {
    "input": "Translate into first-order logic: All sustainable fashion brands are eco-friendly brands.",
    "output": " ∀x (SustainableFashionBrand(x) → Eco-friendlyBrand(x))"
  },
  {
    "input": "Translate into first-order logic: All fast fashion products are disposable products.",
    "output": " ∀x (FastFashionProducts(x) → DisposableProducts(x)) "
  },
  {
    "input": "Translate into first-order logic: If Reformation is not helping slow down global warming, then Reformation is an eco-friendly brand or a sustainable fashion brand.",
    "output": " ¬HelpSlowDownGlobalWarming(reformation) → Eco-friendlyBrand(reformation) ∨ SustainableFashionBrand(reformation)"
  },
  {
    "input": "Translate into first-order logic: No disposable products can help slow down global warming.",
    "output": "∀x (DisposableProducts(x) → ¬HelpSlowDownGlobalWarming(x))"
  },
  {
    "input": "Translate into first-order logic: All eco-friendly brands can help slow down global warming.",
    "output": " ∀x (Eco-friendlyBrand(x) → HelpSlowDownGlobalWarming(x))"
  },
  {
    "input": "Translate into first-order logic: All sustainable fashion brands are eco-friendly brands.",
    "output": " ∀x (SustainableFashionBrand(x) → Eco-friendlyBrand(x))"
  },
  {
    "input": "Translate into first-order logic: All fast fashion products are disposable products.",
    "output": " ∀x (FastFashionProducts(x) → DisposableProducts(x)) "
  },
  {
    "input": "Translate into first-order logic: If Reformation is not helping slow down global warming, then Reformation is an eco-friendly brand or a sustainable fashion brand.",
    "output": " ¬HelpSlowDownGlobalWarming(reformation) → Eco-friendlyBrand(reformation) ∨ SustainableFashionBrand(reformation)"
  },
  {
    "input": "Translate into first-order logic: No disposable products can help slow down global warming.",
    "output": "∀x (DisposableProducts(x) → ¬HelpSlowDownGlobalWarming(x))"
  },
  {
    "input": "Translate into first-order logic: All eco-friendly brands can help slow down global warming.",
    "output": " ∀x (Eco-friendlyBrand(x) → HelpSlowDownGlobalWarming(x))"
  },
  {
    "input": "Translate into first-order logic: All sustainable fashion brands are eco-friendly brands.",
    "output": " ∀x (SustainableFashionBrand(x) → Eco-friendlyBrand(x))"
  },
  {
    "input": "Translate into first-order logic: All fast fashion products are disposable products.",
    "output": " ∀x (FastFashionProducts(x) → DisposableProducts(x)) "
  },
  {
    "input": "Translate into first-order logic: If Reformation is not helping slow down global warming, then Reformation is an eco-friendly brand or a sustainable fashion brand.",
    "output": " ¬HelpSlowDownGlobalWarming(reformation) → Eco-friendlyBrand(reformation) ∨ SustainableFashionBrand(reformation)"
  },
  {
    "input": "Translate into first-order logic: Roy Richardson was a cricketer for Sint Maartener, a consituent country.",
    "output": "Cricketeer(royrichardson) ∧ PlayedFor(royrichardson, sintmaartener) ∧ ConstituentCountry(sintmaartener)"
  },
  {
    "input": "Translate into first-order logic: Roy Richardson was a right handed batsman and medium pace bowler.",
    "output": "RightHanded(royrichardson) ∧ Batsman(royrichardson) ∧ MediumPaceBowler(royrichardson)"
  },
  {
    "input": "Translate into first-order logic: Roy Richardson was old when he debuted in cricket.",
    "output": "Old(royrichardson) ∧ DebutedIn(royrichardson, cricket)"
  },
  {
    "input": "Translate into first-order logic: Sherville Huggins dismissed Roy Richardson.",
    "output": "Dismissed(shervillehuggins, royrichardson)"
  },
  {
    "input": "Translate into first-order logic: Roy Richardson was a cricketer for Sint Maartener, a consituent country.",
    "output": "Cricketeer(royrichardson) ∧ PlayedFor(royrichardson, sintmaartener) ∧ ConstituentCountry(sintmaartener)"
  },
  {
    "input": "Translate into first-order logic: Roy Richardson was a right handed batsman and medium pace bowler.",
    "output": "RightHanded(royrichardson) ∧ Batsman(royrichardson) ∧ MediumPaceBowler(royrichardson)"
  },
  {
    "input": "Translate into first-order logic: Roy Richardson was old when he debuted in cricket.",
    "output": "Old(royrichardson) ∧ DebutedIn(royrichardson, cricket)"
  },
  {
    "input": "Translate into first-order logic: Sherville Huggins dismissed Roy Richardson.",
    "output": "Dismissed(shervillehuggins, royrichardson)"
  },
  {
    "input": "Translate into first-order logic: To get a job at Google, you need to have a lot of work experience or a good education.",
    "output": "∀x (Employed(x, google) → WorkExp(x) ∨ GoodEduc(x))"
  },
  {
    "input": "Translate into first-order logic: All Yale graduates who submitted their resumes to Google got jobs there.",
    "output": "∀x ((Yale(x) ∧ CV(x, google)) → Employed(x, google))"
  },
  {
    "input": "Translate into first-order logic: John has a lot of work experience.",
    "output": "WorkExp(john)"
  },
  {
    "input": "Translate into first-order logic: John submitted his resume to Google and got a job there.",
    "output": "CV(john, google) ∧ Employed(john, google)"
  },
  {
    "input": "Translate into first-order logic: No students are doctors.",
    "output": "∀x (Student(x) → ¬Doctor(x))"
  },
  {
    "input": "Translate into first-order logic: All people taking classes are students.",
    "output": "∀x (TakingClass(x) → Student(x))"
  },
  {
    "input": "Translate into first-order logic: All graduate students are people taking classes.",
    "output": "∀x (GraduateStudent(x) → TakingClass(x))"
  },
  {
    "input": "Translate into first-order logic: All PhD students are graduate students.",
    "output": "∀x (PhDStudent(x) → GraduateStudent(x))"
  },
  {
    "input": "Translate into first-order logic: If Joe is a graduate student or a doctor (but not both), then Joe is not a graduate student and a student.",
    "output": "GraduateStudent(joe) ⊕  Doctor(joe) → ¬(GraduateStudent(joe) ^ Student(joe))"
  },
  {
    "input": "Translate into first-order logic: No students are doctors.",
    "output": "∀x (Student(x) → ¬Doctor(x))"
  },
  {
    "input": "Translate into first-order logic: All people taking classes are students.",
    "output": "∀x (TakingClass(x) → Student(x))"
  },
  {
    "input": "Translate into first-order logic: All graduate students are people taking classes.",
    "output": "∀x (GraduateStudent(x) → TakingClass(x))"
  },
  {
    "input": "Translate into first-order logic: All PhD students are graduate students.",
    "output": "∀x (PhDStudent(x) → GraduateStudent(x))"
  },
  {
    "input": "Translate into first-order logic: If Joe is a graduate student or a doctor (but not both), then Joe is not a graduate student and a student.",
    "output": "GraduateStudent(joe) ⊕  Doctor(joe) → ¬(GraduateStudent(joe) ^ Student(joe))"
  },
  {
    "input": "Translate into first-order logic: No students are doctors.",
    "output": "∀x (Student(x) → ¬Doctor(x))"
  },
  {
    "input": "Translate into first-order logic: All people taking classes are students.",
    "output": "∀x (TakingClass(x) → Student(x))"
  },
  {
    "input": "Translate into first-order logic: All graduate students are people taking classes.",
    "output": "∀x (GraduateStudent(x) → TakingClass(x))"
  },
  {
    "input": "Translate into first-order logic: All PhD students are graduate students.",
    "output": "∀x (PhDStudent(x) → GraduateStudent(x))"
  },
  {
    "input": "Translate into first-order logic: If Joe is a graduate student or a doctor (but not both), then Joe is not a graduate student and a student.",
    "output": "GraduateStudent(joe) ⊕  Doctor(joe) → ¬(GraduateStudent(joe) ^ Student(joe))"
  },
  {
    "input": "Translate into first-order logic: Hugh Vanstone is one of the world's leading lighting designers.",
    "output": "WorldLeadingLightningDesigner(hughVanstone)"
  },
  {
    "input": "Translate into first-order logic: Hugh Vanstone is from the UK.",
    "output": "FromUK(hughVanstone)"
  },
  {
    "input": "Translate into first-order logic: Hugh Vanstone has lit more than 160 productions.",
    "output": "LitOver160Productions(hughVanstone)"
  },
  {
    "input": "Translate into first-order logic: Hugh Vanstone attended school where he is from.",
    "output": "AttendedSchoolWhereFrom(hughVanstone)"
  },
  {
    "input": "Translate into first-order logic: Hugh Vanstone is one of the world's leading lighting designers.",
    "output": "WorldLeadingLightningDesigner(hughVanstone)"
  },
  {
    "input": "Translate into first-order logic: Hugh Vanstone is from the UK.",
    "output": "FromUK(hughVanstone)"
  },
  {
    "input": "Translate into first-order logic: Hugh Vanstone has lit more than 160 productions.",
    "output": "LitOver160Productions(hughVanstone)"
  },
  {
    "input": "Translate into first-order logic: Hugh Vanstone attended school where he is from.",
    "output": "AttendedSchoolWhereFrom(hughVanstone)"
  },
  {
    "input": "Translate into first-order logic: Hugh Vanstone is one of the world's leading lighting designers.",
    "output": "WorldLeadingLightningDesigner(hughVanstone)"
  },
  {
    "input": "Translate into first-order logic: Hugh Vanstone is from the UK.",
    "output": "FromUK(hughVanstone)"
  },
  {
    "input": "Translate into first-order logic: Hugh Vanstone has lit more than 160 productions.",
    "output": "LitOver160Productions(hughVanstone)"
  },
  {
    "input": "Translate into first-order logic: Hugh Vanstone attended school where he is from.",
    "output": "AttendedSchoolWhereFrom(hughVanstone)"
  },
  {
    "input": "Translate into first-order logic: No man can run faster than Bolt.",
    "output": "∀x (Man(x) → ¬FasterThanBolt(x))"
  },
  {
    "input": "Translate into first-order logic: Superman is not a man.",
    "output": "¬Man(superman) "
  },
  {
    "input": "Translate into first-order logic: Donald Ervin Knuth is an American computer scientist, mathematician, and Professor Emeritus at Stanford University.",
    "output": "AmericanComputerScientist(donaldErvinKnuth) ∧ Mathematician(donaldErvinKnuth) ∧ ProfessorStanford(donaldErvinKnuth)"
  },
  {
    "input": "Translate into first-order logic: Knuth has been called the \"father of the analysis of algorithms\".",
    "output": "BeCalled(donaldErvinKnuth, fatherOfTheAnalysisOfAlgorithms)"
  },
  {
    "input": "Translate into first-order logic: Donald Ervin Knuth is an American computer scientist, mathematician, and Professor Emeritus at Stanford University.",
    "output": "AmericanComputerScientist(donaldErvinKnuth) ∧ Mathematician(donaldErvinKnuth) ∧ ProfessorStanford(donaldErvinKnuth)"
  },
  {
    "input": "Translate into first-order logic: Knuth has been called the \"father of the analysis of algorithms\".",
    "output": "BeCalled(donaldErvinKnuth, fatherOfTheAnalysisOfAlgorithms)"
  },
  {
    "input": "Translate into first-order logic: Donald Ervin Knuth is an American computer scientist, mathematician, and Professor Emeritus at Stanford University.",
    "output": "AmericanComputerScientist(donaldErvinKnuth) ∧ Mathematician(donaldErvinKnuth) ∧ ProfessorStanford(donaldErvinKnuth)"
  },
  {
    "input": "Translate into first-order logic: Knuth has been called the \"father of the analysis of algorithms\".",
    "output": "BeCalled(donaldErvinKnuth, fatherOfTheAnalysisOfAlgorithms)"
  },
  {
    "input": "Translate into first-order logic: Neocrepidodera Corpulentas are flea beetles or moths.",
    "output": "FleaBeetle(neocrepidoderacorpulenta) ∨ Moth(neocrepidoderacorpulenta)"
  },
  {
    "input": "Translate into first-order logic: The species Neocrepidodera Corpulenta is in the Chrysomelidae family.",
    "output": "Species(neocrepidoderacorpulenta) ∧ Family(chrysomelidae) ∧ In(neocrepidoderacorpulenta, chrysomelidae)"
  },
  {
    "input": "Translate into first-order logic: There are no moths within the Chrysomelidae family.",
    "output": "∀x (In(x, chrysomelidae) ∧ Family(chrysomelidae) → ¬Moth(x))"
  },
  {
    "input": "Translate into first-order logic: Neocrepidodera Corpulentas are flea beetles or moths.",
    "output": "FleaBeetle(neocrepidoderacorpulenta) ∨ Moth(neocrepidoderacorpulenta)"
  },
  {
    "input": "Translate into first-order logic: The species Neocrepidodera Corpulenta is in the Chrysomelidae family.",
    "output": "Species(neocrepidoderacorpulenta) ∧ Family(chrysomelidae) ∧ In(neocrepidoderacorpulenta, chrysomelidae)"
  },
  {
    "input": "Translate into first-order logic: There are no moths within the Chrysomelidae family.",
    "output": "∀x (In(x, chrysomelidae) ∧ Family(chrysomelidae) → ¬Moth(x))"
  },
  {
    "input": "Translate into first-order logic: Carrozzeria Colli is a Milanese coachbuilder company that was established by Giuseppe Colli in 1931.",
    "output": "MilaneseCoachbuilderCompany(carrozzeriacolli) ∧ EstablishedBy(carrozzeriacolli, giuseppecolli) ∧ EstablishedIn(carrozzeriacolli, y1901)"
  },
  {
    "input": "Translate into first-order logic: Carrozzeria Colli is a company that specialized in using aluminum.",
    "output": "SpecializedIn(carrozzeriacolli, usingaluminum)"
  },
  {
    "input": "Translate into first-order logic: The first automobiles built by Carrozzeria Colli were racing cars.",
    "output": "∀x (FirstAutomobilesBy(x, carrozzeriacolli) → Racingcar(x))"
  },
  {
    "input": "Translate into first-order logic: Some racing cars built by Carrozzeria Colli used Fiat 1100 mechanicals and chasis.",
    "output": "∃x (RacingCar(x) ∧ BuiltBy(x, carrozzeriacolli) ∧ Used(x, fiat110mechanicals) ∧ Used(x, chasis))"
  },
  {
    "input": "Translate into first-order logic: Carrozzeria Colli worked for airforces.",
    "output": "∃x (Airforce(x) ∧ WorkedFor(carrozzeriacolli, x))"
  },
  {
    "input": "Translate into first-order logic: Carrozzeria Colli made car bodies.",
    "output": "Made(carrozzeriacolli, carbodies)"
  },
  {
    "input": "Translate into first-order logic: Carrozzeria Colli is a Milanese coachbuilder company that was established by Giuseppe Colli in 1931.",
    "output": "MilaneseCoachbuilderCompany(carrozzeriacolli) ∧ EstablishedBy(carrozzeriacolli, giuseppecolli) ∧ EstablishedIn(carrozzeriacolli, y1901)"
  },
  {
    "input": "Translate into first-order logic: Carrozzeria Colli is a company that specialized in using aluminum.",
    "output": "SpecializedIn(carrozzeriacolli, usingaluminum)"
  },
  {
    "input": "Translate into first-order logic: The first automobiles built by Carrozzeria Colli were racing cars.",
    "output": "∀x (FirstAutomobilesBy(x, carrozzeriacolli) → Racingcar(x))"
  },
  {
    "input": "Translate into first-order logic: Some racing cars built by Carrozzeria Colli used Fiat 1100 mechanicals and chasis.",
    "output": "∃x (RacingCar(x) ∧ BuiltBy(x, carrozzeriacolli) ∧ Used(x, fiat110mechanicals) ∧ Used(x, chasis))"
  },
  {
    "input": "Translate into first-order logic: Carrozzeria Colli worked for airforces.",
    "output": "∃x (Airforce(x) ∧ WorkedFor(carrozzeriacolli, x))"
  },
  {
    "input": "Translate into first-order logic: Carrozzeria Colli made car bodies.",
    "output": "Made(carrozzeriacolli, carbodies)"
  },
  {
    "input": "Translate into first-order logic: Carrozzeria Colli is a Milanese coachbuilder company that was established by Giuseppe Colli in 1931.",
    "output": "MilaneseCoachbuilderCompany(carrozzeriacolli) ∧ EstablishedBy(carrozzeriacolli, giuseppecolli) ∧ EstablishedIn(carrozzeriacolli, y1901)"
  },
  {
    "input": "Translate into first-order logic: Carrozzeria Colli is a company that specialized in using aluminum.",
    "output": "SpecializedIn(carrozzeriacolli, usingaluminum)"
  },
  {
    "input": "Translate into first-order logic: The first automobiles built by Carrozzeria Colli were racing cars.",
    "output": "∀x (FirstAutomobilesBy(x, carrozzeriacolli) → Racingcar(x))"
  },
  {
    "input": "Translate into first-order logic: Some racing cars built by Carrozzeria Colli used Fiat 1100 mechanicals and chasis.",
    "output": "∃x (RacingCar(x) ∧ BuiltBy(x, carrozzeriacolli) ∧ Used(x, fiat110mechanicals) ∧ Used(x, chasis))"
  },
  {
    "input": "Translate into first-order logic: Carrozzeria Colli worked for airforces.",
    "output": "∃x (Airforce(x) ∧ WorkedFor(carrozzeriacolli, x))"
  },
  {
    "input": "Translate into first-order logic: Carrozzeria Colli made car bodies.",
    "output": "Made(carrozzeriacolli, carbodies)"
  },
  {
    "input": "Translate into first-order logic: Carrozzeria Colli is a Milanese coachbuilder company that was established by Giuseppe Colli in 1931.",
    "output": "MilaneseCoachbuilderCompany(carrozzeriacolli) ∧ EstablishedBy(carrozzeriacolli, giuseppecolli) ∧ EstablishedIn(carrozzeriacolli, y1901)"
  },
  {
    "input": "Translate into first-order logic: Carrozzeria Colli is a company that specialized in using aluminum.",
    "output": "SpecializedIn(carrozzeriacolli, usingaluminum)"
  },
  {
    "input": "Translate into first-order logic: The first automobiles built by Carrozzeria Colli were racing cars.",
    "output": "∀x (FirstAutomobilesBy(x, carrozzeriacolli) → Racingcar(x))"
  },
  {
    "input": "Translate into first-order logic: Some racing cars built by Carrozzeria Colli used Fiat 1100 mechanicals and chasis.",
    "output": "∃x (RacingCar(x) ∧ BuiltBy(x, carrozzeriacolli) ∧ Used(x, fiat110mechanicals) ∧ Used(x, chasis))"
  },
  {
    "input": "Translate into first-order logic: Carrozzeria Colli worked for airforces.",
    "output": "∃x (Airforce(x) ∧ WorkedFor(carrozzeriacolli, x))"
  },
  {
    "input": "Translate into first-order logic: Carrozzeria Colli made car bodies.",
    "output": "Made(carrozzeriacolli, carbodies)"
  },
  {
    "input": "Translate into first-order logic: Carrozzeria Colli is a Milanese coachbuilder company that was established by Giuseppe Colli in 1931.",
    "output": "MilaneseCoachbuilderCompany(carrozzeriacolli) ∧ EstablishedBy(carrozzeriacolli, giuseppecolli) ∧ EstablishedIn(carrozzeriacolli, y1901)"
  },
  {
    "input": "Translate into first-order logic: Carrozzeria Colli is a company that specialized in using aluminum.",
    "output": "SpecializedIn(carrozzeriacolli, usingaluminum)"
  },
  {
    "input": "Translate into first-order logic: The first automobiles built by Carrozzeria Colli were racing cars.",
    "output": "∀x (FirstAutomobilesBy(x, carrozzeriacolli) → Racingcar(x))"
  },
  {
    "input": "Translate into first-order logic: Some racing cars built by Carrozzeria Colli used Fiat 1100 mechanicals and chasis.",
    "output": "∃x (RacingCar(x) ∧ BuiltBy(x, carrozzeriacolli) ∧ Used(x, fiat110mechanicals) ∧ Used(x, chasis))"
  },
  {
    "input": "Translate into first-order logic: Carrozzeria Colli worked for airforces.",
    "output": "∃x (Airforce(x) ∧ WorkedFor(carrozzeriacolli, x))"
  },
  {
    "input": "Translate into first-order logic: Carrozzeria Colli made car bodies.",
    "output": "Made(carrozzeriacolli, carbodies)"
  },
  {
    "input": "Translate into first-order logic: John will go to the cinema if and only if Jack goes to the cinema today.",
    "output": "GoToTheCinema(john, today) ↔ GoToTheCinema(jack, today)"
  },
  {
    "input": "Translate into first-order logic: Jack will go to the cinema if and only if Iron Man is on and the weather is not bad today.",
    "output": "GoToTheCinema(jack, today) ↔ (Movie(ironman) ∧ ¬BadWeather(today))"
  },
  {
    "input": "Translate into first-order logic: Some days in March have bad weather.",
    "output": "∃x (Month(march) → BadWeather(x))"
  },
  {
    "input": "Translate into first-order logic: Iron man is on.",
    "output": "Movie(ironman)"
  },
  {
    "input": "Translate into first-order logic: It's March now.",
    "output": "Month(march)"
  },
  {
    "input": "Translate into first-order logic: John will go to the cinema if and only if Jack goes to the cinema today.",
    "output": "GoToTheCinema(john, today) ↔ GoToTheCinema(jack, today)"
  },
  {
    "input": "Translate into first-order logic: Jack will go to the cinema if and only if Iron Man is on and the weather is not bad today.",
    "output": "GoToTheCinema(jack, today) ↔ (Movie(ironman) ∧ ¬BadWeather(today))"
  },
  {
    "input": "Translate into first-order logic: Some days in March have bad weather.",
    "output": "∃x (Month(march) → BadWeather(x))"
  },
  {
    "input": "Translate into first-order logic: Iron man is on.",
    "output": "Movie(ironman)"
  },
  {
    "input": "Translate into first-order logic: It's March now.",
    "output": "Month(march)"
  },
  {
    "input": "Translate into first-order logic: Quiksilver sells sportswear, clothing, footwear, and accessories.",
    "output": "∀x (QuiksilverSells(x) → Sportswear(x) ∨ Clothing(x) ∨ Footwear(x) ∨ Accessory(x))"
  },
  {
    "input": "Translate into first-order logic: Flannels are a type of clothing.",
    "output": "Clothing(flannel)"
  },
  {
    "input": "Translate into first-order logic: Joe owns an item fron Quiksilver.",
    "output": "∃x (QuiksilverSells(x) → JoeOwns(x))"
  },
  {
    "input": "Translate into first-order logic: Quiksilver sells sportswear, clothing, footwear, and accessories.",
    "output": "∀x (QuiksilverSells(x) → Sportswear(x) ∨ Clothing(x) ∨ Footwear(x) ∨ Accessory(x))"
  },
  {
    "input": "Translate into first-order logic: Flannels are a type of clothing.",
    "output": "Clothing(flannel)"
  },
  {
    "input": "Translate into first-order logic: Joe owns an item fron Quiksilver.",
    "output": "∃x (QuiksilverSells(x) → JoeOwns(x))"
  },
  {
    "input": "Translate into first-order logic: Quiksilver sells sportswear, clothing, footwear, and accessories.",
    "output": "∀x (QuiksilverSells(x) → Sportswear(x) ∨ Clothing(x) ∨ Footwear(x) ∨ Accessory(x))"
  },
  {
    "input": "Translate into first-order logic: Flannels are a type of clothing.",
    "output": "Clothing(flannel)"
  },
  {
    "input": "Translate into first-order logic: Joe owns an item fron Quiksilver.",
    "output": "∃x (QuiksilverSells(x) → JoeOwns(x))"
  },
  {
    "input": "Translate into first-order logic: No video games released by Nintendo support the PS4 platform.",
    "output": "∀x (Nintendo(x) → ¬SupportPS4(x))"
  },
  {
    "input": "Translate into first-order logic: All video games in the Pokemon series are released by Nintendo.",
    "output": "∀x (Pokemon(x) → Nintendo(x))"
  },
  {
    "input": "Translate into first-order logic: All video games in the FIFA series support the PS4 platform.",
    "output": "∀x (FIFA(x) → SupportPS4(x))"
  },
  {
    "input": "Translate into first-order logic: All video games supporting users to simulate playing soccer games online are in the FIFA series.",
    "output": "∀x (SoccerOnline(x) → FIFA(x))"
  },
  {
    "input": "Translate into first-order logic: The video game named “Be Lionel” is in the Pokemon series or supports users to simulate playing football games online.",
    "output": "Pokemon(belionel) ⊕ SoccerOnline(belionel)"
  },
  {
    "input": "Translate into first-order logic: No video games released by Nintendo support the PS4 platform.",
    "output": "∀x (Nintendo(x) → ¬SupportPS4(x))"
  },
  {
    "input": "Translate into first-order logic: All video games in the Pokemon series are released by Nintendo.",
    "output": "∀x (Pokemon(x) → Nintendo(x))"
  },
  {
    "input": "Translate into first-order logic: All video games in the FIFA series support the PS4 platform.",
    "output": "∀x (FIFA(x) → SupportPS4(x))"
  },
  {
    "input": "Translate into first-order logic: All video games supporting users to simulate playing soccer games online are in the FIFA series.",
    "output": "∀x (SoccerOnline(x) → FIFA(x))"
  },
  {
    "input": "Translate into first-order logic: The video game named “Be Lionel” is in the Pokemon series or supports users to simulate playing football games online.",
    "output": "Pokemon(belionel) ⊕ SoccerOnline(belionel)"
  },
  {
    "input": "Translate into first-order logic: No video games released by Nintendo support the PS4 platform.",
    "output": "∀x (Nintendo(x) → ¬SupportPS4(x))"
  },
  {
    "input": "Translate into first-order logic: All video games in the Pokemon series are released by Nintendo.",
    "output": "∀x (Pokemon(x) → Nintendo(x))"
  },
  {
    "input": "Translate into first-order logic: All video games in the FIFA series support the PS4 platform.",
    "output": "∀x (FIFA(x) → SupportPS4(x))"
  },
  {
    "input": "Translate into first-order logic: All video games supporting users to simulate playing soccer games online are in the FIFA series.",
    "output": "∀x (SoccerOnline(x) → FIFA(x))"
  },
  {
    "input": "Translate into first-order logic: The video game named “Be Lionel” is in the Pokemon series or supports users to simulate playing football games online.",
    "output": "Pokemon(belionel) ⊕ SoccerOnline(belionel)"
  },
  {
    "input": "Translate into first-order logic: No video games released by Nintendo support the PS4 platform.",
    "output": "∀x (Nintendo(x) → ¬SupportPS4(x))"
  },
  {
    "input": "Translate into first-order logic: All video games in the Pokemon series are released by Nintendo.",
    "output": "∀x (Pokemon(x) → Nintendo(x))"
  },
  {
    "input": "Translate into first-order logic: All video games in the FIFA series support the PS4 platform.",
    "output": "∀x (FIFA(x) → SupportPS4(x))"
  },
  {
    "input": "Translate into first-order logic: All video games supporting users to simulate playing soccer games online are in the FIFA series.",
    "output": "∀x (SoccerOnline(x) → FIFA(x))"
  },
  {
    "input": "Translate into first-order logic: The video game named “Be Lionel” is in the Pokemon series or supports users to simulate playing football games online.",
    "output": "Pokemon(belionel) ⊕ SoccerOnline(belionel)"
  },
  {
    "input": "Translate into first-order logic: No payment cards issued by Russian banks can be used with ApplePay.",
    "output": "∀x (RussianBank(x) → ¬ApplePay(x))"
  },
  {
    "input": "Translate into first-order logic: All MIR payment cards are issued by Russian banks.",
    "output": "∀x (Mir(x) → RussianBank(x))"
  },
  {
    "input": "Translate into first-order logic: Some international payment cards can be used with ApplePay.",
    "output": "∃x (International(x) → ApplePay(x))"
  },
  {
    "input": "Translate into first-order logic: Social payments in Russia can only be transferred to MIR payment cards.",
    "output": "∀x (SocialRussia(x) → Mir(x))"
  },
  {
    "input": "Translate into first-order logic: Bank of America payment cards can be used with ApplePay.",
    "output": "ApplePay(boapaymentcards)"
  },
  {
    "input": "Translate into first-order logic: No payment cards issued by Russian banks can be used with ApplePay.",
    "output": "∀x (RussianBank(x) → ¬ApplePay(x))"
  },
  {
    "input": "Translate into first-order logic: All MIR payment cards are issued by Russian banks.",
    "output": "∀x (Mir(x) → RussianBank(x))"
  },
  {
    "input": "Translate into first-order logic: Some international payment cards can be used with ApplePay.",
    "output": "∃x (International(x) → ApplePay(x))"
  },
  {
    "input": "Translate into first-order logic: Social payments in Russia can only be transferred to MIR payment cards.",
    "output": "∀x (SocialRussia(x) → Mir(x))"
  },
  {
    "input": "Translate into first-order logic: Bank of America payment cards can be used with ApplePay.",
    "output": "ApplePay(boapaymentcards)"
  },
  {
    "input": "Translate into first-order logic: No payment cards issued by Russian banks can be used with ApplePay.",
    "output": "∀x (RussianBank(x) → ¬ApplePay(x))"
  },
  {
    "input": "Translate into first-order logic: All MIR payment cards are issued by Russian banks.",
    "output": "∀x (Mir(x) → RussianBank(x))"
  },
  {
    "input": "Translate into first-order logic: Some international payment cards can be used with ApplePay.",
    "output": "∃x (International(x) → ApplePay(x))"
  },
  {
    "input": "Translate into first-order logic: Social payments in Russia can only be transferred to MIR payment cards.",
    "output": "∀x (SocialRussia(x) → Mir(x))"
  },
  {
    "input": "Translate into first-order logic: Bank of America payment cards can be used with ApplePay.",
    "output": "ApplePay(boapaymentcards)"
  },
  {
    "input": "Translate into first-order logic: The Lumina APV is produced by Chevrolet.",
    "output": "Chevrolet(luminaAPV)"
  },
  {
    "input": "Translate into first-order logic: The Astro is a van produced by Chevrolet.",
    "output": "Chevrolet(astro) ∧ Van(astro)"
  },
  {
    "input": "Translate into first-order logic: Cars produced by Chevrolet are either cars or vans.",
    "output": "∀x (Chevrolet(x) → Car(x) ⊕ Van(x))"
  },
  {
    "input": "Translate into first-order logic: The Lumina APV is produced by Chevrolet.",
    "output": "Chevrolet(luminaAPV)"
  },
  {
    "input": "Translate into first-order logic: The Astro is a van produced by Chevrolet.",
    "output": "Chevrolet(astro) ∧ Van(astro)"
  },
  {
    "input": "Translate into first-order logic: Cars produced by Chevrolet are either cars or vans.",
    "output": "∀x (Chevrolet(x) → Car(x) ⊕ Van(x))"
  },
  {
    "input": "Translate into first-order logic: The Lumina APV is produced by Chevrolet.",
    "output": "Chevrolet(luminaAPV)"
  },
  {
    "input": "Translate into first-order logic: The Astro is a van produced by Chevrolet.",
    "output": "Chevrolet(astro) ∧ Van(astro)"
  },
  {
    "input": "Translate into first-order logic: Cars produced by Chevrolet are either cars or vans.",
    "output": "∀x (Chevrolet(x) → Car(x) ⊕ Van(x))"
  },
  {
    "input": "Translate into first-order logic: The Lumina APV is produced by Chevrolet.",
    "output": "Chevrolet(luminaAPV)"
  },
  {
    "input": "Translate into first-order logic: The Astro is a van produced by Chevrolet.",
    "output": "Chevrolet(astro) ∧ Van(astro)"
  },
  {
    "input": "Translate into first-order logic: Cars produced by Chevrolet are either cars or vans.",
    "output": "∀x (Chevrolet(x) → Car(x) ⊕ Van(x))"
  },
  {
    "input": "Translate into first-order logic: Everyone who works in person is a commuter.",
    "output": "∀x (InPerson(x) → Commuter(x))"
  },
  {
    "input": "Translate into first-order logic: People either work in person or work from home.",
    "output": "∀x (InPerson(x) ⊕ FromHome(x))"
  },
  {
    "input": "Translate into first-order logic: Everyone who works from home has a relaxed schedule.",
    "output": "∀x (FromHome(x) → Relaxed(x))"
  },
  {
    "input": "Translate into first-order logic: George is either a commuter or has a home office setup.",
    "output": "Commuter(george) ⊕ HomeOffice(george)"
  },
  {
    "input": "Translate into first-order logic: If George is either a person who works from home or has a home office setup, then George is not a person who works from home and a commuter.",
    "output": "FromHome(george) ⊕ HomeOffice(george) → ¬(FromHome(george) ∧ Commuter(george))"
  },
  {
    "input": "Translate into first-order logic: Everyone who works in person is a commuter.",
    "output": "∀x (InPerson(x) → Commuter(x))"
  },
  {
    "input": "Translate into first-order logic: People either work in person or work from home.",
    "output": "∀x (InPerson(x) ⊕ FromHome(x))"
  },
  {
    "input": "Translate into first-order logic: Everyone who works from home has a relaxed schedule.",
    "output": "∀x (FromHome(x) → Relaxed(x))"
  },
  {
    "input": "Translate into first-order logic: George is either a commuter or has a home office setup.",
    "output": "Commuter(george) ⊕ HomeOffice(george)"
  },
  {
    "input": "Translate into first-order logic: If George is either a person who works from home or has a home office setup, then George is not a person who works from home and a commuter.",
    "output": "FromHome(george) ⊕ HomeOffice(george) → ¬(FromHome(george) ∧ Commuter(george))"
  },
  {
    "input": "Translate into first-order logic: Everyone who works in person is a commuter.",
    "output": "∀x (InPerson(x) → Commuter(x))"
  },
  {
    "input": "Translate into first-order logic: People either work in person or work from home.",
    "output": "∀x (InPerson(x) ⊕ FromHome(x))"
  },
  {
    "input": "Translate into first-order logic: Everyone who works from home has a relaxed schedule.",
    "output": "∀x (FromHome(x) → Relaxed(x))"
  },
  {
    "input": "Translate into first-order logic: George is either a commuter or has a home office setup.",
    "output": "Commuter(george) ⊕ HomeOffice(george)"
  },
  {
    "input": "Translate into first-order logic: If George is either a person who works from home or has a home office setup, then George is not a person who works from home and a commuter.",
    "output": "FromHome(george) ⊕ HomeOffice(george) → ¬(FromHome(george) ∧ Commuter(george))"
  },
  {
    "input": "Translate into first-order logic: Jason Kramer is an American music supervisor.",
    "output": "MusicSupervisor(jasonKramer) ∧ American(jasonKramer)"
  },
  {
    "input": "Translate into first-order logic: Some American radio personalities are also music supervisors.",
    "output": "∃x (American(x) ∧ MusicSupervisor(x) ∧ RadioPersonality(x))"
  },
  {
    "input": "Translate into first-order logic: Anyone who hosts a show on a public radio station is a radio personality.",
    "output": "∀x (HostShowOnPublicRadioStation(x) → RadioPersonality(x))"
  },
  {
    "input": "Translate into first-order logic: Joe Rogan is a radio personality.",
    "output": "RadioPersonality(joeRogan)"
  },
  {
    "input": "Translate into first-order logic: Jason Kramer hosted a show on a public radio station.",
    "output": "HostShowOnPublicRadioStation(jasonKramer)"
  },
  {
    "input": "Translate into first-order logic: Jason Kramer is an American music supervisor.",
    "output": "MusicSupervisor(jasonKramer) ∧ American(jasonKramer)"
  },
  {
    "input": "Translate into first-order logic: Some American radio personalities are also music supervisors.",
    "output": "∃x (American(x) ∧ MusicSupervisor(x) ∧ RadioPersonality(x))"
  },
  {
    "input": "Translate into first-order logic: Anyone who hosts a show on a public radio station is a radio personality.",
    "output": "∀x (HostShowOnPublicRadioStation(x) → RadioPersonality(x))"
  },
  {
    "input": "Translate into first-order logic: Joe Rogan is a radio personality.",
    "output": "RadioPersonality(joeRogan)"
  },
  {
    "input": "Translate into first-order logic: Jason Kramer hosted a show on a public radio station.",
    "output": "HostShowOnPublicRadioStation(jasonKramer)"
  },
  {
    "input": "Translate into first-order logic: Jason Kramer is an American music supervisor.",
    "output": "MusicSupervisor(jasonKramer) ∧ American(jasonKramer)"
  },
  {
    "input": "Translate into first-order logic: Some American radio personalities are also music supervisors.",
    "output": "∃x (American(x) ∧ MusicSupervisor(x) ∧ RadioPersonality(x))"
  },
  {
    "input": "Translate into first-order logic: Anyone who hosts a show on a public radio station is a radio personality.",
    "output": "∀x (HostShowOnPublicRadioStation(x) → RadioPersonality(x))"
  },
  {
    "input": "Translate into first-order logic: Joe Rogan is a radio personality.",
    "output": "RadioPersonality(joeRogan)"
  },
  {
    "input": "Translate into first-order logic: Jason Kramer hosted a show on a public radio station.",
    "output": "HostShowOnPublicRadioStation(jasonKramer)"
  },
  {
    "input": "Translate into first-order logic: No coffee sold in Walmart is produced in France.",
    "output": "∀x (Walmart(x) → ¬France(x))"
  },
  {
    "input": "Translate into first-order logic: All coffee supplied by the company is sold in Walmart.",
    "output": "∀x (Company(x) → Walmart(x))"
  },
  {
    "input": "Translate into first-order logic: All coffee produced in Columbia is produced in France.",
    "output": "∀x (Columbia(x) → France(x))"
  },
  {
    "input": "Translate into first-order logic: All coffee favored by local residents is coffee produced in Columbia.",
    "output": "∀x (Favored(x) → Columbia(x))"
  },
  {
    "input": "Translate into first-order logic: All coffee with high prices is favored by local residents.",
    "output": "∀x (HighPrice(x) → Favored(x))"
  },
  {
    "input": "Translate into first-order logic: Civet Coffee is not produced in Columbia and is cheap.",
    "output": "¬(Columbia(civetcoffee) ∧ HighPrice(civetcoffee))"
  },
  {
    "input": "Translate into first-order logic: Jamaica Blue is sold in Walmart or favored by local residents.",
    "output": "Walmart(jamaicablue) ∨ Favored(jamaicablue)"
  },
  {
    "input": "Translate into first-order logic: No coffee sold in Walmart is produced in France.",
    "output": "∀x (Walmart(x) → ¬France(x))"
  },
  {
    "input": "Translate into first-order logic: All coffee supplied by the company is sold in Walmart.",
    "output": "∀x (Company(x) → Walmart(x))"
  },
  {
    "input": "Translate into first-order logic: All coffee produced in Columbia is produced in France.",
    "output": "∀x (Columbia(x) → France(x))"
  },
  {
    "input": "Translate into first-order logic: All coffee favored by local residents is coffee produced in Columbia.",
    "output": "∀x (Favored(x) → Columbia(x))"
  },
  {
    "input": "Translate into first-order logic: All coffee with high prices is favored by local residents.",
    "output": "∀x (HighPrice(x) → Favored(x))"
  },
  {
    "input": "Translate into first-order logic: Civet Coffee is not produced in Columbia and is cheap.",
    "output": "¬(Columbia(civetcoffee) ∧ HighPrice(civetcoffee))"
  },
  {
    "input": "Translate into first-order logic: Jamaica Blue is sold in Walmart or favored by local residents.",
    "output": "Walmart(jamaicablue) ∨ Favored(jamaicablue)"
  },
  {
    "input": "Translate into first-order logic: No coffee sold in Walmart is produced in France.",
    "output": "∀x (Walmart(x) → ¬France(x))"
  },
  {
    "input": "Translate into first-order logic: All coffee supplied by the company is sold in Walmart.",
    "output": "∀x (Company(x) → Walmart(x))"
  },
  {
    "input": "Translate into first-order logic: All coffee produced in Columbia is produced in France.",
    "output": "∀x (Columbia(x) → France(x))"
  },
  {
    "input": "Translate into first-order logic: All coffee favored by local residents is coffee produced in Columbia.",
    "output": "∀x (Favored(x) → Columbia(x))"
  },
  {
    "input": "Translate into first-order logic: All coffee with high prices is favored by local residents.",
    "output": "∀x (HighPrice(x) → Favored(x))"
  },
  {
    "input": "Translate into first-order logic: Civet Coffee is not produced in Columbia and is cheap.",
    "output": "¬(Columbia(civetcoffee) ∧ HighPrice(civetcoffee))"
  },
  {
    "input": "Translate into first-order logic: Jamaica Blue is sold in Walmart or favored by local residents.",
    "output": "Walmart(jamaicablue) ∨ Favored(jamaicablue)"
  },
  {
    "input": "Translate into first-order logic: No coffee sold in Walmart is produced in France.",
    "output": "∀x (Walmart(x) → ¬France(x))"
  },
  {
    "input": "Translate into first-order logic: All coffee supplied by the company is sold in Walmart.",
    "output": "∀x (Company(x) → Walmart(x))"
  },
  {
    "input": "Translate into first-order logic: All coffee produced in Columbia is produced in France.",
    "output": "∀x (Columbia(x) → France(x))"
  },
  {
    "input": "Translate into first-order logic: All coffee favored by local residents is coffee produced in Columbia.",
    "output": "∀x (Favored(x) → Columbia(x))"
  },
  {
    "input": "Translate into first-order logic: All coffee with high prices is favored by local residents.",
    "output": "∀x (HighPrice(x) → Favored(x))"
  },
  {
    "input": "Translate into first-order logic: Civet Coffee is not produced in Columbia and is cheap.",
    "output": "¬(Columbia(civetcoffee) ∧ HighPrice(civetcoffee))"
  },
  {
    "input": "Translate into first-order logic: Jamaica Blue is sold in Walmart or favored by local residents.",
    "output": "Walmart(jamaicablue) ∨ Favored(jamaicablue)"
  },
  {
    "input": "Translate into first-order logic: There are two places named Galicia: either in Spain or in Poland.",
    "output": "∀x (Galicia(x) → Spain(x) ⊕ Poland(x))"
  },
  {
    "input": "Translate into first-order logic: Spain is in Europe.",
    "output": "∀x (Spain(x) → Europe(x))"
  },
  {
    "input": "Translate into first-order logic: Poland is in Europe.",
    "output": "∀x (Poland(x) → Europe(x))"
  },
  {
    "input": "Translate into first-order logic: Rochelle lives in Europe.",
    "output": "∀x (RochelleLive(x) → Europe(x))"
  },
  {
    "input": "Translate into first-order logic: Dominique does not live in Europe.",
    "output": "∀x (DominiqueLive(x) → ¬Europe(x))"
  },
  {
    "input": "Translate into first-order logic: Alfonso lives in Galicia.",
    "output": "∀x (AlfonsoLive(x) → Galicia(x))"
  },
  {
    "input": "Translate into first-order logic: There are two places named Galicia: either in Spain or in Poland.",
    "output": "∀x (Galicia(x) → Spain(x) ⊕ Poland(x))"
  },
  {
    "input": "Translate into first-order logic: Spain is in Europe.",
    "output": "∀x (Spain(x) → Europe(x))"
  },
  {
    "input": "Translate into first-order logic: Poland is in Europe.",
    "output": "∀x (Poland(x) → Europe(x))"
  },
  {
    "input": "Translate into first-order logic: Rochelle lives in Europe.",
    "output": "∀x (RochelleLive(x) → Europe(x))"
  },
  {
    "input": "Translate into first-order logic: Dominique does not live in Europe.",
    "output": "∀x (DominiqueLive(x) → ¬Europe(x))"
  },
  {
    "input": "Translate into first-order logic: Alfonso lives in Galicia.",
    "output": "∀x (AlfonsoLive(x) → Galicia(x))"
  },
  {
    "input": "Translate into first-order logic: There are two places named Galicia: either in Spain or in Poland.",
    "output": "∀x (Galicia(x) → Spain(x) ⊕ Poland(x))"
  },
  {
    "input": "Translate into first-order logic: Spain is in Europe.",
    "output": "∀x (Spain(x) → Europe(x))"
  },
  {
    "input": "Translate into first-order logic: Poland is in Europe.",
    "output": "∀x (Poland(x) → Europe(x))"
  },
  {
    "input": "Translate into first-order logic: Rochelle lives in Europe.",
    "output": "∀x (RochelleLive(x) → Europe(x))"
  },
  {
    "input": "Translate into first-order logic: Dominique does not live in Europe.",
    "output": "∀x (DominiqueLive(x) → ¬Europe(x))"
  },
  {
    "input": "Translate into first-order logic: Alfonso lives in Galicia.",
    "output": "∀x (AlfonsoLive(x) → Galicia(x))"
  },
  {
    "input": "Translate into first-order logic: Ralph Hammerthaler was born in Wasserburg am Inn.",
    "output": "BornIn(ralphHammerthaler, wasserburgAmInn)"
  },
  {
    "input": "Translate into first-order logic: Wasserburg am Inn is in Germany.",
    "output": "LocatedIn(wasserbAmInn, germany)"
  },
  {
    "input": "Translate into first-order logic: Germany is in Europe.",
    "output": "LocatedIn(germany, europe)"
  },
  {
    "input": "Translate into first-order logic: Ralph Hammerthaler is a German writer.",
    "output": "Writer(ralphHammerthaler)"
  },
  {
    "input": "Translate into first-order logic: Ralph Hammerthaler was born in 1965.",
    "output": "BornIn1965(ralphHammerthaler)"
  },
  {
    "input": "Translate into first-order logic: Ralph Hammerthaler was born in Wasserburg am Inn.",
    "output": "BornIn(ralphHammerthaler, wasserburgAmInn)"
  },
  {
    "input": "Translate into first-order logic: Wasserburg am Inn is in Germany.",
    "output": "LocatedIn(wasserbAmInn, germany)"
  },
  {
    "input": "Translate into first-order logic: Germany is in Europe.",
    "output": "LocatedIn(germany, europe)"
  },
  {
    "input": "Translate into first-order logic: Ralph Hammerthaler is a German writer.",
    "output": "Writer(ralphHammerthaler)"
  },
  {
    "input": "Translate into first-order logic: Ralph Hammerthaler was born in 1965.",
    "output": "BornIn1965(ralphHammerthaler)"
  },
  {
    "input": "Translate into first-order logic: All books written by Tomas have sold more than 1 million copies.",
    "output": "∀x (WrittenByTomas(x) → SoldOneMillion(x))"
  },
  {
    "input": "Translate into first-order logic: Some books that have won Hugo Awards are written by Tomas.",
    "output": "∃x (WinningHugoAward(x) ∧ WrittenByTomas(x))"
  },
  {
    "input": "Translate into first-order logic: All books about the future are inspired by Shakespeare.",
    "output": "∀x (AboutFuture(x) → InspiredFromShakespeare(x))"
  },
  {
    "input": "Translate into first-order logic: 2001 is a book either inspired from Shakespeare or it has sold more than 1 million copies.",
    "output": "InspiredFromShakespeare(y2001) ⊕ SoldOneMillion(y2001) "
  },
  {
    "input": "Translate into first-order logic: 2001 is a book that has either sold more than 1 million copies or it was written by Tomas.",
    "output": "SoldOneMillion(y2001) ⊕ WrittenByTomas(y2001)"
  },
  {
    "input": "Translate into first-order logic: All books written by Tomas have sold more than 1 million copies.",
    "output": "∀x (WrittenByTomas(x) → SoldOneMillion(x))"
  },
  {
    "input": "Translate into first-order logic: Some books that have won Hugo Awards are written by Tomas.",
    "output": "∃x (WinningHugoAward(x) ∧ WrittenByTomas(x))"
  },
  {
    "input": "Translate into first-order logic: All books about the future are inspired by Shakespeare.",
    "output": "∀x (AboutFuture(x) → InspiredFromShakespeare(x))"
  },
  {
    "input": "Translate into first-order logic: 2001 is a book either inspired from Shakespeare or it has sold more than 1 million copies.",
    "output": "InspiredFromShakespeare(y2001) ⊕ SoldOneMillion(y2001) "
  },
  {
    "input": "Translate into first-order logic: 2001 is a book that has either sold more than 1 million copies or it was written by Tomas.",
    "output": "SoldOneMillion(y2001) ⊕ WrittenByTomas(y2001)"
  },
  {
    "input": "Translate into first-order logic: All books written by Tomas have sold more than 1 million copies.",
    "output": "∀x (WrittenByTomas(x) → SoldOneMillion(x))"
  },
  {
    "input": "Translate into first-order logic: Some books that have won Hugo Awards are written by Tomas.",
    "output": "∃x (WinningHugoAward(x) ∧ WrittenByTomas(x))"
  },
  {
    "input": "Translate into first-order logic: All books about the future are inspired by Shakespeare.",
    "output": "∀x (AboutFuture(x) → InspiredFromShakespeare(x))"
  },
  {
    "input": "Translate into first-order logic: 2001 is a book either inspired from Shakespeare or it has sold more than 1 million copies.",
    "output": "InspiredFromShakespeare(y2001) ⊕ SoldOneMillion(y2001) "
  },
  {
    "input": "Translate into first-order logic: 2001 is a book that has either sold more than 1 million copies or it was written by Tomas.",
    "output": "SoldOneMillion(y2001) ⊕ WrittenByTomas(y2001)"
  },
  {
    "input": "Translate into first-order logic: No grass is food.",
    "output": "∀x (Grass(x) → ¬Food(x))"
  },
  {
    "input": "Translate into first-order logic: All meadows are grass.",
    "output": "∀x (Meadow(x) → Grass(x))"
  },
  {
    "input": "Translate into first-order logic: All edible things are food.",
    "output": "∀x (Edible(x) → Food(x))"
  },
  {
    "input": "Translate into first-order logic: All fruits are edible.",
    "output": "∀x (Fruit(x) → Edible(x))"
  },
  {
    "input": "Translate into first-order logic: All lemons are fruit.",
    "output": "∀x (Lemon(x) → Fruit(x))"
  },
  {
    "input": "Translate into first-order logic: Grapes are not edible and lemons.",
    "output": "¬(Edible(grape) ∧ Lemon(grape))"
  },
  {
    "input": "Translate into first-order logic: Bananas are grass or fruit.",
    "output": "Grass(banana) ∨ Fruit(banana)"
  },
  {
    "input": "Translate into first-order logic: No grass is food.",
    "output": "∀x (Grass(x) → ¬Food(x))"
  },
  {
    "input": "Translate into first-order logic: All meadows are grass.",
    "output": "∀x (Meadow(x) → Grass(x))"
  },
  {
    "input": "Translate into first-order logic: All edible things are food.",
    "output": "∀x (Edible(x) → Food(x))"
  },
  {
    "input": "Translate into first-order logic: All fruits are edible.",
    "output": "∀x (Fruit(x) → Edible(x))"
  },
  {
    "input": "Translate into first-order logic: All lemons are fruit.",
    "output": "∀x (Lemon(x) → Fruit(x))"
  },
  {
    "input": "Translate into first-order logic: Grapes are not edible and lemons.",
    "output": "¬(Edible(grape) ∧ Lemon(grape))"
  },
  {
    "input": "Translate into first-order logic: Bananas are grass or fruit.",
    "output": "Grass(banana) ∨ Fruit(banana)"
  },
  {
    "input": "Translate into first-order logic: No grass is food.",
    "output": "∀x (Grass(x) → ¬Food(x))"
  },
  {
    "input": "Translate into first-order logic: All meadows are grass.",
    "output": "∀x (Meadow(x) → Grass(x))"
  },
  {
    "input": "Translate into first-order logic: All edible things are food.",
    "output": "∀x (Edible(x) → Food(x))"
  },
  {
    "input": "Translate into first-order logic: All fruits are edible.",
    "output": "∀x (Fruit(x) → Edible(x))"
  },
  {
    "input": "Translate into first-order logic: All lemons are fruit.",
    "output": "∀x (Lemon(x) → Fruit(x))"
  },
  {
    "input": "Translate into first-order logic: Grapes are not edible and lemons.",
    "output": "¬(Edible(grape) ∧ Lemon(grape))"
  },
  {
    "input": "Translate into first-order logic: Bananas are grass or fruit.",
    "output": "Grass(banana) ∨ Fruit(banana)"
  },
  {
    "input": "Translate into first-order logic: No grass is food.",
    "output": "∀x (Grass(x) → ¬Food(x))"
  },
  {
    "input": "Translate into first-order logic: All meadows are grass.",
    "output": "∀x (Meadow(x) → Grass(x))"
  },
  {
    "input": "Translate into first-order logic: All edible things are food.",
    "output": "∀x (Edible(x) → Food(x))"
  },
  {
    "input": "Translate into first-order logic: All fruits are edible.",
    "output": "∀x (Fruit(x) → Edible(x))"
  },
  {
    "input": "Translate into first-order logic: All lemons are fruit.",
    "output": "∀x (Lemon(x) → Fruit(x))"
  },
  {
    "input": "Translate into first-order logic: Grapes are not edible and lemons.",
    "output": "¬(Edible(grape) ∧ Lemon(grape))"
  },
  {
    "input": "Translate into first-order logic: Bananas are grass or fruit.",
    "output": "Grass(banana) ∨ Fruit(banana)"
  },
  {
    "input": "Translate into first-order logic: The Golden State Warriors are a team from San Francisco.",
    "output": "Team(goldenstatewarriors) ∧ From(goldenstatewarriors, sanfrancisco)"
  },
  {
    "input": "Translate into first-order logic: The Golden State Warriors won the NBA finals.",
    "output": "Won(goldenstatewarriors, nbafinals)"
  },
  {
    "input": "Translate into first-order logic: All teams attending the NBA finals have more than thirty years of history.",
    "output": "∀x (team(x) ∧ Attending(x, nbafinals) → HasMoreThan(x, thirtyyearsofhistory))"
  },
  {
    "input": "Translate into first-order logic: Boston Celtics are a team that lost the NBA finals.",
    "output": "Team(bostonceltics) ∧ Lost(bostonceltics, nbafinals)"
  },
  {
    "input": "Translate into first-order logic: If a team wins the NBA finals, then they will have more income.",
    "output": "∀x (Team(x) ∧ Won(x, nbafinals) → MoreIncome(x))"
  },
  {
    "input": "Translate into first-order logic: If a team wins or loses at the NBA finals, then they are attending the finals.",
    "output": "∀x (Won(x, nbafinals) ∨ Lost(x, nbafinals) → Attending(x, nbafinals))"
  },
  {
    "input": "Translate into first-order logic: The Golden State Warriors are a team from San Francisco.",
    "output": "Team(goldenstatewarriors) ∧ From(goldenstatewarriors, sanfrancisco)"
  },
  {
    "input": "Translate into first-order logic: The Golden State Warriors won the NBA finals.",
    "output": "Won(goldenstatewarriors, nbafinals)"
  },
  {
    "input": "Translate into first-order logic: All teams attending the NBA finals have more than thirty years of history.",
    "output": "∀x (team(x) ∧ Attending(x, nbafinals) → HasMoreThan(x, thirtyyearsofhistory))"
  },
  {
    "input": "Translate into first-order logic: Boston Celtics are a team that lost the NBA finals.",
    "output": "Team(bostonceltics) ∧ Lost(bostonceltics, nbafinals)"
  },
  {
    "input": "Translate into first-order logic: If a team wins the NBA finals, then they will have more income.",
    "output": "∀x (Team(x) ∧ Won(x, nbafinals) → MoreIncome(x))"
  },
  {
    "input": "Translate into first-order logic: If a team wins or loses at the NBA finals, then they are attending the finals.",
    "output": "∀x (Won(x, nbafinals) ∨ Lost(x, nbafinals) → Attending(x, nbafinals))"
  },
  {
    "input": "Translate into first-order logic: The Golden State Warriors are a team from San Francisco.",
    "output": "Team(goldenstatewarriors) ∧ From(goldenstatewarriors, sanfrancisco)"
  },
  {
    "input": "Translate into first-order logic: The Golden State Warriors won the NBA finals.",
    "output": "Won(goldenstatewarriors, nbafinals)"
  },
  {
    "input": "Translate into first-order logic: All teams attending the NBA finals have more than thirty years of history.",
    "output": "∀x (team(x) ∧ Attending(x, nbafinals) → HasMoreThan(x, thirtyyearsofhistory))"
  },
  {
    "input": "Translate into first-order logic: Boston Celtics are a team that lost the NBA finals.",
    "output": "Team(bostonceltics) ∧ Lost(bostonceltics, nbafinals)"
  },
  {
    "input": "Translate into first-order logic: If a team wins the NBA finals, then they will have more income.",
    "output": "∀x (Team(x) ∧ Won(x, nbafinals) → MoreIncome(x))"
  },
  {
    "input": "Translate into first-order logic: If a team wins or loses at the NBA finals, then they are attending the finals.",
    "output": "∀x (Won(x, nbafinals) ∨ Lost(x, nbafinals) → Attending(x, nbafinals))"
  },
  {
    "input": "Translate into first-order logic: Maya will play violin if and only if she never injures her fingers.",
    "output": "CanInjureFingures(maya) → ¬WillPlayViolin(maya)"
  },
  {
    "input": "Translate into first-order logic: Volleyball players can injure their ankle, fingers, or shoulder.",
    "output": "∀x (VolleyballPlayer(x) → CanInjureFingures(x))"
  },
  {
    "input": "Translate into first-order logic: Maya is a volleyball player.",
    "output": "VolleyballPlayer(maya)"
  },
  {
    "input": "Translate into first-order logic: All devices belonging to the company are connected to Google Home.",
    "output": "∀x (InCompany(x) → GoogleHome(x))"
  },
  {
    "input": "Translate into first-order logic: All devices with the company logo belong to the company.",
    "output": "∀x (CompanyLogo(x) → InCompany(x))"
  },
  {
    "input": "Translate into first-order logic: A device is either with the company logo or belongs to employees.",
    "output": "∀x (CompanyLogo(x) ∨ Employee(x))"
  },
  {
    "input": "Translate into first-order logic: All devices belonging to employees are available to connect to the company's wifi.",
    "output": "∀x (Employee(x) → Wifi(x))"
  },
  {
    "input": "Translate into first-order logic: All devices connected to Google Home are controlled by managers.",
    "output": "∀x (GoogleHome(x) → ControlledByManager(x))"
  },
  {
    "input": "Translate into first-order logic: All devices that connect to the company's wifi are easy to operate.",
    "output": "∀x (Wifi(x) → EasyToOperate(x))"
  },
  {
    "input": "Translate into first-order logic: All devices that are easy to operate are produced after 2020.",
    "output": "∀x (EasyToOperate(x) → ProducedAfter2020(x))"
  },
  {
    "input": "Translate into first-order logic: IPod1 is produced before 2020.",
    "output": "¬ProducedAfter2020(iPod1)"
  },
  {
    "input": "Translate into first-order logic: All devices belonging to the company are connected to Google Home.",
    "output": "∀x (InCompany(x) → GoogleHome(x))"
  },
  {
    "input": "Translate into first-order logic: All devices with the company logo belong to the company.",
    "output": "∀x (CompanyLogo(x) → InCompany(x))"
  },
  {
    "input": "Translate into first-order logic: A device is either with the company logo or belongs to employees.",
    "output": "∀x (CompanyLogo(x) ∨ Employee(x))"
  },
  {
    "input": "Translate into first-order logic: All devices belonging to employees are available to connect to the company's wifi.",
    "output": "∀x (Employee(x) → Wifi(x))"
  },
  {
    "input": "Translate into first-order logic: All devices connected to Google Home are controlled by managers.",
    "output": "∀x (GoogleHome(x) → ControlledByManager(x))"
  },
  {
    "input": "Translate into first-order logic: All devices that connect to the company's wifi are easy to operate.",
    "output": "∀x (Wifi(x) → EasyToOperate(x))"
  },
  {
    "input": "Translate into first-order logic: All devices that are easy to operate are produced after 2020.",
    "output": "∀x (EasyToOperate(x) → ProducedAfter2020(x))"
  },
  {
    "input": "Translate into first-order logic: IPod1 is produced before 2020.",
    "output": "¬ProducedAfter2020(iPod1)"
  },
  {
    "input": "Translate into first-order logic: All devices belonging to the company are connected to Google Home.",
    "output": "∀x (InCompany(x) → GoogleHome(x))"
  },
  {
    "input": "Translate into first-order logic: All devices with the company logo belong to the company.",
    "output": "∀x (CompanyLogo(x) → InCompany(x))"
  },
  {
    "input": "Translate into first-order logic: A device is either with the company logo or belongs to employees.",
    "output": "∀x (CompanyLogo(x) ∨ Employee(x))"
  },
  {
    "input": "Translate into first-order logic: All devices belonging to employees are available to connect to the company's wifi.",
    "output": "∀x (Employee(x) → Wifi(x))"
  },
  {
    "input": "Translate into first-order logic: All devices connected to Google Home are controlled by managers.",
    "output": "∀x (GoogleHome(x) → ControlledByManager(x))"
  },
  {
    "input": "Translate into first-order logic: All devices that connect to the company's wifi are easy to operate.",
    "output": "∀x (Wifi(x) → EasyToOperate(x))"
  },
  {
    "input": "Translate into first-order logic: All devices that are easy to operate are produced after 2020.",
    "output": "∀x (EasyToOperate(x) → ProducedAfter2020(x))"
  },
  {
    "input": "Translate into first-order logic: IPod1 is produced before 2020.",
    "output": "¬ProducedAfter2020(iPod1)"
  },
  {
    "input": "Translate into first-order logic: All devices belonging to the company are connected to Google Home.",
    "output": "∀x (InCompany(x) → GoogleHome(x))"
  },
  {
    "input": "Translate into first-order logic: All devices with the company logo belong to the company.",
    "output": "∀x (CompanyLogo(x) → InCompany(x))"
  },
  {
    "input": "Translate into first-order logic: A device is either with the company logo or belongs to employees.",
    "output": "∀x (CompanyLogo(x) ∨ Employee(x))"
  },
  {
    "input": "Translate into first-order logic: All devices belonging to employees are available to connect to the company's wifi.",
    "output": "∀x (Employee(x) → Wifi(x))"
  },
  {
    "input": "Translate into first-order logic: All devices connected to Google Home are controlled by managers.",
    "output": "∀x (GoogleHome(x) → ControlledByManager(x))"
  },
  {
    "input": "Translate into first-order logic: All devices that connect to the company's wifi are easy to operate.",
    "output": "∀x (Wifi(x) → EasyToOperate(x))"
  },
  {
    "input": "Translate into first-order logic: All devices that are easy to operate are produced after 2020.",
    "output": "∀x (EasyToOperate(x) → ProducedAfter2020(x))"
  },
  {
    "input": "Translate into first-order logic: IPod1 is produced before 2020.",
    "output": "¬ProducedAfter2020(iPod1)"
  },
  {
    "input": "Translate into first-order logic: All CD players are delicate mechanisms.",
    "output": "∀x (CDPlayer(x) → DelicateMechanism(x))"
  },
  {
    "input": "Translate into first-order logic: No delicate mechanisms are suitable toys for children.",
    "output": "∀x (DelicateMechanism(x) → ¬SuitableToyForChildren(x))"
  },
  {
    "input": "Translate into first-order logic: All mammals are living beings.",
    "output": "∀x (Mammal(x) → LivingBeing(x)) "
  },
  {
    "input": "Translate into first-order logic: All elephants are mammals.",
    "output": "∀x (Elephant(x) → Mammal(x))"
  },
  {
    "input": "Translate into first-order logic: All baby elephants are elephants.",
    "output": "∀x (BabyElephant(x) → Elephant(x))"
  },
  {
    "input": "Translate into first-order logic: Some baby elephants are sleepy.",
    "output": "∃x (BabyElephant(x) ∧ Sleepy(x))"
  },
  {
    "input": "Translate into first-order logic: If Jumbo is a living being, then Jumbo is not an elephant or a mammal.",
    "output": "LivingBeing(jumbo) → ¬(Elephant(jumbo) ∨ Mammal(jumbo))"
  },
  {
    "input": "Translate into first-order logic: If Jumbo is sleepy, then Jumbo is a baby elephant or an elephant.",
    "output": "Sleepy(jumbo) → BabyElephant(jumbo) ∨ Mammal(jumbo)"
  },
  {
    "input": "Translate into first-order logic: All mammals are living beings.",
    "output": "∀x (Mammal(x) → LivingBeing(x)) "
  },
  {
    "input": "Translate into first-order logic: All elephants are mammals.",
    "output": "∀x (Elephant(x) → Mammal(x))"
  },
  {
    "input": "Translate into first-order logic: All baby elephants are elephants.",
    "output": "∀x (BabyElephant(x) → Elephant(x))"
  },
  {
    "input": "Translate into first-order logic: Some baby elephants are sleepy.",
    "output": "∃x (BabyElephant(x) ∧ Sleepy(x))"
  },
  {
    "input": "Translate into first-order logic: If Jumbo is a living being, then Jumbo is not an elephant or a mammal.",
    "output": "LivingBeing(jumbo) → ¬(Elephant(jumbo) ∨ Mammal(jumbo))"
  },
  {
    "input": "Translate into first-order logic: If Jumbo is sleepy, then Jumbo is a baby elephant or an elephant.",
    "output": "Sleepy(jumbo) → BabyElephant(jumbo) ∨ Mammal(jumbo)"
  },
  {
    "input": "Translate into first-order logic: All mammals are living beings.",
    "output": "∀x (Mammal(x) → LivingBeing(x)) "
  },
  {
    "input": "Translate into first-order logic: All elephants are mammals.",
    "output": "∀x (Elephant(x) → Mammal(x))"
  },
  {
    "input": "Translate into first-order logic: All baby elephants are elephants.",
    "output": "∀x (BabyElephant(x) → Elephant(x))"
  },
  {
    "input": "Translate into first-order logic: Some baby elephants are sleepy.",
    "output": "∃x (BabyElephant(x) ∧ Sleepy(x))"
  },
  {
    "input": "Translate into first-order logic: If Jumbo is a living being, then Jumbo is not an elephant or a mammal.",
    "output": "LivingBeing(jumbo) → ¬(Elephant(jumbo) ∨ Mammal(jumbo))"
  },
  {
    "input": "Translate into first-order logic: If Jumbo is sleepy, then Jumbo is a baby elephant or an elephant.",
    "output": "Sleepy(jumbo) → BabyElephant(jumbo) ∨ Mammal(jumbo)"
  },
  {
    "input": "Translate into first-order logic: All mammals are living beings.",
    "output": "∀x (Mammal(x) → LivingBeing(x)) "
  },
  {
    "input": "Translate into first-order logic: All elephants are mammals.",
    "output": "∀x (Elephant(x) → Mammal(x))"
  },
  {
    "input": "Translate into first-order logic: All baby elephants are elephants.",
    "output": "∀x (BabyElephant(x) → Elephant(x))"
  },
  {
    "input": "Translate into first-order logic: Some baby elephants are sleepy.",
    "output": "∃x (BabyElephant(x) ∧ Sleepy(x))"
  },
  {
    "input": "Translate into first-order logic: If Jumbo is a living being, then Jumbo is not an elephant or a mammal.",
    "output": "LivingBeing(jumbo) → ¬(Elephant(jumbo) ∨ Mammal(jumbo))"
  },
  {
    "input": "Translate into first-order logic: If Jumbo is sleepy, then Jumbo is a baby elephant or an elephant.",
    "output": "Sleepy(jumbo) → BabyElephant(jumbo) ∨ Mammal(jumbo)"
  },
  {
    "input": "Translate into first-order logic: All mammals are living beings.",
    "output": "∀x (Mammal(x) → LivingBeing(x)) "
  },
  {
    "input": "Translate into first-order logic: All elephants are mammals.",
    "output": "∀x (Elephant(x) → Mammal(x))"
  },
  {
    "input": "Translate into first-order logic: All baby elephants are elephants.",
    "output": "∀x (BabyElephant(x) → Elephant(x))"
  },
  {
    "input": "Translate into first-order logic: Some baby elephants are sleepy.",
    "output": "∃x (BabyElephant(x) ∧ Sleepy(x))"
  },
  {
    "input": "Translate into first-order logic: If Jumbo is a living being, then Jumbo is not an elephant or a mammal.",
    "output": "LivingBeing(jumbo) → ¬(Elephant(jumbo) ∨ Mammal(jumbo))"
  },
  {
    "input": "Translate into first-order logic: If Jumbo is sleepy, then Jumbo is a baby elephant or an elephant.",
    "output": "Sleepy(jumbo) → BabyElephant(jumbo) ∨ Mammal(jumbo)"
  },
  {
    "input": "Translate into first-order logic: No faculty does homework.",
    "output": "∀x (Faculty(x) → ¬DoesHomework(x))"
  },
  {
    "input": "Translate into first-order logic: All students do homework.",
    "output": "∀x (Student(x) → DoesHomework(x))"
  },
  {
    "input": "Translate into first-order logic: All kids are students.",
    "output": "∀x (Kid(x) → Student(x))"
  },
  {
    "input": "Translate into first-order logic: If someone works at a school, then they are faculty.",
    "output": "∀x (WorkAtSchool(x) → Faculty(x))"
  },
  {
    "input": "Translate into first-order logic: If Jill works at a school or is a teacher, then Jill works at a school.",
    "output": "WorkAtSchool(jill) ∨ DoesHomework(jill) → WorkAtSchool(jill)"
  },
  {
    "input": "Translate into first-order logic: No faculty does homework.",
    "output": "∀x (Faculty(x) → ¬DoesHomework(x))"
  },
  {
    "input": "Translate into first-order logic: All students do homework.",
    "output": "∀x (Student(x) → DoesHomework(x))"
  },
  {
    "input": "Translate into first-order logic: All kids are students.",
    "output": "∀x (Kid(x) → Student(x))"
  },
  {
    "input": "Translate into first-order logic: If someone works at a school, then they are faculty.",
    "output": "∀x (WorkAtSchool(x) → Faculty(x))"
  },
  {
    "input": "Translate into first-order logic: If Jill works at a school or is a teacher, then Jill works at a school.",
    "output": "WorkAtSchool(jill) ∨ DoesHomework(jill) → WorkAtSchool(jill)"
  },
  {
    "input": "Translate into first-order logic: No faculty does homework.",
    "output": "∀x (Faculty(x) → ¬DoesHomework(x))"
  },
  {
    "input": "Translate into first-order logic: All students do homework.",
    "output": "∀x (Student(x) → DoesHomework(x))"
  },
  {
    "input": "Translate into first-order logic: All kids are students.",
    "output": "∀x (Kid(x) → Student(x))"
  },
  {
    "input": "Translate into first-order logic: If someone works at a school, then they are faculty.",
    "output": "∀x (WorkAtSchool(x) → Faculty(x))"
  },
  {
    "input": "Translate into first-order logic: If Jill works at a school or is a teacher, then Jill works at a school.",
    "output": "WorkAtSchool(jill) ∨ DoesHomework(jill) → WorkAtSchool(jill)"
  },
  {
    "input": "Translate into first-order logic: Either Max listens to classical music or Max listens to rap.",
    "output": "∀x (MaxListensToClassicalMusic(x) ∨ MaxListensToRap(x))"
  },
  {
    "input": "Translate into first-order logic: All the songs that Max listens to that are classical music are from the 12th century.",
    "output": "∀x (MaxListensToClassicalMusic(x) → SongsFrom12thCentury(x))"
  },
  {
    "input": "Translate into first-order logic: If the song Max listens to is rap, then the song is from Kanye West.",
    "output": "∀x (MaxListensToRap(x) → SongsFromKanyeWest(x))"
  },
  {
    "input": "Translate into first-order logic: If a songs is from Kanye West, then the song is full of lyrics.",
    "output": "∀x (SongsFromKanyeWest(x) → SongsFullOfLyrics(x))"
  },
  {
    "input": "Translate into first-order logic: All songs that are full of lyrics need to be written with words",
    "output": "∀x (SongsFullOfLyrics(x) → NeedToBeWrittenWithWords(x))"
  },
  {
    "input": "Translate into first-order logic: If “As it was” by Harry Styles is classical music that Max listens to or  from the 12th century, then “As it was” by Harry Styles is either classical music that Max listens to, or the songs are from 12th century.",
    "output": "MaxListensToClassicalMusic(asItWasByHarryStyles) ∨ SongsFrom12thCentury(asItWasByHarryStyles) → MaxListensToClassicalMusic(asItWasByHarryStyles) ⊕ SongsFrom12thCentury(asItWasByHarryStyles)"
  },
  {
    "input": "Translate into first-order logic: Either Max listens to classical music or Max listens to rap.",
    "output": "∀x (MaxListensToClassicalMusic(x) ∨ MaxListensToRap(x))"
  },
  {
    "input": "Translate into first-order logic: All the songs that Max listens to that are classical music are from the 12th century.",
    "output": "∀x (MaxListensToClassicalMusic(x) → SongsFrom12thCentury(x))"
  },
  {
    "input": "Translate into first-order logic: If the song Max listens to is rap, then the song is from Kanye West.",
    "output": "∀x (MaxListensToRap(x) → SongsFromKanyeWest(x))"
  },
  {
    "input": "Translate into first-order logic: If a songs is from Kanye West, then the song is full of lyrics.",
    "output": "∀x (SongsFromKanyeWest(x) → SongsFullOfLyrics(x))"
  },
  {
    "input": "Translate into first-order logic: All songs that are full of lyrics need to be written with words",
    "output": "∀x (SongsFullOfLyrics(x) → NeedToBeWrittenWithWords(x))"
  },
  {
    "input": "Translate into first-order logic: If “As it was” by Harry Styles is classical music that Max listens to or  from the 12th century, then “As it was” by Harry Styles is either classical music that Max listens to, or the songs are from 12th century.",
    "output": "MaxListensToClassicalMusic(asItWasByHarryStyles) ∨ SongsFrom12thCentury(asItWasByHarryStyles) → MaxListensToClassicalMusic(asItWasByHarryStyles) ⊕ SongsFrom12thCentury(asItWasByHarryStyles)"
  },
  {
    "input": "Translate into first-order logic: Either Max listens to classical music or Max listens to rap.",
    "output": "∀x (MaxListensToClassicalMusic(x) ∨ MaxListensToRap(x))"
  },
  {
    "input": "Translate into first-order logic: All the songs that Max listens to that are classical music are from the 12th century.",
    "output": "∀x (MaxListensToClassicalMusic(x) → SongsFrom12thCentury(x))"
  },
  {
    "input": "Translate into first-order logic: If the song Max listens to is rap, then the song is from Kanye West.",
    "output": "∀x (MaxListensToRap(x) → SongsFromKanyeWest(x))"
  },
  {
    "input": "Translate into first-order logic: If a songs is from Kanye West, then the song is full of lyrics.",
    "output": "∀x (SongsFromKanyeWest(x) → SongsFullOfLyrics(x))"
  },
  {
    "input": "Translate into first-order logic: All songs that are full of lyrics need to be written with words",
    "output": "∀x (SongsFullOfLyrics(x) → NeedToBeWrittenWithWords(x))"
  },
  {
    "input": "Translate into first-order logic: If “As it was” by Harry Styles is classical music that Max listens to or  from the 12th century, then “As it was” by Harry Styles is either classical music that Max listens to, or the songs are from 12th century.",
    "output": "MaxListensToClassicalMusic(asItWasByHarryStyles) ∨ SongsFrom12thCentury(asItWasByHarryStyles) → MaxListensToClassicalMusic(asItWasByHarryStyles) ⊕ SongsFrom12thCentury(asItWasByHarryStyles)"
  },
  {
    "input": "Translate into first-order logic: \"Your Woman\" is a song by British one-man band White Town.",
    "output": "Produce(whiteTown, yourWoman)"
  },
  {
    "input": "Translate into first-order logic: \"Your Woman\" song peaked at No. 1 on the UK Singles Chart.",
    "output": "Peak(yourWoman, uKSinglesChart)"
  },
  {
    "input": "Translate into first-order logic: If a song peaked at No.1 at a cetain place, then it was extremely popular.",
    "output": "∀x ∀y (Peak(x, y) → Popular(x))"
  },
  {
    "input": "Translate into first-order logic: \"Your Woman\" also peaked No. 1 in Iceland, Israel and Spain.",
    "output": "Peak(yourWoman, iceland) ∧ Peak(yourWoman, isarel) ∧ Peak(yourWoman, spain)"
  },
  {
    "input": "Translate into first-order logic: \"Your Woman\" is a song by British one-man band White Town.",
    "output": "Produce(whiteTown, yourWoman)"
  },
  {
    "input": "Translate into first-order logic: \"Your Woman\" song peaked at No. 1 on the UK Singles Chart.",
    "output": "Peak(yourWoman, uKSinglesChart)"
  },
  {
    "input": "Translate into first-order logic: If a song peaked at No.1 at a cetain place, then it was extremely popular.",
    "output": "∀x ∀y (Peak(x, y) → Popular(x))"
  },
  {
    "input": "Translate into first-order logic: \"Your Woman\" also peaked No. 1 in Iceland, Israel and Spain.",
    "output": "Peak(yourWoman, iceland) ∧ Peak(yourWoman, isarel) ∧ Peak(yourWoman, spain)"
  },
  {
    "input": "Translate into first-order logic: \"Your Woman\" is a song by British one-man band White Town.",
    "output": "Produce(whiteTown, yourWoman)"
  },
  {
    "input": "Translate into first-order logic: \"Your Woman\" song peaked at No. 1 on the UK Singles Chart.",
    "output": "Peak(yourWoman, uKSinglesChart)"
  },
  {
    "input": "Translate into first-order logic: If a song peaked at No.1 at a cetain place, then it was extremely popular.",
    "output": "∀x ∀y (Peak(x, y) → Popular(x))"
  },
  {
    "input": "Translate into first-order logic: \"Your Woman\" also peaked No. 1 in Iceland, Israel and Spain.",
    "output": "Peak(yourWoman, iceland) ∧ Peak(yourWoman, isarel) ∧ Peak(yourWoman, spain)"
  },
  {
    "input": "Translate into first-order logic: All people who limp often and regularly have long-term medical issues with underlying causes.",
    "output": "∀x (Limp(x) → Medical(x))"
  },
  {
    "input": "Translate into first-order logic: If people have long-term medical issues with underlying causes, then they are not often spry and energetic.",
    "output": "∀x (Medical(x) → ¬Spry(x))"
  },
  {
    "input": "Translate into first-order logic: People either stay indoors and rest a lot at home or people are often tired and disinterested in their activities.",
    "output": "∀x (Spry(x) ⊕ Tired(x)) ∧ (∀x (Tired(x) → Indoors(x)))"
  },
  {
    "input": "Translate into first-order logic: If people stay indoors and rest a lot at home, then they do not visit the gym at least once a day.",
    "output": "∀x (Indoors(x) → ¬Gym(x))"
  },
  {
    "input": "Translate into first-order logic: If Mark either limps often and regularly or is often spry and energetic, then Mark limps often and regularly or is often tired and disinterested in his activities.",
    "output": "(Limp(Mark) ⊕ Spry(Mark)) → Limp(Mark) ∨ Tired(Mark)"
  },
  {
    "input": "Translate into first-order logic: All people who limp often and regularly have long-term medical issues with underlying causes.",
    "output": "∀x (Limp(x) → Medical(x))"
  },
  {
    "input": "Translate into first-order logic: If people have long-term medical issues with underlying causes, then they are not often spry and energetic.",
    "output": "∀x (Medical(x) → ¬Spry(x))"
  },
  {
    "input": "Translate into first-order logic: People either stay indoors and rest a lot at home or people are often tired and disinterested in their activities.",
    "output": "∀x (Spry(x) ⊕ Tired(x)) ∧ (∀x (Tired(x) → Indoors(x)))"
  },
  {
    "input": "Translate into first-order logic: If people stay indoors and rest a lot at home, then they do not visit the gym at least once a day.",
    "output": "∀x (Indoors(x) → ¬Gym(x))"
  },
  {
    "input": "Translate into first-order logic: If Mark either limps often and regularly or is often spry and energetic, then Mark limps often and regularly or is often tired and disinterested in his activities.",
    "output": "(Limp(Mark) ⊕ Spry(Mark)) → Limp(Mark) ∨ Tired(Mark)"
  },
  {
    "input": "Translate into first-order logic: All people who limp often and regularly have long-term medical issues with underlying causes.",
    "output": "∀x (Limp(x) → Medical(x))"
  },
  {
    "input": "Translate into first-order logic: If people have long-term medical issues with underlying causes, then they are not often spry and energetic.",
    "output": "∀x (Medical(x) → ¬Spry(x))"
  },
  {
    "input": "Translate into first-order logic: People either stay indoors and rest a lot at home or people are often tired and disinterested in their activities.",
    "output": "∀x (Spry(x) ⊕ Tired(x)) ∧ (∀x (Tired(x) → Indoors(x)))"
  },
  {
    "input": "Translate into first-order logic: If people stay indoors and rest a lot at home, then they do not visit the gym at least once a day.",
    "output": "∀x (Indoors(x) → ¬Gym(x))"
  },
  {
    "input": "Translate into first-order logic: If Mark either limps often and regularly or is often spry and energetic, then Mark limps often and regularly or is often tired and disinterested in his activities.",
    "output": "(Limp(Mark) ⊕ Spry(Mark)) → Limp(Mark) ∨ Tired(Mark)"
  },
  {
    "input": "Translate into first-order logic: If two soccer teams score the same number of goals in one UCL final during the regular time, they need to play for the extra time.",
    "output": "∀x ∀y (SoccerTeam(x) ∧ SoccerTeam(y) ∧ SameScore(x, y) ∧ During(regularTime) → PlayExtra(x, y))"
  },
  {
    "input": "Translate into first-order logic: If two soccer teams score the same number of goals in one UCL final during both the regular time and extra time, they need to play the penalty shoot-out.",
    "output": "∀x ∀y (SoccerTeam(x) ∧ SoccerTeam(y) ∧ SameScore(x, y) ∧ During(regularTime) ∧ During(extraTime) → PlayPenalty(x, y))"
  },
  {
    "input": "Translate into first-order logic: Real Madrid and Atlético Madrid both scored one goal in 2016 UCL final during the regular time.",
    "output": "SoccerTeam(realMadrid) ∧ SoccerTeam(atleticoMadrid) ∧ SameScore(realMadrid, atleticoMadrid) ∧ During(regularTime)"
  },
  {
    "input": "Translate into first-order logic: Real Madrid and Atlético Madrid both scored zero goals in 2016 UCL final during the extra time.",
    "output": "SoccerTeam(realMadrid) ∧ SoccerTeam(atleticoMadrid) ∧ SameScore(realMadrid, atleticoMadrid) ∧ During(extraTime)"
  },
  {
    "input": "Translate into first-order logic: If two soccer teams score the same number of goals in one UCL final during the regular time, they need to play for the extra time.",
    "output": "∀x ∀y (SoccerTeam(x) ∧ SoccerTeam(y) ∧ SameScore(x, y) ∧ During(regularTime) → PlayExtra(x, y))"
  },
  {
    "input": "Translate into first-order logic: If two soccer teams score the same number of goals in one UCL final during both the regular time and extra time, they need to play the penalty shoot-out.",
    "output": "∀x ∀y (SoccerTeam(x) ∧ SoccerTeam(y) ∧ SameScore(x, y) ∧ During(regularTime) ∧ During(extraTime) → PlayPenalty(x, y))"
  },
  {
    "input": "Translate into first-order logic: Real Madrid and Atlético Madrid both scored one goal in 2016 UCL final during the regular time.",
    "output": "SoccerTeam(realMadrid) ∧ SoccerTeam(atleticoMadrid) ∧ SameScore(realMadrid, atleticoMadrid) ∧ During(regularTime)"
  },
  {
    "input": "Translate into first-order logic: Real Madrid and Atlético Madrid both scored zero goals in 2016 UCL final during the extra time.",
    "output": "SoccerTeam(realMadrid) ∧ SoccerTeam(atleticoMadrid) ∧ SameScore(realMadrid, atleticoMadrid) ∧ During(extraTime)"
  },
  {
    "input": "Translate into first-order logic: System 7 is a UK-based electronic dance music band.",
    "output": "BasedOn(system7, uk) ∧ ElectronicDanceMusicBand(system7)"
  },
  {
    "input": "Translate into first-order logic: Steve Hillage and Miquette Giraudy formed System 7.",
    "output": "Formed(stevehillage, system7) ∧ Formed(miquettegiraudy, system7)"
  },
  {
    "input": "Translate into first-order logic: Steve Hillage and Miquette Giraudy are former members of the band Gong.",
    "output": "FormerMemberOf(stevehillage, gong) ∧ FormerMemberOf(miquettegiraudy, gong)"
  },
  {
    "input": "Translate into first-order logic: Electric dance music bands are bands.",
    "output": "∀x (ElectronicDanceMusicBand(x) → Band(x))"
  },
  {
    "input": "Translate into first-order logic: System 7 has released several club singles.",
    "output": "∃x (ClubSingle(x) ∧ Released(system7, x))"
  },
  {
    "input": "Translate into first-order logic: Club singles are not singles.",
    "output": "∀x (ClubSingle(x) → ¬Single(x))"
  },
  {
    "input": "Translate into first-order logic: System 7 is a UK-based electronic dance music band.",
    "output": "BasedOn(system7, uk) ∧ ElectronicDanceMusicBand(system7)"
  },
  {
    "input": "Translate into first-order logic: Steve Hillage and Miquette Giraudy formed System 7.",
    "output": "Formed(stevehillage, system7) ∧ Formed(miquettegiraudy, system7)"
  },
  {
    "input": "Translate into first-order logic: Steve Hillage and Miquette Giraudy are former members of the band Gong.",
    "output": "FormerMemberOf(stevehillage, gong) ∧ FormerMemberOf(miquettegiraudy, gong)"
  },
  {
    "input": "Translate into first-order logic: Electric dance music bands are bands.",
    "output": "∀x (ElectronicDanceMusicBand(x) → Band(x))"
  },
  {
    "input": "Translate into first-order logic: System 7 has released several club singles.",
    "output": "∃x (ClubSingle(x) ∧ Released(system7, x))"
  },
  {
    "input": "Translate into first-order logic: Club singles are not singles.",
    "output": "∀x (ClubSingle(x) → ¬Single(x))"
  },
  {
    "input": "Translate into first-order logic: System 7 is a UK-based electronic dance music band.",
    "output": "BasedOn(system7, uk) ∧ ElectronicDanceMusicBand(system7)"
  },
  {
    "input": "Translate into first-order logic: Steve Hillage and Miquette Giraudy formed System 7.",
    "output": "Formed(stevehillage, system7) ∧ Formed(miquettegiraudy, system7)"
  },
  {
    "input": "Translate into first-order logic: Steve Hillage and Miquette Giraudy are former members of the band Gong.",
    "output": "FormerMemberOf(stevehillage, gong) ∧ FormerMemberOf(miquettegiraudy, gong)"
  },
  {
    "input": "Translate into first-order logic: Electric dance music bands are bands.",
    "output": "∀x (ElectronicDanceMusicBand(x) → Band(x))"
  },
  {
    "input": "Translate into first-order logic: System 7 has released several club singles.",
    "output": "∃x (ClubSingle(x) ∧ Released(system7, x))"
  },
  {
    "input": "Translate into first-order logic: Club singles are not singles.",
    "output": "∀x (ClubSingle(x) → ¬Single(x))"
  },
  {
    "input": "Translate into first-order logic: A summarization model is always faithful if it uses content from the input documents.",
    "output": "∀x (Model(x) ∧ Summarization(x) ∧ OnlyUseInputDocument(x) → Faithful(x))"
  },
  {
    "input": "Translate into first-order logic: Extractive models are a kind of summarization models.",
    "output": "∀x (Model(x) ∧ Extractive(x) → Summarization(x))"
  },
  {
    "input": "Translate into first-order logic: Extractive model can only use content from the input documents.",
    "output": "∀x (Model(x) ∧ Extractive(x) → OnlyUseInputDocument(x))"
  },
  {
    "input": "Translate into first-order logic: A summarization model is always faithful if it uses content from the input documents.",
    "output": "∀x (Model(x) ∧ Summarization(x) ∧ OnlyUseInputDocument(x) → Faithful(x))"
  },
  {
    "input": "Translate into first-order logic: Extractive models are a kind of summarization models.",
    "output": "∀x (Model(x) ∧ Extractive(x) → Summarization(x))"
  },
  {
    "input": "Translate into first-order logic: Extractive model can only use content from the input documents.",
    "output": "∀x (Model(x) ∧ Extractive(x) → OnlyUseInputDocument(x))"
  },
  {
    "input": "Translate into first-order logic: If people practice coding questions, then they are not studying to go to medical school to become a doctor.",
    "output": "∀x Coding(x) → ¬StudyingToBeDoctor(x)"
  },
  {
    "input": "Translate into first-order logic: If people want to work in the software engineering industry, then they practice coding questions.",
    "output": "∀x Industry(x) → Coding(x)"
  },
  {
    "input": "Translate into first-order logic: If people enjoy healthcare fields and want to help people with medical issues, then they are studying to go to medical school to become a doctor.",
    "output": "∀x Healthcare(x) → StudyingToBeDoctor(x)"
  },
  {
    "input": "Translate into first-order logic: If people grew up with parents who worked as doctors, then they enjoy healthcare fields and want to help people with medical issues.",
    "output": "∀x ParentDoctors(x) → Healthcare(x)"
  },
  {
    "input": "Translate into first-order logic: If people study hard, then they grew up with parents who worked as doctors.",
    "output": "∀x Study(x) → ParentDoctors(x)"
  },
  {
    "input": "Translate into first-order logic: If Robin neither enjoys healthcare fields and wants to help people with medical issues nor grew up with parents who worked as doctors, then Robin is either a person who studies hard or grew up with parents who worked as doctors.",
    "output": "¬(Healthcare(Robin) ∨ ParentDoctors(Robin)) → (Study(Robin) ∨ ParentDoctors(Robin)) "
  },
  {
    "input": "Translate into first-order logic: If people practice coding questions, then they are not studying to go to medical school to become a doctor.",
    "output": "∀x Coding(x) → ¬StudyingToBeDoctor(x)"
  },
  {
    "input": "Translate into first-order logic: If people want to work in the software engineering industry, then they practice coding questions.",
    "output": "∀x Industry(x) → Coding(x)"
  },
  {
    "input": "Translate into first-order logic: If people enjoy healthcare fields and want to help people with medical issues, then they are studying to go to medical school to become a doctor.",
    "output": "∀x Healthcare(x) → StudyingToBeDoctor(x)"
  },
  {
    "input": "Translate into first-order logic: If people grew up with parents who worked as doctors, then they enjoy healthcare fields and want to help people with medical issues.",
    "output": "∀x ParentDoctors(x) → Healthcare(x)"
  },
  {
    "input": "Translate into first-order logic: If people study hard, then they grew up with parents who worked as doctors.",
    "output": "∀x Study(x) → ParentDoctors(x)"
  },
  {
    "input": "Translate into first-order logic: If Robin neither enjoys healthcare fields and wants to help people with medical issues nor grew up with parents who worked as doctors, then Robin is either a person who studies hard or grew up with parents who worked as doctors.",
    "output": "¬(Healthcare(Robin) ∨ ParentDoctors(Robin)) → (Study(Robin) ∨ ParentDoctors(Robin)) "
  },
  {
    "input": "Translate into first-order logic: If people practice coding questions, then they are not studying to go to medical school to become a doctor.",
    "output": "∀x Coding(x) → ¬StudyingToBeDoctor(x)"
  },
  {
    "input": "Translate into first-order logic: If people want to work in the software engineering industry, then they practice coding questions.",
    "output": "∀x Industry(x) → Coding(x)"
  },
  {
    "input": "Translate into first-order logic: If people enjoy healthcare fields and want to help people with medical issues, then they are studying to go to medical school to become a doctor.",
    "output": "∀x Healthcare(x) → StudyingToBeDoctor(x)"
  },
  {
    "input": "Translate into first-order logic: If people grew up with parents who worked as doctors, then they enjoy healthcare fields and want to help people with medical issues.",
    "output": "∀x ParentDoctors(x) → Healthcare(x)"
  },
  {
    "input": "Translate into first-order logic: If people study hard, then they grew up with parents who worked as doctors.",
    "output": "∀x Study(x) → ParentDoctors(x)"
  },
  {
    "input": "Translate into first-order logic: If Robin neither enjoys healthcare fields and wants to help people with medical issues nor grew up with parents who worked as doctors, then Robin is either a person who studies hard or grew up with parents who worked as doctors.",
    "output": "¬(Healthcare(Robin) ∨ ParentDoctors(Robin)) → (Study(Robin) ∨ ParentDoctors(Robin)) "
  },
  {
    "input": "Translate into first-order logic: If people go to the spa at least once a week, then they are not people who are miserly and need to save a large portion of their income.",
    "output": "∀x Spa(x) → ¬Miserly(x)"
  },
  {
    "input": "Translate into first-order logic: People are either miserly and need to save a large portion of their income, or people that frivolously spend a lot of money every time they go out.",
    "output": "∀x Miserly(x) ∨ Frivolous(x)"
  },
  {
    "input": "Translate into first-order logic: If people frivolously spend a lot of money every time they go out, then they value quality manufacturing and luxury items.",
    "output": "∀x Frivolous(x) → Luxury(x)"
  },
  {
    "input": "Translate into first-order logic: If people value quality manufacturing and luxury items, then they enjoy shopping for materialistic items in their free time.",
    "output": "∀x Luxury(x) → Shopping(x)"
  },
  {
    "input": "Translate into first-order logic: If Jess is not miserly and needs to save a large portion of their income, then Jess does not value quality manufacturing and luxury items.",
    "output": "¬Miserly(Jess) → ¬Luxury(Jess)"
  },
  {
    "input": "Translate into first-order logic: If Jess either values quality manufacturing and luxury items or, if he does not, then he is miserly and needs to save a large portion of his income, then Jess frivolously spends a lot of money every time he goes out.",
    "output": "Luxury(Jess) ⊕ Miserly(Jess)) →  Luxury(Jess)"
  },
  {
    "input": "Translate into first-order logic: If people go to the spa at least once a week, then they are not people who are miserly and need to save a large portion of their income.",
    "output": "∀x Spa(x) → ¬Miserly(x)"
  },
  {
    "input": "Translate into first-order logic: People are either miserly and need to save a large portion of their income, or people that frivolously spend a lot of money every time they go out.",
    "output": "∀x Miserly(x) ∨ Frivolous(x)"
  },
  {
    "input": "Translate into first-order logic: If people frivolously spend a lot of money every time they go out, then they value quality manufacturing and luxury items.",
    "output": "∀x Frivolous(x) → Luxury(x)"
  },
  {
    "input": "Translate into first-order logic: If people value quality manufacturing and luxury items, then they enjoy shopping for materialistic items in their free time.",
    "output": "∀x Luxury(x) → Shopping(x)"
  },
  {
    "input": "Translate into first-order logic: If Jess is not miserly and needs to save a large portion of their income, then Jess does not value quality manufacturing and luxury items.",
    "output": "¬Miserly(Jess) → ¬Luxury(Jess)"
  },
  {
    "input": "Translate into first-order logic: If Jess either values quality manufacturing and luxury items or, if he does not, then he is miserly and needs to save a large portion of his income, then Jess frivolously spends a lot of money every time he goes out.",
    "output": "Luxury(Jess) ⊕ Miserly(Jess)) →  Luxury(Jess)"
  },
  {
    "input": "Translate into first-order logic: If people go to the spa at least once a week, then they are not people who are miserly and need to save a large portion of their income.",
    "output": "∀x Spa(x) → ¬Miserly(x)"
  },
  {
    "input": "Translate into first-order logic: People are either miserly and need to save a large portion of their income, or people that frivolously spend a lot of money every time they go out.",
    "output": "∀x Miserly(x) ∨ Frivolous(x)"
  },
  {
    "input": "Translate into first-order logic: If people frivolously spend a lot of money every time they go out, then they value quality manufacturing and luxury items.",
    "output": "∀x Frivolous(x) → Luxury(x)"
  },
  {
    "input": "Translate into first-order logic: If people value quality manufacturing and luxury items, then they enjoy shopping for materialistic items in their free time.",
    "output": "∀x Luxury(x) → Shopping(x)"
  },
  {
    "input": "Translate into first-order logic: If Jess is not miserly and needs to save a large portion of their income, then Jess does not value quality manufacturing and luxury items.",
    "output": "¬Miserly(Jess) → ¬Luxury(Jess)"
  },
  {
    "input": "Translate into first-order logic: If Jess either values quality manufacturing and luxury items or, if he does not, then he is miserly and needs to save a large portion of his income, then Jess frivolously spends a lot of money every time he goes out.",
    "output": "Luxury(Jess) ⊕ Miserly(Jess)) →  Luxury(Jess)"
  },
  {
    "input": "Translate into first-order logic: The indie pop band Phoenix has released 6 albums.",
    "output": "AlbumsReleased(phoenix, l6)"
  },
  {
    "input": "Translate into first-order logic: Phoenix's album \"Wolfgang Amadeus Phoenix\" sold over 500,000 copies.",
    "output": "Album(wolfgangamadeusphoenix) ∧ IsAlbumOf(wolfgangamadeusphoenix, phoenix) ∧ SoldOver(wolfgangamadeusphoenix, l500000)"
  },
  {
    "input": "Translate into first-order logic: A certified gold album or single is one which sold over half a million copies.",
    "output": "∀x ((Album(x) ∨ Single(x)) ∧ SoldOver(x, l500000) → CertifiedGold(x))"
  },
  {
    "input": "Translate into first-order logic: \"1901\" is a single from Phoenix's album \"Wolfgang Amadeus Phoenix.\"",
    "output": "Single(l1901) ∧ From(l1901, wolfgangamadeusphoenix) ∧ By(l1901, phoenix)"
  },
  {
    "input": "Translate into first-order logic: Over 400,000 copies of \"1901\" have been sold.",
    "output": "SoldOver(l1901, l400000)"
  },
  {
    "input": "Translate into first-order logic: The indie pop band Phoenix has released 6 albums.",
    "output": "AlbumsReleased(phoenix, l6)"
  },
  {
    "input": "Translate into first-order logic: Phoenix's album \"Wolfgang Amadeus Phoenix\" sold over 500,000 copies.",
    "output": "Album(wolfgangamadeusphoenix) ∧ IsAlbumOf(wolfgangamadeusphoenix, phoenix) ∧ SoldOver(wolfgangamadeusphoenix, l500000)"
  },
  {
    "input": "Translate into first-order logic: A certified gold album or single is one which sold over half a million copies.",
    "output": "∀x ((Album(x) ∨ Single(x)) ∧ SoldOver(x, l500000) → CertifiedGold(x))"
  },
  {
    "input": "Translate into first-order logic: \"1901\" is a single from Phoenix's album \"Wolfgang Amadeus Phoenix.\"",
    "output": "Single(l1901) ∧ From(l1901, wolfgangamadeusphoenix) ∧ By(l1901, phoenix)"
  },
  {
    "input": "Translate into first-order logic: Over 400,000 copies of \"1901\" have been sold.",
    "output": "SoldOver(l1901, l400000)"
  },
  {
    "input": "Translate into first-order logic: Peter Parker is a either a superhero or a civilian.",
    "output": "Superhero(peter) ⊕ Civilian(peter)"
  },
  {
    "input": "Translate into first-order logic: The Hulk is a destroyer.",
    "output": "Destroyer(hulk)"
  },
  {
    "input": "Translate into first-order logic: The Hulk wakes up when he is angry.",
    "output": "Angry(hulk) → Wake(hulk)"
  },
  {
    "input": "Translate into first-order logic: If the Hulk wakes up, then he will break a bridge.",
    "output": "Wake(hulk) → BreakBridge(hulk)"
  },
  {
    "input": "Translate into first-order logic: Thor is a god.",
    "output": "God(thor)"
  },
  {
    "input": "Translate into first-order logic: Thor will break a bridge when he is happy.",
    "output": "Happy(thor) → BreakBridge(thor)"
  },
  {
    "input": "Translate into first-order logic: A god is not a destroyer and a destroyer is not a god.",
    "output": "∀x (God(x) ↔ ¬Destroyer(x))"
  },
  {
    "input": "Translate into first-order logic: Peter Parker wears a uniform when he is a superhero.",
    "output": "Superhero(peter) → WearUniform(peter)"
  },
  {
    "input": "Translate into first-order logic: Peter Parker is not a civilian if and only if a destroyer is breaking a bridge.",
    "output": "∀x (¬Civilian(peter) ↔ (Destroyer(x) ∧ BreakBridge(x)))"
  },
  {
    "input": "Translate into first-order logic: If Thor is happy, the Hulk is angry.",
    "output": "Happy(thor) → Angry(hulk)"
  },
  {
    "input": "Translate into first-order logic: Peter Parker is a either a superhero or a civilian.",
    "output": "Superhero(peter) ⊕ Civilian(peter)"
  },
  {
    "input": "Translate into first-order logic: The Hulk is a destroyer.",
    "output": "Destroyer(hulk)"
  },
  {
    "input": "Translate into first-order logic: The Hulk wakes up when he is angry.",
    "output": "Angry(hulk) → Wake(hulk)"
  },
  {
    "input": "Translate into first-order logic: If the Hulk wakes up, then he will break a bridge.",
    "output": "Wake(hulk) → BreakBridge(hulk)"
  },
  {
    "input": "Translate into first-order logic: Thor is a god.",
    "output": "God(thor)"
  },
  {
    "input": "Translate into first-order logic: Thor will break a bridge when he is happy.",
    "output": "Happy(thor) → BreakBridge(thor)"
  },
  {
    "input": "Translate into first-order logic: A god is not a destroyer and a destroyer is not a god.",
    "output": "∀x (God(x) ↔ ¬Destroyer(x))"
  },
  {
    "input": "Translate into first-order logic: Peter Parker wears a uniform when he is a superhero.",
    "output": "Superhero(peter) → WearUniform(peter)"
  },
  {
    "input": "Translate into first-order logic: Peter Parker is not a civilian if and only if a destroyer is breaking a bridge.",
    "output": "∀x (¬Civilian(peter) ↔ (Destroyer(x) ∧ BreakBridge(x)))"
  },
  {
    "input": "Translate into first-order logic: If Thor is happy, the Hulk is angry.",
    "output": "Happy(thor) → Angry(hulk)"
  },
  {
    "input": "Translate into first-order logic: Peter Parker is a either a superhero or a civilian.",
    "output": "Superhero(peter) ⊕ Civilian(peter)"
  },
  {
    "input": "Translate into first-order logic: The Hulk is a destroyer.",
    "output": "Destroyer(hulk)"
  },
  {
    "input": "Translate into first-order logic: The Hulk wakes up when he is angry.",
    "output": "Angry(hulk) → Wake(hulk)"
  },
  {
    "input": "Translate into first-order logic: If the Hulk wakes up, then he will break a bridge.",
    "output": "Wake(hulk) → BreakBridge(hulk)"
  },
  {
    "input": "Translate into first-order logic: Thor is a god.",
    "output": "God(thor)"
  },
  {
    "input": "Translate into first-order logic: Thor will break a bridge when he is happy.",
    "output": "Happy(thor) → BreakBridge(thor)"
  },
  {
    "input": "Translate into first-order logic: A god is not a destroyer and a destroyer is not a god.",
    "output": "∀x (God(x) ↔ ¬Destroyer(x))"
  },
  {
    "input": "Translate into first-order logic: Peter Parker wears a uniform when he is a superhero.",
    "output": "Superhero(peter) → WearUniform(peter)"
  },
  {
    "input": "Translate into first-order logic: Peter Parker is not a civilian if and only if a destroyer is breaking a bridge.",
    "output": "∀x (¬Civilian(peter) ↔ (Destroyer(x) ∧ BreakBridge(x)))"
  },
  {
    "input": "Translate into first-order logic: If Thor is happy, the Hulk is angry.",
    "output": "Happy(thor) → Angry(hulk)"
  },
  {
    "input": "Translate into first-order logic: Diethylcarbamazine is a medication discovered in the year 1947.",
    "output": "∀x (Diethylcarbamazine(x) ∧ Medication(x) ∧ DiscoveredIn(x, year1947))"
  },
  {
    "input": "Translate into first-order logic: Diethylcarbamazine can be used to treat river blindness.",
    "output": "∀x ∀y (Diethylcarbamazine(x) ∧ RiverBlindness(y) → Treats(x, y))"
  },
  {
    "input": "Translate into first-order logic: The only preferred treatment for river blindness is ivermectin.",
    "output": "∀x ∀y (RiverBlindness(y) ∧ PreferredTreatment(x, y) → Ivermectin(x))"
  },
  {
    "input": "Translate into first-order logic: Diethylcarbamazine is not ivermectin.",
    "output": "∀x (Diethylcarbamazine(x) → ¬Ivermectin(x))"
  },
  {
    "input": "Translate into first-order logic: Diethylcarbamazine is a medication discovered in the year 1947.",
    "output": "∀x (Diethylcarbamazine(x) ∧ Medication(x) ∧ DiscoveredIn(x, year1947))"
  },
  {
    "input": "Translate into first-order logic: Diethylcarbamazine can be used to treat river blindness.",
    "output": "∀x ∀y (Diethylcarbamazine(x) ∧ RiverBlindness(y) → Treats(x, y))"
  },
  {
    "input": "Translate into first-order logic: The only preferred treatment for river blindness is ivermectin.",
    "output": "∀x ∀y (RiverBlindness(y) ∧ PreferredTreatment(x, y) → Ivermectin(x))"
  },
  {
    "input": "Translate into first-order logic: Diethylcarbamazine is not ivermectin.",
    "output": "∀x (Diethylcarbamazine(x) → ¬Ivermectin(x))"
  },
  {
    "input": "Translate into first-order logic: Diethylcarbamazine is a medication discovered in the year 1947.",
    "output": "∀x (Diethylcarbamazine(x) ∧ Medication(x) ∧ DiscoveredIn(x, year1947))"
  },
  {
    "input": "Translate into first-order logic: Diethylcarbamazine can be used to treat river blindness.",
    "output": "∀x ∀y (Diethylcarbamazine(x) ∧ RiverBlindness(y) → Treats(x, y))"
  },
  {
    "input": "Translate into first-order logic: The only preferred treatment for river blindness is ivermectin.",
    "output": "∀x ∀y (RiverBlindness(y) ∧ PreferredTreatment(x, y) → Ivermectin(x))"
  },
  {
    "input": "Translate into first-order logic: Diethylcarbamazine is not ivermectin.",
    "output": "∀x (Diethylcarbamazine(x) → ¬Ivermectin(x))"
  },
  {
    "input": "Translate into first-order logic: All univariate analyses use a generalized linear model.",
    "output": "∀x (UnivariateAnalysis(x) → UsesGeneralizedLinearModel(x)) "
  },
  {
    "input": "Translate into first-order logic: All multivoxel (pattern) analyses are implementing machine learning algorithms.",
    "output": " ∀x (MultivoxelPatternAnalysis(x) → ImplementingMachineLearningAlgorithms(x))"
  },
  {
    "input": "Translate into first-order logic: All implementing machine learning algorithms are to learn and classify multivariate data.",
    "output": " ∀x (ImplementingMachineLearningAlgorithms(x) → LearnAndClassifyMultivariateData(x)) "
  },
  {
    "input": "Translate into first-order logic: The Latent Dirichlet allocation model uses a generalized linear model or a univariate analysis.",
    "output": " UsesGeneralizedLinearModel(latentDirichletAllocationModel) ∨ UnivariateAnalysis(latentDirichletAllocationModel)"
  },
  {
    "input": "Translate into first-order logic: If the Latent Dirichlet allocation model does not learn and classify multivariate data, then the Latent Dirichlet allocation model uses a generalized linear model and a multivoxel (pattern) analysis.",
    "output": " ¬LearnAndClassifyMultivariateData(latentDirichletAllocationModel) → UsesGeneralizedLinearModel(latentDirichletAllocationModel) ∧ MultivoxelPatternAnalysis(latentDirichletAllocationModel)"
  },
  {
    "input": "Translate into first-order logic: All univariate analyses use a generalized linear model.",
    "output": "∀x (UnivariateAnalysis(x) → UsesGeneralizedLinearModel(x)) "
  },
  {
    "input": "Translate into first-order logic: All multivoxel (pattern) analyses are implementing machine learning algorithms.",
    "output": " ∀x (MultivoxelPatternAnalysis(x) → ImplementingMachineLearningAlgorithms(x))"
  },
  {
    "input": "Translate into first-order logic: All implementing machine learning algorithms are to learn and classify multivariate data.",
    "output": " ∀x (ImplementingMachineLearningAlgorithms(x) → LearnAndClassifyMultivariateData(x)) "
  },
  {
    "input": "Translate into first-order logic: The Latent Dirichlet allocation model uses a generalized linear model or a univariate analysis.",
    "output": " UsesGeneralizedLinearModel(latentDirichletAllocationModel) ∨ UnivariateAnalysis(latentDirichletAllocationModel)"
  },
  {
    "input": "Translate into first-order logic: If the Latent Dirichlet allocation model does not learn and classify multivariate data, then the Latent Dirichlet allocation model uses a generalized linear model and a multivoxel (pattern) analysis.",
    "output": " ¬LearnAndClassifyMultivariateData(latentDirichletAllocationModel) → UsesGeneralizedLinearModel(latentDirichletAllocationModel) ∧ MultivoxelPatternAnalysis(latentDirichletAllocationModel)"
  },
  {
    "input": "Translate into first-order logic: All univariate analyses use a generalized linear model.",
    "output": "∀x (UnivariateAnalysis(x) → UsesGeneralizedLinearModel(x)) "
  },
  {
    "input": "Translate into first-order logic: All multivoxel (pattern) analyses are implementing machine learning algorithms.",
    "output": " ∀x (MultivoxelPatternAnalysis(x) → ImplementingMachineLearningAlgorithms(x))"
  },
  {
    "input": "Translate into first-order logic: All implementing machine learning algorithms are to learn and classify multivariate data.",
    "output": " ∀x (ImplementingMachineLearningAlgorithms(x) → LearnAndClassifyMultivariateData(x)) "
  },
  {
    "input": "Translate into first-order logic: The Latent Dirichlet allocation model uses a generalized linear model or a univariate analysis.",
    "output": " UsesGeneralizedLinearModel(latentDirichletAllocationModel) ∨ UnivariateAnalysis(latentDirichletAllocationModel)"
  },
  {
    "input": "Translate into first-order logic: If the Latent Dirichlet allocation model does not learn and classify multivariate data, then the Latent Dirichlet allocation model uses a generalized linear model and a multivoxel (pattern) analysis.",
    "output": " ¬LearnAndClassifyMultivariateData(latentDirichletAllocationModel) → UsesGeneralizedLinearModel(latentDirichletAllocationModel) ∧ MultivoxelPatternAnalysis(latentDirichletAllocationModel)"
  },
  {
    "input": "Translate into first-order logic: If something requires a medical diagnosis, then lab tests or imaging is required.",
    "output": "∀x (RequiresAMedicalDiagnosis(x) → LabTestsOrImagingRequired(x)) "
  },
  {
    "input": "Translate into first-order logic: All rare diseases require a medical diagnosis.",
    "output": "∀x (RareDiseases(x) → RequiresAMedicalDiagnosis(x))"
  },
  {
    "input": "Translate into first-order logic: If something is mild, then no lab tests or imaging is required.",
    "output": "∀x (Mild(x) → ¬LabTestsOrImagingRequired(x)) "
  },
  {
    "input": "Translate into first-order logic: All blood cancers are rare diseases.",
    "output": "∀x (BloodCancer(x) → RareDiseases(x))"
  },
  {
    "input": "Translate into first-order logic: All Leukemia is blood cancer.",
    "output": "∀x (Leukemia(x) → BloodCancer(x))"
  },
  {
    "input": "Translate into first-order logic: If bladder cancer is either both blood cancer and Leukemia or neither blood cancer nor Leukemia, then bladder cancer is Leukemia.",
    "output": "¬(BloodCancer(bladderCancer) ⊕ Leukemia(bladderCancer)) → Leukemia(bladderCancer)"
  },
  {
    "input": "Translate into first-order logic: If something requires a medical diagnosis, then lab tests or imaging is required.",
    "output": "∀x (RequiresAMedicalDiagnosis(x) → LabTestsOrImagingRequired(x)) "
  },
  {
    "input": "Translate into first-order logic: All rare diseases require a medical diagnosis.",
    "output": "∀x (RareDiseases(x) → RequiresAMedicalDiagnosis(x))"
  },
  {
    "input": "Translate into first-order logic: If something is mild, then no lab tests or imaging is required.",
    "output": "∀x (Mild(x) → ¬LabTestsOrImagingRequired(x)) "
  },
  {
    "input": "Translate into first-order logic: All blood cancers are rare diseases.",
    "output": "∀x (BloodCancer(x) → RareDiseases(x))"
  },
  {
    "input": "Translate into first-order logic: All Leukemia is blood cancer.",
    "output": "∀x (Leukemia(x) → BloodCancer(x))"
  },
  {
    "input": "Translate into first-order logic: If bladder cancer is either both blood cancer and Leukemia or neither blood cancer nor Leukemia, then bladder cancer is Leukemia.",
    "output": "¬(BloodCancer(bladderCancer) ⊕ Leukemia(bladderCancer)) → Leukemia(bladderCancer)"
  },
  {
    "input": "Translate into first-order logic: If something requires a medical diagnosis, then lab tests or imaging is required.",
    "output": "∀x (RequiresAMedicalDiagnosis(x) → LabTestsOrImagingRequired(x)) "
  },
  {
    "input": "Translate into first-order logic: All rare diseases require a medical diagnosis.",
    "output": "∀x (RareDiseases(x) → RequiresAMedicalDiagnosis(x))"
  },
  {
    "input": "Translate into first-order logic: If something is mild, then no lab tests or imaging is required.",
    "output": "∀x (Mild(x) → ¬LabTestsOrImagingRequired(x)) "
  },
  {
    "input": "Translate into first-order logic: All blood cancers are rare diseases.",
    "output": "∀x (BloodCancer(x) → RareDiseases(x))"
  },
  {
    "input": "Translate into first-order logic: All Leukemia is blood cancer.",
    "output": "∀x (Leukemia(x) → BloodCancer(x))"
  },
  {
    "input": "Translate into first-order logic: If bladder cancer is either both blood cancer and Leukemia or neither blood cancer nor Leukemia, then bladder cancer is Leukemia.",
    "output": "¬(BloodCancer(bladderCancer) ⊕ Leukemia(bladderCancer)) → Leukemia(bladderCancer)"
  },
  {
    "input": "Translate into first-order logic: No precious metals aren't scarce.",
    "output": "∀x (PreciousMetals(x) → ¬NotScarce(x))"
  },
  {
    "input": "Translate into first-order logic: All non-rare earth metals are not scarce.",
    "output": " ∀x (Non-rareEarthMetals(x) → NotScarce(x)) "
  },
  {
    "input": "Translate into first-order logic: Either non-rare earth metals or rare earth metals.",
    "output": " ∀x (Non-rareEarthMetals(x) ∨ RareEarthMetals(x)) "
  },
  {
    "input": "Translate into first-order logic: All rare earth metals can be used for batteries.",
    "output": " ∀x (RareEarthMetals(x) → BeUsedForBatteries(x)) "
  },
  {
    "input": "Translate into first-order logic: All rare earth metals are essential for electric vehicles.",
    "output": " ∀x (RareEarthMetals(x) → EssentialForElectricVehicles(x))"
  },
  {
    "input": "Translate into first-order logic: Lithium is neither a non-rare earth metal nor essential for electric vehicles.",
    "output": " ¬Non-rareEarthMetals(lithium) ⊕ ¬EssentialForElectricVehicles(lithium)"
  },
  {
    "input": "Translate into first-order logic: No precious metals aren't scarce.",
    "output": "∀x (PreciousMetals(x) → ¬NotScarce(x))"
  },
  {
    "input": "Translate into first-order logic: All non-rare earth metals are not scarce.",
    "output": " ∀x (Non-rareEarthMetals(x) → NotScarce(x)) "
  },
  {
    "input": "Translate into first-order logic: Either non-rare earth metals or rare earth metals.",
    "output": " ∀x (Non-rareEarthMetals(x) ∨ RareEarthMetals(x)) "
  },
  {
    "input": "Translate into first-order logic: All rare earth metals can be used for batteries.",
    "output": " ∀x (RareEarthMetals(x) → BeUsedForBatteries(x)) "
  },
  {
    "input": "Translate into first-order logic: All rare earth metals are essential for electric vehicles.",
    "output": " ∀x (RareEarthMetals(x) → EssentialForElectricVehicles(x))"
  },
  {
    "input": "Translate into first-order logic: Lithium is neither a non-rare earth metal nor essential for electric vehicles.",
    "output": " ¬Non-rareEarthMetals(lithium) ⊕ ¬EssentialForElectricVehicles(lithium)"
  },
  {
    "input": "Translate into first-order logic: No precious metals aren't scarce.",
    "output": "∀x (PreciousMetals(x) → ¬NotScarce(x))"
  },
  {
    "input": "Translate into first-order logic: All non-rare earth metals are not scarce.",
    "output": " ∀x (Non-rareEarthMetals(x) → NotScarce(x)) "
  },
  {
    "input": "Translate into first-order logic: Either non-rare earth metals or rare earth metals.",
    "output": " ∀x (Non-rareEarthMetals(x) ∨ RareEarthMetals(x)) "
  },
  {
    "input": "Translate into first-order logic: All rare earth metals can be used for batteries.",
    "output": " ∀x (RareEarthMetals(x) → BeUsedForBatteries(x)) "
  },
  {
    "input": "Translate into first-order logic: All rare earth metals are essential for electric vehicles.",
    "output": " ∀x (RareEarthMetals(x) → EssentialForElectricVehicles(x))"
  },
  {
    "input": "Translate into first-order logic: Lithium is neither a non-rare earth metal nor essential for electric vehicles.",
    "output": " ¬Non-rareEarthMetals(lithium) ⊕ ¬EssentialForElectricVehicles(lithium)"
  },
  {
    "input": "Translate into first-order logic: If people own at least one pet, then they do not have tidy houses.",
    "output": "∀x (OwnPet(x) → ¬TidyHouse(x))"
  },
  {
    "input": "Translate into first-order logic: If people grew up with childhood pets, then they own at least one pet.",
    "output": "∀x (ChildhoodPet(x) → OwnPet(x))"
  },
  {
    "input": "Translate into first-order logic: If people hire a maid or cleaning service, then they have tidy houses.",
    "output": "∀x (HireCleaning(x) → TidyHouse(x))"
  },
  {
    "input": "Translate into first-order logic: If people live in the suburbs, then they have tidy houses.",
    "output": "∀x (Suburbs(x) → ChildhoodPet(x))"
  },
  {
    "input": "Translate into first-order logic: Jack either does not hire a maid or cleaning service or, if he does, then he does not own at least one pet.",
    "output": "¬(HireCleaning(jack) ⊕ OwnPet(jack))"
  },
  {
    "input": "Translate into first-order logic: If people own at least one pet, then they do not have tidy houses.",
    "output": "∀x (OwnPet(x) → ¬TidyHouse(x))"
  },
  {
    "input": "Translate into first-order logic: If people grew up with childhood pets, then they own at least one pet.",
    "output": "∀x (ChildhoodPet(x) → OwnPet(x))"
  },
  {
    "input": "Translate into first-order logic: If people hire a maid or cleaning service, then they have tidy houses.",
    "output": "∀x (HireCleaning(x) → TidyHouse(x))"
  },
  {
    "input": "Translate into first-order logic: If people live in the suburbs, then they have tidy houses.",
    "output": "∀x (Suburbs(x) → ChildhoodPet(x))"
  },
  {
    "input": "Translate into first-order logic: Jack either does not hire a maid or cleaning service or, if he does, then he does not own at least one pet.",
    "output": "¬(HireCleaning(jack) ⊕ OwnPet(jack))"
  },
  {
    "input": "Translate into first-order logic: If people own at least one pet, then they do not have tidy houses.",
    "output": "∀x (OwnPet(x) → ¬TidyHouse(x))"
  },
  {
    "input": "Translate into first-order logic: If people grew up with childhood pets, then they own at least one pet.",
    "output": "∀x (ChildhoodPet(x) → OwnPet(x))"
  },
  {
    "input": "Translate into first-order logic: If people hire a maid or cleaning service, then they have tidy houses.",
    "output": "∀x (HireCleaning(x) → TidyHouse(x))"
  },
  {
    "input": "Translate into first-order logic: If people live in the suburbs, then they have tidy houses.",
    "output": "∀x (Suburbs(x) → ChildhoodPet(x))"
  },
  {
    "input": "Translate into first-order logic: Jack either does not hire a maid or cleaning service or, if he does, then he does not own at least one pet.",
    "output": "¬(HireCleaning(jack) ⊕ OwnPet(jack))"
  },
  {
    "input": "Translate into first-order logic: If people own at least one pet, then they do not have tidy houses.",
    "output": "∀x (OwnPet(x) → ¬TidyHouse(x))"
  },
  {
    "input": "Translate into first-order logic: If people grew up with childhood pets, then they own at least one pet.",
    "output": "∀x (ChildhoodPet(x) → OwnPet(x))"
  },
  {
    "input": "Translate into first-order logic: If people hire a maid or cleaning service, then they have tidy houses.",
    "output": "∀x (HireCleaning(x) → TidyHouse(x))"
  },
  {
    "input": "Translate into first-order logic: If people live in the suburbs, then they have tidy houses.",
    "output": "∀x (Suburbs(x) → ChildhoodPet(x))"
  },
  {
    "input": "Translate into first-order logic: Jack either does not hire a maid or cleaning service or, if he does, then he does not own at least one pet.",
    "output": "¬(HireCleaning(jack) ⊕ OwnPet(jack))"
  },
  {
    "input": "Translate into first-order logic: If people own at least one pet, then they do not have tidy houses.",
    "output": "∀x (OwnPet(x) → ¬TidyHouse(x))"
  },
  {
    "input": "Translate into first-order logic: If people grew up with childhood pets, then they own at least one pet.",
    "output": "∀x (ChildhoodPet(x) → OwnPet(x))"
  },
  {
    "input": "Translate into first-order logic: If people hire a maid or cleaning service, then they have tidy houses.",
    "output": "∀x (HireCleaning(x) → TidyHouse(x))"
  },
  {
    "input": "Translate into first-order logic: If people live in the suburbs, then they have tidy houses.",
    "output": "∀x (Suburbs(x) → ChildhoodPet(x))"
  },
  {
    "input": "Translate into first-order logic: Jack either does not hire a maid or cleaning service or, if he does, then he does not own at least one pet.",
    "output": "¬(HireCleaning(jack) ⊕ OwnPet(jack))"
  },
  {
    "input": "Translate into first-order logic: A bottle is either standing upright or toppled over.",
    "output": "Upright(bottle) ⊕ ToppledOver(bottle)"
  },
  {
    "input": "Translate into first-order logic: The bottle is not upright.",
    "output": "¬Upright(bottle)"
  },
  {
    "input": "Translate into first-order logic: If people eat cereal and milk every day for breakfast, then they have very busy morning schedules every day.",
    "output": "∀x (Cereal(x) → BusyMorning(x))"
  },
  {
    "input": "Translate into first-order logic: All young children below the age of ten eat cereal and milk every day for breakfast.",
    "output": "∀x (YoungChildren(x) → BusyMorning(x))"
  },
  {
    "input": "Translate into first-order logic: People are either young children below the age of ten or have a lot of commitments they voluntarily signed up for.",
    "output": "∀x (YoungChildren(x) ⊕ Committments(x))"
  },
  {
    "input": "Translate into first-order logic: If people have a lot of commitments they voluntarily signed up for, then they are hardworking individuals with high ambitions and goals for the future.",
    "output": "∀x (Committments(x) → Hardworking(x))"
  },
  {
    "input": "Translate into first-order logic: If people are hardworking individuals with high ambitions and goals for the future, then they are not good at staying organized and motivated.",
    "output": "∀x (Hardworking(x) → ¬Organized(x))"
  },
  {
    "input": "Translate into first-order logic: John either is both a hardworking individual with high ambitions and goals for the future and has busy morning schedules every day, or he is neither a hardworking individual with high ambitions and goals for the future nor does he have a busy morning schedule every day.",
    "output": "(Hardworking(john) ∧ BusyMorning(john)) ⊕ (¬Hardworking(john) ∧ ¬BusyMorning(john))"
  },
  {
    "input": "Translate into first-order logic: If people eat cereal and milk every day for breakfast, then they have very busy morning schedules every day.",
    "output": "∀x (Cereal(x) → BusyMorning(x))"
  },
  {
    "input": "Translate into first-order logic: All young children below the age of ten eat cereal and milk every day for breakfast.",
    "output": "∀x (YoungChildren(x) → BusyMorning(x))"
  },
  {
    "input": "Translate into first-order logic: People are either young children below the age of ten or have a lot of commitments they voluntarily signed up for.",
    "output": "∀x (YoungChildren(x) ⊕ Committments(x))"
  },
  {
    "input": "Translate into first-order logic: If people have a lot of commitments they voluntarily signed up for, then they are hardworking individuals with high ambitions and goals for the future.",
    "output": "∀x (Committments(x) → Hardworking(x))"
  },
  {
    "input": "Translate into first-order logic: If people are hardworking individuals with high ambitions and goals for the future, then they are not good at staying organized and motivated.",
    "output": "∀x (Hardworking(x) → ¬Organized(x))"
  },
  {
    "input": "Translate into first-order logic: John either is both a hardworking individual with high ambitions and goals for the future and has busy morning schedules every day, or he is neither a hardworking individual with high ambitions and goals for the future nor does he have a busy morning schedule every day.",
    "output": "(Hardworking(john) ∧ BusyMorning(john)) ⊕ (¬Hardworking(john) ∧ ¬BusyMorning(john))"
  },
  {
    "input": "Translate into first-order logic: If people eat cereal and milk every day for breakfast, then they have very busy morning schedules every day.",
    "output": "∀x (Cereal(x) → BusyMorning(x))"
  },
  {
    "input": "Translate into first-order logic: All young children below the age of ten eat cereal and milk every day for breakfast.",
    "output": "∀x (YoungChildren(x) → BusyMorning(x))"
  },
  {
    "input": "Translate into first-order logic: People are either young children below the age of ten or have a lot of commitments they voluntarily signed up for.",
    "output": "∀x (YoungChildren(x) ⊕ Committments(x))"
  },
  {
    "input": "Translate into first-order logic: If people have a lot of commitments they voluntarily signed up for, then they are hardworking individuals with high ambitions and goals for the future.",
    "output": "∀x (Committments(x) → Hardworking(x))"
  },
  {
    "input": "Translate into first-order logic: If people are hardworking individuals with high ambitions and goals for the future, then they are not good at staying organized and motivated.",
    "output": "∀x (Hardworking(x) → ¬Organized(x))"
  },
  {
    "input": "Translate into first-order logic: John either is both a hardworking individual with high ambitions and goals for the future and has busy morning schedules every day, or he is neither a hardworking individual with high ambitions and goals for the future nor does he have a busy morning schedule every day.",
    "output": "(Hardworking(john) ∧ BusyMorning(john)) ⊕ (¬Hardworking(john) ∧ ¬BusyMorning(john))"
  },
  {
    "input": "Translate into first-order logic: Ableton has an office in Germany.",
    "output": "OfficeIn(ableton, germany)"
  },
  {
    "input": "Translate into first-order logic: Ableton has an office in the USA.",
    "output": "OfficeIn(ableton, usa)"
  },
  {
    "input": "Translate into first-order logic: USA and Germany are different countries.",
    "output": "¬SameCountry(germany, usa)"
  },
  {
    "input": "Translate into first-order logic: Any company that has offices in different countries is a multinational company.",
    "output": "∀x ∀y ∀z (OfficeIn(x, y) ∧ OfficeIn(x, z) ∧ ¬SameCountry(y, z) → IsMultinationalCompany(x))"
  },
  {
    "input": "Translate into first-order logic: Ableton makes music software.",
    "output": "MakesMusicSoftware(ableton)"
  },
  {
    "input": "Translate into first-order logic: Ableton has an office in Germany.",
    "output": "OfficeIn(ableton, germany)"
  },
  {
    "input": "Translate into first-order logic: Ableton has an office in the USA.",
    "output": "OfficeIn(ableton, usa)"
  },
  {
    "input": "Translate into first-order logic: USA and Germany are different countries.",
    "output": "¬SameCountry(germany, usa)"
  },
  {
    "input": "Translate into first-order logic: Any company that has offices in different countries is a multinational company.",
    "output": "∀x ∀y ∀z (OfficeIn(x, y) ∧ OfficeIn(x, z) ∧ ¬SameCountry(y, z) → IsMultinationalCompany(x))"
  },
  {
    "input": "Translate into first-order logic: Ableton makes music software.",
    "output": "MakesMusicSoftware(ableton)"
  },
  {
    "input": "Translate into first-order logic: Ableton has an office in Germany.",
    "output": "OfficeIn(ableton, germany)"
  },
  {
    "input": "Translate into first-order logic: Ableton has an office in the USA.",
    "output": "OfficeIn(ableton, usa)"
  },
  {
    "input": "Translate into first-order logic: USA and Germany are different countries.",
    "output": "¬SameCountry(germany, usa)"
  },
  {
    "input": "Translate into first-order logic: Any company that has offices in different countries is a multinational company.",
    "output": "∀x ∀y ∀z (OfficeIn(x, y) ∧ OfficeIn(x, z) ∧ ¬SameCountry(y, z) → IsMultinationalCompany(x))"
  },
  {
    "input": "Translate into first-order logic: Ableton makes music software.",
    "output": "MakesMusicSoftware(ableton)"
  },
  {
    "input": "Translate into first-order logic: Every swimmer can go underwater.",
    "output": "∀x (Swimmer(x) → GoesUnderwater(x))"
  },
  {
    "input": "Translate into first-order logic: Everyone that eats fish they catch themselves is a swimmer.",
    "output": "∀x (EatsFishCaughtThemselves(x) → Swimmer(x))"
  },
  {
    "input": "Translate into first-order logic: Every penguin eats fish they catch themselves.",
    "output": "∀x (Penguin(x) → EatsFishCaughtThemselves(x))"
  },
  {
    "input": "Translate into first-order logic: All nonflying birds in Antarctica are penguins.",
    "output": "∀x (NonFlyingBirdAntartica(x) → Penguin(x))"
  },
  {
    "input": "Translate into first-order logic: Fido is a penguin or a swimmer.",
    "output": "Penguin(fido) ∨ Swimmer(fido)"
  },
  {
    "input": "Translate into first-order logic: Every swimmer can go underwater.",
    "output": "∀x (Swimmer(x) → GoesUnderwater(x))"
  },
  {
    "input": "Translate into first-order logic: Everyone that eats fish they catch themselves is a swimmer.",
    "output": "∀x (EatsFishCaughtThemselves(x) → Swimmer(x))"
  },
  {
    "input": "Translate into first-order logic: Every penguin eats fish they catch themselves.",
    "output": "∀x (Penguin(x) → EatsFishCaughtThemselves(x))"
  },
  {
    "input": "Translate into first-order logic: All nonflying birds in Antarctica are penguins.",
    "output": "∀x (NonFlyingBirdAntartica(x) → Penguin(x))"
  },
  {
    "input": "Translate into first-order logic: Fido is a penguin or a swimmer.",
    "output": "Penguin(fido) ∨ Swimmer(fido)"
  },
  {
    "input": "Translate into first-order logic: Every swimmer can go underwater.",
    "output": "∀x (Swimmer(x) → GoesUnderwater(x))"
  },
  {
    "input": "Translate into first-order logic: Everyone that eats fish they catch themselves is a swimmer.",
    "output": "∀x (EatsFishCaughtThemselves(x) → Swimmer(x))"
  },
  {
    "input": "Translate into first-order logic: Every penguin eats fish they catch themselves.",
    "output": "∀x (Penguin(x) → EatsFishCaughtThemselves(x))"
  },
  {
    "input": "Translate into first-order logic: All nonflying birds in Antarctica are penguins.",
    "output": "∀x (NonFlyingBirdAntartica(x) → Penguin(x))"
  },
  {
    "input": "Translate into first-order logic: Fido is a penguin or a swimmer.",
    "output": "Penguin(fido) ∨ Swimmer(fido)"
  },
  {
    "input": "Translate into first-order logic: All professors are teachers.",
    "output": "∀x (Professor(x) → Teacher(x))"
  },
  {
    "input": "Translate into first-order logic: All researchers are professors.",
    "output": "∀x (Researcher(x) → Professor(x))"
  },
  {
    "input": "Translate into first-order logic: No teachers are students.",
    "output": "∀x (Teacher(x) → ¬Student(x))"
  },
  {
    "input": "Translate into first-order logic: All people who study are students.",
    "output": "∀x (Study(x) → Student(x))"
  },
  {
    "input": "Translate into first-order logic: Leon is not studying or a researcher.",
    "output": "¬Study(leon) ⊕ Researcher(leon)"
  },
  {
    "input": "Translate into first-order logic: If Leon is not studying, then Leon is a teacher.",
    "output": "¬Study(leon) → Teacher(leon)"
  },
  {
    "input": "Translate into first-order logic: All professors are teachers.",
    "output": "∀x (Professor(x) → Teacher(x))"
  },
  {
    "input": "Translate into first-order logic: All researchers are professors.",
    "output": "∀x (Researcher(x) → Professor(x))"
  },
  {
    "input": "Translate into first-order logic: No teachers are students.",
    "output": "∀x (Teacher(x) → ¬Student(x))"
  },
  {
    "input": "Translate into first-order logic: All people who study are students.",
    "output": "∀x (Study(x) → Student(x))"
  },
  {
    "input": "Translate into first-order logic: Leon is not studying or a researcher.",
    "output": "¬Study(leon) ⊕ Researcher(leon)"
  },
  {
    "input": "Translate into first-order logic: If Leon is not studying, then Leon is a teacher.",
    "output": "¬Study(leon) → Teacher(leon)"
  },
  {
    "input": "Translate into first-order logic: All professors are teachers.",
    "output": "∀x (Professor(x) → Teacher(x))"
  },
  {
    "input": "Translate into first-order logic: All researchers are professors.",
    "output": "∀x (Researcher(x) → Professor(x))"
  },
  {
    "input": "Translate into first-order logic: No teachers are students.",
    "output": "∀x (Teacher(x) → ¬Student(x))"
  },
  {
    "input": "Translate into first-order logic: All people who study are students.",
    "output": "∀x (Study(x) → Student(x))"
  },
  {
    "input": "Translate into first-order logic: Leon is not studying or a researcher.",
    "output": "¬Study(leon) ⊕ Researcher(leon)"
  },
  {
    "input": "Translate into first-order logic: If Leon is not studying, then Leon is a teacher.",
    "output": "¬Study(leon) → Teacher(leon)"
  },
  {
    "input": "Translate into first-order logic: A cutman is responsible for preventing and treating physical damage to a fighter.",
    "output": "∀x (Cutman(x) → Prevent(x, physicalDamage) ∧ Treat(x, physicalDamage))"
  },
  {
    "input": "Translate into first-order logic: Cutmen appear in matches such as a boxing, kickboxing or a mixed martial arts bout.",
    "output": "∀x (Cutman(x) → Appear(x, boxing) ∨ Appear(x, kickboxing) ∨ Appear(x, mixedMartialBout))"
  },
  {
    "input": "Translate into first-order logic: Cutmen typically handle swelling, nosebleeds and lacerations.",
    "output": "∀x (Cutman(x) → Handle(x, swelling) ∧ Handle(x, nosebleeds) ∧ Handle(x, lacerations))"
  },
  {
    "input": "Translate into first-order logic: Jack is a cutman.",
    "output": "Cutman(jack)"
  },
  {
    "input": "Translate into first-order logic: A cutman is responsible for preventing and treating physical damage to a fighter.",
    "output": "∀x (Cutman(x) → Prevent(x, physicalDamage) ∧ Treat(x, physicalDamage))"
  },
  {
    "input": "Translate into first-order logic: Cutmen appear in matches such as a boxing, kickboxing or a mixed martial arts bout.",
    "output": "∀x (Cutman(x) → Appear(x, boxing) ∨ Appear(x, kickboxing) ∨ Appear(x, mixedMartialBout))"
  },
  {
    "input": "Translate into first-order logic: Cutmen typically handle swelling, nosebleeds and lacerations.",
    "output": "∀x (Cutman(x) → Handle(x, swelling) ∧ Handle(x, nosebleeds) ∧ Handle(x, lacerations))"
  },
  {
    "input": "Translate into first-order logic: Jack is a cutman.",
    "output": "Cutman(jack)"
  },
  {
    "input": "Translate into first-order logic: A cutman is responsible for preventing and treating physical damage to a fighter.",
    "output": "∀x (Cutman(x) → Prevent(x, physicalDamage) ∧ Treat(x, physicalDamage))"
  },
  {
    "input": "Translate into first-order logic: Cutmen appear in matches such as a boxing, kickboxing or a mixed martial arts bout.",
    "output": "∀x (Cutman(x) → Appear(x, boxing) ∨ Appear(x, kickboxing) ∨ Appear(x, mixedMartialBout))"
  },
  {
    "input": "Translate into first-order logic: Cutmen typically handle swelling, nosebleeds and lacerations.",
    "output": "∀x (Cutman(x) → Handle(x, swelling) ∧ Handle(x, nosebleeds) ∧ Handle(x, lacerations))"
  },
  {
    "input": "Translate into first-order logic: Jack is a cutman.",
    "output": "Cutman(jack)"
  },
  {
    "input": "Translate into first-order logic: The Mona Lisa is one of the world's best-known artworks.",
    "output": "Painting(monaLisa) ∧ WorldsBestKnown(monaLisa)"
  },
  {
    "input": "Translate into first-order logic: The Mona Lisa is a portrait painted by Leonardo da Vinci.",
    "output": "PaintedBy(monaLisa, leonardodaVinci) ∧ Portrait(monaLisa)"
  },
  {
    "input": "Translate into first-order logic: Leonardo da Vinci was a scientist and painter.",
    "output": "Scientist(leonardodaVinci) ∧ Painter(leonardodaVinci)"
  },
  {
    "input": "Translate into first-order logic: Painting genres are history, portrait, animal, landscape, and still life.",
    "output": "∀x (Painting(x) → (History(x) ∨ Portrait(x) ∨ Animal(x) ∨ Landscape(x) ∨ StillLife(x)))"
  },
  {
    "input": "Translate into first-order logic: The Mona Lisa is one of the world's best-known artworks.",
    "output": "Painting(monaLisa) ∧ WorldsBestKnown(monaLisa)"
  },
  {
    "input": "Translate into first-order logic: The Mona Lisa is a portrait painted by Leonardo da Vinci.",
    "output": "PaintedBy(monaLisa, leonardodaVinci) ∧ Portrait(monaLisa)"
  },
  {
    "input": "Translate into first-order logic: Leonardo da Vinci was a scientist and painter.",
    "output": "Scientist(leonardodaVinci) ∧ Painter(leonardodaVinci)"
  },
  {
    "input": "Translate into first-order logic: Painting genres are history, portrait, animal, landscape, and still life.",
    "output": "∀x (Painting(x) → (History(x) ∨ Portrait(x) ∨ Animal(x) ∨ Landscape(x) ∨ StillLife(x)))"
  },
  {
    "input": "Translate into first-order logic: The Mona Lisa is one of the world's best-known artworks.",
    "output": "Painting(monaLisa) ∧ WorldsBestKnown(monaLisa)"
  },
  {
    "input": "Translate into first-order logic: The Mona Lisa is a portrait painted by Leonardo da Vinci.",
    "output": "PaintedBy(monaLisa, leonardodaVinci) ∧ Portrait(monaLisa)"
  },
  {
    "input": "Translate into first-order logic: Leonardo da Vinci was a scientist and painter.",
    "output": "Scientist(leonardodaVinci) ∧ Painter(leonardodaVinci)"
  },
  {
    "input": "Translate into first-order logic: Painting genres are history, portrait, animal, landscape, and still life.",
    "output": "∀x (Painting(x) → (History(x) ∨ Portrait(x) ∨ Animal(x) ∨ Landscape(x) ∨ StillLife(x)))"
  },
  {
    "input": "Translate into first-order logic: No professional tennis umpires are professional tennis players.",
    "output": "∀x (ProfessionalTennisUmpire(x) → ¬ProfessionalTennisPlayer(x))"
  },
  {
    "input": "Translate into first-order logic: If you are a World Tour player, then you are a professional tennis player.",
    "output": "∀x (WorldTourPlayer(x) → ProfessionalTennisPlayer(x))"
  },
  {
    "input": "Translate into first-order logic: All Grand Slam champions are World Tour players.",
    "output": "∀x (GrandSlamChampion(x) → WorldTourPlayer(x))"
  },
  {
    "input": "Translate into first-order logic: All Grand Slam umpires are professional tennis umpires.",
    "output": "∀x (GrandSlamUmpire(x) → ProfessionalTennisUmpire(x))"
  },
  {
    "input": "Translate into first-order logic: Nadal is a World Tour player or a Grand Slam champion",
    "output": "WorldTourPlayer(nadal) ∨ GrandSlamChampion(nadal)"
  },
  {
    "input": "Translate into first-order logic: No professional tennis umpires are professional tennis players.",
    "output": "∀x (ProfessionalTennisUmpire(x) → ¬ProfessionalTennisPlayer(x))"
  },
  {
    "input": "Translate into first-order logic: If you are a World Tour player, then you are a professional tennis player.",
    "output": "∀x (WorldTourPlayer(x) → ProfessionalTennisPlayer(x))"
  },
  {
    "input": "Translate into first-order logic: All Grand Slam champions are World Tour players.",
    "output": "∀x (GrandSlamChampion(x) → WorldTourPlayer(x))"
  },
  {
    "input": "Translate into first-order logic: All Grand Slam umpires are professional tennis umpires.",
    "output": "∀x (GrandSlamUmpire(x) → ProfessionalTennisUmpire(x))"
  },
  {
    "input": "Translate into first-order logic: Nadal is a World Tour player or a Grand Slam champion",
    "output": "WorldTourPlayer(nadal) ∨ GrandSlamChampion(nadal)"
  },
  {
    "input": "Translate into first-order logic: No professional tennis umpires are professional tennis players.",
    "output": "∀x (ProfessionalTennisUmpire(x) → ¬ProfessionalTennisPlayer(x))"
  },
  {
    "input": "Translate into first-order logic: If you are a World Tour player, then you are a professional tennis player.",
    "output": "∀x (WorldTourPlayer(x) → ProfessionalTennisPlayer(x))"
  },
  {
    "input": "Translate into first-order logic: All Grand Slam champions are World Tour players.",
    "output": "∀x (GrandSlamChampion(x) → WorldTourPlayer(x))"
  },
  {
    "input": "Translate into first-order logic: All Grand Slam umpires are professional tennis umpires.",
    "output": "∀x (GrandSlamUmpire(x) → ProfessionalTennisUmpire(x))"
  },
  {
    "input": "Translate into first-order logic: Nadal is a World Tour player or a Grand Slam champion",
    "output": "WorldTourPlayer(nadal) ∨ GrandSlamChampion(nadal)"
  },
  {
    "input": "Translate into first-order logic: No professional tennis umpires are professional tennis players.",
    "output": "∀x (ProfessionalTennisUmpire(x) → ¬ProfessionalTennisPlayer(x))"
  },
  {
    "input": "Translate into first-order logic: If you are a World Tour player, then you are a professional tennis player.",
    "output": "∀x (WorldTourPlayer(x) → ProfessionalTennisPlayer(x))"
  },
  {
    "input": "Translate into first-order logic: All Grand Slam champions are World Tour players.",
    "output": "∀x (GrandSlamChampion(x) → WorldTourPlayer(x))"
  },
  {
    "input": "Translate into first-order logic: All Grand Slam umpires are professional tennis umpires.",
    "output": "∀x (GrandSlamUmpire(x) → ProfessionalTennisUmpire(x))"
  },
  {
    "input": "Translate into first-order logic: Nadal is a World Tour player or a Grand Slam champion",
    "output": "WorldTourPlayer(nadal) ∨ GrandSlamChampion(nadal)"
  },
  {
    "input": "Translate into first-order logic: No professional tennis umpires are professional tennis players.",
    "output": "∀x (ProfessionalTennisUmpire(x) → ¬ProfessionalTennisPlayer(x))"
  },
  {
    "input": "Translate into first-order logic: If you are a World Tour player, then you are a professional tennis player.",
    "output": "∀x (WorldTourPlayer(x) → ProfessionalTennisPlayer(x))"
  },
  {
    "input": "Translate into first-order logic: All Grand Slam champions are World Tour players.",
    "output": "∀x (GrandSlamChampion(x) → WorldTourPlayer(x))"
  },
  {
    "input": "Translate into first-order logic: All Grand Slam umpires are professional tennis umpires.",
    "output": "∀x (GrandSlamUmpire(x) → ProfessionalTennisUmpire(x))"
  },
  {
    "input": "Translate into first-order logic: Nadal is a World Tour player or a Grand Slam champion",
    "output": "WorldTourPlayer(nadal) ∨ GrandSlamChampion(nadal)"
  },
  {
    "input": "Translate into first-order logic: No professional tennis umpires are professional tennis players.",
    "output": "∀x (ProfessionalTennisUmpire(x) → ¬ProfessionalTennisPlayer(x))"
  },
  {
    "input": "Translate into first-order logic: If you are a World Tour player, then you are a professional tennis player.",
    "output": "∀x (WorldTourPlayer(x) → ProfessionalTennisPlayer(x))"
  },
  {
    "input": "Translate into first-order logic: All Grand Slam champions are World Tour players.",
    "output": "∀x (GrandSlamChampion(x) → WorldTourPlayer(x))"
  },
  {
    "input": "Translate into first-order logic: All Grand Slam umpires are professional tennis umpires.",
    "output": "∀x (GrandSlamUmpire(x) → ProfessionalTennisUmpire(x))"
  },
  {
    "input": "Translate into first-order logic: Nadal is a World Tour player or a Grand Slam champion",
    "output": "WorldTourPlayer(nadal) ∨ GrandSlamChampion(nadal)"
  },
  {
    "input": "Translate into first-order logic: Buisnesses are either sanctioned or unsanctioned.",
    "output": "∀x (Buisness(x) → Sanctioned(x) ⊕ ¬Sanctioned(x))"
  },
  {
    "input": "Translate into first-order logic: Sanctioned buisnesses are limited.",
    "output": "∀x (Buisness(x) ∧ Sanctioned(x) → Limited(x))"
  },
  {
    "input": "Translate into first-order logic: Unsanctioned buisnesses are free.",
    "output": "∀x (Buisness(x) ∧ ¬Sanctioned(x) → Free(x))"
  },
  {
    "input": "Translate into first-order logic: The Crude Oil Data Exchange is a buisness that isn't free.",
    "output": "Buisness(crudeoildataexchange) ∧ ¬Free(crudeoildataexchange)"
  },
  {
    "input": "Translate into first-order logic: Buisnesses are either sanctioned or unsanctioned.",
    "output": "∀x (Buisness(x) → Sanctioned(x) ⊕ ¬Sanctioned(x))"
  },
  {
    "input": "Translate into first-order logic: Sanctioned buisnesses are limited.",
    "output": "∀x (Buisness(x) ∧ Sanctioned(x) → Limited(x))"
  },
  {
    "input": "Translate into first-order logic: Unsanctioned buisnesses are free.",
    "output": "∀x (Buisness(x) ∧ ¬Sanctioned(x) → Free(x))"
  },
  {
    "input": "Translate into first-order logic: The Crude Oil Data Exchange is a buisness that isn't free.",
    "output": "Buisness(crudeoildataexchange) ∧ ¬Free(crudeoildataexchange)"
  },
  {
    "input": "Translate into first-order logic: Buisnesses are either sanctioned or unsanctioned.",
    "output": "∀x (Buisness(x) → Sanctioned(x) ⊕ ¬Sanctioned(x))"
  },
  {
    "input": "Translate into first-order logic: Sanctioned buisnesses are limited.",
    "output": "∀x (Buisness(x) ∧ Sanctioned(x) → Limited(x))"
  },
  {
    "input": "Translate into first-order logic: Unsanctioned buisnesses are free.",
    "output": "∀x (Buisness(x) ∧ ¬Sanctioned(x) → Free(x))"
  },
  {
    "input": "Translate into first-order logic: The Crude Oil Data Exchange is a buisness that isn't free.",
    "output": "Buisness(crudeoildataexchange) ∧ ¬Free(crudeoildataexchange)"
  },
  {
    "input": "Translate into first-order logic: When something is depressing, it is sad.",
    "output": "∀x (Depressing(x) → Sad(x))"
  },
  {
    "input": "Translate into first-order logic: V is depressing.",
    "output": "∀x (V(x) → Depressing(x))"
  },
  {
    "input": "Translate into first-order logic: Palstaves are a type of early bronze axe.",
    "output": "∀x (Palstave(x) → From(x, earlybronzeage) ∧ Axe(x))"
  },
  {
    "input": "Translate into first-order logic: Commonly found in northern, western and south-western Europe, palstaves are cast in moulds.",
    "output": "∀x ∀y (Palstave(x) ∧ Mould(y) → FoundIn(x, northerneurope) ∧ FoundIn(x, westerneurope) ∧ FoundIn(x, south-westerneurope) ∧ CastIn(x, y))"
  },
  {
    "input": "Translate into first-order logic: John Evans is an archeologist who popularized the term \"palstave\".",
    "output": "Archeologist(johnevans) ∧ Popularized(johnevans, termpalstave)"
  },
  {
    "input": "Translate into first-order logic: A paalstab is not an axe, but rather a digging shovel.",
    "output": "∀x (Paalstab(x) → ¬Axe(x) ∧ DiggingShovel(x))"
  },
  {
    "input": "Translate into first-order logic: Palstaves are a type of early bronze axe.",
    "output": "∀x (Palstave(x) → From(x, earlybronzeage) ∧ Axe(x))"
  },
  {
    "input": "Translate into first-order logic: Commonly found in northern, western and south-western Europe, palstaves are cast in moulds.",
    "output": "∀x ∀y (Palstave(x) ∧ Mould(y) → FoundIn(x, northerneurope) ∧ FoundIn(x, westerneurope) ∧ FoundIn(x, south-westerneurope) ∧ CastIn(x, y))"
  },
  {
    "input": "Translate into first-order logic: John Evans is an archeologist who popularized the term \"palstave\".",
    "output": "Archeologist(johnevans) ∧ Popularized(johnevans, termpalstave)"
  },
  {
    "input": "Translate into first-order logic: A paalstab is not an axe, but rather a digging shovel.",
    "output": "∀x (Paalstab(x) → ¬Axe(x) ∧ DiggingShovel(x))"
  },
  {
    "input": "Translate into first-order logic: Palstaves are a type of early bronze axe.",
    "output": "∀x (Palstave(x) → From(x, earlybronzeage) ∧ Axe(x))"
  },
  {
    "input": "Translate into first-order logic: Commonly found in northern, western and south-western Europe, palstaves are cast in moulds.",
    "output": "∀x ∀y (Palstave(x) ∧ Mould(y) → FoundIn(x, northerneurope) ∧ FoundIn(x, westerneurope) ∧ FoundIn(x, south-westerneurope) ∧ CastIn(x, y))"
  },
  {
    "input": "Translate into first-order logic: John Evans is an archeologist who popularized the term \"palstave\".",
    "output": "Archeologist(johnevans) ∧ Popularized(johnevans, termpalstave)"
  },
  {
    "input": "Translate into first-order logic: A paalstab is not an axe, but rather a digging shovel.",
    "output": "∀x (Paalstab(x) → ¬Axe(x) ∧ DiggingShovel(x))"
  },
  {
    "input": "Translate into first-order logic: Koei Tecmo is a Japanese video game and anime holding company.",
    "output": "Japanese(koeitecmo) ∧ VideoGameHoldingCompany(koeitecmo) ∧ AnimeHoldingCompany(koeitecmo)"
  },
  {
    "input": "Translate into first-order logic: Holding companies hold several companies.",
    "output": "∀x ∃y (HoldingCompany(x) → Company(y) ∧ Holds(x, y))"
  },
  {
    "input": "Translate into first-order logic: Tecmo was disbanded in Japan, while Koei survived, but was renamed.",
    "output": "Disbanded(tecmo) ∧ DisbandedIn(tecmo, japan) ∧ Survived(koei) ∧ Renamed(koei)"
  },
  {
    "input": "Translate into first-order logic: Video game holding companies are holding companies.",
    "output": "∀x (VideoGameHoldingCompany(x) → HoldingCompany(x))"
  },
  {
    "input": "Translate into first-order logic: Koei Tecmo is a Japanese video game and anime holding company.",
    "output": "Japanese(koeitecmo) ∧ VideoGameHoldingCompany(koeitecmo) ∧ AnimeHoldingCompany(koeitecmo)"
  },
  {
    "input": "Translate into first-order logic: Holding companies hold several companies.",
    "output": "∀x ∃y (HoldingCompany(x) → Company(y) ∧ Holds(x, y))"
  },
  {
    "input": "Translate into first-order logic: Tecmo was disbanded in Japan, while Koei survived, but was renamed.",
    "output": "Disbanded(tecmo) ∧ DisbandedIn(tecmo, japan) ∧ Survived(koei) ∧ Renamed(koei)"
  },
  {
    "input": "Translate into first-order logic: Video game holding companies are holding companies.",
    "output": "∀x (VideoGameHoldingCompany(x) → HoldingCompany(x))"
  },
  {
    "input": "Translate into first-order logic: Koei Tecmo is a Japanese video game and anime holding company.",
    "output": "Japanese(koeitecmo) ∧ VideoGameHoldingCompany(koeitecmo) ∧ AnimeHoldingCompany(koeitecmo)"
  },
  {
    "input": "Translate into first-order logic: Holding companies hold several companies.",
    "output": "∀x ∃y (HoldingCompany(x) → Company(y) ∧ Holds(x, y))"
  },
  {
    "input": "Translate into first-order logic: Tecmo was disbanded in Japan, while Koei survived, but was renamed.",
    "output": "Disbanded(tecmo) ∧ DisbandedIn(tecmo, japan) ∧ Survived(koei) ∧ Renamed(koei)"
  },
  {
    "input": "Translate into first-order logic: Video game holding companies are holding companies.",
    "output": "∀x (VideoGameHoldingCompany(x) → HoldingCompany(x))"
  },
  {
    "input": "Translate into first-order logic: The PlayStation EyeToy is a camera accessory for the Playstation 2.",
    "output": "Accessory(pseyetoy, ps2)"
  },
  {
    "input": "Translate into first-order logic: The PlayStation Eye is a camera accessory for the Playstation 3.",
    "output": "Accessory(pseye, ps3)"
  },
  {
    "input": "Translate into first-order logic: The Playstation Camera is a camera accessory for the Playstation 4 and the Playstation 5.",
    "output": "Accessory(pscamera, ps4) ∧ Accessory(pscamera, ps5)"
  },
  {
    "input": "Translate into first-order logic: Camera accessory for the system is compatible with that system",
    "output": "∀x ∀y (Accessory(x, y) → Compatible(x, y))"
  },
  {
    "input": "Translate into first-order logic: Only the Playstation Camera is compatible with more than one system.",
    "output": "¬Compatible(pseye, ps2) ∧ ¬Compatible(pseye, ps4)∧¬Compatible(pseye, ps5)∧¬Compatible(pseyetoy, ps3)∧¬Compatible(pseyetoy, ps4)∧¬Compatible(pseyetoy, ps5)"
  },
  {
    "input": "Translate into first-order logic: The PlayStation EyeToy is a camera accessory for the Playstation 2.",
    "output": "Accessory(pseyetoy, ps2)"
  },
  {
    "input": "Translate into first-order logic: The PlayStation Eye is a camera accessory for the Playstation 3.",
    "output": "Accessory(pseye, ps3)"
  },
  {
    "input": "Translate into first-order logic: The Playstation Camera is a camera accessory for the Playstation 4 and the Playstation 5.",
    "output": "Accessory(pscamera, ps4) ∧ Accessory(pscamera, ps5)"
  },
  {
    "input": "Translate into first-order logic: Camera accessory for the system is compatible with that system",
    "output": "∀x ∀y (Accessory(x, y) → Compatible(x, y))"
  },
  {
    "input": "Translate into first-order logic: Only the Playstation Camera is compatible with more than one system.",
    "output": "¬Compatible(pseye, ps2) ∧ ¬Compatible(pseye, ps4)∧¬Compatible(pseye, ps5)∧¬Compatible(pseyetoy, ps3)∧¬Compatible(pseyetoy, ps4)∧¬Compatible(pseyetoy, ps5)"
  },
  {
    "input": "Translate into first-order logic: The PlayStation EyeToy is a camera accessory for the Playstation 2.",
    "output": "Accessory(pseyetoy, ps2)"
  },
  {
    "input": "Translate into first-order logic: The PlayStation Eye is a camera accessory for the Playstation 3.",
    "output": "Accessory(pseye, ps3)"
  },
  {
    "input": "Translate into first-order logic: The Playstation Camera is a camera accessory for the Playstation 4 and the Playstation 5.",
    "output": "Accessory(pscamera, ps4) ∧ Accessory(pscamera, ps5)"
  },
  {
    "input": "Translate into first-order logic: Camera accessory for the system is compatible with that system",
    "output": "∀x ∀y (Accessory(x, y) → Compatible(x, y))"
  },
  {
    "input": "Translate into first-order logic: Only the Playstation Camera is compatible with more than one system.",
    "output": "¬Compatible(pseye, ps2) ∧ ¬Compatible(pseye, ps4)∧¬Compatible(pseye, ps5)∧¬Compatible(pseyetoy, ps3)∧¬Compatible(pseyetoy, ps4)∧¬Compatible(pseyetoy, ps5)"
  },
  {
    "input": "Translate into first-order logic: Adam Buska is a European football player.",
    "output": "FootballPlayer(adambuska) ∧ European(adambuska)"
  },
  {
    "input": "Translate into first-order logic: If a European plays football, they play what Americans call soccer.",
    "output": "∀x ((FootballPlayer(x) ∧ European(x)) → PlaysAmericanSoccer(x))"
  },
  {
    "input": "Translate into first-order logic: If the game has sold more than 1 million copies, then it is on the Best Seller list.",
    "output": "∀x (SoldMillion(x) → BestSeller(x))"
  },
  {
    "input": "Translate into first-order logic: All Games developed by Paradox Development Studio sold more than 1 million copies.",
    "output": "∀x (DevelopedByParadox(x) → SoldMillion(x))"
  },
  {
    "input": "Translate into first-order logic: Some games published before 2010 support the Linux OS system.",
    "output": "∃x ((PublishedBefore2010(x) ∧ SupportLinuxSystem(x)))"
  },
  {
    "input": "Translate into first-order logic: All games on the Best Seller list are popular among young people.",
    "output": "∀x (BestSeller(x) → Popular(x))"
  },
  {
    "input": "Translate into first-order logic: FIFA22 neither supports the Linux OS system nor is it popular among young people.",
    "output": "¬(SupportLinuxSystem(fifa21) ∨ Popular(fifa21))"
  },
  {
    "input": "Translate into first-order logic: If the game has sold more than 1 million copies, then it is on the Best Seller list.",
    "output": "∀x (SoldMillion(x) → BestSeller(x))"
  },
  {
    "input": "Translate into first-order logic: All Games developed by Paradox Development Studio sold more than 1 million copies.",
    "output": "∀x (DevelopedByParadox(x) → SoldMillion(x))"
  },
  {
    "input": "Translate into first-order logic: Some games published before 2010 support the Linux OS system.",
    "output": "∃x ((PublishedBefore2010(x) ∧ SupportLinuxSystem(x)))"
  },
  {
    "input": "Translate into first-order logic: All games on the Best Seller list are popular among young people.",
    "output": "∀x (BestSeller(x) → Popular(x))"
  },
  {
    "input": "Translate into first-order logic: FIFA22 neither supports the Linux OS system nor is it popular among young people.",
    "output": "¬(SupportLinuxSystem(fifa21) ∨ Popular(fifa21))"
  },
  {
    "input": "Translate into first-order logic: If the game has sold more than 1 million copies, then it is on the Best Seller list.",
    "output": "∀x (SoldMillion(x) → BestSeller(x))"
  },
  {
    "input": "Translate into first-order logic: All Games developed by Paradox Development Studio sold more than 1 million copies.",
    "output": "∀x (DevelopedByParadox(x) → SoldMillion(x))"
  },
  {
    "input": "Translate into first-order logic: Some games published before 2010 support the Linux OS system.",
    "output": "∃x ((PublishedBefore2010(x) ∧ SupportLinuxSystem(x)))"
  },
  {
    "input": "Translate into first-order logic: All games on the Best Seller list are popular among young people.",
    "output": "∀x (BestSeller(x) → Popular(x))"
  },
  {
    "input": "Translate into first-order logic: FIFA22 neither supports the Linux OS system nor is it popular among young people.",
    "output": "¬(SupportLinuxSystem(fifa21) ∨ Popular(fifa21))"
  },
  {
    "input": "Translate into first-order logic: China is one of BRICS and its economy is emerging.",
    "output": "∀x (China(x) → BRICS(x) ∧ EmergingEconomy(x))"
  },
  {
    "input": "Translate into first-order logic: India is one of BRICS and its economy is emerging.",
    "output": "∀x (India(x) → BRICS(x) ∧ EmergingEconomy(x))"
  },
  {
    "input": "Translate into first-order logic: All people from China speak Chinese.",
    "output": "∀x ∀y (From(x, y) ∧ China(y) → Speak(x, chinese))"
  },
  {
    "input": "Translate into first-order logic: All people from India speak Hindi or English.",
    "output": "∀x ∀y (From(x, y) ∧ India(y) → Speak(x, hindi) ∨ Speak(x, english))"
  },
  {
    "input": "Translate into first-order logic: There is an Indian.",
    "output": "∃x ∃y (From(x, y) ∧ India(y))"
  },
  {
    "input": "Translate into first-order logic: China is one of BRICS and its economy is emerging.",
    "output": "∀x (China(x) → BRICS(x) ∧ EmergingEconomy(x))"
  },
  {
    "input": "Translate into first-order logic: India is one of BRICS and its economy is emerging.",
    "output": "∀x (India(x) → BRICS(x) ∧ EmergingEconomy(x))"
  },
  {
    "input": "Translate into first-order logic: All people from China speak Chinese.",
    "output": "∀x ∀y (From(x, y) ∧ China(y) → Speak(x, chinese))"
  },
  {
    "input": "Translate into first-order logic: All people from India speak Hindi or English.",
    "output": "∀x ∀y (From(x, y) ∧ India(y) → Speak(x, hindi) ∨ Speak(x, english))"
  },
  {
    "input": "Translate into first-order logic: There is an Indian.",
    "output": "∃x ∃y (From(x, y) ∧ India(y))"
  },
  {
    "input": "Translate into first-order logic: China is one of BRICS and its economy is emerging.",
    "output": "∀x (China(x) → BRICS(x) ∧ EmergingEconomy(x))"
  },
  {
    "input": "Translate into first-order logic: India is one of BRICS and its economy is emerging.",
    "output": "∀x (India(x) → BRICS(x) ∧ EmergingEconomy(x))"
  },
  {
    "input": "Translate into first-order logic: All people from China speak Chinese.",
    "output": "∀x ∀y (From(x, y) ∧ China(y) → Speak(x, chinese))"
  },
  {
    "input": "Translate into first-order logic: All people from India speak Hindi or English.",
    "output": "∀x ∀y (From(x, y) ∧ India(y) → Speak(x, hindi) ∨ Speak(x, english))"
  },
  {
    "input": "Translate into first-order logic: There is an Indian.",
    "output": "∃x ∃y (From(x, y) ∧ India(y))"
  },
  {
    "input": "Translate into first-order logic: Daveed Diggs is an actor and film producer.",
    "output": "Actor(daveedDiggs) ∧ FilmProducer(daveedDiggs)"
  },
  {
    "input": "Translate into first-order logic: Daveed Diggs played two roles in the musical Hamilton.",
    "output": "PlayedTwoRoles(daveedDiggs) ∧ PlayedIn(daveedDiggs, hamilton) ∧ Musical(hamilton)"
  },
  {
    "input": "Translate into first-order logic: One of the actors from Hamilton won the best actor award.",
    "output": "∃x (Actor(x) ∧ PlayedIn(x, hamilton) ∧ WonBestActorAward(x))"
  },
  {
    "input": "Translate into first-order logic: The actor playing Thomas Jefferson won the best actor award.",
    "output": "∀x (Actor(x) ∧ Played(x, thomasJefferson) → WonBestActorAward(x))"
  },
  {
    "input": "Translate into first-order logic: Daveed Diggs played Thomas Jefferson.",
    "output": "Played(daveedDiggs, thomasJefferson)"
  },
  {
    "input": "Translate into first-order logic: Musicals are not films.",
    "output": "∀x (Musical(x) → ¬Film(x))"
  },
  {
    "input": "Translate into first-order logic: Daveed Diggs is an actor and film producer.",
    "output": "Actor(daveedDiggs) ∧ FilmProducer(daveedDiggs)"
  },
  {
    "input": "Translate into first-order logic: Daveed Diggs played two roles in the musical Hamilton.",
    "output": "PlayedTwoRoles(daveedDiggs) ∧ PlayedIn(daveedDiggs, hamilton) ∧ Musical(hamilton)"
  },
  {
    "input": "Translate into first-order logic: One of the actors from Hamilton won the best actor award.",
    "output": "∃x (Actor(x) ∧ PlayedIn(x, hamilton) ∧ WonBestActorAward(x))"
  },
  {
    "input": "Translate into first-order logic: The actor playing Thomas Jefferson won the best actor award.",
    "output": "∀x (Actor(x) ∧ Played(x, thomasJefferson) → WonBestActorAward(x))"
  },
  {
    "input": "Translate into first-order logic: Daveed Diggs played Thomas Jefferson.",
    "output": "Played(daveedDiggs, thomasJefferson)"
  },
  {
    "input": "Translate into first-order logic: Musicals are not films.",
    "output": "∀x (Musical(x) → ¬Film(x))"
  },
  {
    "input": "Translate into first-order logic: Daveed Diggs is an actor and film producer.",
    "output": "Actor(daveedDiggs) ∧ FilmProducer(daveedDiggs)"
  },
  {
    "input": "Translate into first-order logic: Daveed Diggs played two roles in the musical Hamilton.",
    "output": "PlayedTwoRoles(daveedDiggs) ∧ PlayedIn(daveedDiggs, hamilton) ∧ Musical(hamilton)"
  },
  {
    "input": "Translate into first-order logic: One of the actors from Hamilton won the best actor award.",
    "output": "∃x (Actor(x) ∧ PlayedIn(x, hamilton) ∧ WonBestActorAward(x))"
  },
  {
    "input": "Translate into first-order logic: The actor playing Thomas Jefferson won the best actor award.",
    "output": "∀x (Actor(x) ∧ Played(x, thomasJefferson) → WonBestActorAward(x))"
  },
  {
    "input": "Translate into first-order logic: Daveed Diggs played Thomas Jefferson.",
    "output": "Played(daveedDiggs, thomasJefferson)"
  },
  {
    "input": "Translate into first-order logic: Musicals are not films.",
    "output": "∀x (Musical(x) → ¬Film(x))"
  },
  {
    "input": "Translate into first-order logic: Ernest Pohl was a Polish football player.",
    "output": "PolishFootballPlayer(ernestpohl)"
  },
  {
    "input": "Translate into first-order logic: A football player in the Polish First Division has scored over 180 goals.",
    "output": "∃x (In(x, polishfirstdivision) ∧ ScoredMoreThan180Goals(x))"
  },
  {
    "input": "Translate into first-order logic: Ernest Pohl scored more than 180 goals in the Polish First Division.",
    "output": "ScoredMoreThan180Goals(ernestpohl) ∧ In(ernestpohl, polishfirstdivision)"
  },
  {
    "input": "Translate into first-order logic: Górnik Zabrze's stadium was named after a soccer player from Ruda Śląska.",
    "output": "∃x (NamedAfter(gornikzabrze, x) ∧ FootballPlayer(x) ∧ From(x, rudaslaska))"
  },
  {
    "input": "Translate into first-order logic: Ernest Pohl is from Ruda Śląska.",
    "output": "From(ernestpohl, rudaslaska)"
  },
  {
    "input": "Translate into first-order logic: Ernest Pohl was a Polish football player.",
    "output": "PolishFootballPlayer(ernestpohl)"
  },
  {
    "input": "Translate into first-order logic: A football player in the Polish First Division has scored over 180 goals.",
    "output": "∃x (In(x, polishfirstdivision) ∧ ScoredMoreThan180Goals(x))"
  },
  {
    "input": "Translate into first-order logic: Ernest Pohl scored more than 180 goals in the Polish First Division.",
    "output": "ScoredMoreThan180Goals(ernestpohl) ∧ In(ernestpohl, polishfirstdivision)"
  },
  {
    "input": "Translate into first-order logic: Górnik Zabrze's stadium was named after a soccer player from Ruda Śląska.",
    "output": "∃x (NamedAfter(gornikzabrze, x) ∧ FootballPlayer(x) ∧ From(x, rudaslaska))"
  },
  {
    "input": "Translate into first-order logic: Ernest Pohl is from Ruda Śląska.",
    "output": "From(ernestpohl, rudaslaska)"
  },
  {
    "input": "Translate into first-order logic: Ann J. Land was a member of the Philadelphia City Council and was also a member of the Democratic Party.",
    "output": "PhiladephiaCouncil(annJLand) ∧ DemocraticParty(annJLand)"
  },
  {
    "input": "Translate into first-order logic: Ann J. Land ran unopposed for the Philadephia City Council in 1980.",
    "output": "Year(y1980) → PhiladephiaCouncil(annJLand) ∧ RunFor(annJLand)"
  },
  {
    "input": "Translate into first-order logic: People who run unopposed for the Philadelphia City Council are elected to the positions they run for in the same year.",
    "output": "∀x (RunFor(x) ∧ PhiladephiaCouncil(x) → Elected(x))"
  },
  {
    "input": "Translate into first-order logic: Michael Nutter was a political challenger.",
    "output": "Challenger(nutter)"
  },
  {
    "input": "Translate into first-order logic: Ann J. Land defeated Michael Nutter and ran for the Philadelphia City Council in 1987.",
    "output": "Year(y1987) → PhiladephiaCouncil(annJLand) ∧ RunFor(annJLand) ∧ Defeated(annJLand, nutter)"
  },
  {
    "input": "Translate into first-order logic: Ann J. Land was a member of the Philadelphia City Council and was also a member of the Democratic Party.",
    "output": "PhiladephiaCouncil(annJLand) ∧ DemocraticParty(annJLand)"
  },
  {
    "input": "Translate into first-order logic: Ann J. Land ran unopposed for the Philadephia City Council in 1980.",
    "output": "Year(y1980) → PhiladephiaCouncil(annJLand) ∧ RunFor(annJLand)"
  },
  {
    "input": "Translate into first-order logic: People who run unopposed for the Philadelphia City Council are elected to the positions they run for in the same year.",
    "output": "∀x (RunFor(x) ∧ PhiladephiaCouncil(x) → Elected(x))"
  },
  {
    "input": "Translate into first-order logic: Michael Nutter was a political challenger.",
    "output": "Challenger(nutter)"
  },
  {
    "input": "Translate into first-order logic: Ann J. Land defeated Michael Nutter and ran for the Philadelphia City Council in 1987.",
    "output": "Year(y1987) → PhiladephiaCouncil(annJLand) ∧ RunFor(annJLand) ∧ Defeated(annJLand, nutter)"
  },
  {
    "input": "Translate into first-order logic: Ann J. Land was a member of the Philadelphia City Council and was also a member of the Democratic Party.",
    "output": "PhiladephiaCouncil(annJLand) ∧ DemocraticParty(annJLand)"
  },
  {
    "input": "Translate into first-order logic: Ann J. Land ran unopposed for the Philadephia City Council in 1980.",
    "output": "Year(y1980) → PhiladephiaCouncil(annJLand) ∧ RunFor(annJLand)"
  },
  {
    "input": "Translate into first-order logic: People who run unopposed for the Philadelphia City Council are elected to the positions they run for in the same year.",
    "output": "∀x (RunFor(x) ∧ PhiladephiaCouncil(x) → Elected(x))"
  },
  {
    "input": "Translate into first-order logic: Michael Nutter was a political challenger.",
    "output": "Challenger(nutter)"
  },
  {
    "input": "Translate into first-order logic: Ann J. Land defeated Michael Nutter and ran for the Philadelphia City Council in 1987.",
    "output": "Year(y1987) → PhiladephiaCouncil(annJLand) ∧ RunFor(annJLand) ∧ Defeated(annJLand, nutter)"
  },
  {
    "input": "Translate into first-order logic: Aberdeen won the cup in the 2013 final.",
    "output": "WonCup(aberdeen, twentythirteen)"
  },
  {
    "input": "Translate into first-order logic: Rangers won the cup in 2014 final.",
    "output": "WonCup(rangers, twentyfourteen)"
  },
  {
    "input": "Translate into first-order logic: Aberdeen and Rangers are different teams.",
    "output": "Different(aberdeen, rangers) ∧ Different(rangers, aberdeen)"
  },
  {
    "input": "Translate into first-order logic: Different teams cannot win the same cup in a given year's final.",
    "output": "∀x ∀y ∀z (Different(x, y)  ∧ WonCup(x, z)  → ¬WonCup(y, z))"
  },
  {
    "input": "Translate into first-order logic: Aberdeen won the cup in the 2013 final.",
    "output": "WonCup(aberdeen, twentythirteen)"
  },
  {
    "input": "Translate into first-order logic: Rangers won the cup in 2014 final.",
    "output": "WonCup(rangers, twentyfourteen)"
  },
  {
    "input": "Translate into first-order logic: Aberdeen and Rangers are different teams.",
    "output": "Different(aberdeen, rangers) ∧ Different(rangers, aberdeen)"
  },
  {
    "input": "Translate into first-order logic: Different teams cannot win the same cup in a given year's final.",
    "output": "∀x ∀y ∀z (Different(x, y)  ∧ WonCup(x, z)  → ¬WonCup(y, z))"
  },
  {
    "input": "Translate into first-order logic: Aberdeen won the cup in the 2013 final.",
    "output": "WonCup(aberdeen, twentythirteen)"
  },
  {
    "input": "Translate into first-order logic: Rangers won the cup in 2014 final.",
    "output": "WonCup(rangers, twentyfourteen)"
  },
  {
    "input": "Translate into first-order logic: Aberdeen and Rangers are different teams.",
    "output": "Different(aberdeen, rangers) ∧ Different(rangers, aberdeen)"
  },
  {
    "input": "Translate into first-order logic: Different teams cannot win the same cup in a given year's final.",
    "output": "∀x ∀y ∀z (Different(x, y)  ∧ WonCup(x, z)  → ¬WonCup(y, z))"
  },
  {
    "input": "Translate into first-order logic: All young working professionals who have regular 9-5 jobs also have pets.",
    "output": "∀x (Working(x) → Pets(x))"
  },
  {
    "input": "Translate into first-order logic: Some people who live in Manhattan are young working professionals who have regular 9-5 jobs.",
    "output": "∃x (Manhattan(x) ∧ Working(x))"
  },
  {
    "input": "Translate into first-order logic: All people who have pets are people who have at least one child.",
    "output": "∀x (Pets(x) → Child(x))"
  },
  {
    "input": "Translate into first-order logic: People who do not have at least one child are people who own a sports car.",
    "output": "∀x (Child(x) → ¬Car(x))"
  },
  {
    "input": "Translate into first-order logic: Mary either does not own a sports car or, if they do, then they do not have at least one child.",
    "output": "¬(Car(mary) ⊕ Child(mary))"
  },
  {
    "input": "Translate into first-order logic: All young working professionals who have regular 9-5 jobs also have pets.",
    "output": "∀x (Working(x) → Pets(x))"
  },
  {
    "input": "Translate into first-order logic: Some people who live in Manhattan are young working professionals who have regular 9-5 jobs.",
    "output": "∃x (Manhattan(x) ∧ Working(x))"
  },
  {
    "input": "Translate into first-order logic: All people who have pets are people who have at least one child.",
    "output": "∀x (Pets(x) → Child(x))"
  },
  {
    "input": "Translate into first-order logic: People who do not have at least one child are people who own a sports car.",
    "output": "∀x (Child(x) → ¬Car(x))"
  },
  {
    "input": "Translate into first-order logic: Mary either does not own a sports car or, if they do, then they do not have at least one child.",
    "output": "¬(Car(mary) ⊕ Child(mary))"
  },
  {
    "input": "Translate into first-order logic: All young working professionals who have regular 9-5 jobs also have pets.",
    "output": "∀x (Working(x) → Pets(x))"
  },
  {
    "input": "Translate into first-order logic: Some people who live in Manhattan are young working professionals who have regular 9-5 jobs.",
    "output": "∃x (Manhattan(x) ∧ Working(x))"
  },
  {
    "input": "Translate into first-order logic: All people who have pets are people who have at least one child.",
    "output": "∀x (Pets(x) → Child(x))"
  },
  {
    "input": "Translate into first-order logic: People who do not have at least one child are people who own a sports car.",
    "output": "∀x (Child(x) → ¬Car(x))"
  },
  {
    "input": "Translate into first-order logic: Mary either does not own a sports car or, if they do, then they do not have at least one child.",
    "output": "¬(Car(mary) ⊕ Child(mary))"
  },
  {
    "input": "Translate into first-order logic: Either block design or event-related design.",
    "output": "∀x (BlockDesign(x) ∨ Event-relatedDesign(x))"
  },
  {
    "input": "Translate into first-order logic: All event-related designs are brain image acquisition.",
    "output": "∀x (Event-relatedDesign(x) → BrainImageAcquisition(x))"
  },
  {
    "input": "Translate into first-order logic: All brain image acquisition is preceded by data processing.",
    "output": "∀x (BrainImageAcquisition(x) → PrecededByDataProcessing(x))"
  },
  {
    "input": "Translate into first-order logic: Nothing preceded by data processing acquires data.",
    "output": "∀x (PrecededByDataProcessing(x) → ¬AcquiringData(x))"
  },
  {
    "input": "Translate into first-order logic: Picture memory is either an event-related design and acquiring data or neither an event-related design nor acquiring data.",
    "output": "(Event-relatedDesign(pictureMemory) ∧ AcquiringData(pictureMemory)) ∨ (¬Event-relatedDesign(pictureMemory) ∧ ¬AcquiringData(pictureMemory))"
  },
  {
    "input": "Translate into first-order logic: Either block design or event-related design.",
    "output": "∀x (BlockDesign(x) ∨ Event-relatedDesign(x))"
  },
  {
    "input": "Translate into first-order logic: All event-related designs are brain image acquisition.",
    "output": "∀x (Event-relatedDesign(x) → BrainImageAcquisition(x))"
  },
  {
    "input": "Translate into first-order logic: All brain image acquisition is preceded by data processing.",
    "output": "∀x (BrainImageAcquisition(x) → PrecededByDataProcessing(x))"
  },
  {
    "input": "Translate into first-order logic: Nothing preceded by data processing acquires data.",
    "output": "∀x (PrecededByDataProcessing(x) → ¬AcquiringData(x))"
  },
  {
    "input": "Translate into first-order logic: Picture memory is either an event-related design and acquiring data or neither an event-related design nor acquiring data.",
    "output": "(Event-relatedDesign(pictureMemory) ∧ AcquiringData(pictureMemory)) ∨ (¬Event-relatedDesign(pictureMemory) ∧ ¬AcquiringData(pictureMemory))"
  },
  {
    "input": "Translate into first-order logic: Either block design or event-related design.",
    "output": "∀x (BlockDesign(x) ∨ Event-relatedDesign(x))"
  },
  {
    "input": "Translate into first-order logic: All event-related designs are brain image acquisition.",
    "output": "∀x (Event-relatedDesign(x) → BrainImageAcquisition(x))"
  },
  {
    "input": "Translate into first-order logic: All brain image acquisition is preceded by data processing.",
    "output": "∀x (BrainImageAcquisition(x) → PrecededByDataProcessing(x))"
  },
  {
    "input": "Translate into first-order logic: Nothing preceded by data processing acquires data.",
    "output": "∀x (PrecededByDataProcessing(x) → ¬AcquiringData(x))"
  },
  {
    "input": "Translate into first-order logic: Picture memory is either an event-related design and acquiring data or neither an event-related design nor acquiring data.",
    "output": "(Event-relatedDesign(pictureMemory) ∧ AcquiringData(pictureMemory)) ∨ (¬Event-relatedDesign(pictureMemory) ∧ ¬AcquiringData(pictureMemory))"
  },
  {
    "input": "Translate into first-order logic: Either block design or event-related design.",
    "output": "∀x (BlockDesign(x) ∨ Event-relatedDesign(x))"
  },
  {
    "input": "Translate into first-order logic: All event-related designs are brain image acquisition.",
    "output": "∀x (Event-relatedDesign(x) → BrainImageAcquisition(x))"
  },
  {
    "input": "Translate into first-order logic: All brain image acquisition is preceded by data processing.",
    "output": "∀x (BrainImageAcquisition(x) → PrecededByDataProcessing(x))"
  },
  {
    "input": "Translate into first-order logic: Nothing preceded by data processing acquires data.",
    "output": "∀x (PrecededByDataProcessing(x) → ¬AcquiringData(x))"
  },
  {
    "input": "Translate into first-order logic: Picture memory is either an event-related design and acquiring data or neither an event-related design nor acquiring data.",
    "output": "(Event-relatedDesign(pictureMemory) ∧ AcquiringData(pictureMemory)) ∨ (¬Event-relatedDesign(pictureMemory) ∧ ¬AcquiringData(pictureMemory))"
  },
  {
    "input": "Translate into first-order logic: The USS Lyon was a US Navy ship involved in WWII.",
    "output": "(USNavyShip(usslyon) ∧ InWWII(usslyon))"
  },
  {
    "input": "Translate into first-order logic: All ships involved in WWII are currently decommissioned or in a museum.",
    "output": "∀x (InWWII(x) → (Decommissioned(x) ∨ InMuseum(x)))"
  },
  {
    "input": "Translate into first-order logic: All disposable chopsticks are made from trees.",
    "output": "∀x (DisposableChopsticks(x) → MadeFromTrees(x))"
  },
  {
    "input": "Translate into first-order logic: Some chopsticks are eco-friendly.",
    "output": "∃x (EcoFriendly(x))"
  },
  {
    "input": "Translate into first-order logic: Either disposable chopsticks or reusable chopsticks.",
    "output": "∀x (DisposableChopsticks(x) ⊕ Reusable(x)) "
  },
  {
    "input": "Translate into first-order logic: If chopsticks are made from metals, then they are not made from plastics.",
    "output": "∀x (MadeFromMetals(x) → ¬MadeFromPlastics(x))"
  },
  {
    "input": "Translate into first-order logic: All reusable chopsticks are made from metal.",
    "output": "∀x (Reusable(x) → MadeFromMetals(x))"
  },
  {
    "input": "Translate into first-order logic: Chopsticks at restaurants are either made from metals and made from plastics, or neither made from metals nor made from plastics.",
    "output": "¬(MadeFromMetals(chopsticksAtRestaurants) ⊕ MadeFromPlastics(chopsticksAtRestaurants))"
  },
  {
    "input": "Translate into first-order logic: All disposable chopsticks are made from trees.",
    "output": "∀x (DisposableChopsticks(x) → MadeFromTrees(x))"
  },
  {
    "input": "Translate into first-order logic: Some chopsticks are eco-friendly.",
    "output": "∃x (EcoFriendly(x))"
  },
  {
    "input": "Translate into first-order logic: Either disposable chopsticks or reusable chopsticks.",
    "output": "∀x (DisposableChopsticks(x) ⊕ Reusable(x)) "
  },
  {
    "input": "Translate into first-order logic: If chopsticks are made from metals, then they are not made from plastics.",
    "output": "∀x (MadeFromMetals(x) → ¬MadeFromPlastics(x))"
  },
  {
    "input": "Translate into first-order logic: All reusable chopsticks are made from metal.",
    "output": "∀x (Reusable(x) → MadeFromMetals(x))"
  },
  {
    "input": "Translate into first-order logic: Chopsticks at restaurants are either made from metals and made from plastics, or neither made from metals nor made from plastics.",
    "output": "¬(MadeFromMetals(chopsticksAtRestaurants) ⊕ MadeFromPlastics(chopsticksAtRestaurants))"
  },
  {
    "input": "Translate into first-order logic: All disposable chopsticks are made from trees.",
    "output": "∀x (DisposableChopsticks(x) → MadeFromTrees(x))"
  },
  {
    "input": "Translate into first-order logic: Some chopsticks are eco-friendly.",
    "output": "∃x (EcoFriendly(x))"
  },
  {
    "input": "Translate into first-order logic: Either disposable chopsticks or reusable chopsticks.",
    "output": "∀x (DisposableChopsticks(x) ⊕ Reusable(x)) "
  },
  {
    "input": "Translate into first-order logic: If chopsticks are made from metals, then they are not made from plastics.",
    "output": "∀x (MadeFromMetals(x) → ¬MadeFromPlastics(x))"
  },
  {
    "input": "Translate into first-order logic: All reusable chopsticks are made from metal.",
    "output": "∀x (Reusable(x) → MadeFromMetals(x))"
  },
  {
    "input": "Translate into first-order logic: Chopsticks at restaurants are either made from metals and made from plastics, or neither made from metals nor made from plastics.",
    "output": "¬(MadeFromMetals(chopsticksAtRestaurants) ⊕ MadeFromPlastics(chopsticksAtRestaurants))"
  },
  {
    "input": "Translate into first-order logic: Anything that is lazy is unproductive.",
    "output": "∀x (Lazy(x) → Unproductive(x))"
  },
  {
    "input": "Translate into first-order logic: No one unproductive is an energetic person.",
    "output": "∀x (Unproductive(x) → ¬Energetic(x))"
  },
  {
    "input": "Translate into first-order logic: If something is a sloth, then it is lazy.",
    "output": "∀x (Sloth(x) → Lazy(x))"
  },
  {
    "input": "Translate into first-order logic: Some animals are sloths.",
    "output": "∃x (Animal(x) ∧ Sloth(x))"
  },
  {
    "input": "Translate into first-order logic: Sid is not either an energetic person or a sloth.",
    "output": "¬Energetic(sid) ∨ Sloth(sid)"
  },
  {
    "input": "Translate into first-order logic: Anything that is lazy is unproductive.",
    "output": "∀x (Lazy(x) → Unproductive(x))"
  },
  {
    "input": "Translate into first-order logic: No one unproductive is an energetic person.",
    "output": "∀x (Unproductive(x) → ¬Energetic(x))"
  },
  {
    "input": "Translate into first-order logic: If something is a sloth, then it is lazy.",
    "output": "∀x (Sloth(x) → Lazy(x))"
  },
  {
    "input": "Translate into first-order logic: Some animals are sloths.",
    "output": "∃x (Animal(x) ∧ Sloth(x))"
  },
  {
    "input": "Translate into first-order logic: Sid is not either an energetic person or a sloth.",
    "output": "¬Energetic(sid) ∨ Sloth(sid)"
  },
  {
    "input": "Translate into first-order logic: Anything that is lazy is unproductive.",
    "output": "∀x (Lazy(x) → Unproductive(x))"
  },
  {
    "input": "Translate into first-order logic: No one unproductive is an energetic person.",
    "output": "∀x (Unproductive(x) → ¬Energetic(x))"
  },
  {
    "input": "Translate into first-order logic: If something is a sloth, then it is lazy.",
    "output": "∀x (Sloth(x) → Lazy(x))"
  },
  {
    "input": "Translate into first-order logic: Some animals are sloths.",
    "output": "∃x (Animal(x) ∧ Sloth(x))"
  },
  {
    "input": "Translate into first-order logic: Sid is not either an energetic person or a sloth.",
    "output": "¬Energetic(sid) ∨ Sloth(sid)"
  },
  {
    "input": "Translate into first-order logic: European soccer clubs can attend UCL, UEL and UECL.",
    "output": "∀x (European(x) ∧ SoccerClub(x) → Attend(x, ucl) ∨ Attend(x, uel) ∨ Attend(x, uecl))"
  },
  {
    "input": "Translate into first-order logic: A soccer club eligible to attend UCL has a higher ranking than a soccer club eligible to attend UEL.",
    "output": "∀x ∀y (SoccerClub(x) ∧ SoccerClub(y) ∧ Attend(x, ucl) ∧ Attend(y, uel) → HigherRank(x, y))"
  },
  {
    "input": "Translate into first-order logic: A soccer club eligible to attend UEL has a higher ranking than a soccer club eligible to attend UECL.",
    "output": "∀x ∀y (SoccerClub(x) ∧ SoccerClub(y) ∧ Attend(x, uel) ∧ Attend(y, uecl) → HigherRank(x, y))"
  },
  {
    "input": "Translate into first-order logic: Manchester United and Machester City are both European soccer clubs.",
    "output": "European(manchesterunited) ∧ SoccerClub(manchesterunited) ∧ European(manchestercity) ∧ SoccerClub(manchestercity)"
  },
  {
    "input": "Translate into first-order logic: Manchester United is eligible to attend UEL next season.",
    "output": "Attend(manchesterunited, uel)"
  },
  {
    "input": "Translate into first-order logic: Manchester City is eligible to attend UCL next season.",
    "output": "Attend(manchestercity, ucl)"
  },
  {
    "input": "Translate into first-order logic: If a person coach a football club, the person is a football coach.",
    "output": "∀x ∀y (Coach(x, y) ∧ IsFootballClub(y) → IsFootballCoach(x))"
  },
  {
    "input": "Translate into first-order logic: If a person has a position in a club for a position in a year, and the club is in NFL in the same year, the person plays in NFL.",
    "output": "∀x ∀y ∀z (PlayFor(x, y) ∧ NFLTeamYear(y, z) ∧ InTeam(x, z) → PlayInNFL(x))"
  },
  {
    "input": "Translate into first-order logic: Minnesota Vikings is a football club.",
    "output": "IsFootballClub(minnesota_Vikings)"
  },
  {
    "input": "Translate into first-order logic: Dennis Green coached Minnesota Vikings.",
    "output": "Coach(dennis_Green, minnesota_Vikings)"
  },
  {
    "input": "Translate into first-order logic: Cris Carter had 13 touchdown receptions.",
    "output": "TouchDownReceptionTime(cris_Carter, t13)"
  },
  {
    "input": "Translate into first-order logic: Minnesota Vikings was in the National Football League in 1997.",
    "output": "NFLTeamYear(minnesota_Vikings, y1997)"
  },
  {
    "input": "Translate into first-order logic: John Randle was Minnesota Vikings defensive tackle in 1997.",
    "output": "Position(john_Randle, defensive_tackle) ∧ InTeam(john_Randle, y1997) ∧ PlayFor(john_Randle, minnesota_Vikings)"
  },
  {
    "input": "Translate into first-order logic: If a person coach a football club, the person is a football coach.",
    "output": "∀x ∀y (Coach(x, y) ∧ IsFootballClub(y) → IsFootballCoach(x))"
  },
  {
    "input": "Translate into first-order logic: If a person has a position in a club for a position in a year, and the club is in NFL in the same year, the person plays in NFL.",
    "output": "∀x ∀y ∀z (PlayFor(x, y) ∧ NFLTeamYear(y, z) ∧ InTeam(x, z) → PlayInNFL(x))"
  },
  {
    "input": "Translate into first-order logic: Minnesota Vikings is a football club.",
    "output": "IsFootballClub(minnesota_Vikings)"
  },
  {
    "input": "Translate into first-order logic: Dennis Green coached Minnesota Vikings.",
    "output": "Coach(dennis_Green, minnesota_Vikings)"
  },
  {
    "input": "Translate into first-order logic: Cris Carter had 13 touchdown receptions.",
    "output": "TouchDownReceptionTime(cris_Carter, t13)"
  },
  {
    "input": "Translate into first-order logic: Minnesota Vikings was in the National Football League in 1997.",
    "output": "NFLTeamYear(minnesota_Vikings, y1997)"
  },
  {
    "input": "Translate into first-order logic: John Randle was Minnesota Vikings defensive tackle in 1997.",
    "output": "Position(john_Randle, defensive_tackle) ∧ InTeam(john_Randle, y1997) ∧ PlayFor(john_Randle, minnesota_Vikings)"
  },
  {
    "input": "Translate into first-order logic: If a person coach a football club, the person is a football coach.",
    "output": "∀x ∀y (Coach(x, y) ∧ IsFootballClub(y) → IsFootballCoach(x))"
  },
  {
    "input": "Translate into first-order logic: If a person has a position in a club for a position in a year, and the club is in NFL in the same year, the person plays in NFL.",
    "output": "∀x ∀y ∀z (PlayFor(x, y) ∧ NFLTeamYear(y, z) ∧ InTeam(x, z) → PlayInNFL(x))"
  },
  {
    "input": "Translate into first-order logic: Minnesota Vikings is a football club.",
    "output": "IsFootballClub(minnesota_Vikings)"
  },
  {
    "input": "Translate into first-order logic: Dennis Green coached Minnesota Vikings.",
    "output": "Coach(dennis_Green, minnesota_Vikings)"
  },
  {
    "input": "Translate into first-order logic: Cris Carter had 13 touchdown receptions.",
    "output": "TouchDownReceptionTime(cris_Carter, t13)"
  },
  {
    "input": "Translate into first-order logic: Minnesota Vikings was in the National Football League in 1997.",
    "output": "NFLTeamYear(minnesota_Vikings, y1997)"
  },
  {
    "input": "Translate into first-order logic: John Randle was Minnesota Vikings defensive tackle in 1997.",
    "output": "Position(john_Randle, defensive_tackle) ∧ InTeam(john_Randle, y1997) ∧ PlayFor(john_Randle, minnesota_Vikings)"
  },
  {
    "input": "Translate into first-order logic: All cats are cute.",
    "output": "∀x (Cat(x) → Cute(x))"
  },
  {
    "input": "Translate into first-order logic: Ghosts do not exist.",
    "output": "∀x (¬Ghost(x))"
  },
  {
    "input": "Translate into first-order logic: An animal is either a cat or a dog.",
    "output": "∀x (Cat(x) ∨ Dog(x))"
  },
  {
    "input": "Translate into first-order logic: Nothing that barks is lovely.",
    "output": "∀x (Bark(x) → ¬Lovely(x))"
  },
  {
    "input": "Translate into first-order logic: If something is a dog, then it barks.",
    "output": "∀x (Dog(x) → Bark(x))"
  },
  {
    "input": "Translate into first-order logic: Grace is either a cat and a dog, or neither a cat nor a dog.",
    "output": "(Cat(grace) ∧ Dog(grace)) ⊕ (¬Cat(grace) ∧ ¬Dog(grace))"
  },
  {
    "input": "Translate into first-order logic: All cats are cute.",
    "output": "∀x (Cat(x) → Cute(x))"
  },
  {
    "input": "Translate into first-order logic: Ghosts do not exist.",
    "output": "∀x (¬Ghost(x))"
  },
  {
    "input": "Translate into first-order logic: An animal is either a cat or a dog.",
    "output": "∀x (Cat(x) ∨ Dog(x))"
  },
  {
    "input": "Translate into first-order logic: Nothing that barks is lovely.",
    "output": "∀x (Bark(x) → ¬Lovely(x))"
  },
  {
    "input": "Translate into first-order logic: If something is a dog, then it barks.",
    "output": "∀x (Dog(x) → Bark(x))"
  },
  {
    "input": "Translate into first-order logic: Grace is either a cat and a dog, or neither a cat nor a dog.",
    "output": "(Cat(grace) ∧ Dog(grace)) ⊕ (¬Cat(grace) ∧ ¬Dog(grace))"
  },
  {
    "input": "Translate into first-order logic: All cats are cute.",
    "output": "∀x (Cat(x) → Cute(x))"
  },
  {
    "input": "Translate into first-order logic: Ghosts do not exist.",
    "output": "∀x (¬Ghost(x))"
  },
  {
    "input": "Translate into first-order logic: An animal is either a cat or a dog.",
    "output": "∀x (Cat(x) ∨ Dog(x))"
  },
  {
    "input": "Translate into first-order logic: Nothing that barks is lovely.",
    "output": "∀x (Bark(x) → ¬Lovely(x))"
  },
  {
    "input": "Translate into first-order logic: If something is a dog, then it barks.",
    "output": "∀x (Dog(x) → Bark(x))"
  },
  {
    "input": "Translate into first-order logic: Grace is either a cat and a dog, or neither a cat nor a dog.",
    "output": "(Cat(grace) ∧ Dog(grace)) ⊕ (¬Cat(grace) ∧ ¬Dog(grace))"
  },
  {
    "input": "Translate into first-order logic: Shafaq-Asiman is a large complex of offshore geological structures in the Caspian Sea.",
    "output": "LargeComplex(shafaq-asiman) ∧ LargeComplex(shafaq-asiman) ∧ Offshore(shafaq-asiman) ∧ GeologicalStructures(shafaq-asiman) ∧ In(shafaq-asiman, caspiansea)"
  },
  {
    "input": "Translate into first-order logic: Baku is northwest of Shafaq-Asiman.",
    "output": "NorthwestOf(baku, shafaq-asiman)"
  },
  {
    "input": "Translate into first-order logic: If place A is northwest of place B, then place B is southeast of place A.",
    "output": "∀x ∀y (NorthwestOf(x, y) → SoutheastOf(y, x))"
  },
  {
    "input": "Translate into first-order logic: Shafaq-Asiman is a large complex of offshore geological structures in the Caspian Sea.",
    "output": "LargeComplex(shafaq-asiman) ∧ LargeComplex(shafaq-asiman) ∧ Offshore(shafaq-asiman) ∧ GeologicalStructures(shafaq-asiman) ∧ In(shafaq-asiman, caspiansea)"
  },
  {
    "input": "Translate into first-order logic: Baku is northwest of Shafaq-Asiman.",
    "output": "NorthwestOf(baku, shafaq-asiman)"
  },
  {
    "input": "Translate into first-order logic: If place A is northwest of place B, then place B is southeast of place A.",
    "output": "∀x ∀y (NorthwestOf(x, y) → SoutheastOf(y, x))"
  },
  {
    "input": "Translate into first-order logic: Shafaq-Asiman is a large complex of offshore geological structures in the Caspian Sea.",
    "output": "LargeComplex(shafaq-asiman) ∧ LargeComplex(shafaq-asiman) ∧ Offshore(shafaq-asiman) ∧ GeologicalStructures(shafaq-asiman) ∧ In(shafaq-asiman, caspiansea)"
  },
  {
    "input": "Translate into first-order logic: Baku is northwest of Shafaq-Asiman.",
    "output": "NorthwestOf(baku, shafaq-asiman)"
  },
  {
    "input": "Translate into first-order logic: If place A is northwest of place B, then place B is southeast of place A.",
    "output": "∀x ∀y (NorthwestOf(x, y) → SoutheastOf(y, x))"
  },
  {
    "input": "Translate into first-order logic: Herodicus was a Greek physician, dietician, sophist, and gymnastic-master.",
    "output": "Greek(herodicus) ∧ Physician(herodicus) ∧ Dietician(herodicus) ∧ Sophist(herodicus) ∧ GymnasticMaster(herodicus)"
  },
  {
    "input": "Translate into first-order logic: Herodicus was born in the city of Selymbria.",
    "output": "Born(herodicus, selymbia) ∧ City(selymbia)"
  },
  {
    "input": "Translate into first-order logic: Selymbria is a colony of the city-state Megara.",
    "output": "Colony(selymbia, megara) ∧ CityState(megara)"
  },
  {
    "input": "Translate into first-order logic: One of the tutors of Hippocrates was Herodicus.",
    "output": "Tutored(herodicus, hippocrates)"
  },
  {
    "input": "Translate into first-order logic: Massages were recommended by Herodicus.",
    "output": "Recommended(herodicus, massages)"
  },
  {
    "input": "Translate into first-order logic: Some of theories of Herodicus are considered to be the foundation of sports medicine.",
    "output": "∃x (Theory(x) ∧ From(x, herodicus) ∧ FoundationOf(x, sportsMedicine))"
  },
  {
    "input": "Translate into first-order logic: Herodicus was a Greek physician, dietician, sophist, and gymnastic-master.",
    "output": "Greek(herodicus) ∧ Physician(herodicus) ∧ Dietician(herodicus) ∧ Sophist(herodicus) ∧ GymnasticMaster(herodicus)"
  },
  {
    "input": "Translate into first-order logic: Herodicus was born in the city of Selymbria.",
    "output": "Born(herodicus, selymbia) ∧ City(selymbia)"
  },
  {
    "input": "Translate into first-order logic: Selymbria is a colony of the city-state Megara.",
    "output": "Colony(selymbia, megara) ∧ CityState(megara)"
  },
  {
    "input": "Translate into first-order logic: One of the tutors of Hippocrates was Herodicus.",
    "output": "Tutored(herodicus, hippocrates)"
  },
  {
    "input": "Translate into first-order logic: Massages were recommended by Herodicus.",
    "output": "Recommended(herodicus, massages)"
  },
  {
    "input": "Translate into first-order logic: Some of theories of Herodicus are considered to be the foundation of sports medicine.",
    "output": "∃x (Theory(x) ∧ From(x, herodicus) ∧ FoundationOf(x, sportsMedicine))"
  },
  {
    "input": "Translate into first-order logic: Herodicus was a Greek physician, dietician, sophist, and gymnastic-master.",
    "output": "Greek(herodicus) ∧ Physician(herodicus) ∧ Dietician(herodicus) ∧ Sophist(herodicus) ∧ GymnasticMaster(herodicus)"
  },
  {
    "input": "Translate into first-order logic: Herodicus was born in the city of Selymbria.",
    "output": "Born(herodicus, selymbia) ∧ City(selymbia)"
  },
  {
    "input": "Translate into first-order logic: Selymbria is a colony of the city-state Megara.",
    "output": "Colony(selymbia, megara) ∧ CityState(megara)"
  },
  {
    "input": "Translate into first-order logic: One of the tutors of Hippocrates was Herodicus.",
    "output": "Tutored(herodicus, hippocrates)"
  },
  {
    "input": "Translate into first-order logic: Massages were recommended by Herodicus.",
    "output": "Recommended(herodicus, massages)"
  },
  {
    "input": "Translate into first-order logic: Some of theories of Herodicus are considered to be the foundation of sports medicine.",
    "output": "∃x (Theory(x) ∧ From(x, herodicus) ∧ FoundationOf(x, sportsMedicine))"
  },
  {
    "input": "Translate into first-order logic: Herodicus was a Greek physician, dietician, sophist, and gymnastic-master.",
    "output": "Greek(herodicus) ∧ Physician(herodicus) ∧ Dietician(herodicus) ∧ Sophist(herodicus) ∧ GymnasticMaster(herodicus)"
  },
  {
    "input": "Translate into first-order logic: Herodicus was born in the city of Selymbria.",
    "output": "Born(herodicus, selymbia) ∧ City(selymbia)"
  },
  {
    "input": "Translate into first-order logic: Selymbria is a colony of the city-state Megara.",
    "output": "Colony(selymbia, megara) ∧ CityState(megara)"
  },
  {
    "input": "Translate into first-order logic: One of the tutors of Hippocrates was Herodicus.",
    "output": "Tutored(herodicus, hippocrates)"
  },
  {
    "input": "Translate into first-order logic: Massages were recommended by Herodicus.",
    "output": "Recommended(herodicus, massages)"
  },
  {
    "input": "Translate into first-order logic: Some of theories of Herodicus are considered to be the foundation of sports medicine.",
    "output": "∃x (Theory(x) ∧ From(x, herodicus) ∧ FoundationOf(x, sportsMedicine))"
  },
  {
    "input": "Translate into first-order logic: Herodicus was a Greek physician, dietician, sophist, and gymnastic-master.",
    "output": "Greek(herodicus) ∧ Physician(herodicus) ∧ Dietician(herodicus) ∧ Sophist(herodicus) ∧ GymnasticMaster(herodicus)"
  },
  {
    "input": "Translate into first-order logic: Herodicus was born in the city of Selymbria.",
    "output": "Born(herodicus, selymbia) ∧ City(selymbia)"
  },
  {
    "input": "Translate into first-order logic: Selymbria is a colony of the city-state Megara.",
    "output": "Colony(selymbia, megara) ∧ CityState(megara)"
  },
  {
    "input": "Translate into first-order logic: One of the tutors of Hippocrates was Herodicus.",
    "output": "Tutored(herodicus, hippocrates)"
  },
  {
    "input": "Translate into first-order logic: Massages were recommended by Herodicus.",
    "output": "Recommended(herodicus, massages)"
  },
  {
    "input": "Translate into first-order logic: Some of theories of Herodicus are considered to be the foundation of sports medicine.",
    "output": "∃x (Theory(x) ∧ From(x, herodicus) ∧ FoundationOf(x, sportsMedicine))"
  },
  {
    "input": "Translate into first-order logic: No kid loves the Opera.",
    "output": "∀x (Kid(x) → ¬OperaLover(x))"
  },
  {
    "input": "Translate into first-order logic: All adults love the Opera.",
    "output": "∀x (Adult(x) → OperaLover(x))"
  },
  {
    "input": "Translate into first-order logic: If someone is a scientist, then they are an adult.",
    "output": "∀x (Scientist(x) → Adult(x))"
  },
  {
    "input": "Translate into first-order logic: Some students are kids.",
    "output": "∃x (Student(x) ∧ Kid(x))"
  },
  {
    "input": "Translate into first-order logic: Billy is a kid.",
    "output": "Kid(billy)"
  },
  {
    "input": "Translate into first-order logic: No kid loves the Opera.",
    "output": "∀x (Kid(x) → ¬OperaLover(x))"
  },
  {
    "input": "Translate into first-order logic: All adults love the Opera.",
    "output": "∀x (Adult(x) → OperaLover(x))"
  },
  {
    "input": "Translate into first-order logic: If someone is a scientist, then they are an adult.",
    "output": "∀x (Scientist(x) → Adult(x))"
  },
  {
    "input": "Translate into first-order logic: Some students are kids.",
    "output": "∃x (Student(x) ∧ Kid(x))"
  },
  {
    "input": "Translate into first-order logic: Billy is a kid.",
    "output": "Kid(billy)"
  },
  {
    "input": "Translate into first-order logic: No kid loves the Opera.",
    "output": "∀x (Kid(x) → ¬OperaLover(x))"
  },
  {
    "input": "Translate into first-order logic: All adults love the Opera.",
    "output": "∀x (Adult(x) → OperaLover(x))"
  },
  {
    "input": "Translate into first-order logic: If someone is a scientist, then they are an adult.",
    "output": "∀x (Scientist(x) → Adult(x))"
  },
  {
    "input": "Translate into first-order logic: Some students are kids.",
    "output": "∃x (Student(x) ∧ Kid(x))"
  },
  {
    "input": "Translate into first-order logic: Billy is a kid.",
    "output": "Kid(billy)"
  },
  {
    "input": "Translate into first-order logic: Brian Winter is a Scottish football referee.",
    "output": "Scottish(brianwinter) ∧ FootballReferee(brianwinter)"
  },
  {
    "input": "Translate into first-order logic: After being injured, Brian Winter retired in 2012.",
    "output": "Injured(brianwinter) ∧ Retired(brianwinter)"
  },
  {
    "input": "Translate into first-order logic: Brian Winter was appointed as a referee observer after his retirement.",
    "output": "RefereeObserver(brianwinter)"
  },
  {
    "input": "Translate into first-order logic: Some football referees become referee observers.",
    "output": "∃x (FootballReferee(x) ∧ RefereeObserver(x))"
  },
  {
    "input": "Translate into first-order logic: The son of Brian Winter, Andy Winter, is a football player who plays for Hamilton Academical.",
    "output": "Son(andywinter, brianwinter) ∧ FootballPlayer(andywinter) ∧ PlaysFor(andywinter, hamiltonacademical)"
  },
  {
    "input": "Translate into first-order logic: Brian Winter is a Scottish football referee.",
    "output": "Scottish(brianwinter) ∧ FootballReferee(brianwinter)"
  },
  {
    "input": "Translate into first-order logic: After being injured, Brian Winter retired in 2012.",
    "output": "Injured(brianwinter) ∧ Retired(brianwinter)"
  },
  {
    "input": "Translate into first-order logic: Brian Winter was appointed as a referee observer after his retirement.",
    "output": "RefereeObserver(brianwinter)"
  },
  {
    "input": "Translate into first-order logic: Some football referees become referee observers.",
    "output": "∃x (FootballReferee(x) ∧ RefereeObserver(x))"
  },
  {
    "input": "Translate into first-order logic: The son of Brian Winter, Andy Winter, is a football player who plays for Hamilton Academical.",
    "output": "Son(andywinter, brianwinter) ∧ FootballPlayer(andywinter) ∧ PlaysFor(andywinter, hamiltonacademical)"
  },
  {
    "input": "Translate into first-order logic: Brian Winter is a Scottish football referee.",
    "output": "Scottish(brianwinter) ∧ FootballReferee(brianwinter)"
  },
  {
    "input": "Translate into first-order logic: After being injured, Brian Winter retired in 2012.",
    "output": "Injured(brianwinter) ∧ Retired(brianwinter)"
  },
  {
    "input": "Translate into first-order logic: Brian Winter was appointed as a referee observer after his retirement.",
    "output": "RefereeObserver(brianwinter)"
  },
  {
    "input": "Translate into first-order logic: Some football referees become referee observers.",
    "output": "∃x (FootballReferee(x) ∧ RefereeObserver(x))"
  },
  {
    "input": "Translate into first-order logic: The son of Brian Winter, Andy Winter, is a football player who plays for Hamilton Academical.",
    "output": "Son(andywinter, brianwinter) ∧ FootballPlayer(andywinter) ∧ PlaysFor(andywinter, hamiltonacademical)"
  },
  {
    "input": "Translate into first-order logic: Brian Winter is a Scottish football referee.",
    "output": "Scottish(brianwinter) ∧ FootballReferee(brianwinter)"
  },
  {
    "input": "Translate into first-order logic: After being injured, Brian Winter retired in 2012.",
    "output": "Injured(brianwinter) ∧ Retired(brianwinter)"
  },
  {
    "input": "Translate into first-order logic: Brian Winter was appointed as a referee observer after his retirement.",
    "output": "RefereeObserver(brianwinter)"
  },
  {
    "input": "Translate into first-order logic: Some football referees become referee observers.",
    "output": "∃x (FootballReferee(x) ∧ RefereeObserver(x))"
  },
  {
    "input": "Translate into first-order logic: The son of Brian Winter, Andy Winter, is a football player who plays for Hamilton Academical.",
    "output": "Son(andywinter, brianwinter) ∧ FootballPlayer(andywinter) ∧ PlaysFor(andywinter, hamiltonacademical)"
  },
  {
    "input": "Translate into first-order logic: People are either interested in puzzles or bad at chess.",
    "output": "∀x (Puzzles(x) ∨ BadChess(x))"
  },
  {
    "input": "Translate into first-order logic: If a person is bad at chess, then they don't play a lot of chess.",
    "output": "∀x (BadChess(x) → ¬PlaysLots(x))"
  },
  {
    "input": "Translate into first-order logic: A person is either a planner or a creative person.",
    "output": "∀x (Plans(x) ∨ Creative(x))"
  },
  {
    "input": "Translate into first-order logic: Erica is someone who plays a lot of chess.",
    "output": "PlaysLots(erica)"
  },
  {
    "input": "Translate into first-order logic: If Erica is neither bad at chess nor creative, then Erica is either someone who plans and is creative, or someone who neither plans nor is creative.",
    "output": "¬(BadChess(erica) ∨ Creative(erica)) → (Plans(erica) ⊕ Creative(erica))"
  },
  {
    "input": "Translate into first-order logic: People are either interested in puzzles or bad at chess.",
    "output": "∀x (Puzzles(x) ∨ BadChess(x))"
  },
  {
    "input": "Translate into first-order logic: If a person is bad at chess, then they don't play a lot of chess.",
    "output": "∀x (BadChess(x) → ¬PlaysLots(x))"
  },
  {
    "input": "Translate into first-order logic: A person is either a planner or a creative person.",
    "output": "∀x (Plans(x) ∨ Creative(x))"
  },
  {
    "input": "Translate into first-order logic: Erica is someone who plays a lot of chess.",
    "output": "PlaysLots(erica)"
  },
  {
    "input": "Translate into first-order logic: If Erica is neither bad at chess nor creative, then Erica is either someone who plans and is creative, or someone who neither plans nor is creative.",
    "output": "¬(BadChess(erica) ∨ Creative(erica)) → (Plans(erica) ⊕ Creative(erica))"
  },
  {
    "input": "Translate into first-order logic: People are either interested in puzzles or bad at chess.",
    "output": "∀x (Puzzles(x) ∨ BadChess(x))"
  },
  {
    "input": "Translate into first-order logic: If a person is bad at chess, then they don't play a lot of chess.",
    "output": "∀x (BadChess(x) → ¬PlaysLots(x))"
  },
  {
    "input": "Translate into first-order logic: A person is either a planner or a creative person.",
    "output": "∀x (Plans(x) ∨ Creative(x))"
  },
  {
    "input": "Translate into first-order logic: Erica is someone who plays a lot of chess.",
    "output": "PlaysLots(erica)"
  },
  {
    "input": "Translate into first-order logic: If Erica is neither bad at chess nor creative, then Erica is either someone who plans and is creative, or someone who neither plans nor is creative.",
    "output": "¬(BadChess(erica) ∨ Creative(erica)) → (Plans(erica) ⊕ Creative(erica))"
  },
  {
    "input": "Translate into first-order logic: People are either interested in puzzles or bad at chess.",
    "output": "∀x (Puzzles(x) ∨ BadChess(x))"
  },
  {
    "input": "Translate into first-order logic: If a person is bad at chess, then they don't play a lot of chess.",
    "output": "∀x (BadChess(x) → ¬PlaysLots(x))"
  },
  {
    "input": "Translate into first-order logic: A person is either a planner or a creative person.",
    "output": "∀x (Plans(x) ∨ Creative(x))"
  },
  {
    "input": "Translate into first-order logic: Erica is someone who plays a lot of chess.",
    "output": "PlaysLots(erica)"
  },
  {
    "input": "Translate into first-order logic: If Erica is neither bad at chess nor creative, then Erica is either someone who plans and is creative, or someone who neither plans nor is creative.",
    "output": "¬(BadChess(erica) ∨ Creative(erica)) → (Plans(erica) ⊕ Creative(erica))"
  },
  {
    "input": "Translate into first-order logic: People are either interested in puzzles or bad at chess.",
    "output": "∀x (Puzzles(x) ∨ BadChess(x))"
  },
  {
    "input": "Translate into first-order logic: If a person is bad at chess, then they don't play a lot of chess.",
    "output": "∀x (BadChess(x) → ¬PlaysLots(x))"
  },
  {
    "input": "Translate into first-order logic: A person is either a planner or a creative person.",
    "output": "∀x (Plans(x) ∨ Creative(x))"
  },
  {
    "input": "Translate into first-order logic: Erica is someone who plays a lot of chess.",
    "output": "PlaysLots(erica)"
  },
  {
    "input": "Translate into first-order logic: If Erica is neither bad at chess nor creative, then Erica is either someone who plans and is creative, or someone who neither plans nor is creative.",
    "output": "¬(BadChess(erica) ∨ Creative(erica)) → (Plans(erica) ⊕ Creative(erica))"
  },
  {
    "input": "Translate into first-order logic: People are either interested in puzzles or bad at chess.",
    "output": "∀x (Puzzles(x) ∨ BadChess(x))"
  },
  {
    "input": "Translate into first-order logic: If a person is bad at chess, then they don't play a lot of chess.",
    "output": "∀x (BadChess(x) → ¬PlaysLots(x))"
  },
  {
    "input": "Translate into first-order logic: A person is either a planner or a creative person.",
    "output": "∀x (Plans(x) ∨ Creative(x))"
  },
  {
    "input": "Translate into first-order logic: Erica is someone who plays a lot of chess.",
    "output": "PlaysLots(erica)"
  },
  {
    "input": "Translate into first-order logic: If Erica is neither bad at chess nor creative, then Erica is either someone who plans and is creative, or someone who neither plans nor is creative.",
    "output": "¬(BadChess(erica) ∨ Creative(erica)) → (Plans(erica) ⊕ Creative(erica))"
  },
  {
    "input": "Translate into first-order logic: People are either interested in puzzles or bad at chess.",
    "output": "∀x (Puzzles(x) ∨ BadChess(x))"
  },
  {
    "input": "Translate into first-order logic: If a person is bad at chess, then they don't play a lot of chess.",
    "output": "∀x (BadChess(x) → ¬PlaysLots(x))"
  },
  {
    "input": "Translate into first-order logic: A person is either a planner or a creative person.",
    "output": "∀x (Plans(x) ∨ Creative(x))"
  },
  {
    "input": "Translate into first-order logic: Erica is someone who plays a lot of chess.",
    "output": "PlaysLots(erica)"
  },
  {
    "input": "Translate into first-order logic: If Erica is neither bad at chess nor creative, then Erica is either someone who plans and is creative, or someone who neither plans nor is creative.",
    "output": "¬(BadChess(erica) ∨ Creative(erica)) → (Plans(erica) ⊕ Creative(erica))"
  },
  {
    "input": "Translate into first-order logic: People are either interested in puzzles or bad at chess.",
    "output": "∀x (Puzzles(x) ∨ BadChess(x))"
  },
  {
    "input": "Translate into first-order logic: If a person is bad at chess, then they don't play a lot of chess.",
    "output": "∀x (BadChess(x) → ¬PlaysLots(x))"
  },
  {
    "input": "Translate into first-order logic: A person is either a planner or a creative person.",
    "output": "∀x (Plans(x) ∨ Creative(x))"
  },
  {
    "input": "Translate into first-order logic: Erica is someone who plays a lot of chess.",
    "output": "PlaysLots(erica)"
  },
  {
    "input": "Translate into first-order logic: If Erica is neither bad at chess nor creative, then Erica is either someone who plans and is creative, or someone who neither plans nor is creative.",
    "output": "¬(BadChess(erica) ∨ Creative(erica)) → (Plans(erica) ⊕ Creative(erica))"
  },
  {
    "input": "Translate into first-order logic: People are either interested in puzzles or bad at chess.",
    "output": "∀x (Puzzles(x) ∨ BadChess(x))"
  },
  {
    "input": "Translate into first-order logic: If a person is bad at chess, then they don't play a lot of chess.",
    "output": "∀x (BadChess(x) → ¬PlaysLots(x))"
  },
  {
    "input": "Translate into first-order logic: A person is either a planner or a creative person.",
    "output": "∀x (Plans(x) ∨ Creative(x))"
  },
  {
    "input": "Translate into first-order logic: Erica is someone who plays a lot of chess.",
    "output": "PlaysLots(erica)"
  },
  {
    "input": "Translate into first-order logic: If Erica is neither bad at chess nor creative, then Erica is either someone who plans and is creative, or someone who neither plans nor is creative.",
    "output": "¬(BadChess(erica) ∨ Creative(erica)) → (Plans(erica) ⊕ Creative(erica))"
  },
  {
    "input": "Translate into first-order logic: People are either interested in puzzles or bad at chess.",
    "output": "∀x (Puzzles(x) ∨ BadChess(x))"
  },
  {
    "input": "Translate into first-order logic: If a person is bad at chess, then they don't play a lot of chess.",
    "output": "∀x (BadChess(x) → ¬PlaysLots(x))"
  },
  {
    "input": "Translate into first-order logic: A person is either a planner or a creative person.",
    "output": "∀x (Plans(x) ∨ Creative(x))"
  },
  {
    "input": "Translate into first-order logic: Erica is someone who plays a lot of chess.",
    "output": "PlaysLots(erica)"
  },
  {
    "input": "Translate into first-order logic: If Erica is neither bad at chess nor creative, then Erica is either someone who plans and is creative, or someone who neither plans nor is creative.",
    "output": "¬(BadChess(erica) ∨ Creative(erica)) → (Plans(erica) ⊕ Creative(erica))"
  },
  {
    "input": "Translate into first-order logic: Soccer players have a right foot and a left foot.",
    "output": "∀x (SoccerPlayer(x) → HasLeftFoot(x) ∧ HasRightFoot(x))"
  },
  {
    "input": "Translate into first-order logic: Top soccer players are soccer players who can use their both feet very efficiently.",
    "output": "∀x (SoccerPlayer(x) ∧ Efficient(x, left) ∧ Efficient(x, right) → Top(x))"
  },
  {
    "input": "Translate into first-order logic: If a soccer player can score many goals using left foot, then they can use that foot very efficiently.",
    "output": "∀x (SoccerPlayer(x) ∧ ScoreManyGoals(x, left) → Efficient(x, left))"
  },
  {
    "input": "Translate into first-order logic: If a soccer player can score many goals using right foot, then they can use that foot very efficiently.",
    "output": "∀x (SoccerPlayer(x) ∧ ScoreManyGoals(x, right) → Efficient(x, right))"
  },
  {
    "input": "Translate into first-order logic: Cristiano Ronaldo is a soccer player.",
    "output": "SoccerPlayer(ronaldo)"
  },
  {
    "input": "Translate into first-order logic: Cristiano Ronaldo can use his right foot very efficiently.",
    "output": "Efficient(ronaldo, right)"
  },
  {
    "input": "Translate into first-order logic: Cristiano Ronaldo have scored more than one hundred goals using his left foot.",
    "output": "ScoreManyGoals(ronaldo, left)"
  },
  {
    "input": "Translate into first-order logic: Soccer players have a right foot and a left foot.",
    "output": "∀x (SoccerPlayer(x) → HasLeftFoot(x) ∧ HasRightFoot(x))"
  },
  {
    "input": "Translate into first-order logic: Top soccer players are soccer players who can use their both feet very efficiently.",
    "output": "∀x (SoccerPlayer(x) ∧ Efficient(x, left) ∧ Efficient(x, right) → Top(x))"
  },
  {
    "input": "Translate into first-order logic: If a soccer player can score many goals using left foot, then they can use that foot very efficiently.",
    "output": "∀x (SoccerPlayer(x) ∧ ScoreManyGoals(x, left) → Efficient(x, left))"
  },
  {
    "input": "Translate into first-order logic: If a soccer player can score many goals using right foot, then they can use that foot very efficiently.",
    "output": "∀x (SoccerPlayer(x) ∧ ScoreManyGoals(x, right) → Efficient(x, right))"
  },
  {
    "input": "Translate into first-order logic: Cristiano Ronaldo is a soccer player.",
    "output": "SoccerPlayer(ronaldo)"
  },
  {
    "input": "Translate into first-order logic: Cristiano Ronaldo can use his right foot very efficiently.",
    "output": "Efficient(ronaldo, right)"
  },
  {
    "input": "Translate into first-order logic: Cristiano Ronaldo have scored more than one hundred goals using his left foot.",
    "output": "ScoreManyGoals(ronaldo, left)"
  },
  {
    "input": "Translate into first-order logic: The National Lobster Hatchery is a hatchery located in Padstow England.",
    "output": "Hatchery(nationallobsterhatchery) ∧ LocatedIn(nationallobsterhatchery, padstowengland)"
  },
  {
    "input": "Translate into first-order logic: The National Lobster Hatchery is open to visitors.",
    "output": "OpenToVisitors(nationallobsterhatchery)"
  },
  {
    "input": "Translate into first-order logic: A hatchery is either for profit, or for conservation.",
    "output": "∀x (Hatchery(x) → ForConservation(x) ∨ ForProfit(x))"
  },
  {
    "input": "Translate into first-order logic: If a hatchery is for conservation, it might release animals into the wild.",
    "output": "∃x (Hatchery(x) ∧ ForConservation(x) ∧ ReleasesAnimalsToWild(x))"
  },
  {
    "input": "Translate into first-order logic: The National Lobster Hatchery is not for profit.",
    "output": "¬ForProfit(nationallobsterhatchery)"
  },
  {
    "input": "Translate into first-order logic: The National Lobster Hatchery is a hatchery located in Padstow England.",
    "output": "Hatchery(nationallobsterhatchery) ∧ LocatedIn(nationallobsterhatchery, padstowengland)"
  },
  {
    "input": "Translate into first-order logic: The National Lobster Hatchery is open to visitors.",
    "output": "OpenToVisitors(nationallobsterhatchery)"
  },
  {
    "input": "Translate into first-order logic: A hatchery is either for profit, or for conservation.",
    "output": "∀x (Hatchery(x) → ForConservation(x) ∨ ForProfit(x))"
  },
  {
    "input": "Translate into first-order logic: If a hatchery is for conservation, it might release animals into the wild.",
    "output": "∃x (Hatchery(x) ∧ ForConservation(x) ∧ ReleasesAnimalsToWild(x))"
  },
  {
    "input": "Translate into first-order logic: The National Lobster Hatchery is not for profit.",
    "output": "¬ForProfit(nationallobsterhatchery)"
  },
  {
    "input": "Translate into first-order logic: The National Lobster Hatchery is a hatchery located in Padstow England.",
    "output": "Hatchery(nationallobsterhatchery) ∧ LocatedIn(nationallobsterhatchery, padstowengland)"
  },
  {
    "input": "Translate into first-order logic: The National Lobster Hatchery is open to visitors.",
    "output": "OpenToVisitors(nationallobsterhatchery)"
  },
  {
    "input": "Translate into first-order logic: A hatchery is either for profit, or for conservation.",
    "output": "∀x (Hatchery(x) → ForConservation(x) ∨ ForProfit(x))"
  },
  {
    "input": "Translate into first-order logic: If a hatchery is for conservation, it might release animals into the wild.",
    "output": "∃x (Hatchery(x) ∧ ForConservation(x) ∧ ReleasesAnimalsToWild(x))"
  },
  {
    "input": "Translate into first-order logic: The National Lobster Hatchery is not for profit.",
    "output": "¬ForProfit(nationallobsterhatchery)"
  },
  {
    "input": "Translate into first-order logic: Rhos Aelwyd F.C. is a Welsh football club.",
    "output": "∀x (Rhosaelwydfc(x) → FootballClub(x) ∧ BasedInPonciau(x) ∧ Welsh(x))"
  },
  {
    "input": "Translate into first-order logic: Rhos Aelwyd F.C. is the only club based in Ponciau.",
    "output": "∀x (BasedInPonciau(x) ↔ Rhosaelwydfc(x))"
  },
  {
    "input": "Translate into first-order logic: The Premier Division was won in 2005–06 by a team from Ponciau.",
    "output": "∃x (BasedInPonciau(x) ∧ WonPremierDivisionDuring(x, y2005))"
  },
  {
    "input": "Translate into first-order logic: The winner of the Premier Division in 2009–10 was promoted back to the Cymru Alliance.",
    "output": "∀x (WonPremierDivisionDuring(x, y2009) → Promoted(x))"
  },
  {
    "input": "Translate into first-order logic: The Premier Division in 2009–10 was won by the same team that won in 2005-06.",
    "output": "∀x (WonPremierDivisionDuring(x, y2009) ↔ WonPremierDivisionDuring(x, y2005))"
  },
  {
    "input": "Translate into first-order logic: Rhos Aelwyd F.C. is a Welsh football club.",
    "output": "∀x (Rhosaelwydfc(x) → FootballClub(x) ∧ BasedInPonciau(x) ∧ Welsh(x))"
  },
  {
    "input": "Translate into first-order logic: Rhos Aelwyd F.C. is the only club based in Ponciau.",
    "output": "∀x (BasedInPonciau(x) ↔ Rhosaelwydfc(x))"
  },
  {
    "input": "Translate into first-order logic: The Premier Division was won in 2005–06 by a team from Ponciau.",
    "output": "∃x (BasedInPonciau(x) ∧ WonPremierDivisionDuring(x, y2005))"
  },
  {
    "input": "Translate into first-order logic: The winner of the Premier Division in 2009–10 was promoted back to the Cymru Alliance.",
    "output": "∀x (WonPremierDivisionDuring(x, y2009) → Promoted(x))"
  },
  {
    "input": "Translate into first-order logic: The Premier Division in 2009–10 was won by the same team that won in 2005-06.",
    "output": "∀x (WonPremierDivisionDuring(x, y2009) ↔ WonPremierDivisionDuring(x, y2005))"
  },
  {
    "input": "Translate into first-order logic: All OS are software.",
    "output": "∀x (OS(x) → Software(x))"
  },
  {
    "input": "Translate into first-order logic: All Mac are OS.",
    "output": "∀x (Mac(x) → OS(x))"
  },
  {
    "input": "Translate into first-order logic: An OS is either Mac or Windows.",
    "output": "∀x (Mac(x) ∨ Windows(x))"
  },
  {
    "input": "Translate into first-order logic: All Windows are convenient.",
    "output": "∀x (Windows(x) → Convenient(x))"
  },
  {
    "input": "Translate into first-order logic: All software has code.",
    "output": "∀x (Software(x) → Code(x))"
  },
  {
    "input": "Translate into first-order logic: If something is convenient, then it is popular.",
    "output": "∀x (Convenient(x) → Popular(x))"
  },
  {
    "input": "Translate into first-order logic: Burger is a piece of code and a Mac.",
    "output": "Code(burger) ∧ Mac(burger))"
  },
  {
    "input": "Translate into first-order logic: PyTorch is either Windows and software, or neither Windows nor software.",
    "output": "(Windows(pytorch) ∧ Software(pytorch)) ⊕ (¬Windows(pytorch) ∧ ¬Software(pytorch))"
  },
  {
    "input": "Translate into first-order logic: All OS are software.",
    "output": "∀x (OS(x) → Software(x))"
  },
  {
    "input": "Translate into first-order logic: All Mac are OS.",
    "output": "∀x (Mac(x) → OS(x))"
  },
  {
    "input": "Translate into first-order logic: An OS is either Mac or Windows.",
    "output": "∀x (Mac(x) ∨ Windows(x))"
  },
  {
    "input": "Translate into first-order logic: All Windows are convenient.",
    "output": "∀x (Windows(x) → Convenient(x))"
  },
  {
    "input": "Translate into first-order logic: All software has code.",
    "output": "∀x (Software(x) → Code(x))"
  },
  {
    "input": "Translate into first-order logic: If something is convenient, then it is popular.",
    "output": "∀x (Convenient(x) → Popular(x))"
  },
  {
    "input": "Translate into first-order logic: Burger is a piece of code and a Mac.",
    "output": "Code(burger) ∧ Mac(burger))"
  },
  {
    "input": "Translate into first-order logic: PyTorch is either Windows and software, or neither Windows nor software.",
    "output": "(Windows(pytorch) ∧ Software(pytorch)) ⊕ (¬Windows(pytorch) ∧ ¬Software(pytorch))"
  },
  {
    "input": "Translate into first-order logic: All OS are software.",
    "output": "∀x (OS(x) → Software(x))"
  },
  {
    "input": "Translate into first-order logic: All Mac are OS.",
    "output": "∀x (Mac(x) → OS(x))"
  },
  {
    "input": "Translate into first-order logic: An OS is either Mac or Windows.",
    "output": "∀x (Mac(x) ∨ Windows(x))"
  },
  {
    "input": "Translate into first-order logic: All Windows are convenient.",
    "output": "∀x (Windows(x) → Convenient(x))"
  },
  {
    "input": "Translate into first-order logic: All software has code.",
    "output": "∀x (Software(x) → Code(x))"
  },
  {
    "input": "Translate into first-order logic: If something is convenient, then it is popular.",
    "output": "∀x (Convenient(x) → Popular(x))"
  },
  {
    "input": "Translate into first-order logic: Burger is a piece of code and a Mac.",
    "output": "Code(burger) ∧ Mac(burger))"
  },
  {
    "input": "Translate into first-order logic: PyTorch is either Windows and software, or neither Windows nor software.",
    "output": "(Windows(pytorch) ∧ Software(pytorch)) ⊕ (¬Windows(pytorch) ∧ ¬Software(pytorch))"
  },
  {
    "input": "Translate into first-order logic: All OS are software.",
    "output": "∀x (OS(x) → Software(x))"
  },
  {
    "input": "Translate into first-order logic: All Mac are OS.",
    "output": "∀x (Mac(x) → OS(x))"
  },
  {
    "input": "Translate into first-order logic: An OS is either Mac or Windows.",
    "output": "∀x (Mac(x) ∨ Windows(x))"
  },
  {
    "input": "Translate into first-order logic: All Windows are convenient.",
    "output": "∀x (Windows(x) → Convenient(x))"
  },
  {
    "input": "Translate into first-order logic: All software has code.",
    "output": "∀x (Software(x) → Code(x))"
  },
  {
    "input": "Translate into first-order logic: If something is convenient, then it is popular.",
    "output": "∀x (Convenient(x) → Popular(x))"
  },
  {
    "input": "Translate into first-order logic: Burger is a piece of code and a Mac.",
    "output": "Code(burger) ∧ Mac(burger))"
  },
  {
    "input": "Translate into first-order logic: PyTorch is either Windows and software, or neither Windows nor software.",
    "output": "(Windows(pytorch) ∧ Software(pytorch)) ⊕ (¬Windows(pytorch) ∧ ¬Software(pytorch))"
  },
  {
    "input": "Translate into first-order logic: Roads are made of either concrete or asphalt.",
    "output": "∀x (Road(x) → (MadeOfConcrete(x) ∨ MadeOfAsphalt(x))"
  },
  {
    "input": "Translate into first-order logic: Roads made of concrete last longer than roads made with asphalt.",
    "output": "∀x ∀y (Road(x) ∧ MadeOfConcrete(x) ∧ Road(y) ∧ MadeOfAsphalt(y) → LastLonger(x, y))"
  },
  {
    "input": "Translate into first-order logic: Roads made of asphalt are smoother than roads made of concrete.",
    "output": "∀x ∀y (Road(x) ∧ MadeOfAsphalt(x) ∧ Road(y) ∧ MadeOfConcrete(y) → Smoother(x, y))"
  },
  {
    "input": "Translate into first-order logic: Everyone prefers the smoother of two roads.",
    "output": "∀x ∀y ∀z (Road(x) ∧ Road(y) ∧ Smoother(x, y) → Prefers(z, x))"
  },
  {
    "input": "Translate into first-order logic: Road one is made of concrete and Road two is made of asphalt.",
    "output": "Road(one) ∧ MadeOfConcrete(one) ∧ Road(two) ∧ MadeOfAsphalt(two)"
  },
  {
    "input": "Translate into first-order logic: Roads are made of either concrete or asphalt.",
    "output": "∀x (Road(x) → (MadeOfConcrete(x) ∨ MadeOfAsphalt(x))"
  },
  {
    "input": "Translate into first-order logic: Roads made of concrete last longer than roads made with asphalt.",
    "output": "∀x ∀y (Road(x) ∧ MadeOfConcrete(x) ∧ Road(y) ∧ MadeOfAsphalt(y) → LastLonger(x, y))"
  },
  {
    "input": "Translate into first-order logic: Roads made of asphalt are smoother than roads made of concrete.",
    "output": "∀x ∀y (Road(x) ∧ MadeOfAsphalt(x) ∧ Road(y) ∧ MadeOfConcrete(y) → Smoother(x, y))"
  },
  {
    "input": "Translate into first-order logic: Everyone prefers the smoother of two roads.",
    "output": "∀x ∀y ∀z (Road(x) ∧ Road(y) ∧ Smoother(x, y) → Prefers(z, x))"
  },
  {
    "input": "Translate into first-order logic: Road one is made of concrete and Road two is made of asphalt.",
    "output": "Road(one) ∧ MadeOfConcrete(one) ∧ Road(two) ∧ MadeOfAsphalt(two)"
  },
  {
    "input": "Translate into first-order logic: Roads are made of either concrete or asphalt.",
    "output": "∀x (Road(x) → (MadeOfConcrete(x) ∨ MadeOfAsphalt(x))"
  },
  {
    "input": "Translate into first-order logic: Roads made of concrete last longer than roads made with asphalt.",
    "output": "∀x ∀y (Road(x) ∧ MadeOfConcrete(x) ∧ Road(y) ∧ MadeOfAsphalt(y) → LastLonger(x, y))"
  },
  {
    "input": "Translate into first-order logic: Roads made of asphalt are smoother than roads made of concrete.",
    "output": "∀x ∀y (Road(x) ∧ MadeOfAsphalt(x) ∧ Road(y) ∧ MadeOfConcrete(y) → Smoother(x, y))"
  },
  {
    "input": "Translate into first-order logic: Everyone prefers the smoother of two roads.",
    "output": "∀x ∀y ∀z (Road(x) ∧ Road(y) ∧ Smoother(x, y) → Prefers(z, x))"
  },
  {
    "input": "Translate into first-order logic: Road one is made of concrete and Road two is made of asphalt.",
    "output": "Road(one) ∧ MadeOfConcrete(one) ∧ Road(two) ∧ MadeOfAsphalt(two)"
  },
  {
    "input": "Translate into first-order logic: Camp Davern is a traditional summer camp for boys and girls.",
    "output": "TraditionalSummerCamp(campdavern) ∧ ForBoysAndGirls(campdavern)"
  },
  {
    "input": "Translate into first-order logic: Camp Davern was established in the year 1946.",
    "output": "EstablishedIn(campdavern, year1946)"
  },
  {
    "input": "Translate into first-order logic: Camp Davern was operated by the YMCA until the year 2015.",
    "output": "OperatedByYMCAUntil(campdavern, year2015)"
  },
  {
    "input": "Translate into first-order logic: Camp Davern is one of Ontario's oldest summer camps.",
    "output": "OneOf(campdavern, ontariosoldestsummercamps)"
  },
  {
    "input": "Translate into first-order logic: Camp Davern is a traditional summer camp for boys and girls.",
    "output": "TraditionalSummerCamp(campdavern) ∧ ForBoysAndGirls(campdavern)"
  },
  {
    "input": "Translate into first-order logic: Camp Davern was established in the year 1946.",
    "output": "EstablishedIn(campdavern, year1946)"
  },
  {
    "input": "Translate into first-order logic: Camp Davern was operated by the YMCA until the year 2015.",
    "output": "OperatedByYMCAUntil(campdavern, year2015)"
  },
  {
    "input": "Translate into first-order logic: Camp Davern is one of Ontario's oldest summer camps.",
    "output": "OneOf(campdavern, ontariosoldestsummercamps)"
  },
  {
    "input": "Translate into first-order logic: Camp Davern is a traditional summer camp for boys and girls.",
    "output": "TraditionalSummerCamp(campdavern) ∧ ForBoysAndGirls(campdavern)"
  },
  {
    "input": "Translate into first-order logic: Camp Davern was established in the year 1946.",
    "output": "EstablishedIn(campdavern, year1946)"
  },
  {
    "input": "Translate into first-order logic: Camp Davern was operated by the YMCA until the year 2015.",
    "output": "OperatedByYMCAUntil(campdavern, year2015)"
  },
  {
    "input": "Translate into first-order logic: Camp Davern is one of Ontario's oldest summer camps.",
    "output": "OneOf(campdavern, ontariosoldestsummercamps)"
  },
  {
    "input": "Translate into first-order logic: If people publish journals, then they do not work in the entertainment industry.",
    "output": "∀x (PublishJournals(x) → ¬Entertainment(x))"
  },
  {
    "input": "Translate into first-order logic: All people who are award-winning novelists publish journals.",
    "output": "∀x (Novelist(x) → PublishJournals(x))"
  },
  {
    "input": "Translate into first-order logic: People either work in the entertainment industry or are highly acclaimed in their profession.",
    "output": "∀x (Entertainment(x) ∨ Acclaimed(x))"
  },
  {
    "input": "Translate into first-order logic: If people are highly acclaimed in their profession, then they often hold tenured and high-ranking positions at their workplace.",
    "output": "∀x (Acclaimed(x) → Tenured(x))"
  },
  {
    "input": "Translate into first-order logic: If people are highly acclaimed in their profession, then they often receive glowing feedback and recommendations from their colleagues.",
    "output": "∀x (Acclaimed(x) → Glowing(x))"
  },
  {
    "input": "Translate into first-order logic: If Emily is either both highly acclaimed in her profession and often holds tenured and high-ranking positions at her workplace, or she is neither highly acclaimed in her profession nor often holds tenured and high-ranking positions at her workplace, then Emily is not highly acclaimed in her profession.",
    "output": "(Acclaimed(emily) ∧ Tenured(emily)) ∨ (¬Acclaimed(emily) ∧ ¬Tenured(emily)) → ¬Acclaimed(emily)"
  },
  {
    "input": "Translate into first-order logic: If people publish journals, then they do not work in the entertainment industry.",
    "output": "∀x (PublishJournals(x) → ¬Entertainment(x))"
  },
  {
    "input": "Translate into first-order logic: All people who are award-winning novelists publish journals.",
    "output": "∀x (Novelist(x) → PublishJournals(x))"
  },
  {
    "input": "Translate into first-order logic: People either work in the entertainment industry or are highly acclaimed in their profession.",
    "output": "∀x (Entertainment(x) ∨ Acclaimed(x))"
  },
  {
    "input": "Translate into first-order logic: If people are highly acclaimed in their profession, then they often hold tenured and high-ranking positions at their workplace.",
    "output": "∀x (Acclaimed(x) → Tenured(x))"
  },
  {
    "input": "Translate into first-order logic: If people are highly acclaimed in their profession, then they often receive glowing feedback and recommendations from their colleagues.",
    "output": "∀x (Acclaimed(x) → Glowing(x))"
  },
  {
    "input": "Translate into first-order logic: If Emily is either both highly acclaimed in her profession and often holds tenured and high-ranking positions at her workplace, or she is neither highly acclaimed in her profession nor often holds tenured and high-ranking positions at her workplace, then Emily is not highly acclaimed in her profession.",
    "output": "(Acclaimed(emily) ∧ Tenured(emily)) ∨ (¬Acclaimed(emily) ∧ ¬Tenured(emily)) → ¬Acclaimed(emily)"
  },
  {
    "input": "Translate into first-order logic: If people publish journals, then they do not work in the entertainment industry.",
    "output": "∀x (PublishJournals(x) → ¬Entertainment(x))"
  },
  {
    "input": "Translate into first-order logic: All people who are award-winning novelists publish journals.",
    "output": "∀x (Novelist(x) → PublishJournals(x))"
  },
  {
    "input": "Translate into first-order logic: People either work in the entertainment industry or are highly acclaimed in their profession.",
    "output": "∀x (Entertainment(x) ∨ Acclaimed(x))"
  },
  {
    "input": "Translate into first-order logic: If people are highly acclaimed in their profession, then they often hold tenured and high-ranking positions at their workplace.",
    "output": "∀x (Acclaimed(x) → Tenured(x))"
  },
  {
    "input": "Translate into first-order logic: If people are highly acclaimed in their profession, then they often receive glowing feedback and recommendations from their colleagues.",
    "output": "∀x (Acclaimed(x) → Glowing(x))"
  },
  {
    "input": "Translate into first-order logic: If Emily is either both highly acclaimed in her profession and often holds tenured and high-ranking positions at her workplace, or she is neither highly acclaimed in her profession nor often holds tenured and high-ranking positions at her workplace, then Emily is not highly acclaimed in her profession.",
    "output": "(Acclaimed(emily) ∧ Tenured(emily)) ∨ (¬Acclaimed(emily) ∧ ¬Tenured(emily)) → ¬Acclaimed(emily)"
  },
  {
    "input": "Translate into first-order logic: Thick as Thieves is a young adult fantasy novel, written by Megan Whalen Turner.",
    "output": "YoungAdultFantasyNovel(thickastheives) ∧ WrittenBy(thickastheives, megan)"
  },
  {
    "input": "Translate into first-order logic: Thick as Thieves was published by Greenwillow Books.",
    "output": "PublishedBy(thickastheives, greenwillowbooks)"
  },
  {
    "input": "Translate into first-order logic: If a book was published by a company, than the author of that book worked with the company that published the book.",
    "output": "∀x ∀y ∀z (WrittenBy(x, y) ∧ PublishedBy(x, z) → WorkedWith(y, z))"
  },
  {
    "input": "Translate into first-order logic: The fictional Mede Empire is where Thick as Thieves is set.",
    "output": "Fictional(medeempire) ∧ SetIn(thickastheives, medeempire)"
  },
  {
    "input": "Translate into first-order logic: The Mede Empire plots to swallow up some nearby countries.",
    "output": "∃x (Country(x) Nearby(medeempire, x) ∧ PlotsToSwallowUp(medeempire, x))"
  },
  {
    "input": "Translate into first-order logic: Attolia and Sounis are countries near the Mede Empire.",
    "output": "Country(attolia) ∧ Nearby(medeempire, attolia) ∧ Country(sounis) ∧ Nearby(medeempire, sounis)"
  },
  {
    "input": "Translate into first-order logic: Thick as Thieves was sold both as a hardcover and an e-book.",
    "output": "SoldAs(thickastheives, hardcover) ∧ SoldAs(thickastheives, softcover)"
  },
  {
    "input": "Translate into first-order logic: Thick as Thieves is a young adult fantasy novel, written by Megan Whalen Turner.",
    "output": "YoungAdultFantasyNovel(thickastheives) ∧ WrittenBy(thickastheives, megan)"
  },
  {
    "input": "Translate into first-order logic: Thick as Thieves was published by Greenwillow Books.",
    "output": "PublishedBy(thickastheives, greenwillowbooks)"
  },
  {
    "input": "Translate into first-order logic: If a book was published by a company, than the author of that book worked with the company that published the book.",
    "output": "∀x ∀y ∀z (WrittenBy(x, y) ∧ PublishedBy(x, z) → WorkedWith(y, z))"
  },
  {
    "input": "Translate into first-order logic: The fictional Mede Empire is where Thick as Thieves is set.",
    "output": "Fictional(medeempire) ∧ SetIn(thickastheives, medeempire)"
  },
  {
    "input": "Translate into first-order logic: The Mede Empire plots to swallow up some nearby countries.",
    "output": "∃x (Country(x) Nearby(medeempire, x) ∧ PlotsToSwallowUp(medeempire, x))"
  },
  {
    "input": "Translate into first-order logic: Attolia and Sounis are countries near the Mede Empire.",
    "output": "Country(attolia) ∧ Nearby(medeempire, attolia) ∧ Country(sounis) ∧ Nearby(medeempire, sounis)"
  },
  {
    "input": "Translate into first-order logic: Thick as Thieves was sold both as a hardcover and an e-book.",
    "output": "SoldAs(thickastheives, hardcover) ∧ SoldAs(thickastheives, softcover)"
  },
  {
    "input": "Translate into first-order logic: Thick as Thieves is a young adult fantasy novel, written by Megan Whalen Turner.",
    "output": "YoungAdultFantasyNovel(thickastheives) ∧ WrittenBy(thickastheives, megan)"
  },
  {
    "input": "Translate into first-order logic: Thick as Thieves was published by Greenwillow Books.",
    "output": "PublishedBy(thickastheives, greenwillowbooks)"
  },
  {
    "input": "Translate into first-order logic: If a book was published by a company, than the author of that book worked with the company that published the book.",
    "output": "∀x ∀y ∀z (WrittenBy(x, y) ∧ PublishedBy(x, z) → WorkedWith(y, z))"
  },
  {
    "input": "Translate into first-order logic: The fictional Mede Empire is where Thick as Thieves is set.",
    "output": "Fictional(medeempire) ∧ SetIn(thickastheives, medeempire)"
  },
  {
    "input": "Translate into first-order logic: The Mede Empire plots to swallow up some nearby countries.",
    "output": "∃x (Country(x) Nearby(medeempire, x) ∧ PlotsToSwallowUp(medeempire, x))"
  },
  {
    "input": "Translate into first-order logic: Attolia and Sounis are countries near the Mede Empire.",
    "output": "Country(attolia) ∧ Nearby(medeempire, attolia) ∧ Country(sounis) ∧ Nearby(medeempire, sounis)"
  },
  {
    "input": "Translate into first-order logic: Thick as Thieves was sold both as a hardcover and an e-book.",
    "output": "SoldAs(thickastheives, hardcover) ∧ SoldAs(thickastheives, softcover)"
  },
  {
    "input": "Translate into first-order logic: Thick as Thieves is a young adult fantasy novel, written by Megan Whalen Turner.",
    "output": "YoungAdultFantasyNovel(thickastheives) ∧ WrittenBy(thickastheives, megan)"
  },
  {
    "input": "Translate into first-order logic: Thick as Thieves was published by Greenwillow Books.",
    "output": "PublishedBy(thickastheives, greenwillowbooks)"
  },
  {
    "input": "Translate into first-order logic: If a book was published by a company, than the author of that book worked with the company that published the book.",
    "output": "∀x ∀y ∀z (WrittenBy(x, y) ∧ PublishedBy(x, z) → WorkedWith(y, z))"
  },
  {
    "input": "Translate into first-order logic: The fictional Mede Empire is where Thick as Thieves is set.",
    "output": "Fictional(medeempire) ∧ SetIn(thickastheives, medeempire)"
  },
  {
    "input": "Translate into first-order logic: The Mede Empire plots to swallow up some nearby countries.",
    "output": "∃x (Country(x) Nearby(medeempire, x) ∧ PlotsToSwallowUp(medeempire, x))"
  },
  {
    "input": "Translate into first-order logic: Attolia and Sounis are countries near the Mede Empire.",
    "output": "Country(attolia) ∧ Nearby(medeempire, attolia) ∧ Country(sounis) ∧ Nearby(medeempire, sounis)"
  },
  {
    "input": "Translate into first-order logic: Thick as Thieves was sold both as a hardcover and an e-book.",
    "output": "SoldAs(thickastheives, hardcover) ∧ SoldAs(thickastheives, softcover)"
  },
  {
    "input": "Translate into first-order logic: WeTab is a MeeGo-based tablet computer.",
    "output": "∀x (WeTab(x) → MeeGoBased(x) ∧ TabletComputer(x))"
  },
  {
    "input": "Translate into first-order logic: There is a WeTab product.",
    "output": "∃x (WeTab(x))"
  },
  {
    "input": "Translate into first-order logic: WeTab was announced by Neofonie.",
    "output": "∀x (WeTab(x) → Announce(neofonie, x))"
  },
  {
    "input": "Translate into first-order logic: Neofonie is a German producer.",
    "output": "German(neofonie) ∧ Producer(neofonie)"
  },
  {
    "input": "Translate into first-order logic: Germans speak English or German.",
    "output": "∀x (German(x) → Speak(x, english) ∨ Speak(x, german))"
  },
  {
    "input": "Translate into first-order logic: WeTab is a MeeGo-based tablet computer.",
    "output": "∀x (WeTab(x) → MeeGoBased(x) ∧ TabletComputer(x))"
  },
  {
    "input": "Translate into first-order logic: There is a WeTab product.",
    "output": "∃x (WeTab(x))"
  },
  {
    "input": "Translate into first-order logic: WeTab was announced by Neofonie.",
    "output": "∀x (WeTab(x) → Announce(neofonie, x))"
  },
  {
    "input": "Translate into first-order logic: Neofonie is a German producer.",
    "output": "German(neofonie) ∧ Producer(neofonie)"
  },
  {
    "input": "Translate into first-order logic: Germans speak English or German.",
    "output": "∀x (German(x) → Speak(x, english) ∨ Speak(x, german))"
  },
  {
    "input": "Translate into first-order logic: Some employees working in business analysis are good at math.",
    "output": "∃x ( BusinessAnalysis(x) ∧ GoodAtMath(x))"
  },
  {
    "input": "Translate into first-order logic: All employees working in business analysis are working in this company.",
    "output": "∀x (BusinessAnalysis(x) → WorkInCompany(x))"
  },
  {
    "input": "Translate into first-order logic: No employees working in this company are from China.",
    "output": "∀x (WorkInCompany(x) → ¬FromChina(x))"
  },
  {
    "input": "Translate into first-order logic: All employees working in software engineering are from China.",
    "output": "∀x (SoftwareEngineering(x) → FromChina(x))"
  },
  {
    "input": "Translate into first-order logic: James is working in software engineering.",
    "output": "SoftwareEngineering(james)"
  },
  {
    "input": "Translate into first-order logic: Some employees working in business analysis are good at math.",
    "output": "∃x ( BusinessAnalysis(x) ∧ GoodAtMath(x))"
  },
  {
    "input": "Translate into first-order logic: All employees working in business analysis are working in this company.",
    "output": "∀x (BusinessAnalysis(x) → WorkInCompany(x))"
  },
  {
    "input": "Translate into first-order logic: No employees working in this company are from China.",
    "output": "∀x (WorkInCompany(x) → ¬FromChina(x))"
  },
  {
    "input": "Translate into first-order logic: All employees working in software engineering are from China.",
    "output": "∀x (SoftwareEngineering(x) → FromChina(x))"
  },
  {
    "input": "Translate into first-order logic: James is working in software engineering.",
    "output": "SoftwareEngineering(james)"
  },
  {
    "input": "Translate into first-order logic: Some employees working in business analysis are good at math.",
    "output": "∃x ( BusinessAnalysis(x) ∧ GoodAtMath(x))"
  },
  {
    "input": "Translate into first-order logic: All employees working in business analysis are working in this company.",
    "output": "∀x (BusinessAnalysis(x) → WorkInCompany(x))"
  },
  {
    "input": "Translate into first-order logic: No employees working in this company are from China.",
    "output": "∀x (WorkInCompany(x) → ¬FromChina(x))"
  },
  {
    "input": "Translate into first-order logic: All employees working in software engineering are from China.",
    "output": "∀x (SoftwareEngineering(x) → FromChina(x))"
  },
  {
    "input": "Translate into first-order logic: James is working in software engineering.",
    "output": "SoftwareEngineering(james)"
  },
  {
    "input": "Translate into first-order logic: The party provides five kinds of fruits: strawberry, orange, blueberry, grape, and cherry.",
    "output": "Party(strawberry) ∨ Party(orange) ∨ Party(blueberry) ∨ Party(grape) ∨ Party(cherry) "
  },
  {
    "input": "Translate into first-order logic: All fruits are provided in the same weight at the beginning of the party.",
    "output": "∀x (Party(x) → SameWeight(x))"
  },
  {
    "input": "Translate into first-order logic: If the fruit had the lowest remaining weight at the end of the party, then it means it was the most popular fruit.",
    "output": "∀x (LowestAmount(x) → MostPopular(x)) "
  },
  {
    "input": "Translate into first-order logic: At the end of the party, strawberries had the lowest remaining weight.",
    "output": "LowestAmount(strawberries)"
  },
  {
    "input": "Translate into first-order logic: At the end of the party, the amount of leftover blueberries was lower than that of cherries.",
    "output": "Lower(blueberry, cherry)"
  },
  {
    "input": "Translate into first-order logic: Benjamin only ate oranges and grapes at the party.",
    "output": "Eat(orange, benjamin) ∧ Eat(grape, benjamin) ∧ ¬Eat(blueberry, benjamin) ∧ ¬Eat(cherry, benjamin) ∧ ¬Eat(strawberry, benjamin)"
  },
  {
    "input": "Translate into first-order logic: The party provides five kinds of fruits: strawberry, orange, blueberry, grape, and cherry.",
    "output": "Party(strawberry) ∨ Party(orange) ∨ Party(blueberry) ∨ Party(grape) ∨ Party(cherry) "
  },
  {
    "input": "Translate into first-order logic: All fruits are provided in the same weight at the beginning of the party.",
    "output": "∀x (Party(x) → SameWeight(x))"
  },
  {
    "input": "Translate into first-order logic: If the fruit had the lowest remaining weight at the end of the party, then it means it was the most popular fruit.",
    "output": "∀x (LowestAmount(x) → MostPopular(x)) "
  },
  {
    "input": "Translate into first-order logic: At the end of the party, strawberries had the lowest remaining weight.",
    "output": "LowestAmount(strawberries)"
  },
  {
    "input": "Translate into first-order logic: At the end of the party, the amount of leftover blueberries was lower than that of cherries.",
    "output": "Lower(blueberry, cherry)"
  },
  {
    "input": "Translate into first-order logic: Benjamin only ate oranges and grapes at the party.",
    "output": "Eat(orange, benjamin) ∧ Eat(grape, benjamin) ∧ ¬Eat(blueberry, benjamin) ∧ ¬Eat(cherry, benjamin) ∧ ¬Eat(strawberry, benjamin)"
  },
  {
    "input": "Translate into first-order logic: The party provides five kinds of fruits: strawberry, orange, blueberry, grape, and cherry.",
    "output": "Party(strawberry) ∨ Party(orange) ∨ Party(blueberry) ∨ Party(grape) ∨ Party(cherry) "
  },
  {
    "input": "Translate into first-order logic: All fruits are provided in the same weight at the beginning of the party.",
    "output": "∀x (Party(x) → SameWeight(x))"
  },
  {
    "input": "Translate into first-order logic: If the fruit had the lowest remaining weight at the end of the party, then it means it was the most popular fruit.",
    "output": "∀x (LowestAmount(x) → MostPopular(x)) "
  },
  {
    "input": "Translate into first-order logic: At the end of the party, strawberries had the lowest remaining weight.",
    "output": "LowestAmount(strawberries)"
  },
  {
    "input": "Translate into first-order logic: At the end of the party, the amount of leftover blueberries was lower than that of cherries.",
    "output": "Lower(blueberry, cherry)"
  },
  {
    "input": "Translate into first-order logic: Benjamin only ate oranges and grapes at the party.",
    "output": "Eat(orange, benjamin) ∧ Eat(grape, benjamin) ∧ ¬Eat(blueberry, benjamin) ∧ ¬Eat(cherry, benjamin) ∧ ¬Eat(strawberry, benjamin)"
  },
  {
    "input": "Translate into first-order logic: All students who attend in person have registered for the conference.",
    "output": "∀x (Attend(x) → Registered(x))"
  },
  {
    "input": "Translate into first-order logic: Students either attend the conference in person or remotely.",
    "output": "∀x (Attend(x) → InPerson(x) ⊕ Remotely(x))"
  },
  {
    "input": "Translate into first-order logic: No students from China attend the conference remotely.",
    "output": "∀x ((Attend(x) ∧ China(x)) → ¬Remotely(x))"
  },
  {
    "input": "Translate into first-order logic: James attends the conference but he does not attend the conference remotely.",
    "output": "Attend(james) ∧ ¬Remotely(james)"
  },
  {
    "input": "Translate into first-order logic: Jack attends the conference and he is a student from China.",
    "output": "China(jack) ∧ Attend(jack)"
  },
  {
    "input": "Translate into first-order logic: All students who attend in person have registered for the conference.",
    "output": "∀x (Attend(x) → Registered(x))"
  },
  {
    "input": "Translate into first-order logic: Students either attend the conference in person or remotely.",
    "output": "∀x (Attend(x) → InPerson(x) ⊕ Remotely(x))"
  },
  {
    "input": "Translate into first-order logic: No students from China attend the conference remotely.",
    "output": "∀x ((Attend(x) ∧ China(x)) → ¬Remotely(x))"
  },
  {
    "input": "Translate into first-order logic: James attends the conference but he does not attend the conference remotely.",
    "output": "Attend(james) ∧ ¬Remotely(james)"
  },
  {
    "input": "Translate into first-order logic: Jack attends the conference and he is a student from China.",
    "output": "China(jack) ∧ Attend(jack)"
  },
  {
    "input": "Translate into first-order logic: All students who attend in person have registered for the conference.",
    "output": "∀x (Attend(x) → Registered(x))"
  },
  {
    "input": "Translate into first-order logic: Students either attend the conference in person or remotely.",
    "output": "∀x (Attend(x) → InPerson(x) ⊕ Remotely(x))"
  },
  {
    "input": "Translate into first-order logic: No students from China attend the conference remotely.",
    "output": "∀x ((Attend(x) ∧ China(x)) → ¬Remotely(x))"
  },
  {
    "input": "Translate into first-order logic: James attends the conference but he does not attend the conference remotely.",
    "output": "Attend(james) ∧ ¬Remotely(james)"
  },
  {
    "input": "Translate into first-order logic: Jack attends the conference and he is a student from China.",
    "output": "China(jack) ∧ Attend(jack)"
  },
  {
    "input": "Translate into first-order logic: David Ha'ivri is a political strategist.",
    "output": "PoliticalStrategist(davidhaivri)"
  },
  {
    "input": "Translate into first-order logic: If you are born in Israel to at least one Israeli parent, then you receive citizenship at birth.",
    "output": "∀x ∃y (BornInIsrael(x) ∧ ParentOf(x, y) ∧ Israeli(y) → IsraeliCitizen(x))"
  },
  {
    "input": "Translate into first-order logic: David Ha'ivri emigrated to the United States from Israel, where he was born to Israeli parents.",
    "output": "∃x (EmigratedTo(davidhaivri, america) ∧ BornInIsrael(davidhaivri) ∧ ParentOf(davidhaivri, x) ∧ Israeli(x))"
  },
  {
    "input": "Translate into first-order logic: Several Zionist leaders have been elected to the Shomron Regional Municipal council.",
    "output": "∃x (ZionistLeader(x) ∧ ElectedTo(x, shomronmunicipalcouncil))"
  },
  {
    "input": "Translate into first-order logic: David Ha'ivri is a Zionist leader.",
    "output": "ZionstLeader(davidhaivri)"
  },
  {
    "input": "Translate into first-order logic: David Ha'ivri is a political strategist.",
    "output": "PoliticalStrategist(davidhaivri)"
  },
  {
    "input": "Translate into first-order logic: If you are born in Israel to at least one Israeli parent, then you receive citizenship at birth.",
    "output": "∀x ∃y (BornInIsrael(x) ∧ ParentOf(x, y) ∧ Israeli(y) → IsraeliCitizen(x))"
  },
  {
    "input": "Translate into first-order logic: David Ha'ivri emigrated to the United States from Israel, where he was born to Israeli parents.",
    "output": "∃x (EmigratedTo(davidhaivri, america) ∧ BornInIsrael(davidhaivri) ∧ ParentOf(davidhaivri, x) ∧ Israeli(x))"
  },
  {
    "input": "Translate into first-order logic: Several Zionist leaders have been elected to the Shomron Regional Municipal council.",
    "output": "∃x (ZionistLeader(x) ∧ ElectedTo(x, shomronmunicipalcouncil))"
  },
  {
    "input": "Translate into first-order logic: David Ha'ivri is a Zionist leader.",
    "output": "ZionstLeader(davidhaivri)"
  },
  {
    "input": "Translate into first-order logic: David Ha'ivri is a political strategist.",
    "output": "PoliticalStrategist(davidhaivri)"
  },
  {
    "input": "Translate into first-order logic: If you are born in Israel to at least one Israeli parent, then you receive citizenship at birth.",
    "output": "∀x ∃y (BornInIsrael(x) ∧ ParentOf(x, y) ∧ Israeli(y) → IsraeliCitizen(x))"
  },
  {
    "input": "Translate into first-order logic: David Ha'ivri emigrated to the United States from Israel, where he was born to Israeli parents.",
    "output": "∃x (EmigratedTo(davidhaivri, america) ∧ BornInIsrael(davidhaivri) ∧ ParentOf(davidhaivri, x) ∧ Israeli(x))"
  },
  {
    "input": "Translate into first-order logic: Several Zionist leaders have been elected to the Shomron Regional Municipal council.",
    "output": "∃x (ZionistLeader(x) ∧ ElectedTo(x, shomronmunicipalcouncil))"
  },
  {
    "input": "Translate into first-order logic: David Ha'ivri is a Zionist leader.",
    "output": "ZionstLeader(davidhaivri)"
  },
  {
    "input": "Translate into first-order logic: Mary has the flu.",
    "output": "Have(mary, flu)"
  },
  {
    "input": "Translate into first-order logic: Flu and influenza are the same disease.",
    "output": "∀x (Have(x, flu) ↔ Have(x, influenza))"
  },
  {
    "input": "Translate into first-order logic: Susan doesn't have influenza.",
    "output": "¬Have(susan, influenza)"
  },
  {
    "input": "Translate into first-order logic: James Cocks was a British lawyer.",
    "output": "British(james) ∧ Lawyer(james)"
  },
  {
    "input": "Translate into first-order logic: James Cocks was a Whig politician who sat in the House of Commons.",
    "output": "Whig(james) ∧ Politician(james) ∧ SatInHouseOfCommons(james)"
  },
  {
    "input": "Translate into first-order logic: A British is a European.",
    "output": "∀x (British(x) → European(x))"
  },
  {
    "input": "Translate into first-order logic: Any lawyer is familiar with laws.",
    "output": "∀x (Lawyer(x) → FamiliarWithLaws(x))"
  },
  {
    "input": "Translate into first-order logic: Some Whigs speak French.",
    "output": "∃x (Whig(x) ∧ SpeakFrench(x))"
  },
  {
    "input": "Translate into first-order logic: James Cocks was a British lawyer.",
    "output": "British(james) ∧ Lawyer(james)"
  },
  {
    "input": "Translate into first-order logic: James Cocks was a Whig politician who sat in the House of Commons.",
    "output": "Whig(james) ∧ Politician(james) ∧ SatInHouseOfCommons(james)"
  },
  {
    "input": "Translate into first-order logic: A British is a European.",
    "output": "∀x (British(x) → European(x))"
  },
  {
    "input": "Translate into first-order logic: Any lawyer is familiar with laws.",
    "output": "∀x (Lawyer(x) → FamiliarWithLaws(x))"
  },
  {
    "input": "Translate into first-order logic: Some Whigs speak French.",
    "output": "∃x (Whig(x) ∧ SpeakFrench(x))"
  },
  {
    "input": "Translate into first-order logic: James Cocks was a British lawyer.",
    "output": "British(james) ∧ Lawyer(james)"
  },
  {
    "input": "Translate into first-order logic: James Cocks was a Whig politician who sat in the House of Commons.",
    "output": "Whig(james) ∧ Politician(james) ∧ SatInHouseOfCommons(james)"
  },
  {
    "input": "Translate into first-order logic: A British is a European.",
    "output": "∀x (British(x) → European(x))"
  },
  {
    "input": "Translate into first-order logic: Any lawyer is familiar with laws.",
    "output": "∀x (Lawyer(x) → FamiliarWithLaws(x))"
  },
  {
    "input": "Translate into first-order logic: Some Whigs speak French.",
    "output": "∃x (Whig(x) ∧ SpeakFrench(x))"
  },
  {
    "input": "Translate into first-order logic: Beasts of Prey is either a fantasy novel or a science fiction novel.",
    "output": "Novel(beastsofprey) ∧ Fantasy(beastsofprey) ∨ ScienceFiction(beastsofprey)"
  },
  {
    "input": "Translate into first-order logic: Science fiction novels are not about mythological creatures",
    "output": "∀x ∀y (ScienceFiction(x) ∧ Mythological(y) ∧ Creature(y) → ¬About(x, y))"
  },
  {
    "input": "Translate into first-order logic: Beasts of Prey Is about a creature known as the Shetani.",
    "output": "About(beastsofprey, shetani) ∧ Creature(shetani)"
  },
  {
    "input": "Translate into first-order logic: Shetanis are mythological.",
    "output": "Mythological(shetani)"
  },
  {
    "input": "Translate into first-order logic: Beasts of Prey is either a fantasy novel or a science fiction novel.",
    "output": "Novel(beastsofprey) ∧ Fantasy(beastsofprey) ∨ ScienceFiction(beastsofprey)"
  },
  {
    "input": "Translate into first-order logic: Science fiction novels are not about mythological creatures",
    "output": "∀x ∀y (ScienceFiction(x) ∧ Mythological(y) ∧ Creature(y) → ¬About(x, y))"
  },
  {
    "input": "Translate into first-order logic: Beasts of Prey Is about a creature known as the Shetani.",
    "output": "About(beastsofprey, shetani) ∧ Creature(shetani)"
  },
  {
    "input": "Translate into first-order logic: Shetanis are mythological.",
    "output": "Mythological(shetani)"
  },
  {
    "input": "Translate into first-order logic: Beasts of Prey is either a fantasy novel or a science fiction novel.",
    "output": "Novel(beastsofprey) ∧ Fantasy(beastsofprey) ∨ ScienceFiction(beastsofprey)"
  },
  {
    "input": "Translate into first-order logic: Science fiction novels are not about mythological creatures",
    "output": "∀x ∀y (ScienceFiction(x) ∧ Mythological(y) ∧ Creature(y) → ¬About(x, y))"
  },
  {
    "input": "Translate into first-order logic: Beasts of Prey Is about a creature known as the Shetani.",
    "output": "About(beastsofprey, shetani) ∧ Creature(shetani)"
  },
  {
    "input": "Translate into first-order logic: Shetanis are mythological.",
    "output": "Mythological(shetani)"
  },
  {
    "input": "Translate into first-order logic: Odell is an English surname originating in Odell, Bedfordshire.",
    "output": "∀x (Odell(x) → Surname(x))"
  },
  {
    "input": "Translate into first-order logic: In some families Odell is spelled O'Dell, in a mistaken Irish adaptation.",
    "output": "∃x (Odell(x) ∧ SpelledODell(x))"
  },
  {
    "input": "Translate into first-order logic: Notable people with the surname include Amy Odell, Jack Odell, and Mats Odell.",
    "output": "Odell(amyOdell) ∧ NotablePeople(amyOdell) ∧ Odell(jackOdell) ∧ NotablePeople(jackOdell) ∧ Odell(matsOdell) ∧ NotablePeople(matsOdell)"
  },
  {
    "input": "Translate into first-order logic: Amy Odell is a British singer-songwriter.",
    "output": "British(amyOdell) ∧ Singer(amyOdell) ∧ SongWriter(amyOdell)"
  },
  {
    "input": "Translate into first-order logic: Jack Odell is an English toy inventor.",
    "output": "English(jackOdell) ∧ ToyInvertor(jackOdell)"
  },
  {
    "input": "Translate into first-order logic: Odell is an English surname originating in Odell, Bedfordshire.",
    "output": "∀x (Odell(x) → Surname(x))"
  },
  {
    "input": "Translate into first-order logic: In some families Odell is spelled O'Dell, in a mistaken Irish adaptation.",
    "output": "∃x (Odell(x) ∧ SpelledODell(x))"
  },
  {
    "input": "Translate into first-order logic: Notable people with the surname include Amy Odell, Jack Odell, and Mats Odell.",
    "output": "Odell(amyOdell) ∧ NotablePeople(amyOdell) ∧ Odell(jackOdell) ∧ NotablePeople(jackOdell) ∧ Odell(matsOdell) ∧ NotablePeople(matsOdell)"
  },
  {
    "input": "Translate into first-order logic: Amy Odell is a British singer-songwriter.",
    "output": "British(amyOdell) ∧ Singer(amyOdell) ∧ SongWriter(amyOdell)"
  },
  {
    "input": "Translate into first-order logic: Jack Odell is an English toy inventor.",
    "output": "English(jackOdell) ∧ ToyInvertor(jackOdell)"
  },
  {
    "input": "Translate into first-order logic: Odell is an English surname originating in Odell, Bedfordshire.",
    "output": "∀x (Odell(x) → Surname(x))"
  },
  {
    "input": "Translate into first-order logic: In some families Odell is spelled O'Dell, in a mistaken Irish adaptation.",
    "output": "∃x (Odell(x) ∧ SpelledODell(x))"
  },
  {
    "input": "Translate into first-order logic: Notable people with the surname include Amy Odell, Jack Odell, and Mats Odell.",
    "output": "Odell(amyOdell) ∧ NotablePeople(amyOdell) ∧ Odell(jackOdell) ∧ NotablePeople(jackOdell) ∧ Odell(matsOdell) ∧ NotablePeople(matsOdell)"
  },
  {
    "input": "Translate into first-order logic: Amy Odell is a British singer-songwriter.",
    "output": "British(amyOdell) ∧ Singer(amyOdell) ∧ SongWriter(amyOdell)"
  },
  {
    "input": "Translate into first-order logic: Jack Odell is an English toy inventor.",
    "output": "English(jackOdell) ∧ ToyInvertor(jackOdell)"
  },
  {
    "input": "Translate into first-order logic: Odell is an English surname originating in Odell, Bedfordshire.",
    "output": "∀x (Odell(x) → Surname(x))"
  },
  {
    "input": "Translate into first-order logic: In some families Odell is spelled O'Dell, in a mistaken Irish adaptation.",
    "output": "∃x (Odell(x) ∧ SpelledODell(x))"
  },
  {
    "input": "Translate into first-order logic: Notable people with the surname include Amy Odell, Jack Odell, and Mats Odell.",
    "output": "Odell(amyOdell) ∧ NotablePeople(amyOdell) ∧ Odell(jackOdell) ∧ NotablePeople(jackOdell) ∧ Odell(matsOdell) ∧ NotablePeople(matsOdell)"
  },
  {
    "input": "Translate into first-order logic: Amy Odell is a British singer-songwriter.",
    "output": "British(amyOdell) ∧ Singer(amyOdell) ∧ SongWriter(amyOdell)"
  },
  {
    "input": "Translate into first-order logic: Jack Odell is an English toy inventor.",
    "output": "English(jackOdell) ∧ ToyInvertor(jackOdell)"
  },
  {
    "input": "Translate into first-order logic: If you go somewhere by train, you will not lose time.",
    "output": "∀x (Train(x) → ¬LoseTime(x))"
  },
  {
    "input": "Translate into first-order logic: If you go somewhere by car and meet traffic jam, you will lose time.",
    "output": "∀x ((Car(x) ∧ MeetJam(x)) → LoseTime(x))"
  },
  {
    "input": "Translate into first-order logic: If you lose time, you will be late for work.",
    "output": "∀x (LoseTime(x) ↔ LateForWork(x))"
  },
  {
    "input": "Translate into first-order logic: Mary can get from New Haven to New York City either by train or car.",
    "output": "Train(mary) ⊕ Car(mary)"
  },
  {
    "input": "Translate into first-order logic: Mary is late for work.",
    "output": "LateForWork(mary)"
  },
  {
    "input": "Translate into first-order logic: If you go somewhere by train, you will not lose time.",
    "output": "∀x (Train(x) → ¬LoseTime(x))"
  },
  {
    "input": "Translate into first-order logic: If you go somewhere by car and meet traffic jam, you will lose time.",
    "output": "∀x ((Car(x) ∧ MeetJam(x)) → LoseTime(x))"
  },
  {
    "input": "Translate into first-order logic: If you lose time, you will be late for work.",
    "output": "∀x (LoseTime(x) ↔ LateForWork(x))"
  },
  {
    "input": "Translate into first-order logic: Mary can get from New Haven to New York City either by train or car.",
    "output": "Train(mary) ⊕ Car(mary)"
  },
  {
    "input": "Translate into first-order logic: Mary is late for work.",
    "output": "LateForWork(mary)"
  },
  {
    "input": "Translate into first-order logic: If you go somewhere by train, you will not lose time.",
    "output": "∀x (Train(x) → ¬LoseTime(x))"
  },
  {
    "input": "Translate into first-order logic: If you go somewhere by car and meet traffic jam, you will lose time.",
    "output": "∀x ((Car(x) ∧ MeetJam(x)) → LoseTime(x))"
  },
  {
    "input": "Translate into first-order logic: If you lose time, you will be late for work.",
    "output": "∀x (LoseTime(x) ↔ LateForWork(x))"
  },
  {
    "input": "Translate into first-order logic: Mary can get from New Haven to New York City either by train or car.",
    "output": "Train(mary) ⊕ Car(mary)"
  },
  {
    "input": "Translate into first-order logic: Mary is late for work.",
    "output": "LateForWork(mary)"
  },
  {
    "input": "Translate into first-order logic: If a person is hungry, the person is uncomfortable.",
    "output": "∀x (Hungry(x) → Uncomfortable(x))"
  },
  {
    "input": "Translate into first-order logic: If a person is uncomfortable, the person is unhappy.",
    "output": "∀x (Uncomfortable(x) → ¬Happy(x))"
  },
  {
    "input": "Translate into first-order logic: Tipped employees do not get a guaranteed minimum wage.",
    "output": "∀x (Tipped(x) → ¬GetMinWage(x))"
  },
  {
    "input": "Translate into first-order logic: If a person is a white-collar worker, they will get a guaranteed minimum wage (All white-collar workers get a guaranteed minimum wage).",
    "output": "∀x (WhiteCollar(x) → GetMinWage(x))"
  },
  {
    "input": "Translate into first-order logic: All lawyers are white-collar workers.",
    "output": "∀x (Lawyer(x) → WhiteCollar(x))"
  },
  {
    "input": "Translate into first-order logic: Every advocate is a lawyer.",
    "output": "∀x (Advocate(x) → Lawyer(x))"
  },
  {
    "input": "Translate into first-order logic: Mary is not a lawyer or a tipped employee.",
    "output": "¬Lawyer(mary) ⊕ Tipped(mary)"
  },
  {
    "input": "Translate into first-order logic: Tipped employees do not get a guaranteed minimum wage.",
    "output": "∀x (Tipped(x) → ¬GetMinWage(x))"
  },
  {
    "input": "Translate into first-order logic: If a person is a white-collar worker, they will get a guaranteed minimum wage (All white-collar workers get a guaranteed minimum wage).",
    "output": "∀x (WhiteCollar(x) → GetMinWage(x))"
  },
  {
    "input": "Translate into first-order logic: All lawyers are white-collar workers.",
    "output": "∀x (Lawyer(x) → WhiteCollar(x))"
  },
  {
    "input": "Translate into first-order logic: Every advocate is a lawyer.",
    "output": "∀x (Advocate(x) → Lawyer(x))"
  },
  {
    "input": "Translate into first-order logic: Mary is not a lawyer or a tipped employee.",
    "output": "¬Lawyer(mary) ⊕ Tipped(mary)"
  },
  {
    "input": "Translate into first-order logic: Tipped employees do not get a guaranteed minimum wage.",
    "output": "∀x (Tipped(x) → ¬GetMinWage(x))"
  },
  {
    "input": "Translate into first-order logic: If a person is a white-collar worker, they will get a guaranteed minimum wage (All white-collar workers get a guaranteed minimum wage).",
    "output": "∀x (WhiteCollar(x) → GetMinWage(x))"
  },
  {
    "input": "Translate into first-order logic: All lawyers are white-collar workers.",
    "output": "∀x (Lawyer(x) → WhiteCollar(x))"
  },
  {
    "input": "Translate into first-order logic: Every advocate is a lawyer.",
    "output": "∀x (Advocate(x) → Lawyer(x))"
  },
  {
    "input": "Translate into first-order logic: Mary is not a lawyer or a tipped employee.",
    "output": "¬Lawyer(mary) ⊕ Tipped(mary)"
  },
  {
    "input": "Translate into first-order logic: Tipped employees do not get a guaranteed minimum wage.",
    "output": "∀x (Tipped(x) → ¬GetMinWage(x))"
  },
  {
    "input": "Translate into first-order logic: If a person is a white-collar worker, they will get a guaranteed minimum wage (All white-collar workers get a guaranteed minimum wage).",
    "output": "∀x (WhiteCollar(x) → GetMinWage(x))"
  },
  {
    "input": "Translate into first-order logic: All lawyers are white-collar workers.",
    "output": "∀x (Lawyer(x) → WhiteCollar(x))"
  },
  {
    "input": "Translate into first-order logic: Every advocate is a lawyer.",
    "output": "∀x (Advocate(x) → Lawyer(x))"
  },
  {
    "input": "Translate into first-order logic: Mary is not a lawyer or a tipped employee.",
    "output": "¬Lawyer(mary) ⊕ Tipped(mary)"
  },
  {
    "input": "Translate into first-order logic: Tipped employees do not get a guaranteed minimum wage.",
    "output": "∀x (Tipped(x) → ¬GetMinWage(x))"
  },
  {
    "input": "Translate into first-order logic: If a person is a white-collar worker, they will get a guaranteed minimum wage (All white-collar workers get a guaranteed minimum wage).",
    "output": "∀x (WhiteCollar(x) → GetMinWage(x))"
  },
  {
    "input": "Translate into first-order logic: All lawyers are white-collar workers.",
    "output": "∀x (Lawyer(x) → WhiteCollar(x))"
  },
  {
    "input": "Translate into first-order logic: Every advocate is a lawyer.",
    "output": "∀x (Advocate(x) → Lawyer(x))"
  },
  {
    "input": "Translate into first-order logic: Mary is not a lawyer or a tipped employee.",
    "output": "¬Lawyer(mary) ⊕ Tipped(mary)"
  },
  {
    "input": "Translate into first-order logic: Tipped employees do not get a guaranteed minimum wage.",
    "output": "∀x (Tipped(x) → ¬GetMinWage(x))"
  },
  {
    "input": "Translate into first-order logic: If a person is a white-collar worker, they will get a guaranteed minimum wage (All white-collar workers get a guaranteed minimum wage).",
    "output": "∀x (WhiteCollar(x) → GetMinWage(x))"
  },
  {
    "input": "Translate into first-order logic: All lawyers are white-collar workers.",
    "output": "∀x (Lawyer(x) → WhiteCollar(x))"
  },
  {
    "input": "Translate into first-order logic: Every advocate is a lawyer.",
    "output": "∀x (Advocate(x) → Lawyer(x))"
  },
  {
    "input": "Translate into first-order logic: Mary is not a lawyer or a tipped employee.",
    "output": "¬Lawyer(mary) ⊕ Tipped(mary)"
  },
  {
    "input": "Translate into first-order logic: Asa Hoffmann was born in New York City.",
    "output": "BornIn(asaHoffmann, newyorkcity)"
  },
  {
    "input": "Translate into first-order logic: Asa Hoffman lives in Manhattan.",
    "output": "LivesIn(asaHoffmann, manhattan)"
  },
  {
    "input": "Translate into first-order logic: Asa Hoffman is a chess player.",
    "output": "IsChessPlayer(asaHoffmann)"
  },
  {
    "input": "Translate into first-order logic: Some chess players are grandmasters.",
    "output": "∃x (IsChestPlayer(x) ∧ IsGrandMaster(x))"
  },
  {
    "input": "Translate into first-order logic: People born and living in New York City are New Yorkers.",
    "output": "∀x (BornIn(x, newyorkcity) ∧ LivesIn(x, newyorkcity) → IsNewYorker(x))"
  },
  {
    "input": "Translate into first-order logic: People liviing in Manhattan live in New York City.",
    "output": "∀x (LivesIn(x, manhattan) → LivesIn(x, newyorkcity))"
  },
  {
    "input": "Translate into first-order logic: Asa Hoffmann was born in New York City.",
    "output": "BornIn(asaHoffmann, newyorkcity)"
  },
  {
    "input": "Translate into first-order logic: Asa Hoffman lives in Manhattan.",
    "output": "LivesIn(asaHoffmann, manhattan)"
  },
  {
    "input": "Translate into first-order logic: Asa Hoffman is a chess player.",
    "output": "IsChessPlayer(asaHoffmann)"
  },
  {
    "input": "Translate into first-order logic: Some chess players are grandmasters.",
    "output": "∃x (IsChestPlayer(x) ∧ IsGrandMaster(x))"
  },
  {
    "input": "Translate into first-order logic: People born and living in New York City are New Yorkers.",
    "output": "∀x (BornIn(x, newyorkcity) ∧ LivesIn(x, newyorkcity) → IsNewYorker(x))"
  },
  {
    "input": "Translate into first-order logic: People liviing in Manhattan live in New York City.",
    "output": "∀x (LivesIn(x, manhattan) → LivesIn(x, newyorkcity))"
  },
  {
    "input": "Translate into first-order logic: Asa Hoffmann was born in New York City.",
    "output": "BornIn(asaHoffmann, newyorkcity)"
  },
  {
    "input": "Translate into first-order logic: Asa Hoffman lives in Manhattan.",
    "output": "LivesIn(asaHoffmann, manhattan)"
  },
  {
    "input": "Translate into first-order logic: Asa Hoffman is a chess player.",
    "output": "IsChessPlayer(asaHoffmann)"
  },
  {
    "input": "Translate into first-order logic: Some chess players are grandmasters.",
    "output": "∃x (IsChestPlayer(x) ∧ IsGrandMaster(x))"
  },
  {
    "input": "Translate into first-order logic: People born and living in New York City are New Yorkers.",
    "output": "∀x (BornIn(x, newyorkcity) ∧ LivesIn(x, newyorkcity) → IsNewYorker(x))"
  },
  {
    "input": "Translate into first-order logic: People liviing in Manhattan live in New York City.",
    "output": "∀x (LivesIn(x, manhattan) → LivesIn(x, newyorkcity))"
  },
  {
    "input": "Translate into first-order logic: Some of those who apply for a Schengen Visa get it.",
    "output": "∃x (ApplyVisa(x) → GetVisa(x))"
  },
  {
    "input": "Translate into first-order logic: To apply for a Schengen Visa, you need to provide financial guarantees.",
    "output": "∀x (ApplyVisa(x) → FinancialGuarantees(x))"
  },
  {
    "input": "Translate into first-order logic: If you need to provide financial guarantees, you must request documents from the bank.",
    "output": "∀x (FinancialGuarantees(x) → RequestDocuments(x))"
  },
  {
    "input": "Translate into first-order logic: Do not close your bank account if you request documents from the bank.",
    "output": "∀x (RequestDocuments(x) → ¬CloseBankAccount(x))"
  },
  {
    "input": "Translate into first-order logic: Philip closed his bank account.",
    "output": "CloseBankAccount(philip)"
  },
  {
    "input": "Translate into first-order logic: Some of those who apply for a Schengen Visa get it.",
    "output": "∃x (ApplyVisa(x) → GetVisa(x))"
  },
  {
    "input": "Translate into first-order logic: To apply for a Schengen Visa, you need to provide financial guarantees.",
    "output": "∀x (ApplyVisa(x) → FinancialGuarantees(x))"
  },
  {
    "input": "Translate into first-order logic: If you need to provide financial guarantees, you must request documents from the bank.",
    "output": "∀x (FinancialGuarantees(x) → RequestDocuments(x))"
  },
  {
    "input": "Translate into first-order logic: Do not close your bank account if you request documents from the bank.",
    "output": "∀x (RequestDocuments(x) → ¬CloseBankAccount(x))"
  },
  {
    "input": "Translate into first-order logic: Philip closed his bank account.",
    "output": "CloseBankAccount(philip)"
  },
  {
    "input": "Translate into first-order logic: Some of those who apply for a Schengen Visa get it.",
    "output": "∃x (ApplyVisa(x) → GetVisa(x))"
  },
  {
    "input": "Translate into first-order logic: To apply for a Schengen Visa, you need to provide financial guarantees.",
    "output": "∀x (ApplyVisa(x) → FinancialGuarantees(x))"
  },
  {
    "input": "Translate into first-order logic: If you need to provide financial guarantees, you must request documents from the bank.",
    "output": "∀x (FinancialGuarantees(x) → RequestDocuments(x))"
  },
  {
    "input": "Translate into first-order logic: Do not close your bank account if you request documents from the bank.",
    "output": "∀x (RequestDocuments(x) → ¬CloseBankAccount(x))"
  },
  {
    "input": "Translate into first-order logic: Philip closed his bank account.",
    "output": "CloseBankAccount(philip)"
  },
  {
    "input": "Translate into first-order logic: Some fears lead to anxiety.",
    "output": "∃x (Fear(x) ∧ Anxiety(x))"
  },
  {
    "input": "Translate into first-order logic: Some anxiety leads to terror.",
    "output": "∃x (Anxiety(x) ∧ Terror(x))"
  },
  {
    "input": "Translate into first-order logic: The Great Lakes are Lake Superior, Lake Michigan, Lake Huron, Lake Erie, and Lake Ontario.",
    "output": "∀x (GreatLake(x) → Superior(x) ∨ Michigan(x) ∨ Huron(x) ∨ Erie(x) ∨ Ontario(x))"
  },
  {
    "input": "Translate into first-order logic: Some major settlements of Lake Erie are in NY, PA, OH, and MI.",
    "output": "∃x ∀y (Erie(y) ∧ MajorSettlementOf(x, y) ∧ In(x, ny) ∨ In(x, pa) ∨ In(x, oh) ∨ In(x, mi))"
  },
  {
    "input": "Translate into first-order logic: NY, PA, OH, MI are states in the US.",
    "output": "State(ny, us) ∧ State(pa, us) ∧ State(oh, us) ∧ State(mi, us)"
  },
  {
    "input": "Translate into first-order logic: ON is a state of Canada.",
    "output": "State(on, canada)"
  },
  {
    "input": "Translate into first-order logic: There is a major settlement of Lake Huron in ON.",
    "output": "∃x ∀y (Huron(y) ∧ MajorSettlementOf(x, y) ∧ In(x, on))"
  },
  {
    "input": "Translate into first-order logic: All states are in their country.",
    "output": "∀x ∀y (State(x, y) → In(x, y))"
  },
  {
    "input": "Translate into first-order logic: The US is in North America.",
    "output": "In(us, northamerica)"
  },
  {
    "input": "Translate into first-order logic: The Great Lakes began to form at the end of the Last Glacial Period.",
    "output": "∀x (GreatLake(x) → FormAtEndOf(x, lastglacialperiod))"
  },
  {
    "input": "Translate into first-order logic: The Great Lakes are Lake Superior, Lake Michigan, Lake Huron, Lake Erie, and Lake Ontario.",
    "output": "∀x (GreatLake(x) → Superior(x) ∨ Michigan(x) ∨ Huron(x) ∨ Erie(x) ∨ Ontario(x))"
  },
  {
    "input": "Translate into first-order logic: Some major settlements of Lake Erie are in NY, PA, OH, and MI.",
    "output": "∃x ∀y (Erie(y) ∧ MajorSettlementOf(x, y) ∧ In(x, ny) ∨ In(x, pa) ∨ In(x, oh) ∨ In(x, mi))"
  },
  {
    "input": "Translate into first-order logic: NY, PA, OH, MI are states in the US.",
    "output": "State(ny, us) ∧ State(pa, us) ∧ State(oh, us) ∧ State(mi, us)"
  },
  {
    "input": "Translate into first-order logic: ON is a state of Canada.",
    "output": "State(on, canada)"
  },
  {
    "input": "Translate into first-order logic: There is a major settlement of Lake Huron in ON.",
    "output": "∃x ∀y (Huron(y) ∧ MajorSettlementOf(x, y) ∧ In(x, on))"
  },
  {
    "input": "Translate into first-order logic: All states are in their country.",
    "output": "∀x ∀y (State(x, y) → In(x, y))"
  },
  {
    "input": "Translate into first-order logic: The US is in North America.",
    "output": "In(us, northamerica)"
  },
  {
    "input": "Translate into first-order logic: The Great Lakes began to form at the end of the Last Glacial Period.",
    "output": "∀x (GreatLake(x) → FormAtEndOf(x, lastglacialperiod))"
  },
  {
    "input": "Translate into first-order logic: All defenders are soccer players.",
    "output": "∀x (Defender(x) → SoccerPlayer(x))"
  },
  {
    "input": "Translate into first-order logic: No soccer players are professional basketball players.",
    "output": "∀x (SoccerPlayer(x) → ¬ProfessionalBasketballPlayer(x))"
  },
  {
    "input": "Translate into first-order logic: All centerbacks are defenders.",
    "output": "∀x (CenterBack(x) → Defender(x))"
  },
  {
    "input": "Translate into first-order logic: All NBA players are professional basketball players.",
    "output": "∀x (NBAPlayer(x) → ProfessionalBasketballPlayer(x))"
  },
  {
    "input": "Translate into first-order logic: If Stephen Curry is not an NBA player, then Stephen Curry is not an NBA player or a soccer player.",
    "output": "¬NBAPlayer(stephencurry) → ¬(NBAPlayer(stephencurry) ⊕ SoccerPlayer(stephencurry))"
  },
  {
    "input": "Translate into first-order logic: All defenders are soccer players.",
    "output": "∀x (Defender(x) → SoccerPlayer(x))"
  },
  {
    "input": "Translate into first-order logic: No soccer players are professional basketball players.",
    "output": "∀x (SoccerPlayer(x) → ¬ProfessionalBasketballPlayer(x))"
  },
  {
    "input": "Translate into first-order logic: All centerbacks are defenders.",
    "output": "∀x (CenterBack(x) → Defender(x))"
  },
  {
    "input": "Translate into first-order logic: All NBA players are professional basketball players.",
    "output": "∀x (NBAPlayer(x) → ProfessionalBasketballPlayer(x))"
  },
  {
    "input": "Translate into first-order logic: If Stephen Curry is not an NBA player, then Stephen Curry is not an NBA player or a soccer player.",
    "output": "¬NBAPlayer(stephencurry) → ¬(NBAPlayer(stephencurry) ⊕ SoccerPlayer(stephencurry))"
  },
  {
    "input": "Translate into first-order logic: All defenders are soccer players.",
    "output": "∀x (Defender(x) → SoccerPlayer(x))"
  },
  {
    "input": "Translate into first-order logic: No soccer players are professional basketball players.",
    "output": "∀x (SoccerPlayer(x) → ¬ProfessionalBasketballPlayer(x))"
  },
  {
    "input": "Translate into first-order logic: All centerbacks are defenders.",
    "output": "∀x (CenterBack(x) → Defender(x))"
  },
  {
    "input": "Translate into first-order logic: All NBA players are professional basketball players.",
    "output": "∀x (NBAPlayer(x) → ProfessionalBasketballPlayer(x))"
  },
  {
    "input": "Translate into first-order logic: If Stephen Curry is not an NBA player, then Stephen Curry is not an NBA player or a soccer player.",
    "output": "¬NBAPlayer(stephencurry) → ¬(NBAPlayer(stephencurry) ⊕ SoccerPlayer(stephencurry))"
  },
  {
    "input": "Translate into first-order logic: Naive cynicism was proposed by Justin Kruger and a colleague.",
    "output": "Proposed(justinKruger, naiveCynicism) ∧ Proposed(colleagueOfJustinKruger, naiveCynicism) "
  },
  {
    "input": "Translate into first-order logic: Thomas Gilovich is a colleague of Justin Kruger.",
    "output": "Colleague(thomasGilovich, justinKruger)"
  },
  {
    "input": "Translate into first-order logic: Naive cynicism is a philosophy of mind.",
    "output": "PhilosophyOfMind(naiveCynicism)"
  },
  {
    "input": "Translate into first-order logic: Naive cynicism was proposed by Justin Kruger and a colleague.",
    "output": "Proposed(justinKruger, naiveCynicism) ∧ Proposed(colleagueOfJustinKruger, naiveCynicism) "
  },
  {
    "input": "Translate into first-order logic: Thomas Gilovich is a colleague of Justin Kruger.",
    "output": "Colleague(thomasGilovich, justinKruger)"
  },
  {
    "input": "Translate into first-order logic: Naive cynicism is a philosophy of mind.",
    "output": "PhilosophyOfMind(naiveCynicism)"
  },
  {
    "input": "Translate into first-order logic: Naive cynicism was proposed by Justin Kruger and a colleague.",
    "output": "Proposed(justinKruger, naiveCynicism) ∧ Proposed(colleagueOfJustinKruger, naiveCynicism) "
  },
  {
    "input": "Translate into first-order logic: Thomas Gilovich is a colleague of Justin Kruger.",
    "output": "Colleague(thomasGilovich, justinKruger)"
  },
  {
    "input": "Translate into first-order logic: Naive cynicism is a philosophy of mind.",
    "output": "PhilosophyOfMind(naiveCynicism)"
  },
  {
    "input": "Translate into first-order logic: The Turing Award has been awarded to Donald Knuth, Marvin Minsky, Richard Hamming and John McCarthy.",
    "output": "TuringAwarded(donaldKnuth) ∧ TuringAwarded(marvinMinsky) ∧ TuringAwarded(richardHamming) ∧ TuringAwarded(johnMccarthy)"
  },
  {
    "input": "Translate into first-order logic: Donald Knuth made major contributions to the analysis of algorithms.",
    "output": "ContributedTo(donaldKnuth, algorithms)"
  },
  {
    "input": "Translate into first-order logic: Marvin Minsky is recognized by his contributions to the field of artificial intelligence.",
    "output": "ContributedTo(marvinMinsky, ai)"
  },
  {
    "input": "Translate into first-order logic: Richard Hamming did research on numerical methods.",
    "output": "ContributedTo(richardHamming, numericalMethods)"
  },
  {
    "input": "Translate into first-order logic: John McCarthy had a central role in creating and shaping the field of artificial inteligence.",
    "output": "ContributedTo(johnMccarthy, ai)"
  },
  {
    "input": "Translate into first-order logic: The Turing Award has been awarded to Donald Knuth, Marvin Minsky, Richard Hamming and John McCarthy.",
    "output": "TuringAwarded(donaldKnuth) ∧ TuringAwarded(marvinMinsky) ∧ TuringAwarded(richardHamming) ∧ TuringAwarded(johnMccarthy)"
  },
  {
    "input": "Translate into first-order logic: Donald Knuth made major contributions to the analysis of algorithms.",
    "output": "ContributedTo(donaldKnuth, algorithms)"
  },
  {
    "input": "Translate into first-order logic: Marvin Minsky is recognized by his contributions to the field of artificial intelligence.",
    "output": "ContributedTo(marvinMinsky, ai)"
  },
  {
    "input": "Translate into first-order logic: Richard Hamming did research on numerical methods.",
    "output": "ContributedTo(richardHamming, numericalMethods)"
  },
  {
    "input": "Translate into first-order logic: John McCarthy had a central role in creating and shaping the field of artificial inteligence.",
    "output": "ContributedTo(johnMccarthy, ai)"
  },
  {
    "input": "Translate into first-order logic: The Turing Award has been awarded to Donald Knuth, Marvin Minsky, Richard Hamming and John McCarthy.",
    "output": "TuringAwarded(donaldKnuth) ∧ TuringAwarded(marvinMinsky) ∧ TuringAwarded(richardHamming) ∧ TuringAwarded(johnMccarthy)"
  },
  {
    "input": "Translate into first-order logic: Donald Knuth made major contributions to the analysis of algorithms.",
    "output": "ContributedTo(donaldKnuth, algorithms)"
  },
  {
    "input": "Translate into first-order logic: Marvin Minsky is recognized by his contributions to the field of artificial intelligence.",
    "output": "ContributedTo(marvinMinsky, ai)"
  },
  {
    "input": "Translate into first-order logic: Richard Hamming did research on numerical methods.",
    "output": "ContributedTo(richardHamming, numericalMethods)"
  },
  {
    "input": "Translate into first-order logic: John McCarthy had a central role in creating and shaping the field of artificial inteligence.",
    "output": "ContributedTo(johnMccarthy, ai)"
  },
  {
    "input": "Translate into first-order logic: The Turing Award has been awarded to Donald Knuth, Marvin Minsky, Richard Hamming and John McCarthy.",
    "output": "TuringAwarded(donaldKnuth) ∧ TuringAwarded(marvinMinsky) ∧ TuringAwarded(richardHamming) ∧ TuringAwarded(johnMccarthy)"
  },
  {
    "input": "Translate into first-order logic: Donald Knuth made major contributions to the analysis of algorithms.",
    "output": "ContributedTo(donaldKnuth, algorithms)"
  },
  {
    "input": "Translate into first-order logic: Marvin Minsky is recognized by his contributions to the field of artificial intelligence.",
    "output": "ContributedTo(marvinMinsky, ai)"
  },
  {
    "input": "Translate into first-order logic: Richard Hamming did research on numerical methods.",
    "output": "ContributedTo(richardHamming, numericalMethods)"
  },
  {
    "input": "Translate into first-order logic: John McCarthy had a central role in creating and shaping the field of artificial inteligence.",
    "output": "ContributedTo(johnMccarthy, ai)"
  },
  {
    "input": "Translate into first-order logic: No easy Leetcode problems have an AC rate lower than 20 percent.",
    "output": "∀x (Easy(x) → ¬LowerAC(x))"
  },
  {
    "input": "Translate into first-order logic: All Leetcode problems recommended to novices are easy.",
    "output": "∀x (Recommended(x) → Easy(x))"
  },
  {
    "input": "Translate into first-order logic: Leetcode problems either have an AC rate lower than 20 percent or are starred by more than 1 thousand users.",
    "output": "∀x (LowerAC(x) ⊕ Starred(x))"
  },
  {
    "input": "Translate into first-order logic: All hard Leetcode problems are starred by more than 1 thousand users.",
    "output": "∀x (Hard(x) → Starred(x))"
  },
  {
    "input": "Translate into first-order logic: No Leetcode problems published after 2022 are starred by more than 1 thousand users.",
    "output": "∀x (PublishedAfter2022(x) → ¬Starred(x))"
  },
  {
    "input": "Translate into first-order logic: 2Sum is not recommended to novices and hard.",
    "output": "¬(Recommended(twosum) ∧ Hard(twosum))"
  },
  {
    "input": "Translate into first-order logic: 4Sum is either starred by more than 1 thousand users and published after 2022, or neither starred by more than 1 thousand users nor published after 2022.",
    "output": "¬(Starred(foursum) ⊕ PublishedAfter2022(foursum))"
  },
  {
    "input": "Translate into first-order logic: No easy Leetcode problems have an AC rate lower than 20 percent.",
    "output": "∀x (Easy(x) → ¬LowerAC(x))"
  },
  {
    "input": "Translate into first-order logic: All Leetcode problems recommended to novices are easy.",
    "output": "∀x (Recommended(x) → Easy(x))"
  },
  {
    "input": "Translate into first-order logic: Leetcode problems either have an AC rate lower than 20 percent or are starred by more than 1 thousand users.",
    "output": "∀x (LowerAC(x) ⊕ Starred(x))"
  },
  {
    "input": "Translate into first-order logic: All hard Leetcode problems are starred by more than 1 thousand users.",
    "output": "∀x (Hard(x) → Starred(x))"
  },
  {
    "input": "Translate into first-order logic: No Leetcode problems published after 2022 are starred by more than 1 thousand users.",
    "output": "∀x (PublishedAfter2022(x) → ¬Starred(x))"
  },
  {
    "input": "Translate into first-order logic: 2Sum is not recommended to novices and hard.",
    "output": "¬(Recommended(twosum) ∧ Hard(twosum))"
  },
  {
    "input": "Translate into first-order logic: 4Sum is either starred by more than 1 thousand users and published after 2022, or neither starred by more than 1 thousand users nor published after 2022.",
    "output": "¬(Starred(foursum) ⊕ PublishedAfter2022(foursum))"
  },
  {
    "input": "Translate into first-order logic: No easy Leetcode problems have an AC rate lower than 20 percent.",
    "output": "∀x (Easy(x) → ¬LowerAC(x))"
  },
  {
    "input": "Translate into first-order logic: All Leetcode problems recommended to novices are easy.",
    "output": "∀x (Recommended(x) → Easy(x))"
  },
  {
    "input": "Translate into first-order logic: Leetcode problems either have an AC rate lower than 20 percent or are starred by more than 1 thousand users.",
    "output": "∀x (LowerAC(x) ⊕ Starred(x))"
  },
  {
    "input": "Translate into first-order logic: All hard Leetcode problems are starred by more than 1 thousand users.",
    "output": "∀x (Hard(x) → Starred(x))"
  },
  {
    "input": "Translate into first-order logic: No Leetcode problems published after 2022 are starred by more than 1 thousand users.",
    "output": "∀x (PublishedAfter2022(x) → ¬Starred(x))"
  },
  {
    "input": "Translate into first-order logic: 2Sum is not recommended to novices and hard.",
    "output": "¬(Recommended(twosum) ∧ Hard(twosum))"
  },
  {
    "input": "Translate into first-order logic: 4Sum is either starred by more than 1 thousand users and published after 2022, or neither starred by more than 1 thousand users nor published after 2022.",
    "output": "¬(Starred(foursum) ⊕ PublishedAfter2022(foursum))"
  },
  {
    "input": "Translate into first-order logic: No easy Leetcode problems have an AC rate lower than 20 percent.",
    "output": "∀x (Easy(x) → ¬LowerAC(x))"
  },
  {
    "input": "Translate into first-order logic: All Leetcode problems recommended to novices are easy.",
    "output": "∀x (Recommended(x) → Easy(x))"
  },
  {
    "input": "Translate into first-order logic: Leetcode problems either have an AC rate lower than 20 percent or are starred by more than 1 thousand users.",
    "output": "∀x (LowerAC(x) ⊕ Starred(x))"
  },
  {
    "input": "Translate into first-order logic: All hard Leetcode problems are starred by more than 1 thousand users.",
    "output": "∀x (Hard(x) → Starred(x))"
  },
  {
    "input": "Translate into first-order logic: No Leetcode problems published after 2022 are starred by more than 1 thousand users.",
    "output": "∀x (PublishedAfter2022(x) → ¬Starred(x))"
  },
  {
    "input": "Translate into first-order logic: 2Sum is not recommended to novices and hard.",
    "output": "¬(Recommended(twosum) ∧ Hard(twosum))"
  },
  {
    "input": "Translate into first-order logic: 4Sum is either starred by more than 1 thousand users and published after 2022, or neither starred by more than 1 thousand users nor published after 2022.",
    "output": "¬(Starred(foursum) ⊕ PublishedAfter2022(foursum))"
  },
  {
    "input": "Translate into first-order logic: Show Your Love is a song recorded by the South Korean boy band BtoB 4u.",
    "output": "Song(showyourlove) ∧ RecordedBy(showyourlove, btob4u) ∧ SouthKorean(btob4u) ∧ BoyBand(btob4u)"
  },
  {
    "input": "Translate into first-order logic: The lead single of the extended play Inside is Show Your Love.",
    "output": "ExtendedPlay(inside) ∧ LeadSingle(showyourlove) ∧ LeadSingleOf(showyourlove, inside)"
  },
  {
    "input": "Translate into first-order logic: Show Your Love contains a hopeful message.",
    "output": "Contains(showyourlove, hopefulmessage)"
  },
  {
    "input": "Translate into first-order logic: BtoB 4u member Hyunsik wrote Show Your Love.",
    "output": "Member(hyunsik, btob4u) ∧ Wrote(hyunsik, showyourlove)"
  },
  {
    "input": "Translate into first-order logic: There is a music video for Show Your Love.",
    "output": "HasMusicVideo(showyourlove)"
  },
  {
    "input": "Translate into first-order logic: Show Your Love is a song recorded by the South Korean boy band BtoB 4u.",
    "output": "Song(showyourlove) ∧ RecordedBy(showyourlove, btob4u) ∧ SouthKorean(btob4u) ∧ BoyBand(btob4u)"
  },
  {
    "input": "Translate into first-order logic: The lead single of the extended play Inside is Show Your Love.",
    "output": "ExtendedPlay(inside) ∧ LeadSingle(showyourlove) ∧ LeadSingleOf(showyourlove, inside)"
  },
  {
    "input": "Translate into first-order logic: Show Your Love contains a hopeful message.",
    "output": "Contains(showyourlove, hopefulmessage)"
  },
  {
    "input": "Translate into first-order logic: BtoB 4u member Hyunsik wrote Show Your Love.",
    "output": "Member(hyunsik, btob4u) ∧ Wrote(hyunsik, showyourlove)"
  },
  {
    "input": "Translate into first-order logic: There is a music video for Show Your Love.",
    "output": "HasMusicVideo(showyourlove)"
  },
  {
    "input": "Translate into first-order logic: Show Your Love is a song recorded by the South Korean boy band BtoB 4u.",
    "output": "Song(showyourlove) ∧ RecordedBy(showyourlove, btob4u) ∧ SouthKorean(btob4u) ∧ BoyBand(btob4u)"
  },
  {
    "input": "Translate into first-order logic: The lead single of the extended play Inside is Show Your Love.",
    "output": "ExtendedPlay(inside) ∧ LeadSingle(showyourlove) ∧ LeadSingleOf(showyourlove, inside)"
  },
  {
    "input": "Translate into first-order logic: Show Your Love contains a hopeful message.",
    "output": "Contains(showyourlove, hopefulmessage)"
  },
  {
    "input": "Translate into first-order logic: BtoB 4u member Hyunsik wrote Show Your Love.",
    "output": "Member(hyunsik, btob4u) ∧ Wrote(hyunsik, showyourlove)"
  },
  {
    "input": "Translate into first-order logic: There is a music video for Show Your Love.",
    "output": "HasMusicVideo(showyourlove)"
  },
  {
    "input": "Translate into first-order logic: All tables are round.",
    "output": "∀x (Table(x) → Round(x))"
  },
  {
    "input": "Translate into first-order logic: Some furniture are tables.",
    "output": "∃x (Furniture(x) ∧ Table(x))"
  },
  {
    "input": "Translate into first-order logic: All juvenile delinquents are maladjusted individuals.",
    "output": "∀x (JuvenileDelinquent(x) → MaladjustedIndividual(x))"
  },
  {
    "input": "Translate into first-order logic: Some juvenile delinquents are products of broken homes.",
    "output": "∃x (JuvenileDelinquent(x)  ∧ ProductOfBrokenHome(x))"
  },
  {
    "input": "Translate into first-order logic: Either brain reading or brain decoding.",
    "output": "∀x (BrainReading(x) ∨ BrainDecoding(x)) "
  },
  {
    "input": "Translate into first-order logic: All brain decoding is extracting information from BOLD signals.",
    "output": "∀x (BrainDecoding(x) → ExtractingInformationFromBOLDSignals(x))"
  },
  {
    "input": "Translate into first-order logic: No extracting information from BOLD signals is without statistical pattern analysis.",
    "output": "∀x (ExtractingInformationFromBOLDSignals(x) → ¬WithoutStatisticalPatternAnalysis(x))"
  },
  {
    "input": "Translate into first-order logic: Writing a novel is without statistical pattern analysis.",
    "output": "∀x (WritingANovel(x) → WithoutStatisticalPatternAnalysis(x)) "
  },
  {
    "input": "Translate into first-order logic: If multivoxel (pattern) analysis is without statistical pattern analysis and a brain reading, then multivoxel (pattern) analysis is without statistical pattern analysis and brain decoding.",
    "output": "WithoutStatisticalPatternAnalysis(multivoxelPatternAnalysis) ∧ BrainReading(multivoxelPatternAnalysis) → WithoutStatisticalPatternAnalysis(multivoxelPatternAnalysis) ∧ BrainDecoding(multivoxelPatternAnalysis)"
  },
  {
    "input": "Translate into first-order logic: Either brain reading or brain decoding.",
    "output": "∀x (BrainReading(x) ∨ BrainDecoding(x)) "
  },
  {
    "input": "Translate into first-order logic: All brain decoding is extracting information from BOLD signals.",
    "output": "∀x (BrainDecoding(x) → ExtractingInformationFromBOLDSignals(x))"
  },
  {
    "input": "Translate into first-order logic: No extracting information from BOLD signals is without statistical pattern analysis.",
    "output": "∀x (ExtractingInformationFromBOLDSignals(x) → ¬WithoutStatisticalPatternAnalysis(x))"
  },
  {
    "input": "Translate into first-order logic: Writing a novel is without statistical pattern analysis.",
    "output": "∀x (WritingANovel(x) → WithoutStatisticalPatternAnalysis(x)) "
  },
  {
    "input": "Translate into first-order logic: If multivoxel (pattern) analysis is without statistical pattern analysis and a brain reading, then multivoxel (pattern) analysis is without statistical pattern analysis and brain decoding.",
    "output": "WithoutStatisticalPatternAnalysis(multivoxelPatternAnalysis) ∧ BrainReading(multivoxelPatternAnalysis) → WithoutStatisticalPatternAnalysis(multivoxelPatternAnalysis) ∧ BrainDecoding(multivoxelPatternAnalysis)"
  },
  {
    "input": "Translate into first-order logic: Either brain reading or brain decoding.",
    "output": "∀x (BrainReading(x) ∨ BrainDecoding(x)) "
  },
  {
    "input": "Translate into first-order logic: All brain decoding is extracting information from BOLD signals.",
    "output": "∀x (BrainDecoding(x) → ExtractingInformationFromBOLDSignals(x))"
  },
  {
    "input": "Translate into first-order logic: No extracting information from BOLD signals is without statistical pattern analysis.",
    "output": "∀x (ExtractingInformationFromBOLDSignals(x) → ¬WithoutStatisticalPatternAnalysis(x))"
  },
  {
    "input": "Translate into first-order logic: Writing a novel is without statistical pattern analysis.",
    "output": "∀x (WritingANovel(x) → WithoutStatisticalPatternAnalysis(x)) "
  },
  {
    "input": "Translate into first-order logic: If multivoxel (pattern) analysis is without statistical pattern analysis and a brain reading, then multivoxel (pattern) analysis is without statistical pattern analysis and brain decoding.",
    "output": "WithoutStatisticalPatternAnalysis(multivoxelPatternAnalysis) ∧ BrainReading(multivoxelPatternAnalysis) → WithoutStatisticalPatternAnalysis(multivoxelPatternAnalysis) ∧ BrainDecoding(multivoxelPatternAnalysis)"
  },
  {
    "input": "Translate into first-order logic: Either brain reading or brain decoding.",
    "output": "∀x (BrainReading(x) ∨ BrainDecoding(x)) "
  },
  {
    "input": "Translate into first-order logic: All brain decoding is extracting information from BOLD signals.",
    "output": "∀x (BrainDecoding(x) → ExtractingInformationFromBOLDSignals(x))"
  },
  {
    "input": "Translate into first-order logic: No extracting information from BOLD signals is without statistical pattern analysis.",
    "output": "∀x (ExtractingInformationFromBOLDSignals(x) → ¬WithoutStatisticalPatternAnalysis(x))"
  },
  {
    "input": "Translate into first-order logic: Writing a novel is without statistical pattern analysis.",
    "output": "∀x (WritingANovel(x) → WithoutStatisticalPatternAnalysis(x)) "
  },
  {
    "input": "Translate into first-order logic: If multivoxel (pattern) analysis is without statistical pattern analysis and a brain reading, then multivoxel (pattern) analysis is without statistical pattern analysis and brain decoding.",
    "output": "WithoutStatisticalPatternAnalysis(multivoxelPatternAnalysis) ∧ BrainReading(multivoxelPatternAnalysis) → WithoutStatisticalPatternAnalysis(multivoxelPatternAnalysis) ∧ BrainDecoding(multivoxelPatternAnalysis)"
  },
  {
    "input": "Translate into first-order logic: Either brain reading or brain decoding.",
    "output": "∀x (BrainReading(x) ∨ BrainDecoding(x)) "
  },
  {
    "input": "Translate into first-order logic: All brain decoding is extracting information from BOLD signals.",
    "output": "∀x (BrainDecoding(x) → ExtractingInformationFromBOLDSignals(x))"
  },
  {
    "input": "Translate into first-order logic: No extracting information from BOLD signals is without statistical pattern analysis.",
    "output": "∀x (ExtractingInformationFromBOLDSignals(x) → ¬WithoutStatisticalPatternAnalysis(x))"
  },
  {
    "input": "Translate into first-order logic: Writing a novel is without statistical pattern analysis.",
    "output": "∀x (WritingANovel(x) → WithoutStatisticalPatternAnalysis(x)) "
  },
  {
    "input": "Translate into first-order logic: If multivoxel (pattern) analysis is without statistical pattern analysis and a brain reading, then multivoxel (pattern) analysis is without statistical pattern analysis and brain decoding.",
    "output": "WithoutStatisticalPatternAnalysis(multivoxelPatternAnalysis) ∧ BrainReading(multivoxelPatternAnalysis) → WithoutStatisticalPatternAnalysis(multivoxelPatternAnalysis) ∧ BrainDecoding(multivoxelPatternAnalysis)"
  },
  {
    "input": "Translate into first-order logic: Either brain reading or brain decoding.",
    "output": "∀x (BrainReading(x) ∨ BrainDecoding(x)) "
  },
  {
    "input": "Translate into first-order logic: All brain decoding is extracting information from BOLD signals.",
    "output": "∀x (BrainDecoding(x) → ExtractingInformationFromBOLDSignals(x))"
  },
  {
    "input": "Translate into first-order logic: No extracting information from BOLD signals is without statistical pattern analysis.",
    "output": "∀x (ExtractingInformationFromBOLDSignals(x) → ¬WithoutStatisticalPatternAnalysis(x))"
  },
  {
    "input": "Translate into first-order logic: Writing a novel is without statistical pattern analysis.",
    "output": "∀x (WritingANovel(x) → WithoutStatisticalPatternAnalysis(x)) "
  },
  {
    "input": "Translate into first-order logic: If multivoxel (pattern) analysis is without statistical pattern analysis and a brain reading, then multivoxel (pattern) analysis is without statistical pattern analysis and brain decoding.",
    "output": "WithoutStatisticalPatternAnalysis(multivoxelPatternAnalysis) ∧ BrainReading(multivoxelPatternAnalysis) → WithoutStatisticalPatternAnalysis(multivoxelPatternAnalysis) ∧ BrainDecoding(multivoxelPatternAnalysis)"
  },
  {
    "input": "Translate into first-order logic: If you have room for dessert, you have room for broccoli.",
    "output": "∀x (RoomFor(x, dessert) → RoomFor(x, broccoli))"
  },
  {
    "input": "Translate into first-order logic: Everyone at Luis's dinner party has room for dessert, including Luis.",
    "output": "∀x (AtLuisParty(x) → RoomFor(x, dessert))"
  },
  {
    "input": "Translate into first-order logic: Mauricia does not have room for broccoli.",
    "output": "¬RoomFor(mauricia, broccoli)"
  },
  {
    "input": "Translate into first-order logic: Luis's dinner party is the first ever dinner party that Allison has attended.",
    "output": "FirstDinnerParty(allison, luisparty) ∧ AtLuisParty(allison)"
  },
  {
    "input": "Translate into first-order logic: Gustave has room for both broccoli and asparagus.",
    "output": "RoomFor(gustave, broccoli) ∧ RoomFor(gustave, asparagus)"
  },
  {
    "input": "Translate into first-order logic: Broccoli and asparagus are both vegetables.",
    "output": "Vegetable(broccoli) ∧ Vegetable(asparagus)"
  },
  {
    "input": "Translate into first-order logic: If you have room for dessert, you have room for broccoli.",
    "output": "∀x (RoomFor(x, dessert) → RoomFor(x, broccoli))"
  },
  {
    "input": "Translate into first-order logic: Everyone at Luis's dinner party has room for dessert, including Luis.",
    "output": "∀x (AtLuisParty(x) → RoomFor(x, dessert))"
  },
  {
    "input": "Translate into first-order logic: Mauricia does not have room for broccoli.",
    "output": "¬RoomFor(mauricia, broccoli)"
  },
  {
    "input": "Translate into first-order logic: Luis's dinner party is the first ever dinner party that Allison has attended.",
    "output": "FirstDinnerParty(allison, luisparty) ∧ AtLuisParty(allison)"
  },
  {
    "input": "Translate into first-order logic: Gustave has room for both broccoli and asparagus.",
    "output": "RoomFor(gustave, broccoli) ∧ RoomFor(gustave, asparagus)"
  },
  {
    "input": "Translate into first-order logic: Broccoli and asparagus are both vegetables.",
    "output": "Vegetable(broccoli) ∧ Vegetable(asparagus)"
  },
  {
    "input": "Translate into first-order logic: If you have room for dessert, you have room for broccoli.",
    "output": "∀x (RoomFor(x, dessert) → RoomFor(x, broccoli))"
  },
  {
    "input": "Translate into first-order logic: Everyone at Luis's dinner party has room for dessert, including Luis.",
    "output": "∀x (AtLuisParty(x) → RoomFor(x, dessert))"
  },
  {
    "input": "Translate into first-order logic: Mauricia does not have room for broccoli.",
    "output": "¬RoomFor(mauricia, broccoli)"
  },
  {
    "input": "Translate into first-order logic: Luis's dinner party is the first ever dinner party that Allison has attended.",
    "output": "FirstDinnerParty(allison, luisparty) ∧ AtLuisParty(allison)"
  },
  {
    "input": "Translate into first-order logic: Gustave has room for both broccoli and asparagus.",
    "output": "RoomFor(gustave, broccoli) ∧ RoomFor(gustave, asparagus)"
  },
  {
    "input": "Translate into first-order logic: Broccoli and asparagus are both vegetables.",
    "output": "Vegetable(broccoli) ∧ Vegetable(asparagus)"
  },
  {
    "input": "Translate into first-order logic: Imagine Dragons is an American pop rock band.",
    "output": "American(imagineDragon) ∧ RockBand(imagineDragon)"
  },
  {
    "input": "Translate into first-order logic: The lead singer of Imagine Dragons is Dan.",
    "output": "LeadSinger(imagineDragon, dan)"
  },
  {
    "input": "Translate into first-order logic: Dan is also a songwriter.",
    "output": "SongWriter(dan)"
  },
  {
    "input": "Translate into first-order logic: All lead singers are singers.",
    "output": "∀x ∀y (LeadSinger(x, y) → Singer(y))"
  },
  {
    "input": "Translate into first-order logic: All singers are musicians.",
    "output": "∀x (Singer(x) → Musician(x))"
  },
  {
    "input": "Translate into first-order logic: Demons is one of the most popular singles of Imagine Dragons.",
    "output": "PopularSingle(imagineDragon, demons)"
  },
  {
    "input": "Translate into first-order logic: Some singles of Imagine Dragons have been on Billboard Hot 100.",
    "output": "∃x (PopularSingle(imagineDragon, x) ∧ BillboardHot100(x))"
  },
  {
    "input": "Translate into first-order logic: Imagine Dragons is an American pop rock band.",
    "output": "American(imagineDragon) ∧ RockBand(imagineDragon)"
  },
  {
    "input": "Translate into first-order logic: The lead singer of Imagine Dragons is Dan.",
    "output": "LeadSinger(imagineDragon, dan)"
  },
  {
    "input": "Translate into first-order logic: Dan is also a songwriter.",
    "output": "SongWriter(dan)"
  },
  {
    "input": "Translate into first-order logic: All lead singers are singers.",
    "output": "∀x ∀y (LeadSinger(x, y) → Singer(y))"
  },
  {
    "input": "Translate into first-order logic: All singers are musicians.",
    "output": "∀x (Singer(x) → Musician(x))"
  },
  {
    "input": "Translate into first-order logic: Demons is one of the most popular singles of Imagine Dragons.",
    "output": "PopularSingle(imagineDragon, demons)"
  },
  {
    "input": "Translate into first-order logic: Some singles of Imagine Dragons have been on Billboard Hot 100.",
    "output": "∃x (PopularSingle(imagineDragon, x) ∧ BillboardHot100(x))"
  },
  {
    "input": "Translate into first-order logic: Imagine Dragons is an American pop rock band.",
    "output": "American(imagineDragon) ∧ RockBand(imagineDragon)"
  },
  {
    "input": "Translate into first-order logic: The lead singer of Imagine Dragons is Dan.",
    "output": "LeadSinger(imagineDragon, dan)"
  },
  {
    "input": "Translate into first-order logic: Dan is also a songwriter.",
    "output": "SongWriter(dan)"
  },
  {
    "input": "Translate into first-order logic: All lead singers are singers.",
    "output": "∀x ∀y (LeadSinger(x, y) → Singer(y))"
  },
  {
    "input": "Translate into first-order logic: All singers are musicians.",
    "output": "∀x (Singer(x) → Musician(x))"
  },
  {
    "input": "Translate into first-order logic: Demons is one of the most popular singles of Imagine Dragons.",
    "output": "PopularSingle(imagineDragon, demons)"
  },
  {
    "input": "Translate into first-order logic: Some singles of Imagine Dragons have been on Billboard Hot 100.",
    "output": "∃x (PopularSingle(imagineDragon, x) ∧ BillboardHot100(x))"
  },
  {
    "input": "Translate into first-order logic: All bread is food.",
    "output": "∀x (Bread(x) → Food(x))"
  },
  {
    "input": "Translate into first-order logic: Some sandwiches are bread.",
    "output": "∃x (Sandwich(x) ∧ Bread(x))"
  },
  {
    "input": "Translate into first-order logic: All food is edible.",
    "output": "∀x (Food(x) → Edible(x))"
  },
  {
    "input": "Translate into first-order logic: No edible things are poisonous.",
    "output": "∀x (Edible(x) → ¬Poisonous(x))"
  },
  {
    "input": "Translate into first-order logic: Deodorant is poisonous.",
    "output": "Poisonous(deodorant)"
  },
  {
    "input": "Translate into first-order logic: All bread is food.",
    "output": "∀x (Bread(x) → Food(x))"
  },
  {
    "input": "Translate into first-order logic: Some sandwiches are bread.",
    "output": "∃x (Sandwich(x) ∧ Bread(x))"
  },
  {
    "input": "Translate into first-order logic: All food is edible.",
    "output": "∀x (Food(x) → Edible(x))"
  },
  {
    "input": "Translate into first-order logic: No edible things are poisonous.",
    "output": "∀x (Edible(x) → ¬Poisonous(x))"
  },
  {
    "input": "Translate into first-order logic: Deodorant is poisonous.",
    "output": "Poisonous(deodorant)"
  },
  {
    "input": "Translate into first-order logic: All bread is food.",
    "output": "∀x (Bread(x) → Food(x))"
  },
  {
    "input": "Translate into first-order logic: Some sandwiches are bread.",
    "output": "∃x (Sandwich(x) ∧ Bread(x))"
  },
  {
    "input": "Translate into first-order logic: All food is edible.",
    "output": "∀x (Food(x) → Edible(x))"
  },
  {
    "input": "Translate into first-order logic: No edible things are poisonous.",
    "output": "∀x (Edible(x) → ¬Poisonous(x))"
  },
  {
    "input": "Translate into first-order logic: Deodorant is poisonous.",
    "output": "Poisonous(deodorant)"
  },
  {
    "input": "Translate into first-order logic: Common utilities include water, electricity, gas, heating, sewer, trash, and recycling.",
    "output": "CommonUtilities(water) ∧ CommonUtilities(electricity) ∧ CommonUtilities(gas) ∧ CommonUtilities(heating)"
  },
  {
    "input": "Translate into first-order logic: Many apartment rents cover the cost of water and electricity.",
    "output": "∃x (Cover(x, water) ∧ Cover(x, electricity))"
  },
  {
    "input": "Translate into first-order logic: Susan lives in an apartment where the rent covers all utilities.",
    "output": "∀x (Cover(susan, x))"
  },
  {
    "input": "Translate into first-order logic: The rent of the apartment where Ava lives does not cover any utility expenses.",
    "output": "∀x (¬Cover(ava, x))"
  },
  {
    "input": "Translate into first-order logic: Noah lives in an apartment where the rent does not cover heating.",
    "output": "¬Cover(noah, heating)"
  },
  {
    "input": "Translate into first-order logic: Common utilities include water, electricity, gas, heating, sewer, trash, and recycling.",
    "output": "CommonUtilities(water) ∧ CommonUtilities(electricity) ∧ CommonUtilities(gas) ∧ CommonUtilities(heating)"
  },
  {
    "input": "Translate into first-order logic: Many apartment rents cover the cost of water and electricity.",
    "output": "∃x (Cover(x, water) ∧ Cover(x, electricity))"
  },
  {
    "input": "Translate into first-order logic: Susan lives in an apartment where the rent covers all utilities.",
    "output": "∀x (Cover(susan, x))"
  },
  {
    "input": "Translate into first-order logic: The rent of the apartment where Ava lives does not cover any utility expenses.",
    "output": "∀x (¬Cover(ava, x))"
  },
  {
    "input": "Translate into first-order logic: Noah lives in an apartment where the rent does not cover heating.",
    "output": "¬Cover(noah, heating)"
  },
  {
    "input": "Translate into first-order logic: Common utilities include water, electricity, gas, heating, sewer, trash, and recycling.",
    "output": "CommonUtilities(water) ∧ CommonUtilities(electricity) ∧ CommonUtilities(gas) ∧ CommonUtilities(heating)"
  },
  {
    "input": "Translate into first-order logic: Many apartment rents cover the cost of water and electricity.",
    "output": "∃x (Cover(x, water) ∧ Cover(x, electricity))"
  },
  {
    "input": "Translate into first-order logic: Susan lives in an apartment where the rent covers all utilities.",
    "output": "∀x (Cover(susan, x))"
  },
  {
    "input": "Translate into first-order logic: The rent of the apartment where Ava lives does not cover any utility expenses.",
    "output": "∀x (¬Cover(ava, x))"
  },
  {
    "input": "Translate into first-order logic: Noah lives in an apartment where the rent does not cover heating.",
    "output": "¬Cover(noah, heating)"
  },
  {
    "input": "Translate into first-order logic: All clothes are products.",
    "output": "∀x (Clothes(x) → Product(x))"
  },
  {
    "input": "Translate into first-order logic: No products are perfect.",
    "output": "∀x (Product(x) → ¬Perfect(x))"
  },
  {
    "input": "Translate into first-order logic: All dresses are clothes.",
    "output": "∀x (Dress(x) → Clothes(x))"
  },
  {
    "input": "Translate into first-order logic: All skirts are dresses.",
    "output": "∀x (Skirt(x) → Dress(x))"
  },
  {
    "input": "Translate into first-order logic: If Nike is clothes, then Nike is perfect and a dress.",
    "output": "Clothes(nike) → Perfect(nike) ∧ Dress(nike)"
  },
  {
    "input": "Translate into first-order logic: All clothes are products.",
    "output": "∀x (Clothes(x) → Product(x))"
  },
  {
    "input": "Translate into first-order logic: No products are perfect.",
    "output": "∀x (Product(x) → ¬Perfect(x))"
  },
  {
    "input": "Translate into first-order logic: All dresses are clothes.",
    "output": "∀x (Dress(x) → Clothes(x))"
  },
  {
    "input": "Translate into first-order logic: All skirts are dresses.",
    "output": "∀x (Skirt(x) → Dress(x))"
  },
  {
    "input": "Translate into first-order logic: If Nike is clothes, then Nike is perfect and a dress.",
    "output": "Clothes(nike) → Perfect(nike) ∧ Dress(nike)"
  },
  {
    "input": "Translate into first-order logic: All clothes are products.",
    "output": "∀x (Clothes(x) → Product(x))"
  },
  {
    "input": "Translate into first-order logic: No products are perfect.",
    "output": "∀x (Product(x) → ¬Perfect(x))"
  },
  {
    "input": "Translate into first-order logic: All dresses are clothes.",
    "output": "∀x (Dress(x) → Clothes(x))"
  },
  {
    "input": "Translate into first-order logic: All skirts are dresses.",
    "output": "∀x (Skirt(x) → Dress(x))"
  },
  {
    "input": "Translate into first-order logic: If Nike is clothes, then Nike is perfect and a dress.",
    "output": "Clothes(nike) → Perfect(nike) ∧ Dress(nike)"
  },
  {
    "input": "Translate into first-order logic: All pets are animals.",
    "output": "∀x (Pet(x) → Animal(x))"
  },
  {
    "input": "Translate into first-order logic: Pets can be either a dog or a cat.",
    "output": "∀x (Pet(x) → Dog(x) ⊕ Cat(x))"
  },
  {
    "input": "Translate into first-order logic: If a person has a pet, they care for that pet.",
    "output": "∀x ∀y (HasPet(x) → Cares(x, y))"
  },
  {
    "input": "Translate into first-order logic: Dogs and Cats can be naughty.",
    "output": "∃x ((Cat(x) ∧ Naughty(x)) ∨ (Dog(x) ∧ Naughty(x)))"
  },
  {
    "input": "Translate into first-order logic: Pets who are naughty are not liked as much.",
    "output": "∀x ∀y (Pet(x) ∧ Naughty(x) → ¬Liked(x, y))"
  },
  {
    "input": "Translate into first-order logic: Charlie has a naughty pet dog named Leo.",
    "output": "HasPet(charlie) ∧ Pet(leo) ∧ Dog(leo) ∧ Naughty(leo)"
  },
  {
    "input": "Translate into first-order logic: All pets are animals.",
    "output": "∀x (Pet(x) → Animal(x))"
  },
  {
    "input": "Translate into first-order logic: Pets can be either a dog or a cat.",
    "output": "∀x (Pet(x) → Dog(x) ⊕ Cat(x))"
  },
  {
    "input": "Translate into first-order logic: If a person has a pet, they care for that pet.",
    "output": "∀x ∀y (HasPet(x) → Cares(x, y))"
  },
  {
    "input": "Translate into first-order logic: Dogs and Cats can be naughty.",
    "output": "∃x ((Cat(x) ∧ Naughty(x)) ∨ (Dog(x) ∧ Naughty(x)))"
  },
  {
    "input": "Translate into first-order logic: Pets who are naughty are not liked as much.",
    "output": "∀x ∀y (Pet(x) ∧ Naughty(x) → ¬Liked(x, y))"
  },
  {
    "input": "Translate into first-order logic: Charlie has a naughty pet dog named Leo.",
    "output": "HasPet(charlie) ∧ Pet(leo) ∧ Dog(leo) ∧ Naughty(leo)"
  },
  {
    "input": "Translate into first-order logic: All pets are animals.",
    "output": "∀x (Pet(x) → Animal(x))"
  },
  {
    "input": "Translate into first-order logic: Pets can be either a dog or a cat.",
    "output": "∀x (Pet(x) → Dog(x) ⊕ Cat(x))"
  },
  {
    "input": "Translate into first-order logic: If a person has a pet, they care for that pet.",
    "output": "∀x ∀y (HasPet(x) → Cares(x, y))"
  },
  {
    "input": "Translate into first-order logic: Dogs and Cats can be naughty.",
    "output": "∃x ((Cat(x) ∧ Naughty(x)) ∨ (Dog(x) ∧ Naughty(x)))"
  },
  {
    "input": "Translate into first-order logic: Pets who are naughty are not liked as much.",
    "output": "∀x ∀y (Pet(x) ∧ Naughty(x) → ¬Liked(x, y))"
  },
  {
    "input": "Translate into first-order logic: Charlie has a naughty pet dog named Leo.",
    "output": "HasPet(charlie) ∧ Pet(leo) ∧ Dog(leo) ∧ Naughty(leo)"
  },
  {
    "input": "Translate into first-order logic: Surprises are either fun or dreadful.",
    "output": "∀x (Surprise(x) → (Fun(x) ⊕ Dreadful(x)))"
  },
  {
    "input": "Translate into first-order logic: All scares are surprises.",
    "output": "∀x (Scare(x) → Surprise(x))"
  },
  {
    "input": "Translate into first-order logic: All books written by Cixin Liu have sold more than 1 million copies.",
    "output": "∀x (Book(x) ∧ WrittenBy(x, cixinliu) → SoldMoreThan(x, onemillion))"
  },
  {
    "input": "Translate into first-order logic: Some books that have won the Hugo Award were written by Cixin Liu.",
    "output": "∃x (Won(x, hugoaward) ∧ Book(x) ∧ WrittenBy(x, cixinliu))"
  },
  {
    "input": "Translate into first-order logic: All books about the future are influenced by Isaac Asimov.",
    "output": "∀x (Book(x) ∧ AboutFuture(x) → InfluencedBy(x, isaacasimov))"
  },
  {
    "input": "Translate into first-order logic: The book the Three Body Problem has sold more than 1 million copies.",
    "output": "Book(threebodyproblem) ∧ SoldMoreThan(threebodyproblem, onemillion)"
  },
  {
    "input": "Translate into first-order logic: The Three Body Problem is about the future.",
    "output": "AboutFuture(threebodyproblem)"
  },
  {
    "input": "Translate into first-order logic: All books written by Cixin Liu have sold more than 1 million copies.",
    "output": "∀x (Book(x) ∧ WrittenBy(x, cixinliu) → SoldMoreThan(x, onemillion))"
  },
  {
    "input": "Translate into first-order logic: Some books that have won the Hugo Award were written by Cixin Liu.",
    "output": "∃x (Won(x, hugoaward) ∧ Book(x) ∧ WrittenBy(x, cixinliu))"
  },
  {
    "input": "Translate into first-order logic: All books about the future are influenced by Isaac Asimov.",
    "output": "∀x (Book(x) ∧ AboutFuture(x) → InfluencedBy(x, isaacasimov))"
  },
  {
    "input": "Translate into first-order logic: The book the Three Body Problem has sold more than 1 million copies.",
    "output": "Book(threebodyproblem) ∧ SoldMoreThan(threebodyproblem, onemillion)"
  },
  {
    "input": "Translate into first-order logic: The Three Body Problem is about the future.",
    "output": "AboutFuture(threebodyproblem)"
  },
  {
    "input": "Translate into first-order logic: All books written by Cixin Liu have sold more than 1 million copies.",
    "output": "∀x (Book(x) ∧ WrittenBy(x, cixinliu) → SoldMoreThan(x, onemillion))"
  },
  {
    "input": "Translate into first-order logic: Some books that have won the Hugo Award were written by Cixin Liu.",
    "output": "∃x (Won(x, hugoaward) ∧ Book(x) ∧ WrittenBy(x, cixinliu))"
  },
  {
    "input": "Translate into first-order logic: All books about the future are influenced by Isaac Asimov.",
    "output": "∀x (Book(x) ∧ AboutFuture(x) → InfluencedBy(x, isaacasimov))"
  },
  {
    "input": "Translate into first-order logic: The book the Three Body Problem has sold more than 1 million copies.",
    "output": "Book(threebodyproblem) ∧ SoldMoreThan(threebodyproblem, onemillion)"
  },
  {
    "input": "Translate into first-order logic: The Three Body Problem is about the future.",
    "output": "AboutFuture(threebodyproblem)"
  },
  {
    "input": "Translate into first-order logic: Some students who major in computer science get up early.",
    "output": "∃x (ComputerScience(x) ∧ GetUpEarly(x))"
  },
  {
    "input": "Translate into first-order logic: If a student gets up early, then he/she will study in the morning.",
    "output": "∀x (GetUpEarly(x) → StudyMorning(x))"
  },
  {
    "input": "Translate into first-order logic: All students studying in the morning are good at time management.",
    "output": "∀x (StudyMorning(x) → GoodAtTimeManagement(x))"
  },
  {
    "input": "Translate into first-order logic: All students good at time management are popular among students.",
    "output": "∀x (GoodAtTimeManagement(x) → Popular(x))"
  },
  {
    "input": "Translate into first-order logic: James is not popular among students.",
    "output": "¬Popular(james)"
  },
  {
    "input": "Translate into first-order logic: Some students who major in computer science get up early.",
    "output": "∃x (ComputerScience(x) ∧ GetUpEarly(x))"
  },
  {
    "input": "Translate into first-order logic: If a student gets up early, then he/she will study in the morning.",
    "output": "∀x (GetUpEarly(x) → StudyMorning(x))"
  },
  {
    "input": "Translate into first-order logic: All students studying in the morning are good at time management.",
    "output": "∀x (StudyMorning(x) → GoodAtTimeManagement(x))"
  },
  {
    "input": "Translate into first-order logic: All students good at time management are popular among students.",
    "output": "∀x (GoodAtTimeManagement(x) → Popular(x))"
  },
  {
    "input": "Translate into first-order logic: James is not popular among students.",
    "output": "¬Popular(james)"
  },
  {
    "input": "Translate into first-order logic: Some students who major in computer science get up early.",
    "output": "∃x (ComputerScience(x) ∧ GetUpEarly(x))"
  },
  {
    "input": "Translate into first-order logic: If a student gets up early, then he/she will study in the morning.",
    "output": "∀x (GetUpEarly(x) → StudyMorning(x))"
  },
  {
    "input": "Translate into first-order logic: All students studying in the morning are good at time management.",
    "output": "∀x (StudyMorning(x) → GoodAtTimeManagement(x))"
  },
  {
    "input": "Translate into first-order logic: All students good at time management are popular among students.",
    "output": "∀x (GoodAtTimeManagement(x) → Popular(x))"
  },
  {
    "input": "Translate into first-order logic: James is not popular among students.",
    "output": "¬Popular(james)"
  },
  {
    "input": "Translate into first-order logic: There is no dog on the roof.",
    "output": "¬(∃x (Dog(x) ∧ OnRoof(x)))"
  },
  {
    "input": "Translate into first-order logic: If there is a dog on the roof something went wrong.",
    "output": "∀x ∃y ((Dog(x) ∧ OnRoof(x)) → WentWrong(y))"
  },
  {
    "input": "Translate into first-order logic: Elephantopus is a genus of perennial plants in the daisy family.",
    "output": "∀x (Elephantopus(x) → Genus(x, perennialplants) ∧ BelongTo(x, daisyfamily))"
  },
  {
    "input": "Translate into first-order logic: Elephantopus is widespread over much of Africa, southern Asia, Australia, and the Americas.",
    "output": "∀x (Elephantopus(x) → WidespreadOver(x, africa) ∧ WidespreadOver(x, southernasia) ∧ WidespreadOver(x, australia) ∧ WidespreadOver(x, americas))"
  },
  {
    "input": "Translate into first-order logic: Several species of Elephantopus are native to the southeastern United States.",
    "output": "∃x (Elephantopus(x) ∧ NativeTo(x, southeasternunitedstates))"
  },
  {
    "input": "Translate into first-order logic: Elephantopus scaber is a traditional medicine.",
    "output": "∀x (ElephantopusScaber(x) → TraditionalMedicine(x))"
  },
  {
    "input": "Translate into first-order logic: Elephantopus is a genus of perennial plants in the daisy family.",
    "output": "∀x (Elephantopus(x) → Genus(x, perennialplants) ∧ BelongTo(x, daisyfamily))"
  },
  {
    "input": "Translate into first-order logic: Elephantopus is widespread over much of Africa, southern Asia, Australia, and the Americas.",
    "output": "∀x (Elephantopus(x) → WidespreadOver(x, africa) ∧ WidespreadOver(x, southernasia) ∧ WidespreadOver(x, australia) ∧ WidespreadOver(x, americas))"
  },
  {
    "input": "Translate into first-order logic: Several species of Elephantopus are native to the southeastern United States.",
    "output": "∃x (Elephantopus(x) ∧ NativeTo(x, southeasternunitedstates))"
  },
  {
    "input": "Translate into first-order logic: Elephantopus scaber is a traditional medicine.",
    "output": "∀x (ElephantopusScaber(x) → TraditionalMedicine(x))"
  },
  {
    "input": "Translate into first-order logic: Elephantopus is a genus of perennial plants in the daisy family.",
    "output": "∀x (Elephantopus(x) → Genus(x, perennialplants) ∧ BelongTo(x, daisyfamily))"
  },
  {
    "input": "Translate into first-order logic: Elephantopus is widespread over much of Africa, southern Asia, Australia, and the Americas.",
    "output": "∀x (Elephantopus(x) → WidespreadOver(x, africa) ∧ WidespreadOver(x, southernasia) ∧ WidespreadOver(x, australia) ∧ WidespreadOver(x, americas))"
  },
  {
    "input": "Translate into first-order logic: Several species of Elephantopus are native to the southeastern United States.",
    "output": "∃x (Elephantopus(x) ∧ NativeTo(x, southeasternunitedstates))"
  },
  {
    "input": "Translate into first-order logic: Elephantopus scaber is a traditional medicine.",
    "output": "∀x (ElephantopusScaber(x) → TraditionalMedicine(x))"
  },
  {
    "input": "Translate into first-order logic: All Yale dormitories are located on York Street.",
    "output": "∀x (YaleDormitory(x) → InYorkStreet(x))"
  },
  {
    "input": "Translate into first-order logic: All buildings managed by Yale Housing are dormitories.",
    "output": "∀x (ManagedByYaleHousing(x) → YaleDormitory(x))"
  },
  {
    "input": "Translate into first-order logic: All buildings operated by Yale Housing staff are managed by Yale Housing.",
    "output": "∀x (OperatedByYaleHousingStaffs(x) → ManagedByYaleHousing(x))"
  },
  {
    "input": "Translate into first-order logic: No buildings open to students are established after 1800.",
    "output": "∀x (OpenToStudents(x) → ¬EstablishedAfter1800(x))"
  },
  {
    "input": "Translate into first-order logic: All buildings located on York Street are open to students.",
    "output": "∀x (InYorkStreet(x) → OpenToStudents(x))"
  },
  {
    "input": "Translate into first-order logic: Harkness is either a building operated by Yale Housing staff or located on York Street.",
    "output": "OperatedByYaleHousingStaffs(harkness) ⊕ InYorkStreet(harkness)"
  },
  {
    "input": "Translate into first-order logic: All Yale dormitories are located on York Street.",
    "output": "∀x (YaleDormitory(x) → InYorkStreet(x))"
  },
  {
    "input": "Translate into first-order logic: All buildings managed by Yale Housing are dormitories.",
    "output": "∀x (ManagedByYaleHousing(x) → YaleDormitory(x))"
  },
  {
    "input": "Translate into first-order logic: All buildings operated by Yale Housing staff are managed by Yale Housing.",
    "output": "∀x (OperatedByYaleHousingStaffs(x) → ManagedByYaleHousing(x))"
  },
  {
    "input": "Translate into first-order logic: No buildings open to students are established after 1800.",
    "output": "∀x (OpenToStudents(x) → ¬EstablishedAfter1800(x))"
  },
  {
    "input": "Translate into first-order logic: All buildings located on York Street are open to students.",
    "output": "∀x (InYorkStreet(x) → OpenToStudents(x))"
  },
  {
    "input": "Translate into first-order logic: Harkness is either a building operated by Yale Housing staff or located on York Street.",
    "output": "OperatedByYaleHousingStaffs(harkness) ⊕ InYorkStreet(harkness)"
  },
  {
    "input": "Translate into first-order logic: All Yale dormitories are located on York Street.",
    "output": "∀x (YaleDormitory(x) → InYorkStreet(x))"
  },
  {
    "input": "Translate into first-order logic: All buildings managed by Yale Housing are dormitories.",
    "output": "∀x (ManagedByYaleHousing(x) → YaleDormitory(x))"
  },
  {
    "input": "Translate into first-order logic: All buildings operated by Yale Housing staff are managed by Yale Housing.",
    "output": "∀x (OperatedByYaleHousingStaffs(x) → ManagedByYaleHousing(x))"
  },
  {
    "input": "Translate into first-order logic: No buildings open to students are established after 1800.",
    "output": "∀x (OpenToStudents(x) → ¬EstablishedAfter1800(x))"
  },
  {
    "input": "Translate into first-order logic: All buildings located on York Street are open to students.",
    "output": "∀x (InYorkStreet(x) → OpenToStudents(x))"
  },
  {
    "input": "Translate into first-order logic: Harkness is either a building operated by Yale Housing staff or located on York Street.",
    "output": "OperatedByYaleHousingStaffs(harkness) ⊕ InYorkStreet(harkness)"
  },
  {
    "input": "Translate into first-order logic: All Yale dormitories are located on York Street.",
    "output": "∀x (YaleDormitory(x) → InYorkStreet(x))"
  },
  {
    "input": "Translate into first-order logic: All buildings managed by Yale Housing are dormitories.",
    "output": "∀x (ManagedByYaleHousing(x) → YaleDormitory(x))"
  },
  {
    "input": "Translate into first-order logic: All buildings operated by Yale Housing staff are managed by Yale Housing.",
    "output": "∀x (OperatedByYaleHousingStaffs(x) → ManagedByYaleHousing(x))"
  },
  {
    "input": "Translate into first-order logic: No buildings open to students are established after 1800.",
    "output": "∀x (OpenToStudents(x) → ¬EstablishedAfter1800(x))"
  },
  {
    "input": "Translate into first-order logic: All buildings located on York Street are open to students.",
    "output": "∀x (InYorkStreet(x) → OpenToStudents(x))"
  },
  {
    "input": "Translate into first-order logic: Harkness is either a building operated by Yale Housing staff or located on York Street.",
    "output": "OperatedByYaleHousingStaffs(harkness) ⊕ InYorkStreet(harkness)"
  },
  {
    "input": "Translate into first-order logic: There are no mansion houses in an urban area.",
    "output": "∀x (UrbanArea(x) → ¬MansionHouse(x))"
  },
  {
    "input": "Translate into first-order logic: All skyscrapers reside in urban areas.",
    "output": "∀x (Skyscraper(x) → UrbanArea(x))"
  },
  {
    "input": "Translate into first-order logic: Every creepy haunted house is in a mansion house.",
    "output": "∀x (CreepyHauntedHouse(x) → MansionHouse(x))"
  },
  {
    "input": "Translate into first-order logic: Every terrifying Halloween scare comes from a creepy haunted house.",
    "output": "∀x (TerrifyingHalloweenScare(x) → CreepyHauntedHouse(x))"
  },
  {
    "input": "Translate into first-order logic: The Scream is a creepy haunted house or a terrifying Halloween scare.",
    "output": "CreepyHauntedHouse(thescream) ∨ TerrifyingHalloweenScare(thescream)"
  },
  {
    "input": "Translate into first-order logic: There are no mansion houses in an urban area.",
    "output": "∀x (UrbanArea(x) → ¬MansionHouse(x))"
  },
  {
    "input": "Translate into first-order logic: All skyscrapers reside in urban areas.",
    "output": "∀x (Skyscraper(x) → UrbanArea(x))"
  },
  {
    "input": "Translate into first-order logic: Every creepy haunted house is in a mansion house.",
    "output": "∀x (CreepyHauntedHouse(x) → MansionHouse(x))"
  },
  {
    "input": "Translate into first-order logic: Every terrifying Halloween scare comes from a creepy haunted house.",
    "output": "∀x (TerrifyingHalloweenScare(x) → CreepyHauntedHouse(x))"
  },
  {
    "input": "Translate into first-order logic: The Scream is a creepy haunted house or a terrifying Halloween scare.",
    "output": "CreepyHauntedHouse(thescream) ∨ TerrifyingHalloweenScare(thescream)"
  },
  {
    "input": "Translate into first-order logic: There are no mansion houses in an urban area.",
    "output": "∀x (UrbanArea(x) → ¬MansionHouse(x))"
  },
  {
    "input": "Translate into first-order logic: All skyscrapers reside in urban areas.",
    "output": "∀x (Skyscraper(x) → UrbanArea(x))"
  },
  {
    "input": "Translate into first-order logic: Every creepy haunted house is in a mansion house.",
    "output": "∀x (CreepyHauntedHouse(x) → MansionHouse(x))"
  },
  {
    "input": "Translate into first-order logic: Every terrifying Halloween scare comes from a creepy haunted house.",
    "output": "∀x (TerrifyingHalloweenScare(x) → CreepyHauntedHouse(x))"
  },
  {
    "input": "Translate into first-order logic: The Scream is a creepy haunted house or a terrifying Halloween scare.",
    "output": "CreepyHauntedHouse(thescream) ∨ TerrifyingHalloweenScare(thescream)"
  },
  {
    "input": "Translate into first-order logic: There are no mansion houses in an urban area.",
    "output": "∀x (UrbanArea(x) → ¬MansionHouse(x))"
  },
  {
    "input": "Translate into first-order logic: All skyscrapers reside in urban areas.",
    "output": "∀x (Skyscraper(x) → UrbanArea(x))"
  },
  {
    "input": "Translate into first-order logic: Every creepy haunted house is in a mansion house.",
    "output": "∀x (CreepyHauntedHouse(x) → MansionHouse(x))"
  },
  {
    "input": "Translate into first-order logic: Every terrifying Halloween scare comes from a creepy haunted house.",
    "output": "∀x (TerrifyingHalloweenScare(x) → CreepyHauntedHouse(x))"
  },
  {
    "input": "Translate into first-order logic: The Scream is a creepy haunted house or a terrifying Halloween scare.",
    "output": "CreepyHauntedHouse(thescream) ∨ TerrifyingHalloweenScare(thescream)"
  },
  {
    "input": "Translate into first-order logic: There are no mansion houses in an urban area.",
    "output": "∀x (UrbanArea(x) → ¬MansionHouse(x))"
  },
  {
    "input": "Translate into first-order logic: All skyscrapers reside in urban areas.",
    "output": "∀x (Skyscraper(x) → UrbanArea(x))"
  },
  {
    "input": "Translate into first-order logic: Every creepy haunted house is in a mansion house.",
    "output": "∀x (CreepyHauntedHouse(x) → MansionHouse(x))"
  },
  {
    "input": "Translate into first-order logic: Every terrifying Halloween scare comes from a creepy haunted house.",
    "output": "∀x (TerrifyingHalloweenScare(x) → CreepyHauntedHouse(x))"
  },
  {
    "input": "Translate into first-order logic: The Scream is a creepy haunted house or a terrifying Halloween scare.",
    "output": "CreepyHauntedHouse(thescream) ∨ TerrifyingHalloweenScare(thescream)"
  },
  {
    "input": "Translate into first-order logic: There are no mansion houses in an urban area.",
    "output": "∀x (UrbanArea(x) → ¬MansionHouse(x))"
  },
  {
    "input": "Translate into first-order logic: All skyscrapers reside in urban areas.",
    "output": "∀x (Skyscraper(x) → UrbanArea(x))"
  },
  {
    "input": "Translate into first-order logic: Every creepy haunted house is in a mansion house.",
    "output": "∀x (CreepyHauntedHouse(x) → MansionHouse(x))"
  },
  {
    "input": "Translate into first-order logic: Every terrifying Halloween scare comes from a creepy haunted house.",
    "output": "∀x (TerrifyingHalloweenScare(x) → CreepyHauntedHouse(x))"
  },
  {
    "input": "Translate into first-order logic: The Scream is a creepy haunted house or a terrifying Halloween scare.",
    "output": "CreepyHauntedHouse(thescream) ∨ TerrifyingHalloweenScare(thescream)"
  },
  {
    "input": "Translate into first-order logic: There are no mansion houses in an urban area.",
    "output": "∀x (UrbanArea(x) → ¬MansionHouse(x))"
  },
  {
    "input": "Translate into first-order logic: All skyscrapers reside in urban areas.",
    "output": "∀x (Skyscraper(x) → UrbanArea(x))"
  },
  {
    "input": "Translate into first-order logic: Every creepy haunted house is in a mansion house.",
    "output": "∀x (CreepyHauntedHouse(x) → MansionHouse(x))"
  },
  {
    "input": "Translate into first-order logic: Every terrifying Halloween scare comes from a creepy haunted house.",
    "output": "∀x (TerrifyingHalloweenScare(x) → CreepyHauntedHouse(x))"
  },
  {
    "input": "Translate into first-order logic: The Scream is a creepy haunted house or a terrifying Halloween scare.",
    "output": "CreepyHauntedHouse(thescream) ∨ TerrifyingHalloweenScare(thescream)"
  },
  {
    "input": "Translate into first-order logic: There are no mansion houses in an urban area.",
    "output": "∀x (UrbanArea(x) → ¬MansionHouse(x))"
  },
  {
    "input": "Translate into first-order logic: All skyscrapers reside in urban areas.",
    "output": "∀x (Skyscraper(x) → UrbanArea(x))"
  },
  {
    "input": "Translate into first-order logic: Every creepy haunted house is in a mansion house.",
    "output": "∀x (CreepyHauntedHouse(x) → MansionHouse(x))"
  },
  {
    "input": "Translate into first-order logic: Every terrifying Halloween scare comes from a creepy haunted house.",
    "output": "∀x (TerrifyingHalloweenScare(x) → CreepyHauntedHouse(x))"
  },
  {
    "input": "Translate into first-order logic: The Scream is a creepy haunted house or a terrifying Halloween scare.",
    "output": "CreepyHauntedHouse(thescream) ∨ TerrifyingHalloweenScare(thescream)"
  },
  {
    "input": "Translate into first-order logic: There are no mansion houses in an urban area.",
    "output": "∀x (UrbanArea(x) → ¬MansionHouse(x))"
  },
  {
    "input": "Translate into first-order logic: All skyscrapers reside in urban areas.",
    "output": "∀x (Skyscraper(x) → UrbanArea(x))"
  },
  {
    "input": "Translate into first-order logic: Every creepy haunted house is in a mansion house.",
    "output": "∀x (CreepyHauntedHouse(x) → MansionHouse(x))"
  },
  {
    "input": "Translate into first-order logic: Every terrifying Halloween scare comes from a creepy haunted house.",
    "output": "∀x (TerrifyingHalloweenScare(x) → CreepyHauntedHouse(x))"
  },
  {
    "input": "Translate into first-order logic: The Scream is a creepy haunted house or a terrifying Halloween scare.",
    "output": "CreepyHauntedHouse(thescream) ∨ TerrifyingHalloweenScare(thescream)"
  },
  {
    "input": "Translate into first-order logic: There are no mansion houses in an urban area.",
    "output": "∀x (UrbanArea(x) → ¬MansionHouse(x))"
  },
  {
    "input": "Translate into first-order logic: All skyscrapers reside in urban areas.",
    "output": "∀x (Skyscraper(x) → UrbanArea(x))"
  },
  {
    "input": "Translate into first-order logic: Every creepy haunted house is in a mansion house.",
    "output": "∀x (CreepyHauntedHouse(x) → MansionHouse(x))"
  },
  {
    "input": "Translate into first-order logic: Every terrifying Halloween scare comes from a creepy haunted house.",
    "output": "∀x (TerrifyingHalloweenScare(x) → CreepyHauntedHouse(x))"
  },
  {
    "input": "Translate into first-order logic: The Scream is a creepy haunted house or a terrifying Halloween scare.",
    "output": "CreepyHauntedHouse(thescream) ∨ TerrifyingHalloweenScare(thescream)"
  },
  {
    "input": "Translate into first-order logic: Phuoc Binh national park is a national park in Vietnam.",
    "output": "NationalPark(phuocBinh) ∧ Locatedin(phuocBinh, vietnam)"
  },
  {
    "input": "Translate into first-order logic: Any national park in Vietnam is classified as a nature reserve.",
    "output": "∀x (NationalPark(x) ∧ Locatedin(x, vietnam) → NatureReserve(x))"
  },
  {
    "input": "Translate into first-order logic: There is a national park in Vietnam classified as a UNESCO World Heritage Site.",
    "output": "∃x (NationalPark(x) ∧ Locatedin(x, vietnam) ∧ UNESCOWorldHeritageSite(x))"
  },
  {
    "input": "Translate into first-order logic: All national parks in Vietnam are either managed by the Ministry of Agriculture or by the People's Committee.",
    "output": "∀x (NationalPark(x) ∧ Locatedin(x, vietnam) → Mangedby(x, ministryofAgriculture) ∨ Mangedby(x, peoplesCommittee))"
  },
  {
    "input": "Translate into first-order logic: Phuoc Binh is not managed by the Ministry of Agriculture.",
    "output": "¬Mangedby(phuocBinh, ministryofAgriculture)"
  },
  {
    "input": "Translate into first-order logic: Phuoc Binh national park is a national park in Vietnam.",
    "output": "NationalPark(phuocBinh) ∧ Locatedin(phuocBinh, vietnam)"
  },
  {
    "input": "Translate into first-order logic: Any national park in Vietnam is classified as a nature reserve.",
    "output": "∀x (NationalPark(x) ∧ Locatedin(x, vietnam) → NatureReserve(x))"
  },
  {
    "input": "Translate into first-order logic: There is a national park in Vietnam classified as a UNESCO World Heritage Site.",
    "output": "∃x (NationalPark(x) ∧ Locatedin(x, vietnam) ∧ UNESCOWorldHeritageSite(x))"
  },
  {
    "input": "Translate into first-order logic: All national parks in Vietnam are either managed by the Ministry of Agriculture or by the People's Committee.",
    "output": "∀x (NationalPark(x) ∧ Locatedin(x, vietnam) → Mangedby(x, ministryofAgriculture) ∨ Mangedby(x, peoplesCommittee))"
  },
  {
    "input": "Translate into first-order logic: Phuoc Binh is not managed by the Ministry of Agriculture.",
    "output": "¬Mangedby(phuocBinh, ministryofAgriculture)"
  },
  {
    "input": "Translate into first-order logic: Phuoc Binh national park is a national park in Vietnam.",
    "output": "NationalPark(phuocBinh) ∧ Locatedin(phuocBinh, vietnam)"
  },
  {
    "input": "Translate into first-order logic: Any national park in Vietnam is classified as a nature reserve.",
    "output": "∀x (NationalPark(x) ∧ Locatedin(x, vietnam) → NatureReserve(x))"
  },
  {
    "input": "Translate into first-order logic: There is a national park in Vietnam classified as a UNESCO World Heritage Site.",
    "output": "∃x (NationalPark(x) ∧ Locatedin(x, vietnam) ∧ UNESCOWorldHeritageSite(x))"
  },
  {
    "input": "Translate into first-order logic: All national parks in Vietnam are either managed by the Ministry of Agriculture or by the People's Committee.",
    "output": "∀x (NationalPark(x) ∧ Locatedin(x, vietnam) → Mangedby(x, ministryofAgriculture) ∨ Mangedby(x, peoplesCommittee))"
  },
  {
    "input": "Translate into first-order logic: Phuoc Binh is not managed by the Ministry of Agriculture.",
    "output": "¬Mangedby(phuocBinh, ministryofAgriculture)"
  },
  {
    "input": "Translate into first-order logic: Greyhound racing is a competitive sport where spectators bet on greyhounds.",
    "output": "∀x ∃y (GreyhoundRacing(x) → CompetitiveSport(x) ∧ Greyhound(y) ∧ SpectatorsBetOn(x, y))"
  },
  {
    "input": "Translate into first-order logic: Coursing is a part of Greyhound racing.",
    "output": "∀x (GreyhoundRacing(x) ↔ Coursing(x))"
  },
  {
    "input": "Translate into first-order logic: Some competitive sports where spectators bet on things are banned.",
    "output": "∃x ∃y (CompetitiveSport(x) ∧ SpectaorsBetOn(x, y) ∧ Banned(x))"
  },
  {
    "input": "Translate into first-order logic: Coursing involves spectators betting on a hare being pursued by greyhounds.",
    "output": "∀x ∃y ∃z (Coursing(x) → Hare(y) ∧ SpectatorsBetOn(x, y) ∧ GreyHound(z) ∧ Pursue(z, y))"
  },
  {
    "input": "Translate into first-order logic: Hares are small game.",
    "output": "∀x (Hare(x) → SmallGame(x))"
  },
  {
    "input": "Translate into first-order logic: If a competitive sport involves spectators betting on small game, then it is banned.",
    "output": "∀x ∃y (CompetitiveSport(x) ∧ SmallGame(y) ∧ SpectatorsBetOn(x, y) → Banned(x))"
  },
  {
    "input": "Translate into first-order logic: Greyhound racing is a competitive sport where spectators bet on greyhounds.",
    "output": "∀x ∃y (GreyhoundRacing(x) → CompetitiveSport(x) ∧ Greyhound(y) ∧ SpectatorsBetOn(x, y))"
  },
  {
    "input": "Translate into first-order logic: Coursing is a part of Greyhound racing.",
    "output": "∀x (GreyhoundRacing(x) ↔ Coursing(x))"
  },
  {
    "input": "Translate into first-order logic: Some competitive sports where spectators bet on things are banned.",
    "output": "∃x ∃y (CompetitiveSport(x) ∧ SpectaorsBetOn(x, y) ∧ Banned(x))"
  },
  {
    "input": "Translate into first-order logic: Coursing involves spectators betting on a hare being pursued by greyhounds.",
    "output": "∀x ∃y ∃z (Coursing(x) → Hare(y) ∧ SpectatorsBetOn(x, y) ∧ GreyHound(z) ∧ Pursue(z, y))"
  },
  {
    "input": "Translate into first-order logic: Hares are small game.",
    "output": "∀x (Hare(x) → SmallGame(x))"
  },
  {
    "input": "Translate into first-order logic: If a competitive sport involves spectators betting on small game, then it is banned.",
    "output": "∀x ∃y (CompetitiveSport(x) ∧ SmallGame(y) ∧ SpectatorsBetOn(x, y) → Banned(x))"
  },
  {
    "input": "Translate into first-order logic: If a soccer player receives two yellow cards in one game, this player will be ejected from the rest of the game.",
    "output": "∀x (SoccerPlayer(x) ∧ TwoYellow(x) → Eject(x))"
  },
  {
    "input": "Translate into first-order logic: If a soccer player receives one red card in one game, this player will be ejected from the rest of the game.",
    "output": "∀x (SoccerPlayer(x) ∧ OneRed(x) → Eject(x))   "
  },
  {
    "input": "Translate into first-order logic: Henry is a soccer player.",
    "output": "SoccerPlayer(henry)"
  },
  {
    "input": "Translate into first-order logic: In one game, Henry first receives one yellow card, then he receives one red card.",
    "output": "¬TwoYellow(henry) ∧ OneRed(henry)"
  },
  {
    "input": "Translate into first-order logic: If a soccer player receives two yellow cards in one game, this player will be ejected from the rest of the game.",
    "output": "∀x (SoccerPlayer(x) ∧ TwoYellow(x) → Eject(x))"
  },
  {
    "input": "Translate into first-order logic: If a soccer player receives one red card in one game, this player will be ejected from the rest of the game.",
    "output": "∀x (SoccerPlayer(x) ∧ OneRed(x) → Eject(x))   "
  },
  {
    "input": "Translate into first-order logic: Henry is a soccer player.",
    "output": "SoccerPlayer(henry)"
  },
  {
    "input": "Translate into first-order logic: In one game, Henry first receives one yellow card, then he receives one red card.",
    "output": "¬TwoYellow(henry) ∧ OneRed(henry)"
  },
  {
    "input": "Translate into first-order logic: All trees are plants.",
    "output": "∀x (Tree(x) → Plant(x))"
  },
  {
    "input": "Translate into first-order logic: Some living things are trees.",
    "output": "∃x (Living(x) ∧ Tree(x))"
  },
  {
    "input": "Translate into first-order logic: Dagfinn is a given name.",
    "output": "∀x (Dagfinn(x) → GivenName(x))"
  },
  {
    "input": "Translate into first-order logic: Notable people with the given name include Dagfinn Aarskog, Dagfinn Bakke and Dagfinn Dahl.",
    "output": "Dagfinn(dagfinnAarskog) ∧ NotablePeople(dagfinnAarskog) ∧ Dagfinn(dagfinnBakke) ∧ NotablePeople(dagfinnBakke) ∧ Dagfinn(dagfinnDahl) ∧ NotablePeople(dagfinnDahl)"
  },
  {
    "input": "Translate into first-order logic: Dagfinn Aarskog is a Norwegian physician.",
    "output": "Norwegian(dagfinnAarskog) ∧ Physician(dagfinnAarskog)"
  },
  {
    "input": "Translate into first-order logic: Dagfinn Dahl is a Norwegian barrister.",
    "output": "Norwegian(dagfinnDahl) ∧ Barrister(dagfinnDahl)"
  },
  {
    "input": "Translate into first-order logic: Dagfinn is a given name.",
    "output": "∀x (Dagfinn(x) → GivenName(x))"
  },
  {
    "input": "Translate into first-order logic: Notable people with the given name include Dagfinn Aarskog, Dagfinn Bakke and Dagfinn Dahl.",
    "output": "Dagfinn(dagfinnAarskog) ∧ NotablePeople(dagfinnAarskog) ∧ Dagfinn(dagfinnBakke) ∧ NotablePeople(dagfinnBakke) ∧ Dagfinn(dagfinnDahl) ∧ NotablePeople(dagfinnDahl)"
  },
  {
    "input": "Translate into first-order logic: Dagfinn Aarskog is a Norwegian physician.",
    "output": "Norwegian(dagfinnAarskog) ∧ Physician(dagfinnAarskog)"
  },
  {
    "input": "Translate into first-order logic: Dagfinn Dahl is a Norwegian barrister.",
    "output": "Norwegian(dagfinnDahl) ∧ Barrister(dagfinnDahl)"
  },
  {
    "input": "Translate into first-order logic: Dagfinn is a given name.",
    "output": "∀x (Dagfinn(x) → GivenName(x))"
  },
  {
    "input": "Translate into first-order logic: Notable people with the given name include Dagfinn Aarskog, Dagfinn Bakke and Dagfinn Dahl.",
    "output": "Dagfinn(dagfinnAarskog) ∧ NotablePeople(dagfinnAarskog) ∧ Dagfinn(dagfinnBakke) ∧ NotablePeople(dagfinnBakke) ∧ Dagfinn(dagfinnDahl) ∧ NotablePeople(dagfinnDahl)"
  },
  {
    "input": "Translate into first-order logic: Dagfinn Aarskog is a Norwegian physician.",
    "output": "Norwegian(dagfinnAarskog) ∧ Physician(dagfinnAarskog)"
  },
  {
    "input": "Translate into first-order logic: Dagfinn Dahl is a Norwegian barrister.",
    "output": "Norwegian(dagfinnDahl) ∧ Barrister(dagfinnDahl)"
  },
  {
    "input": "Translate into first-order logic: If entertainment is interesting, it will be popular.",
    "output": "∀x ((Entertainment(x) ∧ Interesting(x)) → Popular(x))"
  },
  {
    "input": "Translate into first-order logic: All popular things are well-known.",
    "output": "∀x (Popular(x) → WellKnown(x))"
  },
  {
    "input": "Translate into first-order logic: It is not true that some giant language models do not have good performance.",
    "output": "¬(∃x (LanguageModel(x) ∧ Giant(x) ∧ ¬GoodPerformance(x)))"
  },
  {
    "input": "Translate into first-order logic: All language models with good performance are used by some researchers.",
    "output": "∀x ((LanguageModel(x) ∧ GoodPerformance(x)) → UsedBySomeResearchers(x))"
  },
  {
    "input": "Translate into first-order logic: If a language model is used by some researchers, it is popular.",
    "output": "∀x (UsedBySomeResearchers(x) → Popular(x))"
  },
  {
    "input": "Translate into first-order logic: If BERT is a giant language model, then GPT-3 is also a giant language model.",
    "output": "(LanguageModel(bert) ∧ Giant(bert)) → (LanguageModel(gpt-3) ∧ Giant(gpt-3))."
  },
  {
    "input": "Translate into first-order logic: BERT is a giant language model.",
    "output": "LanguageModel(bert) ∧ Giant(bert) "
  },
  {
    "input": "Translate into first-order logic: St Johnstone is a Scottish team.",
    "output": "Scottish(johnstone)"
  },
  {
    "input": "Translate into first-order logic: St Johnstone is part of the Scottish Premiership.",
    "output": "PartOf(johnstone, scottishpremiership)"
  },
  {
    "input": "Translate into first-order logic: If a team is part of the league, it has joined the league.",
    "output": "∀x ∀y (PartOf(x, y) → Joined(x, y))"
  },
  {
    "input": "Translate into first-order logic: St Johnstone and Minsk are different teams.",
    "output": "Different(misnk, johnstone) ∧ Different(johnstone, minsk)"
  },
  {
    "input": "Translate into first-order logic: For two different teams, either one team wins or the other team wins.",
    "output": "∀x ∀y (Different(x, y) → WonGame(x, y) ⊕ WonGame(y, x))"
  },
  {
    "input": "Translate into first-order logic: Minsk won against St Johnstone.",
    "output": "WonGame(minsk, johnstone)"
  },
  {
    "input": "Translate into first-order logic: St Johnstone is a Scottish team.",
    "output": "Scottish(johnstone)"
  },
  {
    "input": "Translate into first-order logic: St Johnstone is part of the Scottish Premiership.",
    "output": "PartOf(johnstone, scottishpremiership)"
  },
  {
    "input": "Translate into first-order logic: If a team is part of the league, it has joined the league.",
    "output": "∀x ∀y (PartOf(x, y) → Joined(x, y))"
  },
  {
    "input": "Translate into first-order logic: St Johnstone and Minsk are different teams.",
    "output": "Different(misnk, johnstone) ∧ Different(johnstone, minsk)"
  },
  {
    "input": "Translate into first-order logic: For two different teams, either one team wins or the other team wins.",
    "output": "∀x ∀y (Different(x, y) → WonGame(x, y) ⊕ WonGame(y, x))"
  },
  {
    "input": "Translate into first-order logic: Minsk won against St Johnstone.",
    "output": "WonGame(minsk, johnstone)"
  },
  {
    "input": "Translate into first-order logic: St Johnstone is a Scottish team.",
    "output": "Scottish(johnstone)"
  },
  {
    "input": "Translate into first-order logic: St Johnstone is part of the Scottish Premiership.",
    "output": "PartOf(johnstone, scottishpremiership)"
  },
  {
    "input": "Translate into first-order logic: If a team is part of the league, it has joined the league.",
    "output": "∀x ∀y (PartOf(x, y) → Joined(x, y))"
  },
  {
    "input": "Translate into first-order logic: St Johnstone and Minsk are different teams.",
    "output": "Different(misnk, johnstone) ∧ Different(johnstone, minsk)"
  },
  {
    "input": "Translate into first-order logic: For two different teams, either one team wins or the other team wins.",
    "output": "∀x ∀y (Different(x, y) → WonGame(x, y) ⊕ WonGame(y, x))"
  },
  {
    "input": "Translate into first-order logic: Minsk won against St Johnstone.",
    "output": "WonGame(minsk, johnstone)"
  },
  {
    "input": "Translate into first-order logic: No Boeing-737 plane is equipped with more than 300 seats.",
    "output": "∀x (Boeing737(x) → ¬Seats300(x))"
  },
  {
    "input": "Translate into first-order logic: All planes in Delta are of type Boeing-737.",
    "output": "∀x (Delta(x) → Boeing737(x))"
  },
  {
    "input": "Translate into first-order logic: Planes are either equipped with more than 300 seats or have a capacity of 100 passengers.",
    "output": "∀x (Seats300(x) ∨ Passengers100(x))"
  },
  {
    "input": "Translate into first-order logic: All planes with a capacity of 100 passengers are scheduled for a short-distance flight.",
    "output": "∀x (Passengers100(x) → ShortDistance(x))"
  },
  {
    "input": "Translate into first-order logic: All planes with a capacity of 100 passengers are produced before 2010.",
    "output": "∀x (Passengers100(x) → ProducedBefore2010(x))"
  },
  {
    "input": "Translate into first-order logic: Jake32 is either a Boeing-737 plane or a plane in Delta.",
    "output": "Boeing737(jake32) ⊕ Delta(jake32) "
  },
  {
    "input": "Translate into first-order logic: T10 is either a Boeing-737 plane and in Delta, or neither a Boeing-737 plane nor in Delta.",
    "output": "Boeing737(t10) ⊕ Delta(t10)"
  },
  {
    "input": "Translate into first-order logic: No Boeing-737 plane is equipped with more than 300 seats.",
    "output": "∀x (Boeing737(x) → ¬Seats300(x))"
  },
  {
    "input": "Translate into first-order logic: All planes in Delta are of type Boeing-737.",
    "output": "∀x (Delta(x) → Boeing737(x))"
  },
  {
    "input": "Translate into first-order logic: Planes are either equipped with more than 300 seats or have a capacity of 100 passengers.",
    "output": "∀x (Seats300(x) ∨ Passengers100(x))"
  },
  {
    "input": "Translate into first-order logic: All planes with a capacity of 100 passengers are scheduled for a short-distance flight.",
    "output": "∀x (Passengers100(x) → ShortDistance(x))"
  },
  {
    "input": "Translate into first-order logic: All planes with a capacity of 100 passengers are produced before 2010.",
    "output": "∀x (Passengers100(x) → ProducedBefore2010(x))"
  },
  {
    "input": "Translate into first-order logic: Jake32 is either a Boeing-737 plane or a plane in Delta.",
    "output": "Boeing737(jake32) ⊕ Delta(jake32) "
  },
  {
    "input": "Translate into first-order logic: T10 is either a Boeing-737 plane and in Delta, or neither a Boeing-737 plane nor in Delta.",
    "output": "Boeing737(t10) ⊕ Delta(t10)"
  },
  {
    "input": "Translate into first-order logic: No Boeing-737 plane is equipped with more than 300 seats.",
    "output": "∀x (Boeing737(x) → ¬Seats300(x))"
  },
  {
    "input": "Translate into first-order logic: All planes in Delta are of type Boeing-737.",
    "output": "∀x (Delta(x) → Boeing737(x))"
  },
  {
    "input": "Translate into first-order logic: Planes are either equipped with more than 300 seats or have a capacity of 100 passengers.",
    "output": "∀x (Seats300(x) ∨ Passengers100(x))"
  },
  {
    "input": "Translate into first-order logic: All planes with a capacity of 100 passengers are scheduled for a short-distance flight.",
    "output": "∀x (Passengers100(x) → ShortDistance(x))"
  },
  {
    "input": "Translate into first-order logic: All planes with a capacity of 100 passengers are produced before 2010.",
    "output": "∀x (Passengers100(x) → ProducedBefore2010(x))"
  },
  {
    "input": "Translate into first-order logic: Jake32 is either a Boeing-737 plane or a plane in Delta.",
    "output": "Boeing737(jake32) ⊕ Delta(jake32) "
  },
  {
    "input": "Translate into first-order logic: T10 is either a Boeing-737 plane and in Delta, or neither a Boeing-737 plane nor in Delta.",
    "output": "Boeing737(t10) ⊕ Delta(t10)"
  },
  {
    "input": "Translate into first-order logic: No Boeing-737 plane is equipped with more than 300 seats.",
    "output": "∀x (Boeing737(x) → ¬Seats300(x))"
  },
  {
    "input": "Translate into first-order logic: All planes in Delta are of type Boeing-737.",
    "output": "∀x (Delta(x) → Boeing737(x))"
  },
  {
    "input": "Translate into first-order logic: Planes are either equipped with more than 300 seats or have a capacity of 100 passengers.",
    "output": "∀x (Seats300(x) ∨ Passengers100(x))"
  },
  {
    "input": "Translate into first-order logic: All planes with a capacity of 100 passengers are scheduled for a short-distance flight.",
    "output": "∀x (Passengers100(x) → ShortDistance(x))"
  },
  {
    "input": "Translate into first-order logic: All planes with a capacity of 100 passengers are produced before 2010.",
    "output": "∀x (Passengers100(x) → ProducedBefore2010(x))"
  },
  {
    "input": "Translate into first-order logic: Jake32 is either a Boeing-737 plane or a plane in Delta.",
    "output": "Boeing737(jake32) ⊕ Delta(jake32) "
  },
  {
    "input": "Translate into first-order logic: T10 is either a Boeing-737 plane and in Delta, or neither a Boeing-737 plane nor in Delta.",
    "output": "Boeing737(t10) ⊕ Delta(t10)"
  },
  {
    "input": "Translate into first-order logic: The SAT test is wholly owned and developed by the College Board.",
    "output": "Own(sat, collegeBoard) ∧ ¬Own(sat, others)"
  },
  {
    "input": "Translate into first-order logic: The SAT test is intended to assess student's readiness for college.",
    "output": "Test(sat, readiness)"
  },
  {
    "input": "Translate into first-order logic: The SAT was originally designed not to be aligned with high school curricula.",
    "output": "∀x (Year(x) ∧ Before2016(x) → ¬AlignHighSchool(x)) "
  },
  {
    "input": "Translate into first-order logic: Several adjustments were made for the version of the SAT introduced in 2016 to reflect more closely on what students learn in high school.",
    "output": "∃x (Year(x) ∧ Since2016(x) ∧ AlignHighSchool(x)) "
  },
  {
    "input": "Translate into first-order logic: The SAT test is wholly owned and developed by the College Board.",
    "output": "Own(sat, collegeBoard) ∧ ¬Own(sat, others)"
  },
  {
    "input": "Translate into first-order logic: The SAT test is intended to assess student's readiness for college.",
    "output": "Test(sat, readiness)"
  },
  {
    "input": "Translate into first-order logic: The SAT was originally designed not to be aligned with high school curricula.",
    "output": "∀x (Year(x) ∧ Before2016(x) → ¬AlignHighSchool(x)) "
  },
  {
    "input": "Translate into first-order logic: Several adjustments were made for the version of the SAT introduced in 2016 to reflect more closely on what students learn in high school.",
    "output": "∃x (Year(x) ∧ Since2016(x) ∧ AlignHighSchool(x)) "
  },
  {
    "input": "Translate into first-order logic: The SAT test is wholly owned and developed by the College Board.",
    "output": "Own(sat, collegeBoard) ∧ ¬Own(sat, others)"
  },
  {
    "input": "Translate into first-order logic: The SAT test is intended to assess student's readiness for college.",
    "output": "Test(sat, readiness)"
  },
  {
    "input": "Translate into first-order logic: The SAT was originally designed not to be aligned with high school curricula.",
    "output": "∀x (Year(x) ∧ Before2016(x) → ¬AlignHighSchool(x)) "
  },
  {
    "input": "Translate into first-order logic: Several adjustments were made for the version of the SAT introduced in 2016 to reflect more closely on what students learn in high school.",
    "output": "∃x (Year(x) ∧ Since2016(x) ∧ AlignHighSchool(x)) "
  },
  {
    "input": "Translate into first-order logic: Rafa Nadal was born in Mallorca.",
    "output": "BornIn(rafaNadal, mallorca)"
  },
  {
    "input": "Translate into first-order logic: Rafa Nadal is a professional tennis player.",
    "output": "ProfessionalTennisPlayer(rafaNadal)"
  },
  {
    "input": "Translate into first-order logic: Nadal's win ratio is higher than 80%.",
    "output": "HighWinRatio(rafaNadal)"
  },
  {
    "input": "Translate into first-order logic: All players in the Big 3 are professionals who have a high win ratio.",
    "output": "∀x (ProfessionalTennisPlayer(x) ∧ HighWinRatio(x) → InBig3(x))"
  },
  {
    "input": "Translate into first-order logic: Rafa Nadal was born in Mallorca.",
    "output": "BornIn(rafaNadal, mallorca)"
  },
  {
    "input": "Translate into first-order logic: Rafa Nadal is a professional tennis player.",
    "output": "ProfessionalTennisPlayer(rafaNadal)"
  },
  {
    "input": "Translate into first-order logic: Nadal's win ratio is higher than 80%.",
    "output": "HighWinRatio(rafaNadal)"
  },
  {
    "input": "Translate into first-order logic: All players in the Big 3 are professionals who have a high win ratio.",
    "output": "∀x (ProfessionalTennisPlayer(x) ∧ HighWinRatio(x) → InBig3(x))"
  },
  {
    "input": "Translate into first-order logic: Rafa Nadal was born in Mallorca.",
    "output": "BornIn(rafaNadal, mallorca)"
  },
  {
    "input": "Translate into first-order logic: Rafa Nadal is a professional tennis player.",
    "output": "ProfessionalTennisPlayer(rafaNadal)"
  },
  {
    "input": "Translate into first-order logic: Nadal's win ratio is higher than 80%.",
    "output": "HighWinRatio(rafaNadal)"
  },
  {
    "input": "Translate into first-order logic: All players in the Big 3 are professionals who have a high win ratio.",
    "output": "∀x (ProfessionalTennisPlayer(x) ∧ HighWinRatio(x) → InBig3(x))"
  },
  {
    "input": "Translate into first-order logic: No cookie is healthy.",
    "output": "∀x (Cookie(x) → ¬Healthy(x))"
  },
  {
    "input": "Translate into first-order logic: All oreos are cookies.",
    "output": "∀x (Oreo(x) → Cookie(x))"
  },
  {
    "input": "Translate into first-order logic: No animals are plants.",
    "output": "∀x (Animal(x) → ¬Plant(x))"
  },
  {
    "input": "Translate into first-order logic: All humans are animals.",
    "output": "∀x (Human(x) → Animal(x))"
  },
  {
    "input": "Translate into first-order logic: All pupils are human.",
    "output": "∀x (Pupil(x) → Human(x))"
  },
  {
    "input": "Translate into first-order logic: All flowers are plants.",
    "output": "∀x (Flower(x) → Plant(x))"
  },
  {
    "input": "Translate into first-order logic: If Jack is a human or a flower, then Jack is a human and a flower.",
    "output": "Human(jack) ∨ Flower(jack) → Human(jack) ∧ Flower(jack)"
  },
  {
    "input": "Translate into first-order logic: No animals are plants.",
    "output": "∀x (Animal(x) → ¬Plant(x))"
  },
  {
    "input": "Translate into first-order logic: All humans are animals.",
    "output": "∀x (Human(x) → Animal(x))"
  },
  {
    "input": "Translate into first-order logic: All pupils are human.",
    "output": "∀x (Pupil(x) → Human(x))"
  },
  {
    "input": "Translate into first-order logic: All flowers are plants.",
    "output": "∀x (Flower(x) → Plant(x))"
  },
  {
    "input": "Translate into first-order logic: If Jack is a human or a flower, then Jack is a human and a flower.",
    "output": "Human(jack) ∨ Flower(jack) → Human(jack) ∧ Flower(jack)"
  },
  {
    "input": "Translate into first-order logic: No animals are plants.",
    "output": "∀x (Animal(x) → ¬Plant(x))"
  },
  {
    "input": "Translate into first-order logic: All humans are animals.",
    "output": "∀x (Human(x) → Animal(x))"
  },
  {
    "input": "Translate into first-order logic: All pupils are human.",
    "output": "∀x (Pupil(x) → Human(x))"
  },
  {
    "input": "Translate into first-order logic: All flowers are plants.",
    "output": "∀x (Flower(x) → Plant(x))"
  },
  {
    "input": "Translate into first-order logic: If Jack is a human or a flower, then Jack is a human and a flower.",
    "output": "Human(jack) ∨ Flower(jack) → Human(jack) ∧ Flower(jack)"
  },
  {
    "input": "Translate into first-order logic: No animals are plants.",
    "output": "∀x (Animal(x) → ¬Plant(x))"
  },
  {
    "input": "Translate into first-order logic: All humans are animals.",
    "output": "∀x (Human(x) → Animal(x))"
  },
  {
    "input": "Translate into first-order logic: All pupils are human.",
    "output": "∀x (Pupil(x) → Human(x))"
  },
  {
    "input": "Translate into first-order logic: All flowers are plants.",
    "output": "∀x (Flower(x) → Plant(x))"
  },
  {
    "input": "Translate into first-order logic: If Jack is a human or a flower, then Jack is a human and a flower.",
    "output": "Human(jack) ∨ Flower(jack) → Human(jack) ∧ Flower(jack)"
  },
  {
    "input": "Translate into first-order logic: No shoes are food.",
    "output": "∀x (Shoes(x) → ¬Food(x))"
  },
  {
    "input": "Translate into first-order logic: All slippers are shoes.",
    "output": "∀x (Slipper(x) → Shoes(x))"
  },
  {
    "input": "Translate into first-order logic: A thing is either food or clothes.",
    "output": "∀x (Food(x) ⊕ Clothes(x))"
  },
  {
    "input": "Translate into first-order logic: No wearable things are airtight.",
    "output": "∀x (Wearable(x) → ¬AirTight(x))"
  },
  {
    "input": "Translate into first-order logic: All clothes are wearable.",
    "output": "∀x (Clothes(x) → Wearable(x))"
  },
  {
    "input": "Translate into first-order logic: If a watch is not airtight and clothes, then a watch is either both airtight and clothes, or neither airtight nor clothes.",
    "output": "¬(AirTight(watch) ∧ Clothes(watch)) → (AirTight(watch) ∧ Clothes(watch)) ⊕ (¬AirTight(watch) ∧ ¬Clothes(watch))"
  },
  {
    "input": "Translate into first-order logic: No shoes are food.",
    "output": "∀x (Shoes(x) → ¬Food(x))"
  },
  {
    "input": "Translate into first-order logic: All slippers are shoes.",
    "output": "∀x (Slipper(x) → Shoes(x))"
  },
  {
    "input": "Translate into first-order logic: A thing is either food or clothes.",
    "output": "∀x (Food(x) ⊕ Clothes(x))"
  },
  {
    "input": "Translate into first-order logic: No wearable things are airtight.",
    "output": "∀x (Wearable(x) → ¬AirTight(x))"
  },
  {
    "input": "Translate into first-order logic: All clothes are wearable.",
    "output": "∀x (Clothes(x) → Wearable(x))"
  },
  {
    "input": "Translate into first-order logic: If a watch is not airtight and clothes, then a watch is either both airtight and clothes, or neither airtight nor clothes.",
    "output": "¬(AirTight(watch) ∧ Clothes(watch)) → (AirTight(watch) ∧ Clothes(watch)) ⊕ (¬AirTight(watch) ∧ ¬Clothes(watch))"
  },
  {
    "input": "Translate into first-order logic: No shoes are food.",
    "output": "∀x (Shoes(x) → ¬Food(x))"
  },
  {
    "input": "Translate into first-order logic: All slippers are shoes.",
    "output": "∀x (Slipper(x) → Shoes(x))"
  },
  {
    "input": "Translate into first-order logic: A thing is either food or clothes.",
    "output": "∀x (Food(x) ⊕ Clothes(x))"
  },
  {
    "input": "Translate into first-order logic: No wearable things are airtight.",
    "output": "∀x (Wearable(x) → ¬AirTight(x))"
  },
  {
    "input": "Translate into first-order logic: All clothes are wearable.",
    "output": "∀x (Clothes(x) → Wearable(x))"
  },
  {
    "input": "Translate into first-order logic: If a watch is not airtight and clothes, then a watch is either both airtight and clothes, or neither airtight nor clothes.",
    "output": "¬(AirTight(watch) ∧ Clothes(watch)) → (AirTight(watch) ∧ Clothes(watch)) ⊕ (¬AirTight(watch) ∧ ¬Clothes(watch))"
  },
  {
    "input": "Translate into first-order logic: An Olympian is a person who trains for an Olympic sport and goes to the Olympics.",
    "output": "∀x (DoesOlympicSport(x) ∧ GoesToOlympicGames(x) → IsOlympian(x))"
  },
  {
    "input": "Translate into first-order logic: Carlos Reyes trains for an Olympic sport.",
    "output": "DoesOlympicSport(carlosReyes)"
  },
  {
    "input": "Translate into first-order logic: Carlos Reyes went to the Olympics.",
    "output": "GoesToOlympicGames(carlosReyes)"
  },
  {
    "input": "Translate into first-order logic: Carlos Reyes is a welterweight.",
    "output": "IsWelterWeight(carlosReyes)"
  },
  {
    "input": "Translate into first-order logic: Heavy weights are not welterweights.",
    "output": "∀x (IsWelterWeight(x) → ¬IsHeavyWeight(x))"
  },
  {
    "input": "Translate into first-order logic: An Olympian is a person who trains for an Olympic sport and goes to the Olympics.",
    "output": "∀x (DoesOlympicSport(x) ∧ GoesToOlympicGames(x) → IsOlympian(x))"
  },
  {
    "input": "Translate into first-order logic: Carlos Reyes trains for an Olympic sport.",
    "output": "DoesOlympicSport(carlosReyes)"
  },
  {
    "input": "Translate into first-order logic: Carlos Reyes went to the Olympics.",
    "output": "GoesToOlympicGames(carlosReyes)"
  },
  {
    "input": "Translate into first-order logic: Carlos Reyes is a welterweight.",
    "output": "IsWelterWeight(carlosReyes)"
  },
  {
    "input": "Translate into first-order logic: Heavy weights are not welterweights.",
    "output": "∀x (IsWelterWeight(x) → ¬IsHeavyWeight(x))"
  },
  {
    "input": "Translate into first-order logic: An Olympian is a person who trains for an Olympic sport and goes to the Olympics.",
    "output": "∀x (DoesOlympicSport(x) ∧ GoesToOlympicGames(x) → IsOlympian(x))"
  },
  {
    "input": "Translate into first-order logic: Carlos Reyes trains for an Olympic sport.",
    "output": "DoesOlympicSport(carlosReyes)"
  },
  {
    "input": "Translate into first-order logic: Carlos Reyes went to the Olympics.",
    "output": "GoesToOlympicGames(carlosReyes)"
  },
  {
    "input": "Translate into first-order logic: Carlos Reyes is a welterweight.",
    "output": "IsWelterWeight(carlosReyes)"
  },
  {
    "input": "Translate into first-order logic: Heavy weights are not welterweights.",
    "output": "∀x (IsWelterWeight(x) → ¬IsHeavyWeight(x))"
  },
  {
    "input": "Translate into first-order logic: If people have a lot of decorations in their room, they cannot pack and move out of their rooms very easily.",
    "output": "∀x (Decor(x) → ¬MoveOut(x))"
  },
  {
    "input": "Translate into first-order logic: If people have high ambitions and future career goals, then they can pack and move out of their rooms very easily.",
    "output": "∀x (Ambitious(x) → MoveOut(x))"
  },
  {
    "input": "Translate into first-order logic: If people are big fans of pop bands and singers, then they have a lot of decorations in their room.",
    "output": "∀x (Fans(x) → Decor(x))"
  },
  {
    "input": "Translate into first-order logic: All young teenage girls who attend college are big fans of pop bands and singers.",
    "output": "∀x (CollegeTeen(x) → Ambitious(x))"
  },
  {
    "input": "Translate into first-order logic: If Sam has high ambitions and future career goals, then Sam is a big fan of pop bands and singers.",
    "output": "Ambitious(sam) → Fans(sam)"
  },
  {
    "input": "Translate into first-order logic: If people have a lot of decorations in their room, they cannot pack and move out of their rooms very easily.",
    "output": "∀x (Decor(x) → ¬MoveOut(x))"
  },
  {
    "input": "Translate into first-order logic: If people have high ambitions and future career goals, then they can pack and move out of their rooms very easily.",
    "output": "∀x (Ambitious(x) → MoveOut(x))"
  },
  {
    "input": "Translate into first-order logic: If people are big fans of pop bands and singers, then they have a lot of decorations in their room.",
    "output": "∀x (Fans(x) → Decor(x))"
  },
  {
    "input": "Translate into first-order logic: All young teenage girls who attend college are big fans of pop bands and singers.",
    "output": "∀x (CollegeTeen(x) → Ambitious(x))"
  },
  {
    "input": "Translate into first-order logic: If Sam has high ambitions and future career goals, then Sam is a big fan of pop bands and singers.",
    "output": "Ambitious(sam) → Fans(sam)"
  },
  {
    "input": "Translate into first-order logic: If people have a lot of decorations in their room, they cannot pack and move out of their rooms very easily.",
    "output": "∀x (Decor(x) → ¬MoveOut(x))"
  },
  {
    "input": "Translate into first-order logic: If people have high ambitions and future career goals, then they can pack and move out of their rooms very easily.",
    "output": "∀x (Ambitious(x) → MoveOut(x))"
  },
  {
    "input": "Translate into first-order logic: If people are big fans of pop bands and singers, then they have a lot of decorations in their room.",
    "output": "∀x (Fans(x) → Decor(x))"
  },
  {
    "input": "Translate into first-order logic: All young teenage girls who attend college are big fans of pop bands and singers.",
    "output": "∀x (CollegeTeen(x) → Ambitious(x))"
  },
  {
    "input": "Translate into first-order logic: If Sam has high ambitions and future career goals, then Sam is a big fan of pop bands and singers.",
    "output": "Ambitious(sam) → Fans(sam)"
  },
  {
    "input": "Translate into first-order logic: If people have a lot of decorations in their room, they cannot pack and move out of their rooms very easily.",
    "output": "∀x (Decor(x) → ¬MoveOut(x))"
  },
  {
    "input": "Translate into first-order logic: If people have high ambitions and future career goals, then they can pack and move out of their rooms very easily.",
    "output": "∀x (Ambitious(x) → MoveOut(x))"
  },
  {
    "input": "Translate into first-order logic: If people are big fans of pop bands and singers, then they have a lot of decorations in their room.",
    "output": "∀x (Fans(x) → Decor(x))"
  },
  {
    "input": "Translate into first-order logic: All young teenage girls who attend college are big fans of pop bands and singers.",
    "output": "∀x (CollegeTeen(x) → Ambitious(x))"
  },
  {
    "input": "Translate into first-order logic: If Sam has high ambitions and future career goals, then Sam is a big fan of pop bands and singers.",
    "output": "Ambitious(sam) → Fans(sam)"
  },
  {
    "input": "Translate into first-order logic: If people have a lot of decorations in their room, they cannot pack and move out of their rooms very easily.",
    "output": "∀x (Decor(x) → ¬MoveOut(x))"
  },
  {
    "input": "Translate into first-order logic: If people have high ambitions and future career goals, then they can pack and move out of their rooms very easily.",
    "output": "∀x (Ambitious(x) → MoveOut(x))"
  },
  {
    "input": "Translate into first-order logic: If people are big fans of pop bands and singers, then they have a lot of decorations in their room.",
    "output": "∀x (Fans(x) → Decor(x))"
  },
  {
    "input": "Translate into first-order logic: All young teenage girls who attend college are big fans of pop bands and singers.",
    "output": "∀x (CollegeTeen(x) → Ambitious(x))"
  },
  {
    "input": "Translate into first-order logic: If Sam has high ambitions and future career goals, then Sam is a big fan of pop bands and singers.",
    "output": "Ambitious(sam) → Fans(sam)"
  },
  {
    "input": "Translate into first-order logic: If people have a lot of decorations in their room, they cannot pack and move out of their rooms very easily.",
    "output": "∀x (Decor(x) → ¬MoveOut(x))"
  },
  {
    "input": "Translate into first-order logic: If people have high ambitions and future career goals, then they can pack and move out of their rooms very easily.",
    "output": "∀x (Ambitious(x) → MoveOut(x))"
  },
  {
    "input": "Translate into first-order logic: If people are big fans of pop bands and singers, then they have a lot of decorations in their room.",
    "output": "∀x (Fans(x) → Decor(x))"
  },
  {
    "input": "Translate into first-order logic: All young teenage girls who attend college are big fans of pop bands and singers.",
    "output": "∀x (CollegeTeen(x) → Ambitious(x))"
  },
  {
    "input": "Translate into first-order logic: If Sam has high ambitions and future career goals, then Sam is a big fan of pop bands and singers.",
    "output": "Ambitious(sam) → Fans(sam)"
  },
  {
    "input": "Translate into first-order logic: If people have a lot of decorations in their room, they cannot pack and move out of their rooms very easily.",
    "output": "∀x (Decor(x) → ¬MoveOut(x))"
  },
  {
    "input": "Translate into first-order logic: If people have high ambitions and future career goals, then they can pack and move out of their rooms very easily.",
    "output": "∀x (Ambitious(x) → MoveOut(x))"
  },
  {
    "input": "Translate into first-order logic: If people are big fans of pop bands and singers, then they have a lot of decorations in their room.",
    "output": "∀x (Fans(x) → Decor(x))"
  },
  {
    "input": "Translate into first-order logic: All young teenage girls who attend college are big fans of pop bands and singers.",
    "output": "∀x (CollegeTeen(x) → Ambitious(x))"
  },
  {
    "input": "Translate into first-order logic: If Sam has high ambitions and future career goals, then Sam is a big fan of pop bands and singers.",
    "output": "Ambitious(sam) → Fans(sam)"
  },
  {
    "input": "Translate into first-order logic: If people have a lot of decorations in their room, they cannot pack and move out of their rooms very easily.",
    "output": "∀x (Decor(x) → ¬MoveOut(x))"
  },
  {
    "input": "Translate into first-order logic: If people have high ambitions and future career goals, then they can pack and move out of their rooms very easily.",
    "output": "∀x (Ambitious(x) → MoveOut(x))"
  },
  {
    "input": "Translate into first-order logic: If people are big fans of pop bands and singers, then they have a lot of decorations in their room.",
    "output": "∀x (Fans(x) → Decor(x))"
  },
  {
    "input": "Translate into first-order logic: All young teenage girls who attend college are big fans of pop bands and singers.",
    "output": "∀x (CollegeTeen(x) → Ambitious(x))"
  },
  {
    "input": "Translate into first-order logic: If Sam has high ambitions and future career goals, then Sam is a big fan of pop bands and singers.",
    "output": "Ambitious(sam) → Fans(sam)"
  },
  {
    "input": "Translate into first-order logic: If people have a lot of decorations in their room, they cannot pack and move out of their rooms very easily.",
    "output": "∀x (Decor(x) → ¬MoveOut(x))"
  },
  {
    "input": "Translate into first-order logic: If people have high ambitions and future career goals, then they can pack and move out of their rooms very easily.",
    "output": "∀x (Ambitious(x) → MoveOut(x))"
  },
  {
    "input": "Translate into first-order logic: If people are big fans of pop bands and singers, then they have a lot of decorations in their room.",
    "output": "∀x (Fans(x) → Decor(x))"
  },
  {
    "input": "Translate into first-order logic: All young teenage girls who attend college are big fans of pop bands and singers.",
    "output": "∀x (CollegeTeen(x) → Ambitious(x))"
  },
  {
    "input": "Translate into first-order logic: If Sam has high ambitions and future career goals, then Sam is a big fan of pop bands and singers.",
    "output": "Ambitious(sam) → Fans(sam)"
  },
  {
    "input": "Translate into first-order logic: A student who loves shrieking will be punished.",
    "output": "∀x (Student(x) ∧ Shriek(x) → Punished(x))"
  },
  {
    "input": "Translate into first-order logic: If a person swears, then he is a student.",
    "output": "∀x (Swear(x) → Student(x))"
  },
  {
    "input": "Translate into first-order logic: If someone is a teacher, then Bob will talk to him.",
    "output": "∀x (Teacher(x) → Talk(bob, x))"
  },
  {
    "input": "Translate into first-order logic: All gentlemen are in a suit.",
    "output": "∀x (Gentleman(x) → Suit(x))"
  },
  {
    "input": "Translate into first-order logic: All teachers are men.",
    "output": "∀x (Teacher(x) → Man(x))"
  },
  {
    "input": "Translate into first-order logic: There is a teacher.",
    "output": "∃x (Teacher(x))"
  },
  {
    "input": "Translate into first-order logic: If someone is not a gentlemen, then he is not nice.",
    "output": "∀x (¬Gentleman(x) → ¬Nice(x))"
  },
  {
    "input": "Translate into first-order logic: Willy is nice.",
    "output": "Nice(willy)"
  },
  {
    "input": "Translate into first-order logic: Bob loves shrieking and swearing.",
    "output": "Shriek(bob) ∧ Swear(bob)"
  },
  {
    "input": "Translate into first-order logic: A student who loves shrieking will be punished.",
    "output": "∀x (Student(x) ∧ Shriek(x) → Punished(x))"
  },
  {
    "input": "Translate into first-order logic: If a person swears, then he is a student.",
    "output": "∀x (Swear(x) → Student(x))"
  },
  {
    "input": "Translate into first-order logic: If someone is a teacher, then Bob will talk to him.",
    "output": "∀x (Teacher(x) → Talk(bob, x))"
  },
  {
    "input": "Translate into first-order logic: All gentlemen are in a suit.",
    "output": "∀x (Gentleman(x) → Suit(x))"
  },
  {
    "input": "Translate into first-order logic: All teachers are men.",
    "output": "∀x (Teacher(x) → Man(x))"
  },
  {
    "input": "Translate into first-order logic: There is a teacher.",
    "output": "∃x (Teacher(x))"
  },
  {
    "input": "Translate into first-order logic: If someone is not a gentlemen, then he is not nice.",
    "output": "∀x (¬Gentleman(x) → ¬Nice(x))"
  },
  {
    "input": "Translate into first-order logic: Willy is nice.",
    "output": "Nice(willy)"
  },
  {
    "input": "Translate into first-order logic: Bob loves shrieking and swearing.",
    "output": "Shriek(bob) ∧ Swear(bob)"
  },
  {
    "input": "Translate into first-order logic: A student who loves shrieking will be punished.",
    "output": "∀x (Student(x) ∧ Shriek(x) → Punished(x))"
  },
  {
    "input": "Translate into first-order logic: If a person swears, then he is a student.",
    "output": "∀x (Swear(x) → Student(x))"
  },
  {
    "input": "Translate into first-order logic: If someone is a teacher, then Bob will talk to him.",
    "output": "∀x (Teacher(x) → Talk(bob, x))"
  },
  {
    "input": "Translate into first-order logic: All gentlemen are in a suit.",
    "output": "∀x (Gentleman(x) → Suit(x))"
  },
  {
    "input": "Translate into first-order logic: All teachers are men.",
    "output": "∀x (Teacher(x) → Man(x))"
  },
  {
    "input": "Translate into first-order logic: There is a teacher.",
    "output": "∃x (Teacher(x))"
  },
  {
    "input": "Translate into first-order logic: If someone is not a gentlemen, then he is not nice.",
    "output": "∀x (¬Gentleman(x) → ¬Nice(x))"
  },
  {
    "input": "Translate into first-order logic: Willy is nice.",
    "output": "Nice(willy)"
  },
  {
    "input": "Translate into first-order logic: Bob loves shrieking and swearing.",
    "output": "Shriek(bob) ∧ Swear(bob)"
  },
  {
    "input": "Translate into first-order logic: Quincy McDuffie is an American professional wide receiver in Canadian Football.",
    "output": "American(quincymcduffie) ∧ Professional(quincymcduffie) ∧ WideReciever(quincymcduffie) ∧ In(quincymcduffie, canadianfootball)"
  },
  {
    "input": "Translate into first-order logic: People who can catch balls are good wide receivers.",
    "output": "∀x ∃y (CanCatch(x, y) ∧ Ball(y) → Good(x, widereciever))"
  },
  {
    "input": "Translate into first-order logic: Quincy McDuffie can catch many footballs easily.",
    "output": "∃x (Football(x) ∧ CanCatch(quincymcduffie, x))"
  },
  {
    "input": "Translate into first-order logic: Good wide receivers play professionally.",
    "output": "∀x (Good(x, widereciever) → Professional(x))"
  },
  {
    "input": "Translate into first-order logic: Good wide receivers can catch with both their left and right hand.",
    "output": "∀x (Good(x, widereciever) → CanCatchWith(x, lefthand) ∧ CanCatchWith(x, righthand))"
  },
  {
    "input": "Translate into first-order logic: All footballs are balls.",
    "output": "∀x (Football(x) → Ball(x))"
  },
  {
    "input": "Translate into first-order logic: Quincy McDuffie is an American professional wide receiver in Canadian Football.",
    "output": "American(quincymcduffie) ∧ Professional(quincymcduffie) ∧ WideReciever(quincymcduffie) ∧ In(quincymcduffie, canadianfootball)"
  },
  {
    "input": "Translate into first-order logic: People who can catch balls are good wide receivers.",
    "output": "∀x ∃y (CanCatch(x, y) ∧ Ball(y) → Good(x, widereciever))"
  },
  {
    "input": "Translate into first-order logic: Quincy McDuffie can catch many footballs easily.",
    "output": "∃x (Football(x) ∧ CanCatch(quincymcduffie, x))"
  },
  {
    "input": "Translate into first-order logic: Good wide receivers play professionally.",
    "output": "∀x (Good(x, widereciever) → Professional(x))"
  },
  {
    "input": "Translate into first-order logic: Good wide receivers can catch with both their left and right hand.",
    "output": "∀x (Good(x, widereciever) → CanCatchWith(x, lefthand) ∧ CanCatchWith(x, righthand))"
  },
  {
    "input": "Translate into first-order logic: All footballs are balls.",
    "output": "∀x (Football(x) → Ball(x))"
  },
  {
    "input": "Translate into first-order logic: Quincy McDuffie is an American professional wide receiver in Canadian Football.",
    "output": "American(quincymcduffie) ∧ Professional(quincymcduffie) ∧ WideReciever(quincymcduffie) ∧ In(quincymcduffie, canadianfootball)"
  },
  {
    "input": "Translate into first-order logic: People who can catch balls are good wide receivers.",
    "output": "∀x ∃y (CanCatch(x, y) ∧ Ball(y) → Good(x, widereciever))"
  },
  {
    "input": "Translate into first-order logic: Quincy McDuffie can catch many footballs easily.",
    "output": "∃x (Football(x) ∧ CanCatch(quincymcduffie, x))"
  },
  {
    "input": "Translate into first-order logic: Good wide receivers play professionally.",
    "output": "∀x (Good(x, widereciever) → Professional(x))"
  },
  {
    "input": "Translate into first-order logic: Good wide receivers can catch with both their left and right hand.",
    "output": "∀x (Good(x, widereciever) → CanCatchWith(x, lefthand) ∧ CanCatchWith(x, righthand))"
  },
  {
    "input": "Translate into first-order logic: All footballs are balls.",
    "output": "∀x (Football(x) → Ball(x))"
  },
  {
    "input": "Translate into first-order logic: Boves is a railway station located in France.",
    "output": "RailwayStation(boves) ∧ Locate(boves, france)"
  },
  {
    "input": "Translate into first-order logic: The preceding station of Boves is Longueau.",
    "output": "Precede(boves, longueau)"
  },
  {
    "input": "Translate into first-order logic: The preceding station of Dommartin is Boves.",
    "output": "Precede(dommartin, boves)"
  },
  {
    "input": "Translate into first-order logic: France is a European country.",
    "output": "Locate(france, europe)"
  },
  {
    "input": "Translate into first-order logic: Dommartin is situated on the Paris–Lille railway.",
    "output": "Situate(dommartin, pairsLille)"
  },
  {
    "input": "Translate into first-order logic: Any two contiguous stations are on the same railway.",
    "output": "∀x ∀y ∀z ((Situate(x, z) ∧ (Precede(x, y) ∨ Precede(y, x))) → Situate(y, z))"
  },
  {
    "input": "Translate into first-order logic: Boves is served by regional TER Hauts-de-France trains.",
    "output": "Serve(hautsDeFrance, boves)"
  },
  {
    "input": "Translate into first-order logic: If A is located in B and B is located in C, then A is located in C.",
    "output": "∀x ∀y ∀z ((Locate(x, y) ∧ Locate(y, z)) → Locate(x, z))"
  },
  {
    "input": "Translate into first-order logic: If A precedes B and B preceds C, than A preceds C.",
    "output": "∀x ∀y ∀z ((Precede(x, y) ∧ Precede(y, z)) → Precede(x, z))"
  },
  {
    "input": "Translate into first-order logic: Boves is a railway station located in France.",
    "output": "RailwayStation(boves) ∧ Locate(boves, france)"
  },
  {
    "input": "Translate into first-order logic: The preceding station of Boves is Longueau.",
    "output": "Precede(boves, longueau)"
  },
  {
    "input": "Translate into first-order logic: The preceding station of Dommartin is Boves.",
    "output": "Precede(dommartin, boves)"
  },
  {
    "input": "Translate into first-order logic: France is a European country.",
    "output": "Locate(france, europe)"
  },
  {
    "input": "Translate into first-order logic: Dommartin is situated on the Paris–Lille railway.",
    "output": "Situate(dommartin, pairsLille)"
  },
  {
    "input": "Translate into first-order logic: Any two contiguous stations are on the same railway.",
    "output": "∀x ∀y ∀z ((Situate(x, z) ∧ (Precede(x, y) ∨ Precede(y, x))) → Situate(y, z))"
  },
  {
    "input": "Translate into first-order logic: Boves is served by regional TER Hauts-de-France trains.",
    "output": "Serve(hautsDeFrance, boves)"
  },
  {
    "input": "Translate into first-order logic: If A is located in B and B is located in C, then A is located in C.",
    "output": "∀x ∀y ∀z ((Locate(x, y) ∧ Locate(y, z)) → Locate(x, z))"
  },
  {
    "input": "Translate into first-order logic: If A precedes B and B preceds C, than A preceds C.",
    "output": "∀x ∀y ∀z ((Precede(x, y) ∧ Precede(y, z)) → Precede(x, z))"
  },
  {
    "input": "Translate into first-order logic: Boves is a railway station located in France.",
    "output": "RailwayStation(boves) ∧ Locate(boves, france)"
  },
  {
    "input": "Translate into first-order logic: The preceding station of Boves is Longueau.",
    "output": "Precede(boves, longueau)"
  },
  {
    "input": "Translate into first-order logic: The preceding station of Dommartin is Boves.",
    "output": "Precede(dommartin, boves)"
  },
  {
    "input": "Translate into first-order logic: France is a European country.",
    "output": "Locate(france, europe)"
  },
  {
    "input": "Translate into first-order logic: Dommartin is situated on the Paris–Lille railway.",
    "output": "Situate(dommartin, pairsLille)"
  },
  {
    "input": "Translate into first-order logic: Any two contiguous stations are on the same railway.",
    "output": "∀x ∀y ∀z ((Situate(x, z) ∧ (Precede(x, y) ∨ Precede(y, x))) → Situate(y, z))"
  },
  {
    "input": "Translate into first-order logic: Boves is served by regional TER Hauts-de-France trains.",
    "output": "Serve(hautsDeFrance, boves)"
  },
  {
    "input": "Translate into first-order logic: If A is located in B and B is located in C, then A is located in C.",
    "output": "∀x ∀y ∀z ((Locate(x, y) ∧ Locate(y, z)) → Locate(x, z))"
  },
  {
    "input": "Translate into first-order logic: If A precedes B and B preceds C, than A preceds C.",
    "output": "∀x ∀y ∀z ((Precede(x, y) ∧ Precede(y, z)) → Precede(x, z))"
  },
  {
    "input": "Translate into first-order logic: Edwin Smith was a New Zealand Rower from Auckland.",
    "output": "From(edwinsmith, newzealand) ∧ Rower(edwinsmith) ∧ From(edwinsmith, auckland)"
  },
  {
    "input": "Translate into first-order logic: Edwin Smith was also known as Ted Smith.",
    "output": "KnownAs(edwinsmith, tedsmith)"
  },
  {
    "input": "Translate into first-order logic: Edwin Smith went to Rose Road Primary School, located in Grey Lynn.",
    "output": "WentTo(edwinsmith, roseroadprimaryschool) ∧ LocatedIn(roseroadprimaryschool, greylynn)"
  },
  {
    "input": "Translate into first-order logic: Edwin Smith was a sergeant who served with the New Zealand 24th battalion in Italy and Egypt.",
    "output": "Sergeant(edwinsmith) ∧ ServedWith(edwinsmith, newzealand24thbattalion) ∧ ServedIn(edwinsmith, italy) ∧ ServedIn(edwinsmith, egypt)"
  },
  {
    "input": "Translate into first-order logic: Broadway Sheetmetals was a buisness that was ran and owned by Edwin Smith, who was a sheetmetal worker.",
    "output": "Buisness(broadwaysheetmetals) ∧ Ran(edwinsmith, broadwaysheetmetals) ∧ Owned(edwinsmith, broadwaysheetmetals) ∧ SheetmetalWorker(edwinsmith)"
  },
  {
    "input": "Translate into first-order logic: Edwin Smith was a New Zealand Rower from Auckland.",
    "output": "From(edwinsmith, newzealand) ∧ Rower(edwinsmith) ∧ From(edwinsmith, auckland)"
  },
  {
    "input": "Translate into first-order logic: Edwin Smith was also known as Ted Smith.",
    "output": "KnownAs(edwinsmith, tedsmith)"
  },
  {
    "input": "Translate into first-order logic: Edwin Smith went to Rose Road Primary School, located in Grey Lynn.",
    "output": "WentTo(edwinsmith, roseroadprimaryschool) ∧ LocatedIn(roseroadprimaryschool, greylynn)"
  },
  {
    "input": "Translate into first-order logic: Edwin Smith was a sergeant who served with the New Zealand 24th battalion in Italy and Egypt.",
    "output": "Sergeant(edwinsmith) ∧ ServedWith(edwinsmith, newzealand24thbattalion) ∧ ServedIn(edwinsmith, italy) ∧ ServedIn(edwinsmith, egypt)"
  },
  {
    "input": "Translate into first-order logic: Broadway Sheetmetals was a buisness that was ran and owned by Edwin Smith, who was a sheetmetal worker.",
    "output": "Buisness(broadwaysheetmetals) ∧ Ran(edwinsmith, broadwaysheetmetals) ∧ Owned(edwinsmith, broadwaysheetmetals) ∧ SheetmetalWorker(edwinsmith)"
  },
  {
    "input": "Translate into first-order logic: Edwin Smith was a New Zealand Rower from Auckland.",
    "output": "From(edwinsmith, newzealand) ∧ Rower(edwinsmith) ∧ From(edwinsmith, auckland)"
  },
  {
    "input": "Translate into first-order logic: Edwin Smith was also known as Ted Smith.",
    "output": "KnownAs(edwinsmith, tedsmith)"
  },
  {
    "input": "Translate into first-order logic: Edwin Smith went to Rose Road Primary School, located in Grey Lynn.",
    "output": "WentTo(edwinsmith, roseroadprimaryschool) ∧ LocatedIn(roseroadprimaryschool, greylynn)"
  },
  {
    "input": "Translate into first-order logic: Edwin Smith was a sergeant who served with the New Zealand 24th battalion in Italy and Egypt.",
    "output": "Sergeant(edwinsmith) ∧ ServedWith(edwinsmith, newzealand24thbattalion) ∧ ServedIn(edwinsmith, italy) ∧ ServedIn(edwinsmith, egypt)"
  },
  {
    "input": "Translate into first-order logic: Broadway Sheetmetals was a buisness that was ran and owned by Edwin Smith, who was a sheetmetal worker.",
    "output": "Buisness(broadwaysheetmetals) ∧ Ran(edwinsmith, broadwaysheetmetals) ∧ Owned(edwinsmith, broadwaysheetmetals) ∧ SheetmetalWorker(edwinsmith)"
  },
  {
    "input": "Translate into first-order logic: Edwin Smith was a New Zealand Rower from Auckland.",
    "output": "From(edwinsmith, newzealand) ∧ Rower(edwinsmith) ∧ From(edwinsmith, auckland)"
  },
  {
    "input": "Translate into first-order logic: Edwin Smith was also known as Ted Smith.",
    "output": "KnownAs(edwinsmith, tedsmith)"
  },
  {
    "input": "Translate into first-order logic: Edwin Smith went to Rose Road Primary School, located in Grey Lynn.",
    "output": "WentTo(edwinsmith, roseroadprimaryschool) ∧ LocatedIn(roseroadprimaryschool, greylynn)"
  },
  {
    "input": "Translate into first-order logic: Edwin Smith was a sergeant who served with the New Zealand 24th battalion in Italy and Egypt.",
    "output": "Sergeant(edwinsmith) ∧ ServedWith(edwinsmith, newzealand24thbattalion) ∧ ServedIn(edwinsmith, italy) ∧ ServedIn(edwinsmith, egypt)"
  },
  {
    "input": "Translate into first-order logic: Broadway Sheetmetals was a buisness that was ran and owned by Edwin Smith, who was a sheetmetal worker.",
    "output": "Buisness(broadwaysheetmetals) ∧ Ran(edwinsmith, broadwaysheetmetals) ∧ Owned(edwinsmith, broadwaysheetmetals) ∧ SheetmetalWorker(edwinsmith)"
  },
  {
    "input": "Translate into first-order logic: A werewolf is a human that can turn into a wolf.",
    "output": "∀x (Human(x) ∧ CanTurnInto(x, wolf) → Werewolf(x))"
  },
  {
    "input": "Translate into first-order logic: A werewolf has been scratched or bitten by another werewolf.",
    "output": "∀x ∃y (Werewolf(x) → (BittenBy(x, y) ∨ ScratchedBy(x, y)) ∧ Werewolf(y))"
  },
  {
    "input": "Translate into first-order logic: If someone has been scratched or bitten, they have been attacked.",
    "output": "∀x ∃y (BittenBy(x, y) ∨ ScratchedBy(x, y)) → AttackedBy(x,y)"
  },
  {
    "input": "Translate into first-order logic: A werewolf is a human that can turn into a wolf.",
    "output": "∀x (Human(x) ∧ CanTurnInto(x, wolf) → Werewolf(x))"
  },
  {
    "input": "Translate into first-order logic: A werewolf has been scratched or bitten by another werewolf.",
    "output": "∀x ∃y (Werewolf(x) → (BittenBy(x, y) ∨ ScratchedBy(x, y)) ∧ Werewolf(y))"
  },
  {
    "input": "Translate into first-order logic: If someone has been scratched or bitten, they have been attacked.",
    "output": "∀x ∃y (BittenBy(x, y) ∨ ScratchedBy(x, y)) → AttackedBy(x,y)"
  },
  {
    "input": "Translate into first-order logic: A werewolf is a human that can turn into a wolf.",
    "output": "∀x (Human(x) ∧ CanTurnInto(x, wolf) → Werewolf(x))"
  },
  {
    "input": "Translate into first-order logic: A werewolf has been scratched or bitten by another werewolf.",
    "output": "∀x ∃y (Werewolf(x) → (BittenBy(x, y) ∨ ScratchedBy(x, y)) ∧ Werewolf(y))"
  },
  {
    "input": "Translate into first-order logic: If someone has been scratched or bitten, they have been attacked.",
    "output": "∀x ∃y (BittenBy(x, y) ∨ ScratchedBy(x, y)) → AttackedBy(x,y)"
  },
  {
    "input": "Translate into first-order logic: UFC Fight Night was a mixed martial arts event and was held in Sweden.",
    "output": "Event(uFCFightNight) ∧ MixedMartial(uFCFightNight) ∧ Sweden(uFCFightNight)"
  },
  {
    "input": "Translate into first-order logic: At UFC Fight Night, Sadollah was scheduled to fight Musoke.",
    "output": "Event(uFCFightNight) → ScheduledToFight(sadollah, musoke)"
  },
  {
    "input": "Translate into first-order logic: Sadollah fought Akiyama at UFC Fight Night.",
    "output": "Event(uFCFightNight) → Fight(sadollah, akiyama)"
  },
  {
    "input": "Translate into first-order logic: Musoke fought Yakovlev at UFC Fight Night.",
    "output": "Event(uFCFightNight) → Fight(musoke, yakovlev)"
  },
  {
    "input": "Translate into first-order logic: Jung was injured at UFC Fight Night.",
    "output": "Event(uFCFightNight) → Injured(jung)"
  },
  {
    "input": "Translate into first-order logic: Injured people did not fight at UFC Fight Night.",
    "output": "∀x (Injured(x) → ¬FightInUFC(x))"
  },
  {
    "input": "Translate into first-order logic: UFC Fight Night was a mixed martial arts event and was held in Sweden.",
    "output": "Event(uFCFightNight) ∧ MixedMartial(uFCFightNight) ∧ Sweden(uFCFightNight)"
  },
  {
    "input": "Translate into first-order logic: At UFC Fight Night, Sadollah was scheduled to fight Musoke.",
    "output": "Event(uFCFightNight) → ScheduledToFight(sadollah, musoke)"
  },
  {
    "input": "Translate into first-order logic: Sadollah fought Akiyama at UFC Fight Night.",
    "output": "Event(uFCFightNight) → Fight(sadollah, akiyama)"
  },
  {
    "input": "Translate into first-order logic: Musoke fought Yakovlev at UFC Fight Night.",
    "output": "Event(uFCFightNight) → Fight(musoke, yakovlev)"
  },
  {
    "input": "Translate into first-order logic: Jung was injured at UFC Fight Night.",
    "output": "Event(uFCFightNight) → Injured(jung)"
  },
  {
    "input": "Translate into first-order logic: Injured people did not fight at UFC Fight Night.",
    "output": "∀x (Injured(x) → ¬FightInUFC(x))"
  },
  {
    "input": "Translate into first-order logic: UFC Fight Night was a mixed martial arts event and was held in Sweden.",
    "output": "Event(uFCFightNight) ∧ MixedMartial(uFCFightNight) ∧ Sweden(uFCFightNight)"
  },
  {
    "input": "Translate into first-order logic: At UFC Fight Night, Sadollah was scheduled to fight Musoke.",
    "output": "Event(uFCFightNight) → ScheduledToFight(sadollah, musoke)"
  },
  {
    "input": "Translate into first-order logic: Sadollah fought Akiyama at UFC Fight Night.",
    "output": "Event(uFCFightNight) → Fight(sadollah, akiyama)"
  },
  {
    "input": "Translate into first-order logic: Musoke fought Yakovlev at UFC Fight Night.",
    "output": "Event(uFCFightNight) → Fight(musoke, yakovlev)"
  },
  {
    "input": "Translate into first-order logic: Jung was injured at UFC Fight Night.",
    "output": "Event(uFCFightNight) → Injured(jung)"
  },
  {
    "input": "Translate into first-order logic: Injured people did not fight at UFC Fight Night.",
    "output": "∀x (Injured(x) → ¬FightInUFC(x))"
  },
  {
    "input": "Translate into first-order logic: UFC Fight Night was a mixed martial arts event and was held in Sweden.",
    "output": "Event(uFCFightNight) ∧ MixedMartial(uFCFightNight) ∧ Sweden(uFCFightNight)"
  },
  {
    "input": "Translate into first-order logic: At UFC Fight Night, Sadollah was scheduled to fight Musoke.",
    "output": "Event(uFCFightNight) → ScheduledToFight(sadollah, musoke)"
  },
  {
    "input": "Translate into first-order logic: Sadollah fought Akiyama at UFC Fight Night.",
    "output": "Event(uFCFightNight) → Fight(sadollah, akiyama)"
  },
  {
    "input": "Translate into first-order logic: Musoke fought Yakovlev at UFC Fight Night.",
    "output": "Event(uFCFightNight) → Fight(musoke, yakovlev)"
  },
  {
    "input": "Translate into first-order logic: Jung was injured at UFC Fight Night.",
    "output": "Event(uFCFightNight) → Injured(jung)"
  },
  {
    "input": "Translate into first-order logic: Injured people did not fight at UFC Fight Night.",
    "output": "∀x (Injured(x) → ¬FightInUFC(x))"
  },
  {
    "input": "Translate into first-order logic: All drinks are edible.",
    "output": "∀x (Drink(x) → Edible(x))"
  },
  {
    "input": "Translate into first-order logic: All juices are drinks.",
    "output": "∀x (Juice(x) → Drink(x))"
  },
  {
    "input": "Translate into first-order logic: All orange juice is a juice.",
    "output": "∀x (OrangeJuice(x) → Juice(x))"
  },
  {
    "input": "Translate into first-order logic: A juice is either an orange juice or an apple juice.",
    "output": "∀x (OrangeJuice(x) ∨ AppleJuice(x))"
  },
  {
    "input": "Translate into first-order logic: All apple juice is sweet.",
    "output": "∀x (AppleJuice(x) → Sweet(x))"
  },
  {
    "input": "Translate into first-order logic: If coke is apple juice, then coke is a drink.",
    "output": "AppleJuice(coke) → Drink(coke)"
  },
  {
    "input": "Translate into first-order logic: If coke is not apple juice, then coke is not edible.",
    "output": "¬AppleJuice(coke) → ¬Edible(coke)"
  },
  {
    "input": "Translate into first-order logic: All drinks are edible.",
    "output": "∀x (Drink(x) → Edible(x))"
  },
  {
    "input": "Translate into first-order logic: All juices are drinks.",
    "output": "∀x (Juice(x) → Drink(x))"
  },
  {
    "input": "Translate into first-order logic: All orange juice is a juice.",
    "output": "∀x (OrangeJuice(x) → Juice(x))"
  },
  {
    "input": "Translate into first-order logic: A juice is either an orange juice or an apple juice.",
    "output": "∀x (OrangeJuice(x) ∨ AppleJuice(x))"
  },
  {
    "input": "Translate into first-order logic: All apple juice is sweet.",
    "output": "∀x (AppleJuice(x) → Sweet(x))"
  },
  {
    "input": "Translate into first-order logic: If coke is apple juice, then coke is a drink.",
    "output": "AppleJuice(coke) → Drink(coke)"
  },
  {
    "input": "Translate into first-order logic: If coke is not apple juice, then coke is not edible.",
    "output": "¬AppleJuice(coke) → ¬Edible(coke)"
  },
  {
    "input": "Translate into first-order logic: All drinks are edible.",
    "output": "∀x (Drink(x) → Edible(x))"
  },
  {
    "input": "Translate into first-order logic: All juices are drinks.",
    "output": "∀x (Juice(x) → Drink(x))"
  },
  {
    "input": "Translate into first-order logic: All orange juice is a juice.",
    "output": "∀x (OrangeJuice(x) → Juice(x))"
  },
  {
    "input": "Translate into first-order logic: A juice is either an orange juice or an apple juice.",
    "output": "∀x (OrangeJuice(x) ∨ AppleJuice(x))"
  },
  {
    "input": "Translate into first-order logic: All apple juice is sweet.",
    "output": "∀x (AppleJuice(x) → Sweet(x))"
  },
  {
    "input": "Translate into first-order logic: If coke is apple juice, then coke is a drink.",
    "output": "AppleJuice(coke) → Drink(coke)"
  },
  {
    "input": "Translate into first-order logic: If coke is not apple juice, then coke is not edible.",
    "output": "¬AppleJuice(coke) → ¬Edible(coke)"
  },
  {
    "input": "Translate into first-order logic: Federico Garcia Lorca was a talented Spanish poet and he supported the Popular Front.",
    "output": "TalentedPoet(lorca) ∧ SupportPopulists(lorca)"
  },
  {
    "input": "Translate into first-order logic: The Spanish Nationalists opposed anyone who supported the Popular Front",
    "output": "∀x (SupportPopulists(x) → Opposed(nationalists, x))"
  },
  {
    "input": "Translate into first-order logic: Talented poets are popular.",
    "output": "∀x (TalentedPoet(x) → Popular(x))"
  },
  {
    "input": "Translate into first-order logic: Spanish Nationalists killed anyone who they opposed and were popular.",
    "output": "∀x (Opposed(nationalists, x) ∧ Popular(x) → Killed(nationalists, x))"
  },
  {
    "input": "Translate into first-order logic: Daniel supported the Popular Front but was not popular.",
    "output": "SupportPopulists(daniel) ∧ ¬Popular(daniel)"
  },
  {
    "input": "Translate into first-order logic: Federico Garcia Lorca was a talented Spanish poet and he supported the Popular Front.",
    "output": "TalentedPoet(lorca) ∧ SupportPopulists(lorca)"
  },
  {
    "input": "Translate into first-order logic: The Spanish Nationalists opposed anyone who supported the Popular Front",
    "output": "∀x (SupportPopulists(x) → Opposed(nationalists, x))"
  },
  {
    "input": "Translate into first-order logic: Talented poets are popular.",
    "output": "∀x (TalentedPoet(x) → Popular(x))"
  },
  {
    "input": "Translate into first-order logic: Spanish Nationalists killed anyone who they opposed and were popular.",
    "output": "∀x (Opposed(nationalists, x) ∧ Popular(x) → Killed(nationalists, x))"
  },
  {
    "input": "Translate into first-order logic: Daniel supported the Popular Front but was not popular.",
    "output": "SupportPopulists(daniel) ∧ ¬Popular(daniel)"
  },
  {
    "input": "Translate into first-order logic: People either drink kombucha every day or drink Coca-Cola or Pepsi products every day.",
    "output": "∀x (Kombucha(x) ∨ CocaCola(x))"
  },
  {
    "input": "Translate into first-order logic: If people drink Coca-Cola or Pepsi products every day, then they grew up with extremely busy parents who did not have time to pack them lunch.",
    "output": "∀x (CocaCola(x) → BusyParents(x))"
  },
  {
    "input": "Translate into first-order logic: If people drink Coca-Cola or Pepsi products every day, then they have to visit the dentist frequently.",
    "output": "∀x (CocaCola(x) → Dentist(x))"
  },
  {
    "input": "Translate into first-order logic: If people grew up with extremely busy parents who did not have time to pack them lunch, then they have erratic and diverse eating habits.",
    "output": "∀x (BusyParents(x) → Erratic(x))"
  },
  {
    "input": "Translate into first-order logic: If people have erratic and diverse eating habits, then they do not have consistent everyday routines and like sticking to a solid schedule.",
    "output": "∀x (Erratic(x) → ¬Consistent(x))"
  },
  {
    "input": "Translate into first-order logic: Franny either both grew up with extremely busy parents who did not have time to pack her lunch and has consistent everyday routines and like sticking to a solid schedule, or she neither grew up with extremely busy parents who did not have time to pack her lunch nor has consistent everyday routines and likes sticking to a schedule.",
    "output": "(BusyParents(franny) ∧ Consistent(franny)) ⊕ (¬BusyParents(franny) ∧ ¬Consistent(franny))"
  },
  {
    "input": "Translate into first-order logic: People either drink kombucha every day or drink Coca-Cola or Pepsi products every day.",
    "output": "∀x (Kombucha(x) ∨ CocaCola(x))"
  },
  {
    "input": "Translate into first-order logic: If people drink Coca-Cola or Pepsi products every day, then they grew up with extremely busy parents who did not have time to pack them lunch.",
    "output": "∀x (CocaCola(x) → BusyParents(x))"
  },
  {
    "input": "Translate into first-order logic: If people drink Coca-Cola or Pepsi products every day, then they have to visit the dentist frequently.",
    "output": "∀x (CocaCola(x) → Dentist(x))"
  },
  {
    "input": "Translate into first-order logic: If people grew up with extremely busy parents who did not have time to pack them lunch, then they have erratic and diverse eating habits.",
    "output": "∀x (BusyParents(x) → Erratic(x))"
  },
  {
    "input": "Translate into first-order logic: If people have erratic and diverse eating habits, then they do not have consistent everyday routines and like sticking to a solid schedule.",
    "output": "∀x (Erratic(x) → ¬Consistent(x))"
  },
  {
    "input": "Translate into first-order logic: Franny either both grew up with extremely busy parents who did not have time to pack her lunch and has consistent everyday routines and like sticking to a solid schedule, or she neither grew up with extremely busy parents who did not have time to pack her lunch nor has consistent everyday routines and likes sticking to a schedule.",
    "output": "(BusyParents(franny) ∧ Consistent(franny)) ⊕ (¬BusyParents(franny) ∧ ¬Consistent(franny))"
  },
  {
    "input": "Translate into first-order logic: People either drink kombucha every day or drink Coca-Cola or Pepsi products every day.",
    "output": "∀x (Kombucha(x) ∨ CocaCola(x))"
  },
  {
    "input": "Translate into first-order logic: If people drink Coca-Cola or Pepsi products every day, then they grew up with extremely busy parents who did not have time to pack them lunch.",
    "output": "∀x (CocaCola(x) → BusyParents(x))"
  },
  {
    "input": "Translate into first-order logic: If people drink Coca-Cola or Pepsi products every day, then they have to visit the dentist frequently.",
    "output": "∀x (CocaCola(x) → Dentist(x))"
  },
  {
    "input": "Translate into first-order logic: If people grew up with extremely busy parents who did not have time to pack them lunch, then they have erratic and diverse eating habits.",
    "output": "∀x (BusyParents(x) → Erratic(x))"
  },
  {
    "input": "Translate into first-order logic: If people have erratic and diverse eating habits, then they do not have consistent everyday routines and like sticking to a solid schedule.",
    "output": "∀x (Erratic(x) → ¬Consistent(x))"
  },
  {
    "input": "Translate into first-order logic: Franny either both grew up with extremely busy parents who did not have time to pack her lunch and has consistent everyday routines and like sticking to a solid schedule, or she neither grew up with extremely busy parents who did not have time to pack her lunch nor has consistent everyday routines and likes sticking to a schedule.",
    "output": "(BusyParents(franny) ∧ Consistent(franny)) ⊕ (¬BusyParents(franny) ∧ ¬Consistent(franny))"
  },
  {
    "input": "Translate into first-order logic: If a customer subscribes to AMC A List, then he/she can watch 3 movies every week without any additional fees.",
    "output": "∀x (SubscribedTo(x, amcalist) → ThreeMovies(x) ∧ NoFees(x))"
  },
  {
    "input": "Translate into first-order logic: Some customers go to cinemas every week.",
    "output": "∃x (CinemaEveryWeek(x))"
  },
  {
    "input": "Translate into first-order logic: Customers who prefer TV series will not watch TV series in cinemas.",
    "output": "∀x (Prefer(x, tvseries) → ¬WatchTVIn(x, cinemas))"
  },
  {
    "input": "Translate into first-order logic: James watches TV series in cinemas.",
    "output": "WatchTVIn(james, cinemas)"
  },
  {
    "input": "Translate into first-order logic: James subscribes to AMC A List.",
    "output": "SubscribedTo(james, amcalist)"
  },
  {
    "input": "Translate into first-order logic: Peter prefers TV series.",
    "output": "Prefer(peter, tvseries)"
  },
  {
    "input": "Translate into first-order logic: If a customer subscribes to AMC A List, then he/she can watch 3 movies every week without any additional fees.",
    "output": "∀x (SubscribedTo(x, amcalist) → ThreeMovies(x) ∧ NoFees(x))"
  },
  {
    "input": "Translate into first-order logic: Some customers go to cinemas every week.",
    "output": "∃x (CinemaEveryWeek(x))"
  },
  {
    "input": "Translate into first-order logic: Customers who prefer TV series will not watch TV series in cinemas.",
    "output": "∀x (Prefer(x, tvseries) → ¬WatchTVIn(x, cinemas))"
  },
  {
    "input": "Translate into first-order logic: James watches TV series in cinemas.",
    "output": "WatchTVIn(james, cinemas)"
  },
  {
    "input": "Translate into first-order logic: James subscribes to AMC A List.",
    "output": "SubscribedTo(james, amcalist)"
  },
  {
    "input": "Translate into first-order logic: Peter prefers TV series.",
    "output": "Prefer(peter, tvseries)"
  },
  {
    "input": "Translate into first-order logic: If a customer subscribes to AMC A List, then he/she can watch 3 movies every week without any additional fees.",
    "output": "∀x (SubscribedTo(x, amcalist) → ThreeMovies(x) ∧ NoFees(x))"
  },
  {
    "input": "Translate into first-order logic: Some customers go to cinemas every week.",
    "output": "∃x (CinemaEveryWeek(x))"
  },
  {
    "input": "Translate into first-order logic: Customers who prefer TV series will not watch TV series in cinemas.",
    "output": "∀x (Prefer(x, tvseries) → ¬WatchTVIn(x, cinemas))"
  },
  {
    "input": "Translate into first-order logic: James watches TV series in cinemas.",
    "output": "WatchTVIn(james, cinemas)"
  },
  {
    "input": "Translate into first-order logic: James subscribes to AMC A List.",
    "output": "SubscribedTo(james, amcalist)"
  },
  {
    "input": "Translate into first-order logic: Peter prefers TV series.",
    "output": "Prefer(peter, tvseries)"
  },
  {
    "input": "Translate into first-order logic: Bulbophyllum attenuatum is in the genus bulbophyllum.",
    "output": "InGenus(bulbophyllumattenuatum, bulbophyllum)"
  },
  {
    "input": "Translate into first-order logic: All bulbophyllum are orchids.",
    "output": "∀x (InGenus(x, bulbophyllum) → Orchid(x))"
  },
  {
    "input": "Translate into first-order logic: There are eight federal districts of Russia: Central, Northwestern, Southern, North Caucasian, Volga, Ural, Siberian and Far Eastern.",
    "output": "FederalDistrictOfRussia(central) ∨ FederalDistrictOfRussia(northwestern) ∨ FederalDistrictOfRussia(southern) ∨ FederalDistrictOfRussia(northcaucasian) ∨ FederalDistrictOfRussia(volga) ∨ FederalDistrictOfRussia(ural) ∨ FederalDistrictOfRussia(siberian) ∨ FederalDistrictOfRussia(fareastern)"
  },
  {
    "input": "Translate into first-order logic: The Central federal district has the largest population among all federal districts in Russia.",
    "output": "FederalDistrictOfRussia(central) ∧ LargestPopulationIn(central) "
  },
  {
    "input": "Translate into first-order logic: Moscow is the administrative center of the Central federal district.",
    "output": "AdministrativeCenterOf(moscow, central)"
  },
  {
    "input": "Translate into first-order logic: Yekaterinburg is the administrative center of the Ural federal district.",
    "output": "AdministrativeCenterOf(yekaterinburg, ural)"
  },
  {
    "input": "Translate into first-order logic: Vladivostok is the administrative center of the Far Eastern federal district.",
    "output": "AdministrativeCenterOf(vladivostok, fareastern)"
  },
  {
    "input": "Translate into first-order logic: The Far Eastern federal district has the largest area among all federal districts in Russia.",
    "output": "FederalDistrictOfRussia(fareastern) ∧ LargestAreaIn(fareastern)"
  },
  {
    "input": "Translate into first-order logic: Some federal districts of Russia were established in 2000.",
    "output": "∃x (FederalDistrictOfRussia(x) → EstablishedIn(x, 2000))"
  },
  {
    "input": "Translate into first-order logic: There are eight federal districts of Russia: Central, Northwestern, Southern, North Caucasian, Volga, Ural, Siberian and Far Eastern.",
    "output": "FederalDistrictOfRussia(central) ∨ FederalDistrictOfRussia(northwestern) ∨ FederalDistrictOfRussia(southern) ∨ FederalDistrictOfRussia(northcaucasian) ∨ FederalDistrictOfRussia(volga) ∨ FederalDistrictOfRussia(ural) ∨ FederalDistrictOfRussia(siberian) ∨ FederalDistrictOfRussia(fareastern)"
  },
  {
    "input": "Translate into first-order logic: The Central federal district has the largest population among all federal districts in Russia.",
    "output": "FederalDistrictOfRussia(central) ∧ LargestPopulationIn(central) "
  },
  {
    "input": "Translate into first-order logic: Moscow is the administrative center of the Central federal district.",
    "output": "AdministrativeCenterOf(moscow, central)"
  },
  {
    "input": "Translate into first-order logic: Yekaterinburg is the administrative center of the Ural federal district.",
    "output": "AdministrativeCenterOf(yekaterinburg, ural)"
  },
  {
    "input": "Translate into first-order logic: Vladivostok is the administrative center of the Far Eastern federal district.",
    "output": "AdministrativeCenterOf(vladivostok, fareastern)"
  },
  {
    "input": "Translate into first-order logic: The Far Eastern federal district has the largest area among all federal districts in Russia.",
    "output": "FederalDistrictOfRussia(fareastern) ∧ LargestAreaIn(fareastern)"
  },
  {
    "input": "Translate into first-order logic: Some federal districts of Russia were established in 2000.",
    "output": "∃x (FederalDistrictOfRussia(x) → EstablishedIn(x, 2000))"
  },
  {
    "input": "Translate into first-order logic: There are eight federal districts of Russia: Central, Northwestern, Southern, North Caucasian, Volga, Ural, Siberian and Far Eastern.",
    "output": "FederalDistrictOfRussia(central) ∨ FederalDistrictOfRussia(northwestern) ∨ FederalDistrictOfRussia(southern) ∨ FederalDistrictOfRussia(northcaucasian) ∨ FederalDistrictOfRussia(volga) ∨ FederalDistrictOfRussia(ural) ∨ FederalDistrictOfRussia(siberian) ∨ FederalDistrictOfRussia(fareastern)"
  },
  {
    "input": "Translate into first-order logic: The Central federal district has the largest population among all federal districts in Russia.",
    "output": "FederalDistrictOfRussia(central) ∧ LargestPopulationIn(central) "
  },
  {
    "input": "Translate into first-order logic: Moscow is the administrative center of the Central federal district.",
    "output": "AdministrativeCenterOf(moscow, central)"
  },
  {
    "input": "Translate into first-order logic: Yekaterinburg is the administrative center of the Ural federal district.",
    "output": "AdministrativeCenterOf(yekaterinburg, ural)"
  },
  {
    "input": "Translate into first-order logic: Vladivostok is the administrative center of the Far Eastern federal district.",
    "output": "AdministrativeCenterOf(vladivostok, fareastern)"
  },
  {
    "input": "Translate into first-order logic: The Far Eastern federal district has the largest area among all federal districts in Russia.",
    "output": "FederalDistrictOfRussia(fareastern) ∧ LargestAreaIn(fareastern)"
  },
  {
    "input": "Translate into first-order logic: Some federal districts of Russia were established in 2000.",
    "output": "∃x (FederalDistrictOfRussia(x) → EstablishedIn(x, 2000))"
  },
  {
    "input": "Translate into first-order logic: All cancers are malignant tumors.",
    "output": "∀x (Cancer(x) → MalignantTumor(x))"
  },
  {
    "input": "Translate into first-order logic: No malignant tumor can be treated at home.",
    "output": "∀x (MalignantTumor(x) → ¬CanBeTreatedAtHome(x))"
  },
  {
    "input": "Translate into first-order logic: All colorectal cancer is cancer.",
    "output": "∀x (ColorectalCancer(x) → Cancer(x))"
  },
  {
    "input": "Translate into first-order logic: Having a cold can be treated at home.",
    "output": "∀x (HavingACold(x) → CanBeTreatedAtHome(x))"
  },
  {
    "input": "Translate into first-order logic: Breast cancer is neither having a cold nor a malignant tumor (exclusive).",
    "output": "¬(HavingACold(breastCancer) ⊕ MalignantTumor(breastCancer))"
  },
  {
    "input": "Translate into first-order logic: All cancers are malignant tumors.",
    "output": "∀x (Cancer(x) → MalignantTumor(x))"
  },
  {
    "input": "Translate into first-order logic: No malignant tumor can be treated at home.",
    "output": "∀x (MalignantTumor(x) → ¬CanBeTreatedAtHome(x))"
  },
  {
    "input": "Translate into first-order logic: All colorectal cancer is cancer.",
    "output": "∀x (ColorectalCancer(x) → Cancer(x))"
  },
  {
    "input": "Translate into first-order logic: Having a cold can be treated at home.",
    "output": "∀x (HavingACold(x) → CanBeTreatedAtHome(x))"
  },
  {
    "input": "Translate into first-order logic: Breast cancer is neither having a cold nor a malignant tumor (exclusive).",
    "output": "¬(HavingACold(breastCancer) ⊕ MalignantTumor(breastCancer))"
  },
  {
    "input": "Translate into first-order logic: All cancers are malignant tumors.",
    "output": "∀x (Cancer(x) → MalignantTumor(x))"
  },
  {
    "input": "Translate into first-order logic: No malignant tumor can be treated at home.",
    "output": "∀x (MalignantTumor(x) → ¬CanBeTreatedAtHome(x))"
  },
  {
    "input": "Translate into first-order logic: All colorectal cancer is cancer.",
    "output": "∀x (ColorectalCancer(x) → Cancer(x))"
  },
  {
    "input": "Translate into first-order logic: Having a cold can be treated at home.",
    "output": "∀x (HavingACold(x) → CanBeTreatedAtHome(x))"
  },
  {
    "input": "Translate into first-order logic: Breast cancer is neither having a cold nor a malignant tumor (exclusive).",
    "output": "¬(HavingACold(breastCancer) ⊕ MalignantTumor(breastCancer))"
  },
  {
    "input": "Translate into first-order logic: All cancers are malignant tumors.",
    "output": "∀x (Cancer(x) → MalignantTumor(x))"
  },
  {
    "input": "Translate into first-order logic: No malignant tumor can be treated at home.",
    "output": "∀x (MalignantTumor(x) → ¬CanBeTreatedAtHome(x))"
  },
  {
    "input": "Translate into first-order logic: All colorectal cancer is cancer.",
    "output": "∀x (ColorectalCancer(x) → Cancer(x))"
  },
  {
    "input": "Translate into first-order logic: Having a cold can be treated at home.",
    "output": "∀x (HavingACold(x) → CanBeTreatedAtHome(x))"
  },
  {
    "input": "Translate into first-order logic: Breast cancer is neither having a cold nor a malignant tumor (exclusive).",
    "output": "¬(HavingACold(breastCancer) ⊕ MalignantTumor(breastCancer))"
  },
  {
    "input": "Translate into first-order logic: All cancers are malignant tumors.",
    "output": "∀x (Cancer(x) → MalignantTumor(x))"
  },
  {
    "input": "Translate into first-order logic: No malignant tumor can be treated at home.",
    "output": "∀x (MalignantTumor(x) → ¬CanBeTreatedAtHome(x))"
  },
  {
    "input": "Translate into first-order logic: All colorectal cancer is cancer.",
    "output": "∀x (ColorectalCancer(x) → Cancer(x))"
  },
  {
    "input": "Translate into first-order logic: Having a cold can be treated at home.",
    "output": "∀x (HavingACold(x) → CanBeTreatedAtHome(x))"
  },
  {
    "input": "Translate into first-order logic: Breast cancer is neither having a cold nor a malignant tumor (exclusive).",
    "output": "¬(HavingACold(breastCancer) ⊕ MalignantTumor(breastCancer))"
  },
  {
    "input": "Translate into first-order logic: All cancers are malignant tumors.",
    "output": "∀x (Cancer(x) → MalignantTumor(x))"
  },
  {
    "input": "Translate into first-order logic: No malignant tumor can be treated at home.",
    "output": "∀x (MalignantTumor(x) → ¬CanBeTreatedAtHome(x))"
  },
  {
    "input": "Translate into first-order logic: All colorectal cancer is cancer.",
    "output": "∀x (ColorectalCancer(x) → Cancer(x))"
  },
  {
    "input": "Translate into first-order logic: Having a cold can be treated at home.",
    "output": "∀x (HavingACold(x) → CanBeTreatedAtHome(x))"
  },
  {
    "input": "Translate into first-order logic: Breast cancer is neither having a cold nor a malignant tumor (exclusive).",
    "output": "¬(HavingACold(breastCancer) ⊕ MalignantTumor(breastCancer))"
  },
  {
    "input": "Translate into first-order logic: I should not worry about things outside of my control.",
    "output": "∀x (OutsideControl(x) → ¬ShouldWorry(x))"
  },
  {
    "input": "Translate into first-order logic: Traffic is outside of my control.",
    "output": "∀x (Traffic(x) → OutsideControl(x))"
  },
  {
    "input": "Translate into first-order logic: Roversi is an Italian surname.",
    "output": "∀x (UseAsSurname(x, roversi) → UseItalianSurname(x))"
  },
  {
    "input": "Translate into first-order logic: Alba Roversi uses Roversi as a surname.",
    "output": "UseAsSurname(alba, roversi)"
  },
  {
    "input": "Translate into first-order logic: Paolo Roversi uses Roversi as a surname.",
    "output": "UseAsSurname(paolo, roversi)"
  },
  {
    "input": "Translate into first-order logic: Roberto Roversi uses Roversi as a surname.",
    "output": "UseAsSurname(roberto, roversi)"
  },
  {
    "input": "Translate into first-order logic: Paolo Roversi is a photographer.",
    "output": "Photographer(paolo)"
  },
  {
    "input": "Translate into first-order logic: A photographer is a professional or an amateur.",
    "output": "∀x (Photographer(x) → Professional(x) ∨ Amateur(x))"
  },
  {
    "input": "Translate into first-order logic: Roversi is an Italian surname.",
    "output": "∀x (UseAsSurname(x, roversi) → UseItalianSurname(x))"
  },
  {
    "input": "Translate into first-order logic: Alba Roversi uses Roversi as a surname.",
    "output": "UseAsSurname(alba, roversi)"
  },
  {
    "input": "Translate into first-order logic: Paolo Roversi uses Roversi as a surname.",
    "output": "UseAsSurname(paolo, roversi)"
  },
  {
    "input": "Translate into first-order logic: Roberto Roversi uses Roversi as a surname.",
    "output": "UseAsSurname(roberto, roversi)"
  },
  {
    "input": "Translate into first-order logic: Paolo Roversi is a photographer.",
    "output": "Photographer(paolo)"
  },
  {
    "input": "Translate into first-order logic: A photographer is a professional or an amateur.",
    "output": "∀x (Photographer(x) → Professional(x) ∨ Amateur(x))"
  },
  {
    "input": "Translate into first-order logic: Roversi is an Italian surname.",
    "output": "∀x (UseAsSurname(x, roversi) → UseItalianSurname(x))"
  },
  {
    "input": "Translate into first-order logic: Alba Roversi uses Roversi as a surname.",
    "output": "UseAsSurname(alba, roversi)"
  },
  {
    "input": "Translate into first-order logic: Paolo Roversi uses Roversi as a surname.",
    "output": "UseAsSurname(paolo, roversi)"
  },
  {
    "input": "Translate into first-order logic: Roberto Roversi uses Roversi as a surname.",
    "output": "UseAsSurname(roberto, roversi)"
  },
  {
    "input": "Translate into first-order logic: Paolo Roversi is a photographer.",
    "output": "Photographer(paolo)"
  },
  {
    "input": "Translate into first-order logic: A photographer is a professional or an amateur.",
    "output": "∀x (Photographer(x) → Professional(x) ∨ Amateur(x))"
  },
  {
    "input": "Translate into first-order logic: Zaha Hadid is a British-Iraqi architect, artist and designer.",
    "output": "British-IraqiArchitect(zahaHadid)"
  },
  {
    "input": "Translate into first-order logic: Zaha Hadid was born on 31 October 1950 in Baghdad, Iraq.",
    "output": "BornIn(zahaHadid, y1950)"
  },
  {
    "input": "Translate into first-order logic: Hadid was a visiting professor of Architectural Design at the Yale School of Architecture.",
    "output": "Visitingprofessor(zahaHadid, yaleSchoolofArchitecture)"
  },
  {
    "input": "Translate into first-order logic: Max is an aspiring architecture student, and he plans to apply to Yale School of Architecture.",
    "output": "AspiringArchitectureStudent(max) ∧ PlansToApplyTo(max, yaleSchoolofArchitecture)"
  },
  {
    "input": "Translate into first-order logic: Zaha Hadid is a British-Iraqi architect, artist and designer.",
    "output": "British-IraqiArchitect(zahaHadid)"
  },
  {
    "input": "Translate into first-order logic: Zaha Hadid was born on 31 October 1950 in Baghdad, Iraq.",
    "output": "BornIn(zahaHadid, y1950)"
  },
  {
    "input": "Translate into first-order logic: Hadid was a visiting professor of Architectural Design at the Yale School of Architecture.",
    "output": "Visitingprofessor(zahaHadid, yaleSchoolofArchitecture)"
  },
  {
    "input": "Translate into first-order logic: Max is an aspiring architecture student, and he plans to apply to Yale School of Architecture.",
    "output": "AspiringArchitectureStudent(max) ∧ PlansToApplyTo(max, yaleSchoolofArchitecture)"
  },
  {
    "input": "Translate into first-order logic: Zaha Hadid is a British-Iraqi architect, artist and designer.",
    "output": "British-IraqiArchitect(zahaHadid)"
  },
  {
    "input": "Translate into first-order logic: Zaha Hadid was born on 31 October 1950 in Baghdad, Iraq.",
    "output": "BornIn(zahaHadid, y1950)"
  },
  {
    "input": "Translate into first-order logic: Hadid was a visiting professor of Architectural Design at the Yale School of Architecture.",
    "output": "Visitingprofessor(zahaHadid, yaleSchoolofArchitecture)"
  },
  {
    "input": "Translate into first-order logic: Max is an aspiring architecture student, and he plans to apply to Yale School of Architecture.",
    "output": "AspiringArchitectureStudent(max) ∧ PlansToApplyTo(max, yaleSchoolofArchitecture)"
  },
  {
    "input": "Translate into first-order logic: Zaha Hadid is a British-Iraqi architect, artist and designer.",
    "output": "British-IraqiArchitect(zahaHadid)"
  },
  {
    "input": "Translate into first-order logic: Zaha Hadid was born on 31 October 1950 in Baghdad, Iraq.",
    "output": "BornIn(zahaHadid, y1950)"
  },
  {
    "input": "Translate into first-order logic: Hadid was a visiting professor of Architectural Design at the Yale School of Architecture.",
    "output": "Visitingprofessor(zahaHadid, yaleSchoolofArchitecture)"
  },
  {
    "input": "Translate into first-order logic: Max is an aspiring architecture student, and he plans to apply to Yale School of Architecture.",
    "output": "AspiringArchitectureStudent(max) ∧ PlansToApplyTo(max, yaleSchoolofArchitecture)"
  },
  {
    "input": "Translate into first-order logic: Something is either an invasive neuroimaging technique or a noninvasive neuroimaging technique.",
    "output": "∀x (InvasiveNeuroimagingTechnique(x) ∨ NoninvasiveNeuroimagingTechnique(x)) "
  },
  {
    "input": "Translate into first-order logic: All noninvasive neuroimaging techniques provide a spatial resolution of brains.",
    "output": " ∀x (NoninvasiveNeuroimagingTechnique(x) → ProvidesSpatialResolutionOfBrains(x)) "
  },
  {
    "input": "Translate into first-order logic: If a technique provides a spatial resolution of brains, then it is a measurement of brain activity.",
    "output": " ∀x (ProvidesSpatialResolutionOfBrains(x) → MeasurementOfBrainActivity(x)) "
  },
  {
    "input": "Translate into first-order logic: All measurements of brain activity are used by neuroscience researchers.",
    "output": " ∀x (MeasurementOfBrainActivity(x) → UsedByNeuroscienceResearchers(x))"
  },
  {
    "input": "Translate into first-order logic: FMRI is either a measurement of brain activity or a noninvasive neuroimaging technique.",
    "output": " MeasurementOfBrainActivity(fMRI) ⊕ NoninvasiveNeuroimagingTechnique(fMRI)"
  },
  {
    "input": "Translate into first-order logic: Something is either an invasive neuroimaging technique or a noninvasive neuroimaging technique.",
    "output": "∀x (InvasiveNeuroimagingTechnique(x) ∨ NoninvasiveNeuroimagingTechnique(x)) "
  },
  {
    "input": "Translate into first-order logic: All noninvasive neuroimaging techniques provide a spatial resolution of brains.",
    "output": " ∀x (NoninvasiveNeuroimagingTechnique(x) → ProvidesSpatialResolutionOfBrains(x)) "
  },
  {
    "input": "Translate into first-order logic: If a technique provides a spatial resolution of brains, then it is a measurement of brain activity.",
    "output": " ∀x (ProvidesSpatialResolutionOfBrains(x) → MeasurementOfBrainActivity(x)) "
  },
  {
    "input": "Translate into first-order logic: All measurements of brain activity are used by neuroscience researchers.",
    "output": " ∀x (MeasurementOfBrainActivity(x) → UsedByNeuroscienceResearchers(x))"
  },
  {
    "input": "Translate into first-order logic: FMRI is either a measurement of brain activity or a noninvasive neuroimaging technique.",
    "output": " MeasurementOfBrainActivity(fMRI) ⊕ NoninvasiveNeuroimagingTechnique(fMRI)"
  },
  {
    "input": "Translate into first-order logic: Something is either an invasive neuroimaging technique or a noninvasive neuroimaging technique.",
    "output": "∀x (InvasiveNeuroimagingTechnique(x) ∨ NoninvasiveNeuroimagingTechnique(x)) "
  },
  {
    "input": "Translate into first-order logic: All noninvasive neuroimaging techniques provide a spatial resolution of brains.",
    "output": " ∀x (NoninvasiveNeuroimagingTechnique(x) → ProvidesSpatialResolutionOfBrains(x)) "
  },
  {
    "input": "Translate into first-order logic: If a technique provides a spatial resolution of brains, then it is a measurement of brain activity.",
    "output": " ∀x (ProvidesSpatialResolutionOfBrains(x) → MeasurementOfBrainActivity(x)) "
  },
  {
    "input": "Translate into first-order logic: All measurements of brain activity are used by neuroscience researchers.",
    "output": " ∀x (MeasurementOfBrainActivity(x) → UsedByNeuroscienceResearchers(x))"
  },
  {
    "input": "Translate into first-order logic: FMRI is either a measurement of brain activity or a noninvasive neuroimaging technique.",
    "output": " MeasurementOfBrainActivity(fMRI) ⊕ NoninvasiveNeuroimagingTechnique(fMRI)"
  },
  {
    "input": "Translate into first-order logic: Something is either an invasive neuroimaging technique or a noninvasive neuroimaging technique.",
    "output": "∀x (InvasiveNeuroimagingTechnique(x) ∨ NoninvasiveNeuroimagingTechnique(x)) "
  },
  {
    "input": "Translate into first-order logic: All noninvasive neuroimaging techniques provide a spatial resolution of brains.",
    "output": " ∀x (NoninvasiveNeuroimagingTechnique(x) → ProvidesSpatialResolutionOfBrains(x)) "
  },
  {
    "input": "Translate into first-order logic: If a technique provides a spatial resolution of brains, then it is a measurement of brain activity.",
    "output": " ∀x (ProvidesSpatialResolutionOfBrains(x) → MeasurementOfBrainActivity(x)) "
  },
  {
    "input": "Translate into first-order logic: All measurements of brain activity are used by neuroscience researchers.",
    "output": " ∀x (MeasurementOfBrainActivity(x) → UsedByNeuroscienceResearchers(x))"
  },
  {
    "input": "Translate into first-order logic: FMRI is either a measurement of brain activity or a noninvasive neuroimaging technique.",
    "output": " MeasurementOfBrainActivity(fMRI) ⊕ NoninvasiveNeuroimagingTechnique(fMRI)"
  },
  {
    "input": "Translate into first-order logic: Either present their work at the conference or provide a tutorial session at the conference.",
    "output": "∀x ( Present(x) ∨ Tutorial(x))"
  },
  {
    "input": "Translate into first-order logic: All who present their work at the conference will attend in person.",
    "output": "∀x (Present(x) → InPerson(x))"
  },
  {
    "input": "Translate into first-order logic: All those providing a tutorial session at the conference are invited to join the club.",
    "output": "∀x (Tutorial(x) → Invited(x))"
  },
  {
    "input": "Translate into first-order logic: All who attend the conference in person are provided with souvenirs.",
    "output": "∀x (InPerson(x) → Souvenirs(x))"
  },
  {
    "input": "Translate into first-order logic: All invited to join the club are provided with delicious meals.",
    "output": "∀x (Invited(x) → Meals(x))"
  },
  {
    "input": "Translate into first-order logic: All provided with delicious meals are happy to communicate with each other during the dinner.",
    "output": "∀x (Meals(x) → HappyCommunicate(x))"
  },
  {
    "input": "Translate into first-order logic: All provided with delicious meals are invited to take a photo with the audience.",
    "output": "∀x (Meals(x) → InvitedTakePhoto(x))"
  },
  {
    "input": "Translate into first-order logic: James does not attend the conference in person and is not provided with souvenirs.",
    "output": "¬(InPerson(james) ∧ Souvenirs(james))"
  },
  {
    "input": "Translate into first-order logic: Either present their work at the conference or provide a tutorial session at the conference.",
    "output": "∀x ( Present(x) ∨ Tutorial(x))"
  },
  {
    "input": "Translate into first-order logic: All who present their work at the conference will attend in person.",
    "output": "∀x (Present(x) → InPerson(x))"
  },
  {
    "input": "Translate into first-order logic: All those providing a tutorial session at the conference are invited to join the club.",
    "output": "∀x (Tutorial(x) → Invited(x))"
  },
  {
    "input": "Translate into first-order logic: All who attend the conference in person are provided with souvenirs.",
    "output": "∀x (InPerson(x) → Souvenirs(x))"
  },
  {
    "input": "Translate into first-order logic: All invited to join the club are provided with delicious meals.",
    "output": "∀x (Invited(x) → Meals(x))"
  },
  {
    "input": "Translate into first-order logic: All provided with delicious meals are happy to communicate with each other during the dinner.",
    "output": "∀x (Meals(x) → HappyCommunicate(x))"
  },
  {
    "input": "Translate into first-order logic: All provided with delicious meals are invited to take a photo with the audience.",
    "output": "∀x (Meals(x) → InvitedTakePhoto(x))"
  },
  {
    "input": "Translate into first-order logic: James does not attend the conference in person and is not provided with souvenirs.",
    "output": "¬(InPerson(james) ∧ Souvenirs(james))"
  },
  {
    "input": "Translate into first-order logic: Either present their work at the conference or provide a tutorial session at the conference.",
    "output": "∀x ( Present(x) ∨ Tutorial(x))"
  },
  {
    "input": "Translate into first-order logic: All who present their work at the conference will attend in person.",
    "output": "∀x (Present(x) → InPerson(x))"
  },
  {
    "input": "Translate into first-order logic: All those providing a tutorial session at the conference are invited to join the club.",
    "output": "∀x (Tutorial(x) → Invited(x))"
  },
  {
    "input": "Translate into first-order logic: All who attend the conference in person are provided with souvenirs.",
    "output": "∀x (InPerson(x) → Souvenirs(x))"
  },
  {
    "input": "Translate into first-order logic: All invited to join the club are provided with delicious meals.",
    "output": "∀x (Invited(x) → Meals(x))"
  },
  {
    "input": "Translate into first-order logic: All provided with delicious meals are happy to communicate with each other during the dinner.",
    "output": "∀x (Meals(x) → HappyCommunicate(x))"
  },
  {
    "input": "Translate into first-order logic: All provided with delicious meals are invited to take a photo with the audience.",
    "output": "∀x (Meals(x) → InvitedTakePhoto(x))"
  },
  {
    "input": "Translate into first-order logic: James does not attend the conference in person and is not provided with souvenirs.",
    "output": "¬(InPerson(james) ∧ Souvenirs(james))"
  },
  {
    "input": "Translate into first-order logic: Either present their work at the conference or provide a tutorial session at the conference.",
    "output": "∀x ( Present(x) ∨ Tutorial(x))"
  },
  {
    "input": "Translate into first-order logic: All who present their work at the conference will attend in person.",
    "output": "∀x (Present(x) → InPerson(x))"
  },
  {
    "input": "Translate into first-order logic: All those providing a tutorial session at the conference are invited to join the club.",
    "output": "∀x (Tutorial(x) → Invited(x))"
  },
  {
    "input": "Translate into first-order logic: All who attend the conference in person are provided with souvenirs.",
    "output": "∀x (InPerson(x) → Souvenirs(x))"
  },
  {
    "input": "Translate into first-order logic: All invited to join the club are provided with delicious meals.",
    "output": "∀x (Invited(x) → Meals(x))"
  },
  {
    "input": "Translate into first-order logic: All provided with delicious meals are happy to communicate with each other during the dinner.",
    "output": "∀x (Meals(x) → HappyCommunicate(x))"
  },
  {
    "input": "Translate into first-order logic: All provided with delicious meals are invited to take a photo with the audience.",
    "output": "∀x (Meals(x) → InvitedTakePhoto(x))"
  },
  {
    "input": "Translate into first-order logic: James does not attend the conference in person and is not provided with souvenirs.",
    "output": "¬(InPerson(james) ∧ Souvenirs(james))"
  },
  {
    "input": "Translate into first-order logic: Either present their work at the conference or provide a tutorial session at the conference.",
    "output": "∀x ( Present(x) ∨ Tutorial(x))"
  },
  {
    "input": "Translate into first-order logic: All who present their work at the conference will attend in person.",
    "output": "∀x (Present(x) → InPerson(x))"
  },
  {
    "input": "Translate into first-order logic: All those providing a tutorial session at the conference are invited to join the club.",
    "output": "∀x (Tutorial(x) → Invited(x))"
  },
  {
    "input": "Translate into first-order logic: All who attend the conference in person are provided with souvenirs.",
    "output": "∀x (InPerson(x) → Souvenirs(x))"
  },
  {
    "input": "Translate into first-order logic: All invited to join the club are provided with delicious meals.",
    "output": "∀x (Invited(x) → Meals(x))"
  },
  {
    "input": "Translate into first-order logic: All provided with delicious meals are happy to communicate with each other during the dinner.",
    "output": "∀x (Meals(x) → HappyCommunicate(x))"
  },
  {
    "input": "Translate into first-order logic: All provided with delicious meals are invited to take a photo with the audience.",
    "output": "∀x (Meals(x) → InvitedTakePhoto(x))"
  },
  {
    "input": "Translate into first-order logic: James does not attend the conference in person and is not provided with souvenirs.",
    "output": "¬(InPerson(james) ∧ Souvenirs(james))"
  },
  {
    "input": "Translate into first-order logic: The USS Salem is a heavy cruiser built for the United States navy.",
    "output": "HeavyCruiser(usssalem) ∧ BuiltFor(usssalem, unitedstatesnavy)"
  },
  {
    "input": "Translate into first-order logic: The last heavy cruiser to enter service was the USS Salem.",
    "output": "LastHeavyCruiserToEnterService(usssalem)"
  },
  {
    "input": "Translate into first-order logic: The USS Salem is a museum ship.",
    "output": "MuseumShip(usssalem)"
  },
  {
    "input": "Translate into first-order logic: Museum ships are open to the public.",
    "output": "∀x (MuseumShip(x) → OpenToPublic(x))"
  },
  {
    "input": "Translate into first-order logic: The USS Salem served in the Atlantic and Mediterranean.",
    "output": "ServedIn(usssalem, atlantic) ∧ ServedIn(usssalem, mediterranean)"
  },
  {
    "input": "Translate into first-order logic: The USS Salem is a heavy cruiser built for the United States navy.",
    "output": "HeavyCruiser(usssalem) ∧ BuiltFor(usssalem, unitedstatesnavy)"
  },
  {
    "input": "Translate into first-order logic: The last heavy cruiser to enter service was the USS Salem.",
    "output": "LastHeavyCruiserToEnterService(usssalem)"
  },
  {
    "input": "Translate into first-order logic: The USS Salem is a museum ship.",
    "output": "MuseumShip(usssalem)"
  },
  {
    "input": "Translate into first-order logic: Museum ships are open to the public.",
    "output": "∀x (MuseumShip(x) → OpenToPublic(x))"
  },
  {
    "input": "Translate into first-order logic: The USS Salem served in the Atlantic and Mediterranean.",
    "output": "ServedIn(usssalem, atlantic) ∧ ServedIn(usssalem, mediterranean)"
  },
  {
    "input": "Translate into first-order logic: The USS Salem is a heavy cruiser built for the United States navy.",
    "output": "HeavyCruiser(usssalem) ∧ BuiltFor(usssalem, unitedstatesnavy)"
  },
  {
    "input": "Translate into first-order logic: The last heavy cruiser to enter service was the USS Salem.",
    "output": "LastHeavyCruiserToEnterService(usssalem)"
  },
  {
    "input": "Translate into first-order logic: The USS Salem is a museum ship.",
    "output": "MuseumShip(usssalem)"
  },
  {
    "input": "Translate into first-order logic: Museum ships are open to the public.",
    "output": "∀x (MuseumShip(x) → OpenToPublic(x))"
  },
  {
    "input": "Translate into first-order logic: The USS Salem served in the Atlantic and Mediterranean.",
    "output": "ServedIn(usssalem, atlantic) ∧ ServedIn(usssalem, mediterranean)"
  },
  {
    "input": "Translate into first-order logic: TS Leda was a good passenger and cargo vessel.",
    "output": "∀x (TSLeda(x) → Passenger(x) ∧ CargoVessel(x))"
  },
  {
    "input": "Translate into first-order logic: TS Leda was the first Norweigian vessel that was built with stabilizers.",
    "output": "∀x (TSLeda(x) → Norweigian(x) ∧ Stabilizers(x))"
  },
  {
    "input": "Translate into first-order logic: Stabilizers are mechanical devices that are only on ships that have powerful steam turbine engines.",
    "output": "∀x (Stabilizers(x) → OnlyOnShips(x) ∧ SteamTurbine(x))"
  },
  {
    "input": "Translate into first-order logic: To be a good passenger and cargo vessel, ships must be quiet and good at sea.",
    "output": "∀x (Passenger(x) ∧ CargoVessel(x) → Quiet(x) ∧ GoodSea(x))"
  },
  {
    "input": "Translate into first-order logic: Some ships that are quiet and good at sea have powerful steam turbine engines.",
    "output": "∃x (Quiet(x) ∧ GoodSea(x) ∧ SteamTurbine(x))"
  },
  {
    "input": "Translate into first-order logic: TS Leda was a good passenger and cargo vessel.",
    "output": "∀x (TSLeda(x) → Passenger(x) ∧ CargoVessel(x))"
  },
  {
    "input": "Translate into first-order logic: TS Leda was the first Norweigian vessel that was built with stabilizers.",
    "output": "∀x (TSLeda(x) → Norweigian(x) ∧ Stabilizers(x))"
  },
  {
    "input": "Translate into first-order logic: Stabilizers are mechanical devices that are only on ships that have powerful steam turbine engines.",
    "output": "∀x (Stabilizers(x) → OnlyOnShips(x) ∧ SteamTurbine(x))"
  },
  {
    "input": "Translate into first-order logic: To be a good passenger and cargo vessel, ships must be quiet and good at sea.",
    "output": "∀x (Passenger(x) ∧ CargoVessel(x) → Quiet(x) ∧ GoodSea(x))"
  },
  {
    "input": "Translate into first-order logic: Some ships that are quiet and good at sea have powerful steam turbine engines.",
    "output": "∃x (Quiet(x) ∧ GoodSea(x) ∧ SteamTurbine(x))"
  },
  {
    "input": "Translate into first-order logic: TS Leda was a good passenger and cargo vessel.",
    "output": "∀x (TSLeda(x) → Passenger(x) ∧ CargoVessel(x))"
  },
  {
    "input": "Translate into first-order logic: TS Leda was the first Norweigian vessel that was built with stabilizers.",
    "output": "∀x (TSLeda(x) → Norweigian(x) ∧ Stabilizers(x))"
  },
  {
    "input": "Translate into first-order logic: Stabilizers are mechanical devices that are only on ships that have powerful steam turbine engines.",
    "output": "∀x (Stabilizers(x) → OnlyOnShips(x) ∧ SteamTurbine(x))"
  },
  {
    "input": "Translate into first-order logic: To be a good passenger and cargo vessel, ships must be quiet and good at sea.",
    "output": "∀x (Passenger(x) ∧ CargoVessel(x) → Quiet(x) ∧ GoodSea(x))"
  },
  {
    "input": "Translate into first-order logic: Some ships that are quiet and good at sea have powerful steam turbine engines.",
    "output": "∃x (Quiet(x) ∧ GoodSea(x) ∧ SteamTurbine(x))"
  },
  {
    "input": "Translate into first-order logic: Rosa was born in Santiago.",
    "output": "Born(rosa, santiago)"
  },
  {
    "input": "Translate into first-order logic: Santiago is the capital and largest city of Chile.",
    "output": "Capital(santiago, chile) ∧ LargestCity(santiago, chile)"
  },
  {
    "input": "Translate into first-order logic: Rosa is the daughter of a Catalan building contractor, Jose.",
    "output": "Daughter(rosa, jose) ∧ BuildingContractor(jose) ∧ ¬Chilean(jose)"
  },
  {
    "input": "Translate into first-order logic: Jose has a Chilean wife, Carmen.",
    "output": "Wife(jose, carmen) ∧ Chilean(carmen)"
  },
  {
    "input": "Translate into first-order logic: A building contractor is responsible for the day-to-day oversight of a construction site.",
    "output": "∀x ∃y (BuildingContractor(x) ∧ ConstructionSite(y) → Oversee(x, y))"
  },
  {
    "input": "Translate into first-order logic: Rosa was born in Santiago.",
    "output": "Born(rosa, santiago)"
  },
  {
    "input": "Translate into first-order logic: Santiago is the capital and largest city of Chile.",
    "output": "Capital(santiago, chile) ∧ LargestCity(santiago, chile)"
  },
  {
    "input": "Translate into first-order logic: Rosa is the daughter of a Catalan building contractor, Jose.",
    "output": "Daughter(rosa, jose) ∧ BuildingContractor(jose) ∧ ¬Chilean(jose)"
  },
  {
    "input": "Translate into first-order logic: Jose has a Chilean wife, Carmen.",
    "output": "Wife(jose, carmen) ∧ Chilean(carmen)"
  },
  {
    "input": "Translate into first-order logic: A building contractor is responsible for the day-to-day oversight of a construction site.",
    "output": "∀x ∃y (BuildingContractor(x) ∧ ConstructionSite(y) → Oversee(x, y))"
  },
  {
    "input": "Translate into first-order logic: Rosa was born in Santiago.",
    "output": "Born(rosa, santiago)"
  },
  {
    "input": "Translate into first-order logic: Santiago is the capital and largest city of Chile.",
    "output": "Capital(santiago, chile) ∧ LargestCity(santiago, chile)"
  },
  {
    "input": "Translate into first-order logic: Rosa is the daughter of a Catalan building contractor, Jose.",
    "output": "Daughter(rosa, jose) ∧ BuildingContractor(jose) ∧ ¬Chilean(jose)"
  },
  {
    "input": "Translate into first-order logic: Jose has a Chilean wife, Carmen.",
    "output": "Wife(jose, carmen) ∧ Chilean(carmen)"
  },
  {
    "input": "Translate into first-order logic: A building contractor is responsible for the day-to-day oversight of a construction site.",
    "output": "∀x ∃y (BuildingContractor(x) ∧ ConstructionSite(y) → Oversee(x, y))"
  },
  {
    "input": "Translate into first-order logic: Tyga is a rapper.",
    "output": "IsRapper(tyga)"
  },
  {
    "input": "Translate into first-order logic: Rappers release rap albums.",
    "output": "ReleasedAlbum(tyga, wellDone3)"
  },
  {
    "input": "Translate into first-order logic: Tyga released the Well Done 3 album.",
    "output": "∀x ∀y (IsRapper(x) ∧ ReleasedAlbum(x, y) → IsRapAlbum(y))"
  },
  {
    "input": "Translate into first-order logic: Rappers are not opera singers.",
    "output": "∀x (IsRapper(x) → ¬IsOperaSinger(x))"
  },
  {
    "input": "Translate into first-order logic: Tyga is a rapper.",
    "output": "IsRapper(tyga)"
  },
  {
    "input": "Translate into first-order logic: Rappers release rap albums.",
    "output": "ReleasedAlbum(tyga, wellDone3)"
  },
  {
    "input": "Translate into first-order logic: Tyga released the Well Done 3 album.",
    "output": "∀x ∀y (IsRapper(x) ∧ ReleasedAlbum(x, y) → IsRapAlbum(y))"
  },
  {
    "input": "Translate into first-order logic: Rappers are not opera singers.",
    "output": "∀x (IsRapper(x) → ¬IsOperaSinger(x))"
  },
  {
    "input": "Translate into first-order logic: Tyga is a rapper.",
    "output": "IsRapper(tyga)"
  },
  {
    "input": "Translate into first-order logic: Rappers release rap albums.",
    "output": "ReleasedAlbum(tyga, wellDone3)"
  },
  {
    "input": "Translate into first-order logic: Tyga released the Well Done 3 album.",
    "output": "∀x ∀y (IsRapper(x) ∧ ReleasedAlbum(x, y) → IsRapAlbum(y))"
  },
  {
    "input": "Translate into first-order logic: Rappers are not opera singers.",
    "output": "∀x (IsRapper(x) → ¬IsOperaSinger(x))"
  },
  {
    "input": "Translate into first-order logic: Deborah Wallace is a Scottish born actress, playwright and producer.",
    "output": "BornIn(deborahwallace, scotland) ∧ Actress(deborahwallace) ∧ Playwright(deborahwallace) ∧ Producer(deborahwallace)"
  },
  {
    "input": "Translate into first-order logic: Psyche is a play based on the life of James Miranda Barry.",
    "output": "Play(psyche) ∧ BasedOn(psyche, lifeofjamesmirandabarry)"
  },
  {
    "input": "Translate into first-order logic: Homesick, Psyche and The Void are plays from Deborah Wallace.",
    "output": "Play(homesick) ∧ From(homesick, deborahwallace) ∧ Play(psyche) ∧ From(psyche, deborahwallace) ∧ Play(thevoid) ∧ From(thevoid, deborahwallace)"
  },
  {
    "input": "Translate into first-order logic: Deborah Wallace co-produced Gasland.",
    "output": "Co-Produced(deborahwallace, gasland)"
  },
  {
    "input": "Translate into first-order logic: Deborah Wallace is a Scottish born actress, playwright and producer.",
    "output": "BornIn(deborahwallace, scotland) ∧ Actress(deborahwallace) ∧ Playwright(deborahwallace) ∧ Producer(deborahwallace)"
  },
  {
    "input": "Translate into first-order logic: Psyche is a play based on the life of James Miranda Barry.",
    "output": "Play(psyche) ∧ BasedOn(psyche, lifeofjamesmirandabarry)"
  },
  {
    "input": "Translate into first-order logic: Homesick, Psyche and The Void are plays from Deborah Wallace.",
    "output": "Play(homesick) ∧ From(homesick, deborahwallace) ∧ Play(psyche) ∧ From(psyche, deborahwallace) ∧ Play(thevoid) ∧ From(thevoid, deborahwallace)"
  },
  {
    "input": "Translate into first-order logic: Deborah Wallace co-produced Gasland.",
    "output": "Co-Produced(deborahwallace, gasland)"
  },
  {
    "input": "Translate into first-order logic: Deborah Wallace is a Scottish born actress, playwright and producer.",
    "output": "BornIn(deborahwallace, scotland) ∧ Actress(deborahwallace) ∧ Playwright(deborahwallace) ∧ Producer(deborahwallace)"
  },
  {
    "input": "Translate into first-order logic: Psyche is a play based on the life of James Miranda Barry.",
    "output": "Play(psyche) ∧ BasedOn(psyche, lifeofjamesmirandabarry)"
  },
  {
    "input": "Translate into first-order logic: Homesick, Psyche and The Void are plays from Deborah Wallace.",
    "output": "Play(homesick) ∧ From(homesick, deborahwallace) ∧ Play(psyche) ∧ From(psyche, deborahwallace) ∧ Play(thevoid) ∧ From(thevoid, deborahwallace)"
  },
  {
    "input": "Translate into first-order logic: Deborah Wallace co-produced Gasland.",
    "output": "Co-Produced(deborahwallace, gasland)"
  },
  {
    "input": "Translate into first-order logic: If an animal needs a large territory, then it travels far.",
    "output": "∀x (NeedsLargeTerritory(x) → TravelFar(x))"
  },
  {
    "input": "Translate into first-order logic: Everything that eats a lot needs a large territory.",
    "output": "∀x (EatsALot(x) → NeedsLargeTerritory(x))"
  },
  {
    "input": "Translate into first-order logic: If something is a big animal, then it will eat a lot.",
    "output": "∀x (BigAnimal(x) → EatsALot(x))"
  },
  {
    "input": "Translate into first-order logic: All bears are big animals.",
    "output": "∀x (Bear(x) → BigAnimal(x))"
  },
  {
    "input": "Translate into first-order logic: Larry is a big animal.",
    "output": "BigAnimal(larry)"
  },
  {
    "input": "Translate into first-order logic: If an animal needs a large territory, then it travels far.",
    "output": "∀x (NeedsLargeTerritory(x) → TravelFar(x))"
  },
  {
    "input": "Translate into first-order logic: Everything that eats a lot needs a large territory.",
    "output": "∀x (EatsALot(x) → NeedsLargeTerritory(x))"
  },
  {
    "input": "Translate into first-order logic: If something is a big animal, then it will eat a lot.",
    "output": "∀x (BigAnimal(x) → EatsALot(x))"
  },
  {
    "input": "Translate into first-order logic: All bears are big animals.",
    "output": "∀x (Bear(x) → BigAnimal(x))"
  },
  {
    "input": "Translate into first-order logic: Larry is a big animal.",
    "output": "BigAnimal(larry)"
  },
  {
    "input": "Translate into first-order logic: If an animal needs a large territory, then it travels far.",
    "output": "∀x (NeedsLargeTerritory(x) → TravelFar(x))"
  },
  {
    "input": "Translate into first-order logic: Everything that eats a lot needs a large territory.",
    "output": "∀x (EatsALot(x) → NeedsLargeTerritory(x))"
  },
  {
    "input": "Translate into first-order logic: If something is a big animal, then it will eat a lot.",
    "output": "∀x (BigAnimal(x) → EatsALot(x))"
  },
  {
    "input": "Translate into first-order logic: All bears are big animals.",
    "output": "∀x (Bear(x) → BigAnimal(x))"
  },
  {
    "input": "Translate into first-order logic: Larry is a big animal.",
    "output": "BigAnimal(larry)"
  },
  {
    "input": "Translate into first-order logic: No criminal is kind.",
    "output": "∀x (Criminal(x) → ¬Kind(x))"
  },
  {
    "input": "Translate into first-order logic: All person who breaks the law is a criminals.",
    "output": "∀x (BreakLaw(x) → Criminal(x))"
  },
  {
    "input": "Translate into first-order logic: People are either kind or evil.",
    "output": "∀x (Kind(x) ⊕ Evil(x))"
  },
  {
    "input": "Translate into first-order logic: If someone is evil, then they are ugly.",
    "output": "∀x (Evil(x) → Ugly(x))"
  },
  {
    "input": "Translate into first-order logic: If someone is evil, then they are cold-blood.",
    "output": "∀x (Evil(x) → ColdBlood(x))"
  },
  {
    "input": "Translate into first-order logic: If Garry is either evil and ugly or neither evil nor ugly, then Garry is not evil.",
    "output": "((Evil(garry) ∧ Ugly(garry)) ⊕ (¬Evil(garry) ∧ ¬Ugly(garry))) → ¬Evil(garry)"
  },
  {
    "input": "Translate into first-order logic: No criminal is kind.",
    "output": "∀x (Criminal(x) → ¬Kind(x))"
  },
  {
    "input": "Translate into first-order logic: All person who breaks the law is a criminals.",
    "output": "∀x (BreakLaw(x) → Criminal(x))"
  },
  {
    "input": "Translate into first-order logic: People are either kind or evil.",
    "output": "∀x (Kind(x) ⊕ Evil(x))"
  },
  {
    "input": "Translate into first-order logic: If someone is evil, then they are ugly.",
    "output": "∀x (Evil(x) → Ugly(x))"
  },
  {
    "input": "Translate into first-order logic: If someone is evil, then they are cold-blood.",
    "output": "∀x (Evil(x) → ColdBlood(x))"
  },
  {
    "input": "Translate into first-order logic: If Garry is either evil and ugly or neither evil nor ugly, then Garry is not evil.",
    "output": "((Evil(garry) ∧ Ugly(garry)) ⊕ (¬Evil(garry) ∧ ¬Ugly(garry))) → ¬Evil(garry)"
  },
  {
    "input": "Translate into first-order logic: No criminal is kind.",
    "output": "∀x (Criminal(x) → ¬Kind(x))"
  },
  {
    "input": "Translate into first-order logic: All person who breaks the law is a criminals.",
    "output": "∀x (BreakLaw(x) → Criminal(x))"
  },
  {
    "input": "Translate into first-order logic: People are either kind or evil.",
    "output": "∀x (Kind(x) ⊕ Evil(x))"
  },
  {
    "input": "Translate into first-order logic: If someone is evil, then they are ugly.",
    "output": "∀x (Evil(x) → Ugly(x))"
  },
  {
    "input": "Translate into first-order logic: If someone is evil, then they are cold-blood.",
    "output": "∀x (Evil(x) → ColdBlood(x))"
  },
  {
    "input": "Translate into first-order logic: If Garry is either evil and ugly or neither evil nor ugly, then Garry is not evil.",
    "output": "((Evil(garry) ∧ Ugly(garry)) ⊕ (¬Evil(garry) ∧ ¬Ugly(garry))) → ¬Evil(garry)"
  },
  {
    "input": "Translate into first-order logic: Phoneix's music is classified under the indie pop genre.",
    "output": "IndiePop(phoenix)"
  },
  {
    "input": "Translate into first-order logic: Phoenix is a band from France.",
    "output": "Band(phoenix) ∧ France(phoenix)"
  },
  {
    "input": "Translate into first-order logic: French bands write songs in French or in English.",
    "output": "∀x ∀y (Band(x) ∧ France(x) ∧ Make(x, y) → FrenchSong(y) ⊕ EnglishSong(y))"
  },
  {
    "input": "Translate into first-order logic: Aside from indie pop, pop rock and synth-pop are two other genres of music.",
    "output": "∀x (IndiePop(x) → ¬PopRock(x) ∧ ¬SynthPop(x))"
  },
  {
    "input": "Translate into first-order logic: Phoneix has no songs in French.",
    "output": "∀x (Make(phoenix, x) → ¬FrenchSong(x))"
  },
  {
    "input": "Translate into first-order logic: Phoneix's music is classified under the indie pop genre.",
    "output": "IndiePop(phoenix)"
  },
  {
    "input": "Translate into first-order logic: Phoenix is a band from France.",
    "output": "Band(phoenix) ∧ France(phoenix)"
  },
  {
    "input": "Translate into first-order logic: French bands write songs in French or in English.",
    "output": "∀x ∀y (Band(x) ∧ France(x) ∧ Make(x, y) → FrenchSong(y) ⊕ EnglishSong(y))"
  },
  {
    "input": "Translate into first-order logic: Aside from indie pop, pop rock and synth-pop are two other genres of music.",
    "output": "∀x (IndiePop(x) → ¬PopRock(x) ∧ ¬SynthPop(x))"
  },
  {
    "input": "Translate into first-order logic: Phoneix has no songs in French.",
    "output": "∀x (Make(phoenix, x) → ¬FrenchSong(x))"
  }
]