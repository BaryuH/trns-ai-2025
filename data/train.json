[
{
"input": "Translate into first-order logic: If a Python code is well-tested, then the project is optimized.",
"output": "∀x (WT(x) → O(x))"
},
{
"input": "Translate into first-order logic: If a Python code does not follow PEP 8 standards, then it is not well-tested.",
"output": "∀x (¬PEP8(x) → ¬WT(x))"
},
{
"input": "Translate into first-order logic: All Python projects are easy to maintain.",
"output": "∀x (EM(x))"
},
{
"input": "Translate into first-order logic: All Python code is well-tested.",
"output": "∀x (WT(x))"
},
{
"input": "Translate into first-order logic: If a Python code follows PEP 8 standards, then it is easy to maintain.",
"output": "∀x (PEP8(x) → EM(x))"
},
{
"input": "Translate into first-order logic: If a Python code is well-tested, then it follows PEP 8 standards.",
"output": "∀x (WT(x) → PEP8(x))"
},
{
"input": "Translate into first-order logic: If a Python project is well-structured, then it is optimized.",
"output": "∀x (WS(x) → O(x))"
},
{
"input": "Translate into first-order logic: If a Python project is easy to maintain, then it is well-tested.",
"output": "∀x (EM(x) → WT(x))"
},
{
"input": "Translate into first-order logic: If a Python project is optimized, then it has clean and readable code.",
"output": "∀x (O(x) -> CR(x))"
},
{
"input": "Translate into first-order logic: All Python projects are well-structured.",
"output": "∀x (WS(x))"
},
{
"input": "Translate into first-order logic: All Python projects have clean and readable code.",
"output": "∀x (CR(x))"
},
{
"input": "Translate into first-order logic: There exists at least one Python project that follows best practices.",
"output": "∃x (BP(x))"
},
{
"input": "Translate into first-order logic: There exists at least one Python project that is optimized.",
"output": "∃x (O(x))"
},
{
"input": "Translate into first-order logic: If a Python project is not well-structured, then it does not follow PEP 8 standards.",
"output": "∀x (¬WS(x) → ¬PEP8(x))"
},
{
"input": "Translate into first-order logic: Students who have completed the core curriculum and passed the science assessment are qualified for advanced courses.",
"output": "∀x ((CompletedCoreCurriculum(x) ∧ PassedScienceAssessment(x)) → QualifiedForAdvancedCourses(x))"
},
{
"input": "Translate into first-order logic: Students who are qualified for advanced courses and have completed research methodology are eligible for the international program.",
"output": "∀x ((QualifiedForAdvancedCourses(x) ∧ CompletedResearchMethodology(x)) → EligibleForInternationalProgram(x))"
},
{
"input": "Translate into first-order logic: Students who have passed the language proficiency exam are eligible for the international program.",
"output": "∀x (PassedLanguageProficiency(x) → EligibleForInternationalProgram(x))"
},
{
"input": "Translate into first-order logic: Students who are eligible for the international program and have completed a capstone project are awarded an honors diploma.",
"output": "∀x ((EligibleForInternationalProgram(x) ∧ CompletedCapstoneProject(x)) → AwardedHonorsDiploma(x))"
},
{
"input": "Translate into first-order logic: Students who have been awarded an honors diploma and have completed community service qualify for the university scholarship.",
"output": "∀x ((AwardedHonorsDiploma(x) ∧ CompletedCommunityService(x)) → QualifiesForScholarship(x))"
},
{
"input": "Translate into first-order logic: Students who have been awarded an honors diploma and have received a faculty recommendation qualify for the university scholarship.",
"output": "∀x ((AwardedHonorsDiploma(x) ∧ ReceivedFacultyRecommendation(x)) → QualifiesForScholarship(x))"
},
{
"input": "Translate into first-order logic: Sophia has completed the core curriculum.",
"output": "CompletedCoreCurriculum(Sophia)"
},
{
"input": "Translate into first-order logic: Sophia has passed the science assessment.",
"output": "PassedScienceAssessment(Sophia)"
},
{
"input": "Translate into first-order logic: Sophia has completed the research methodology course.",
"output": "CompletedResearchMethodology(Sophia)"
},
{
"input": "Translate into first-order logic: Sophia has completed her capstone project.",
"output": "CompletedCapstoneProject(Sophia)"
},
{
"input": "Translate into first-order logic: Sophia has completed the required community service hours.",
"output": "CompletedCommunityService(Sophia)"
},
{
"input": "Translate into first-order logic: Students who have completed the core curriculum and passed the science assessment are qualified for advanced courses.",
"output": "∀x ((CompletedCoreCurriculum(x) ∧ PassedScienceAssessment(x)) → QualifiedForAdvancedCourses(x))"
},
{
"input": "Translate into first-order logic: Students who are qualified for advanced courses and have completed research methodology are eligible for the international program.",
"output": "∀x ((QualifiedForAdvancedCourses(x) ∧ CompletedResearchMethodology(x)) → EligibleForInternationalProgram(x))"
},
{
"input": "Translate into first-order logic: Students who have passed the language proficiency exam are eligible for the international program.",
"output": "∀x (PassedLanguageProficiency(x) → EligibleForInternationalProgram(x))"
},
{
"input": "Translate into first-order logic: Students who are eligible for the international program and have completed a capstone project are awarded an honors diploma.",
"output": "∀x ((EligibleForInternationalProgram(x) ∧ CompletedCapstoneProject(x)) → AwardedHonorsDiploma(x))"
},
{
"input": "Translate into first-order logic: Students who have been awarded an honors diploma and have completed community service qualify for the university scholarship.",
"output": "∀x ((AwardedHonorsDiploma(x) ∧ CompletedCommunityService(x)) → QualifiesForScholarship(x))"
},
{
"input": "Translate into first-order logic: Students who have been awarded an honors diploma and have received a faculty recommendation qualify for the university scholarship.",
"output": "∀x ((AwardedHonorsDiploma(x) ∧ ReceivedFacultyRecommendation(x)) → QualifiesForScholarship(x))"
},
{
"input": "Translate into first-order logic: Sophia has completed the core curriculum.",
"output": "CompletedCoreCurriculum(Sophia)"
},
{
"input": "Translate into first-order logic: Sophia has passed the science assessment.",
"output": "PassedScienceAssessment(Sophia)"
},
{
"input": "Translate into first-order logic: Sophia has completed the research methodology course.",
"output": "CompletedResearchMethodology(Sophia)"
},
{
"input": "Translate into first-order logic: Sophia has completed her capstone project.",
"output": "CompletedCapstoneProject(Sophia)"
},
{
"input": "Translate into first-order logic: Sophia has completed the required community service hours.",
"output": "CompletedCommunityService(Sophia)"
},
{
"input": "Translate into first-order logic: If a student completes all required courses, they are eligible for graduation.",
"output": "∀x (CompletedRequiredCourses(x) → EligibleForGraduation(x))"
},
{
"input": "Translate into first-order logic: If a student is eligible for graduation and maintains a GPA above 3.5, they graduate with honors.",
"output": "∀x ((EligibleForGraduation(x) ∧ gpa_above_3_5(x)) → GraduatesWithHonors(x))"
},
{
"input": "Translate into first-order logic: If a student graduates with honors and completes a thesis, they receive academic distinction.",
"output": "∀x ((GraduatesWithHonors(x) ∧ CompletedThesis(x)) → AcademicDistinction(x))"
},
{
"input": "Translate into first-order logic: If a student receives academic distinction, they qualify for the graduate fellowship program.",
"output": "∀x (AcademicDistinction(x) → QualifiesForFellowship(x))"
},
{
"input": "Translate into first-order logic: John has completed all required courses.",
"output": "CompletedRequiredCourses(John)"
},
{
"input": "Translate into first-order logic: John maintains a GPA of 3.8.",
"output": "gpa_above_3_5(John)"
},
{
"input": "Translate into first-order logic: John has completed a thesis.",
"output": "CompletedThesis(John)"
},
{
"input": "Translate into first-order logic: If a faculty member has completed training, they can teach undergraduate courses.",
"output": "∀x (CompletedPedagogicalTraining(x) → CanTeachUndergraduate(x))"
},
{
"input": "Translate into first-order logic: If a faculty member can teach undergraduate courses and holds a PhD, they can supervise graduate students.",
"output": "∀x ((CanTeachUndergraduate(x) ∧ HoldsPhd(x)) → CanSuperviseGraduate(x))"
},
{
"input": "Translate into first-order logic: If a faculty member can supervise graduate students and has at least 3 publications, they can serve on curriculum committees.",
"output": "∀x ((CanSuperviseGraduate(x) ∧ HasAtLeastThreePublications(x)) → CanServeCurriculumCommittees(x))"
},
{
"input": "Translate into first-order logic: If a faculty member can serve on curriculum committees and has a positive teaching evaluation, they can propose new courses.",
"output": "∀x ((CanServeCurriculumCommittees(x) ∧ HasPositiveEvaluation(x)) → CanProposeCourses(x))"
},
{
"input": "Translate into first-order logic: Professor John has completed pedagogical training.",
"output": "CompletedPedagogicalTraining(John)"
},
{
"input": "Translate into first-order logic: Professor John holds a PhD.",
"output": "HoldsPhd(John)"
},
{
"input": "Translate into first-order logic: Professor John has published at least 3 academic papers.",
"output": "HasAtLeastThreePublications(John)"
},
{
"input": "Translate into first-order logic: Professor John has received a positive teaching evaluation.",
"output": "HasPositiveEvaluation(John)"
},
{
"input": "Translate into first-order logic: If a faculty member has taught for at least 5 years, they are eligible for extended library access.",
"output": "∀x (TaughtMinFiveYears(x) → EligibleExtendedLibrary(x))"
},
{
"input": "Translate into first-order logic: If someone has extended library access and has published at least one academic paper, they can access restricted archives.",
"output": "∀x ((EligibleExtendedLibrary(x) ∧ HasPublications(x)) → CanAccessRestrictedArchives(x))"
},
{
"input": "Translate into first-order logic: If someone can access restricted archives and has completed research ethics training, they can submit research proposals.",
"output": "∀x ((CanAccessRestrictedArchives(x) ∧ CompletedEthicsTraining(x)) → CanSubmitResearchProposals(x))"
},
{
"input": "Translate into first-order logic: If someone can submit research proposals and has a departmental endorsement, they can apply for collaborative research projects.",
"output": "∀x ((CanSubmitResearchProposals(x) ∧ HasDepartmentalEndorsement(x)) → CanApplyCollaborativeProjects(x))"
},
{
"input": "Translate into first-order logic: Professor John has taught for at least 5 years.",
"output": "TaughtMinFiveYears(John)"
},
{
"input": "Translate into first-order logic: Professor John has published at least one academic paper.",
"output": "HasPublications(John)"
},
{
"input": "Translate into first-order logic: Professor John has completed research ethics training.",
"output": "CompletedEthicsTraining(John)"
},
{
"input": "Translate into first-order logic: Professor John has a departmental endorsement.",
"output": "HasDepartmentalEndorsement(John)"
},
{
"input": "Translate into first-order logic: If a driver has passed vehicle inspection and has the appropriate license, they can transport standard goods.",
"output": "∀x ((PassedVehicleInspection(x) ∧ HasAppropriateLicense(x)) → CanTransportStandardGoods(x))"
},
{
"input": "Translate into first-order logic: If a driver can transport standard goods and has completed hazmat training and received a safety endorsement, they can transport hazardous materials.",
"output": "∀x ((CanTransportStandardGoods(x) ∧ CompletedHazmatTraining(x) ∧ ReceivedSafetyEndorsement(x)) → CanTransportHazardousMaterials(x))"
},
{
"input": "Translate into first-order logic: If a driver can transport hazardous materials and has an interstate permit, they can cross state lines with hazardous cargo.",
"output": "∀x ((CanTransportHazardousMaterials(x) ∧ HasInterstatePermit(x)) → CanCrossStateLines(x))"
},
{
"input": "Translate into first-order logic: John has passed vehicle inspection.",
"output": "PassedVehicleInspection(John)"
},
{
"input": "Translate into first-order logic: John has the appropriate license.",
"output": "HasAppropriateLicense(John)"
},
{
"input": "Translate into first-order logic: John has completed hazmat training.",
"output": "CompletedHazmatTraining(John)"
},
{
"input": "Translate into first-order logic: John has not received a safety endorsement.",
"output": "¬ReceivedSafetyEndorsement(John)"
},
{
"input": "Translate into first-order logic: John has an interstate permit.",
"output": "HasInterstatePermit(John)"
},
{
"input": "Translate into first-order logic: Faculty members with a degree higher than BA can teach undergraduate courses.",
"output": "∀x (∀d ((FacultyMember(x) ∧ HasDegree(x, d) ∧ Higher(d, BA)) → TeachUndergrad(x)))"
},
{
"input": "Translate into first-order logic: Faculty members with a degree higher than MSc can teach graduate courses.",
"output": "∀x (∀d ((FacultyMember(x) ∧ HasDegree(x, d) ∧ Higher(d, MSc)) → TeachGraduate(x)))"
},
{
"input": "Translate into first-order logic: Anyone who teaches graduate courses can be a research mentor.",
"output": "∀x (TeachGraduate(x) → ResearchMentor(x))"
},
{
"input": "Translate into first-order logic: If degree A is higher than B, and B is higher than C, then A is higher than C.",
"output": "∀a (∀b (∀c ((Higher(a, b) ∧ Higher(b, c)) → Higher(a, c))))"
},
{
"input": "Translate into first-order logic: MSc is higher than BA.",
"output": "Higher(MSc, BA)"
},
{
"input": "Translate into first-order logic: PhD is higher than MSc.",
"output": "Higher(PhD, MSc)"
},
{
"input": "Translate into first-order logic: Dr. John is a faculty member.",
"output": "FacultyMember(dr_john)"
},
{
"input": "Translate into first-order logic: Dr. John has a PhD.",
"output": "HasDegree(dr_john, PhD)"
},
{
"input": "Translate into first-order logic: If a curriculum is well-structured and has exercises, it enhances student engagement.",
"output": "∀c ((WellStructured(c) ∧ HasExercises(c)) → EnhancesEngagement(c))"
},
{
"input": "Translate into first-order logic: If a curriculum enhances student engagement and provides access to advanced resources, it enhances critical thinking.",
"output": "∀c ((EnhancesEngagement(c) ∧ AdvancedResources(c)) → EnhancesCriticalThinking(c))"
},
{
"input": "Translate into first-order logic: If a faculty prioritizes pedagogical training and curriculum development, the curriculum is well-structured.",
"output": "∀f ((PedagogicalTraining(f) ∧ CurriculumDevelopment(f)) → WellStructured(curriculum))"
},
{
"input": "Translate into first-order logic: The faculty prioritizes pedagogical training and curriculum development.",
"output": "PedagogicalTraining(faculty) ∧ CurriculumDevelopment(faculty)"
},
{
"input": "Translate into first-order logic: The curriculum has practical exercises.",
"output": "HasExercises(curriculum)"
},
{
"input": "Translate into first-order logic: The curriculum provides access to advanced resources.",
"output": "AdvancedResources(curriculum)"
},
{
"input": "Translate into first-order logic: If a curriculum is well-structured and has exercises, it enhances student engagement.",
"output": "∀c ((WellStructured(c) ∧ HasExercises(c)) → EnhancesEngagement(c))"
},
{
"input": "Translate into first-order logic: If a curriculum enhances student engagement and provides access to advanced resources, it enhances critical thinking.",
"output": "∀c ((EnhancesEngagement(c) ∧ AdvancedResources(c)) → EnhancesCriticalThinking(c))"
},
{
"input": "Translate into first-order logic: If a faculty prioritizes pedagogical training and curriculum development, the curriculum is well-structured.",
"output": "∀f ((PedagogicalTraining(f) ∧ CurriculumDevelopment(f)) → WellStructured(curriculum))"
},
{
"input": "Translate into first-order logic: The faculty prioritizes pedagogical training and curriculum development.",
"output": "PedagogicalTraining(faculty) ∧ CurriculumDevelopment(faculty)"
},
{
"input": "Translate into first-order logic: The curriculum has practical exercises.",
"output": "HasExercises(curriculum)"
},
{
"input": "Translate into first-order logic: The curriculum provides access to advanced resources.",
"output": "AdvancedResources(curriculum)"
},
{
"input": "Translate into first-order logic: If a student completes Course A, they can enroll in Course B.",
"output": "∀x (Complete(x, A) → Enroll(x, B))"
},
{
"input": "Translate into first-order logic: If a student enrolls in Course B and passes it, they can enroll in Course C.",
"output": "∀x ((Enroll(x, B) ∧ Pass(x, B)) → Enroll(x, C))"
},
{
"input": "Translate into first-order logic: Enrollment in Course C makes a student eligible for the internship program.",
"output": "∀x (Enroll(x, C) → EligibleInternship(x))"
},
{
"input": "Translate into first-order logic: David has completed Course A.",
"output": "Complete(david, A)"
},
{
"input": "Translate into first-order logic: David has enrolled in and passed Course B.",
"output": "Enroll(david, B) ∧ Pass(david, B)"
},
{
"input": "Translate into first-order logic: Alex has completed safety orientation.",
"output": "SafetyOrientation(Alex)"
},
{
"input": "Translate into first-order logic: Alex has a membership duration of 8 months.",
"output": "MembershipDuration(Alex, membershipduration) ∧ membershipduration = 8"
},
{
"input": "Translate into first-order logic: Alex has paid annual fees on time.",
"output": "PaidAnnualFee(Alex)"
},
{
"input": "Translate into first-order logic: If a person has a valid membership card and has completed safety orientation, they can use equipment.",
"output": "∀x ((ValidMembership(x) ∧ SafetyOrientation(x)) → UseEquipment(x))"
},
{
"input": "Translate into first-order logic: If a person can use equipment and has a trainer, they can book training.",
"output": "∀x ((UseEquipment(x) ∧ HasTrainer(x)) → BookTraining(x))"
},
{
"input": "Translate into first-order logic: If a person’s membership duration is at least 6 months, they are eligible for a trainer.",
"output": "∀x ((MembershipDuration(x, membershipduration) ∧ membershipduration ≥ 6) → EligibleTrainer(x))"
},
{
"input": "Translate into first-order logic: If a person has paid the annual fee, they have a valid membership.",
"output": "∀x (PaidAnnualFee(x) → ValidMembership(x))"
},
{
"input": "Translate into first-order logic: Students with active status who have completed at least 5 courses are eligible for advanced classes.",
"output": "∀x ((ActiveStatus(x) ∧ CompletedCourses(x, completedcourse) ∧ completedcourse ≥ 5) → EligibleAdvanced(x))"
},
{
"input": "Translate into first-order logic: Eligible students must obtain advisor approval to take advanced classes.",
"output": "∀x (EligibleAdvanced(x) → RequiresApproval(x))"
},
{
"input": "Translate into first-order logic: Sarah has active student status.",
"output": "ActiveStatus(sarah)"
},
{
"input": "Translate into first-order logic: Sarah has completed 4 courses.",
"output": "CompletedCourses(sarah, completedcourses) ∧ completedcourses = 4"
},
{
"input": "Translate into first-order logic: Sarah has obtained advisor approval.",
"output": "HasApproval(sarah)"
},
{
"input": "Translate into first-order logic: If a professor has a PhD degree, they are qualified to teach graduate courses.",
"output": "∀x (HasDegree(x, PhD) → TeachGraduate(x))"
},
{
"input": "Translate into first-order logic: A doctoral degree (PhD) is higher than a Master's degree.",
"output": "Higher(PhD, MSc)"
},
{
"input": "Translate into first-order logic: If a professor holds a degree higher than a Master's, they are eligible to supervise Master's students.",
"output": "∀x (∀d ((Higher(d, MSc) ∧ HasDegree(x, d)) → SuperviseMasters(x)))"
},
{
"input": "Translate into first-order logic: All professors qualified to teach graduate courses can also supervise graduate-level research.",
"output": "∀x (TeachGraduate(x) → SuperviseResearch(x))"
},
{
"input": "Translate into first-order logic: Professor John holds a PhD degree.",
"output": "HasDegree(John, PhD)"
},
{
"input": "Translate into first-order logic: Lecturers with a Master's degree can teach undergraduate courses.",
"output": "∀x (HasDegree(x, MSc) → TeachUndergrad(x))"
},
{
"input": "Translate into first-order logic: Lecturers with a degree higher than a Master's can teach undergraduate courses.",
"output": "∀x (∀d ((Higher(d, MSc) ∧ HasDegree(x, d)) → TeachUndergrad(x)))"
},
{
"input": "Translate into first-order logic: A PhD is higher than a Master's degree.",
"output": "Higher(PhD, MSc)"
},
{
"input": "Translate into first-order logic: A Master's degree is higher than a Bachelor's degree.",
"output": "Higher(MSc, BSc)"
},
{
"input": "Translate into first-order logic: If degree A is higher than degree B, and degree B is higher than degree C, then degree A is higher than degree C.",
"output": "∀a (∀b (∀c ((Higher(a, b) ∧ Higher(b, c)) → Higher(a, c))))"
},
{
"input": "Translate into first-order logic: Department heads must hold a degree higher than a Bachelor's.",
"output": "∀x (DepartmentHead(x) → (∃d, HasDegree(x, d) ∧ Higher(d, BSc)))"
},
{
"input": "Translate into first-order logic: Dr. John is a department head with a PhD.",
"output": "DepartmentHead(John) ∧ HasDegree(John, PhD)"
},
{
"input": "Translate into first-order logic: Completing 500 clinical hours grants Advanced Practice certification.",
"output": "∀x (∀h ((ClinicalHours(x, h) ∧ h ≥ 500) → AdvancedPractice(x)))"
},
{
"input": "Translate into first-order logic: Nurse John has completed 600 clinical hours.",
"output": "ClinicalHours(john, 600)"
},
{
"input": "Translate into first-order logic: John is a registered nurse.",
"output": "RegisteredNurse(john)"
},
{
"input": "Translate into first-order logic: All registered nurses with Advanced Practice certification are authorized to prescribe medication.",
"output": "∀x ((RegisteredNurse(x) ∧ AdvancedPractice(x)) → CanPrescribe(x))"
},
{
"input": "Translate into first-order logic: Alex has a valid membership card.",
"output": "∀x ((HasCard(x) ∧ SafetyOrientation(x)) → UseEquipment(x))"
},
{
"input": "Translate into first-order logic: Alex has completed safety orientation.",
"output": "∀x ((UseEquipment(x) ∧ HasTrainer(x)) → BookTraining(x))"
},
{
"input": "Translate into first-order logic: Alex has a membership duration of 8 months.",
"output": "∀x ((MembershipDuration(x, membershipduration) ∧ membershipduration ≥ 6) → EligibleTrainer(x))"
},
{
"input": "Translate into first-order logic: Alex has paid annual fees on time.",
"output": "∀x (PaidAnnualFee(x) → ValidMembership(x))"
},
{
"input": "Translate into first-order logic: If a student is enrolled in a science program and has passed Chemistry 101, they can enroll in Organic Chemistry.",
"output": "∀x ((ScienceProgram(x) ∧ Passed(x, Chem101)) → CanEnroll(x, OrganicChem))"
},
{
"input": "Translate into first-order logic: If a student is enrolled in Organic Chemistry and has completed Lab Safety Certification, they can access the advanced lab.",
"output": "∀x ((Enrolled(x, OrganicChem) ∧ Completed(x, LabSafety)) → LabAccess(x))"
},
{
"input": "Translate into first-order logic: All students who complete Organic Chemistry can take Biochemistry.",
"output": "∀x (Completed(x, OrganicChem) → CanTake(x, Biochemistry))"
},
{
"input": "Translate into first-order logic: If course X is a prerequisite for course Y, and course Y is a prerequisite for course Z, then course X is a prerequisite for course Z.",
"output": "∀a (∀b (∀c ((Prereq(a, b) ∧ Prereq(b, c)) → Prereq(a, c))))"
},
{
"input": "Translate into first-order logic: Minh is enrolled in a science program.",
"output": "ScienceProgram(Minh)"
},
{
"input": "Translate into first-order logic: Minh passed Chemistry 101.",
"output": "Passed(Minh, Chem101)"
},
{
"input": "Translate into first-order logic: Minh completed Organic Chemistry.",
"output": "Completed(Minh, OrganicChem)"
},
{
"input": "Translate into first-order logic: Minh completed Lab Safety Certification.",
"output": "Completed(Minh, LabSafety)"
},
{
"input": "Translate into first-order logic: Everyone will receive an update email.",
"output": "∀x (UpdateEmail(x))"
},
{
"input": "Translate into first-order logic: Everyone is trained.",
"output": "∀x (Trained(x))"
},
{
"input": "Translate into first-order logic: If someone receives an update email, then they have paid.",
"output": "∀x (UpdateEmail(x) → Paid(x))"
},
{
"input": "Translate into first-order logic: Everyone has completed the questionnaire.",
"output": "∀x (Questionnaire(x))"
},
{
"input": "Translate into first-order logic: Everyone has submitted a paper.",
"output": "∀x (SubmittedPaper(x))"
},
{
"input": "Translate into first-order logic: If someone receives an update email, then they are registered.",
"output": "∀x (UpdateEmail(x) → Registered(x))"
},
{
"input": "Translate into first-order logic: If a person has a research background, then they have strong qualifications.",
"output": "∀x (ResearchBackground(x) → StrongQualifications(x))"
},
{
"input": "Translate into first-order logic: If a person has strong qualifications, then they are suitable for a senior role.",
"output": "∀x (StrongQualifications(x) → SeniorRoleSuitability(x))"
},
{
"input": "Translate into first-order logic: Every person is enrolled in the company’s development program.",
"output": "∀x (DevelopmentProgram(x))"
},
{
"input": "Translate into first-order logic: Every person has a research background.",
"output": "∀x (ResearchBackground(x))"
},
{
"input": "Translate into first-order logic: If a person is eligible for a promotion, then they will receive a bonus.",
"output": "∀x (PromotionEligible(x) → Bonus(x))"
},
{
"input": "Translate into first-order logic: Everyone is eligible for a promotion.",
"output": "∀x (PromotionEligible(x))"
},
{
"input": "Translate into first-order logic: If a student attends at least 80% of classes, they will be allowed to take the final exam.",
"output": "∀s (∀m ((Attendance(s,m, attendance) ∧ attendance ≥ 80) → AllowedExam(s,m)))"
},
{
"input": "Translate into first-order logic: If a student is allowed to take the final exam and completes the exam, they can pass the course.",
"output": "∀s (∀m ((AllowedExam(s,m) ∧ CompletesExam(s,m)) → CanPass(s,m)))"
},
{
"input": "Translate into first-order logic: If a student fails to pass the course, they must retake the course.",
"output": "∀s (∀m (¬Pass(s,m) → Retake(s,m)))"
},
{
"input": "Translate into first-order logic: If a course requires a major assignment, the student must complete the major assignment or take the final exam.",
"output": "∀m (RequiresAssignment(m) → ∀s (CompletesAssignment(s,m) ∨ TakesExam(s,m)))"
},
{
"input": "Translate into first-order logic: If a student attends less than 50% of classes, they will not be allowed to take the final exam.",
"output": "∀s (∀m ((Attendance(s,m, attendance) ∧ attendance < 50) → ¬AllowedExam(s,m)))"
},
{
"input": "Translate into first-order logic: If a student completes 3 courses with a score above 8.5, they will receive a scholarship.",
"output": "∀s ((∃m1, ∃m2, ∃m3, (m1 ≠ m2) ∧ (m2 ≠ m3) ∧ (m1 ≠ m3) ∧ Grade(s,m1) ∧ (m1 > 8.5) ∧ Grade(s,m2) ∧ (m2 > 8.5) ∧ Grade(s,m3) ∧ (m3 > 8.5)) → Scholarship(s))"
},
{
"input": "Translate into first-order logic: If a student takes the exam but scores below the passing threshold, they will not pass the course.",
"output": "∀s (∀m ((TakesExam(s,m) ∧ Score(s,m) < passing_score) → ¬Pass(s,m)))"
},
{
"input": "Translate into first-order logic: If a student attends all classes but does not complete the exam, they cannot pass the course.",
"output": "∀s (∀m ((Attendance(s,m, attendance) ∧ attendance = 100 ∧ ¬CompletesExam(s,m)) → ¬Pass(s,m)))"
},
{
"input": "Translate into first-order logic: If a student attends less than 50% of the classes but completes the assignment and gets professor approval, they can take the exam.",
"output": "∀s (∀m ((Attendance(s,m, attendance) ∧ attendance < 50 ∧ CompletesAssignment(s,m) ∧ ProfessorApproval(s,m)) → AllowedExam(s,m)))"
},
{
"input": "Translate into first-order logic: If a student studies political theory for more than 12 hours, they will understand fundamental political ideologies.",
"output": "∀s ((Study(s,'PoliticalTheory', study) ∧ study > 12) → Understand(s,'PoliticalIdeologies'))"
},
{
"input": "Translate into first-order logic: If a student understands fundamental political ideologies, they can critically analyze government policies.",
"output": "∀s (Understand(s,'PoliticalIdeologies') → Analyze(s,'GovernmentPolicies'))"
},
{
"input": "Translate into first-order logic: If a student can critically analyze government policies, they will either participate in debates or write analytical essays.",
"output": "∀s (Analyze(s,'GovernmentPolicies') → (Debate(s) ∨ WriteEssay(s)))"
},
{
"input": "Translate into first-order logic: If a student does not participate in debates, they must write analytical essays.",
"output": "∀s (¬Debate(s) → WriteEssay(s))"
},
{
"input": "Translate into first-order logic: If a student studies less than 6 hours, they will struggle to understand fundamental political ideologies.",
"output": "∀s ((Study(s,'PoliticalTheory', study) ∧ study < 6) → Struggle(s,'PoliticalIdeologies'))"
},
{
"input": "Translate into first-order logic: If a professor requires participation in debates, students must either debate or provide a justified reason for not doing so.",
"output": "∀s (ProfessorRequires(s,'Debate') → (Debate(s) ∨ JustifiedReason(s)))"
},
{
"input": "Translate into first-order logic: If a student writes an analytical essay with high quality, they will receive academic recognition.",
"output": "∀s ((WriteEssay(s) ∧ HighQuality(s)) → AcademicRecognition(s))"
},
{
"input": "Translate into first-order logic: If a student receives academic recognition in political studies, they may qualify for a research fellowship.",
"output": "∀s ((AcademicRecognition(s) ∧ Field(s,recognitionfield) ∧ recognitionfield = 'PoliticalStudies') → QualifyFellowship(s))"
},
{
"input": "Translate into first-order logic: If a government policy is controversial, students must analyze it in their coursework.",
"output": "∀p (Controversial(p) → ∀s (MustAnalyze(s,p)))"
},
{
"input": "Translate into first-order logic: If a student avoids both debates and writing essays, they will fail the political theory course.",
"output": "∀s ((¬Debate(s) ∧ ¬WriteEssay(s)) → Fail(s,failcourse) ∧ failcourse = 'PoliticalTheory')"
},
{
"input": "Translate into first-order logic: Mastery of quantum superposition requires at least 15 hours of dedicated study.",
"output": "∀s ((Study(s,quantum_mechanics, studyquantummechanics) ∧ studyquantummechanics ≥ 15) → Understand(s,superposition))"
},
{
"input": "Translate into first-order logic: A solid understanding of superposition enables clear explanations of quantum measurement.",
"output": "∀s (Understand(s,superposition) → Explain(s,quantum_measurement))"
},
{
"input": "Translate into first-order logic: Those who can explain quantum measurement contribute by either writing research papers or giving presentations.",
"output": "∀s (Explain(s,quantum_measurement) → (WritePaper(s) ∨ GivePresentation(s)))"
},
{
"input": "Translate into first-order logic: Failure to give a presentation leaves research papers as the only viable option for contribution.",
"output": "∀s (¬GivePresentation(s) → WritePaper(s))"
},
{
"input": "Translate into first-order logic: Limited exposure (less than 8 hours) to quantum mechanics leads to difficulties in grasping superposition.",
"output": "∀s ((Study(s,quantum_mechanics, studyquantummechanics) ∧ studyquantummechainics < 8) → Struggle(s,superposition))"
},
{
"input": "Translate into first-order logic: When a professor mandates presentations, students must comply or justify their refusal.",
"output": "∀s (ProfessorRequires(s,presentation) → (GivePresentation(s) ∨ JustifiedReason(s)))"
},
{
"input": "Translate into first-order logic: Original analytical work in research papers leads to academic recognition.",
"output": "∀s ((WritePaper(s) ∧ OriginalWork(s)) → AcademicRecognition(s))"
},
{
"input": "Translate into first-order logic: Academic recognition in quantum mechanics opens the possibility of an advanced physics scholarship.",
"output": "∀s ((AcademicRecognition(s) ∧ Field(s,quantum_mechanics)) → QualifyScholarship(s))"
},
{
"input": "Translate into first-order logic: Quantum entanglement experiments must be critically analyzed as part of coursework.",
"output": "∀e (Experiment(e,entanglement) → ∀s (MustAnalyze(s,e)))"
},
{
"input": "Translate into first-order logic: Neglecting both research papers and presentations results in failing the quantum mechanics course.",
"output": "∀s ((¬WritePaper(s) ∧ ¬GivePresentation(s)) → Fail(s,quantum_mechanics))"
},
{
"input": "Translate into first-order logic: A student who understands wave-particle duality can critique interpretations of quantum mechanics.",
"output": "∀x (Student(x) ∧ UnderstandsDuality(x) → CritiquesInterpretations(x))"
},
{
"input": "Translate into first-order logic: Critiquing quantum interpretations enables assessing quantum realism debates.",
"output": "∀x (Student(x) ∧ CritiquesInterpretations(x) → AssessesRealism(x))"
},
{
"input": "Translate into first-order logic: A student who assesses realism debates is prepared for advanced research.",
"output": "∀x (Student(x) ∧ AssessesRealism(x) → PreparedResearch(x))"
},
{
"input": "Translate into first-order logic: A prepared researcher can contribute through publications or seminars.",
"output": "∀x (Student(x) ∧ PreparedResearch(x) → ContributesPublicationOrSeminar(x))"
},
{
"input": "Translate into first-order logic: Avoiding both publications and seminars means no academic contribution.",
"output": "∀x (Student(x) ∧ ¬Publication(x) ∧ ¬Seminar(x) → ¬Contributes(x))"
},
{
"input": "Translate into first-order logic: Academic contribution is needed for a research position.",
"output": "∀x (Student(x) ∧ SecuresPosition(x) → Contributes(x))"
},
{
"input": "Translate into first-order logic: A research position grants access to quantum laboratories.",
"output": "∀x (Student(x) ∧ SecuresPosition(x) → AccessesLab(x))"
},
{
"input": "Translate into first-order logic: Ebbinghaus' forgetting curve formula: R = e^(-t/S), where R is retention rate, t is elapsed time, and S is review interval.",
"output": "∀s (∀t (Retention(s,t) = e^(-t/S)))"
},
{
"input": "Translate into first-order logic: A learning algorithm based on spaced repetition can adjust review intervals based on individual proficiency.",
"output": "∀s (UseSpacedRepetition(s) → BetterMemoryRetention(s))"
},
{
"input": "Translate into first-order logic: Adequate sleep enhances memory consolidation after each review session.",
"output": "∀s (∀m (SleepWell(s) ∧ ReviewMaterial(s,m) → StrongerMemoryConnections(s,m)))"
},
{
"input": "Translate into first-order logic: Creating flashcards with concise questions improves retention compared to passive reading.",
"output": "∀s (∀f (UseFlashcards(s,f) → HigherRetentionRate(s,f)))"
},
{
"input": "Translate into first-order logic: Reviewing just before forgetting significantly boosts memory efficiency.",
"output": "∀s (∀m (ReviewBeforeForgetting(s,m) → HigherMemoryEfficiency(s,m)))"
},
{
"input": "Translate into first-order logic: Neuroscience studies show self-testing activates the hippocampus, enhancing information recall.",
"output": "∀s (∀m (SelfTest(s,m) → (ActivateHippocampus(s) ∧ ImproveRecall(s,m))))"
},
{
"input": "Translate into first-order logic: Encountering knowledge in various contexts improves retention compared to monotonous repetition.",
"output": "∀s (∀m (EncounterDifferentContexts(s,m) → HigherLongTermRetention(s,m)))"
},
{
"input": "Translate into first-order logic: Too short review intervals reduce retention due to lack of time for consolidation.",
"output": "∀s (∀m (TooShortIntervals(s,m) → InefficientLearning(s,m)))"
},
{
"input": "Translate into first-order logic: Too long review intervals risk forgetting most of the material before review.",
"output": "∀s (∀m (TooLongIntervals(s,m) → HighForgettingRate(s,m)))"
},
{
"input": "Translate into first-order logic: AI can personalize study schedules, optimizing memory retention for each student based on their progress.",
"output": "∀s (∀m (AiPersonalizedSchedule(s,m) → MostEfficientLearning(s,m)))"
},
{
"input": "Translate into first-order logic: Ebbinghaus' forgetting curve formula: R = e^(-t/S), where R is retention rate, t is elapsed time, and S is review interval.",
"output": "∀s (∀t (Retention(s,t) = e^(-t/S)))"
},
{
"input": "Translate into first-order logic: A learning algorithm based on spaced repetition can adjust review intervals based on individual proficiency.",
"output": "∀s (UseSpacedRepetition(s) → BetterMemoryRetention(s))"
},
{
"input": "Translate into first-order logic: Adequate sleep enhances memory consolidation after each review session.",
"output": "∀s (∀m (SleepWell(s) ∧ ReviewMaterial(s,m) → StrongerMemoryConnections(s,m)))"
},
{
"input": "Translate into first-order logic: Creating flashcards with concise questions improves retention compared to passive reading.",
"output": "∀s (∀f (UseFlashcards(s,f) → HigherRetentionRate(s,f)))"
},
{
"input": "Translate into first-order logic: Reviewing just before forgetting significantly boosts memory efficiency.",
"output": "∀s (∀m (ReviewBeforeForgetting(s,m) → HigherMemoryEfficiency(s,m)))"
},
{
"input": "Translate into first-order logic: Neuroscience studies show self-testing activates the hippocampus, enhancing information recall.",
"output": "∀s (∀m (SelfTest(s,m) → (ActivateHippocampus(s) ∧ ImproveRecall(s,m))))"
},
{
"input": "Translate into first-order logic: Encountering knowledge in various contexts improves retention compared to monotonous repetition.",
"output": "∀s (∀m (EncounterDifferentContexts(s,m) → HigherLongTermRetention(s,m)))"
},
{
"input": "Translate into first-order logic: Too short review intervals reduce retention due to lack of time for consolidation.",
"output": "∀s (∀m (TooShortIntervals(s,m) → InefficientLearning(s,m)))"
},
{
"input": "Translate into first-order logic: Too long review intervals risk forgetting most of the material before review.",
"output": "∀s (∀m (TooLongIntervals(s,m) → HighForgettingRate(s,m)))"
},
{
"input": "Translate into first-order logic: AI can personalize study schedules, optimizing memory retention for each student based on their progress.",
"output": "∀s (∀m (AiPersonalizedSchedule(s,m) → MostEfficientLearning(s,m)))"
},
{
"input": "Translate into first-order logic: If two triangles are similar, their corresponding sides are proportional.",
"output": "∀ABC (∀DEF (Similar(ABC, DEF) → Proportional(sides(ABC), Sides(DEF))))"
},
{
"input": "Translate into first-order logic: The centroid of a triangle divides each median in a 2:1 ratio.",
"output": "∀G (∀ABC (Centroid(G, ABC) → Ratio(median(G), 2:1)))"
},
{
"input": "Translate into first-order logic: A tangent to a circle is perpendicular to the radius at the point of tangency.",
"output": "∀T (∀O (Tangent(T, O) → Perpendicular(T, radius(O))))"
},
{
"input": "Translate into first-order logic: If two circles are orthogonal, the product of the distances from their intersection points to the centers equals the product of their radii.",
"output": "∀C1 (∀C2 (Orthogonal(C1, C2) → (DistanceProduct(intersections, centers) = RadiiProduct(C1, C2))))"
},
{
"input": "Translate into first-order logic: A point equidistant from two given points lies on the perpendicular bisector of the segment joining them.",
"output": "∀P (∀A (∀B (Equidistant(P, A, B) → LiesOn(P, perpendicular_bisector(AB)))))"
},
{
"input": "Translate into first-order logic: If a triangle is right-angled, then the median to the hypotenuse is half the hypotenuse.",
"output": "∀ABC (RightTriangle(ABC) → (Median(hypotenuse) = 0.5*hypotenuse))"
},
{
"input": "Translate into first-order logic: Procrastination occurs when there is a perceived gap between effort and reward.",
"output": "∀t (PerceivedEffortGap(t) → Procrastination(t))"
},
{
"input": "Translate into first-order logic: If a task has a clear deadline, people are more likely to complete it on time.",
"output": "∀t (HasDeadline(t) → MoreLikelyCompleteOnTime(t))"
},
{
"input": "Translate into first-order logic: If a student uses active recall, they retain more information than passive review.",
"output": "∀s (UsesActiveRecall(s) → RetainsMore(s))"
},
{
"input": "Translate into first-order logic: The Pomodoro technique increases focus by breaking work into timed intervals.",
"output": "∀p (UsesPomodoro(p) → IncreasedFocus(p))"
},
{
"input": "Translate into first-order logic: People are more likely to complete a task if they make a public commitment.",
"output": "∀t (PublicCommitment(t) → MoreLikelyComplete(t))"
},
{
"input": "Translate into first-order logic: Breaking a large task into smaller steps reduces mental resistance.",
"output": "∀t (LargeTask(t) → ReduceResistance(break_into_steps(t)))"
},
{
"input": "Translate into first-order logic: Sleep is crucial for memory consolidation.",
"output": "∀s (SufficientSleep(s) → BetterMemoryConsolidation(s))"
},
{
"input": "Translate into first-order logic: If stress is too high, cognitive performance decreases.",
"output": "∀s (HighStress(s) → DecreasedCognitivePerformance(s))"
},
{
"input": "Translate into first-order logic: If a student prioritizes urgent tasks over important tasks, long-term learning suffers.",
"output": "∀s (PrioritizesUrgent(s) → LearningSuffers(s))"
},
{
"input": "Translate into first-order logic: Motivation increases when a person sees progress in their work.",
"output": "∀p (SeesProgress(p) → IncreasedMotivation(p))"
},
{
"input": "Translate into first-order logic: If an astronaut undergoes advanced training and excels in simulations, they earn a flight clearance.",
"output": "∀a ((Training(a) ∧ Simulations(a)) → Clearance(a))"
},
{
"input": "Translate into first-order logic: If an astronaut earns a flight clearance and the launch vehicle passes a safety audit, they are approved for a Mars expedition.",
"output": "∀a ((Clearance(a) ∧ SafetyAudit(vehicle(a))) → Approved(a))"
},
{
"input": "Translate into first-order logic: If an astronaut is approved for a Mars expedition and the orbital trajectory is precisely calculated, the mission departs on schedule.",
"output": "∀a ((Approved(a) ∧ Trajectory(a)) → Departs(a))"
},
{
"input": "Translate into first-order logic: If the mission departs on schedule and Mars' radiation levels are within safe limits, a surface landing is authorized.",
"output": "∀a ((Departs(a) ∧ SafeRadiation(Mars)) → Landing(a))"
},
{
"input": "Translate into first-order logic: If a surface landing is authorized and the astronaut deploys a functioning rover, geological samples are collected.",
"output": "∀a ((Landing(a) ∧ Rover(a)) → Samples(a))"
},
{
"input": "Translate into first-order logic: If geological samples are collected and the analysis equipment is operational, a scientific breakthrough is possible.",
"output": "∀a ((Samples(a) ∧ Equipment(a)) → Breakthrough(a))"
},
{
"input": "Translate into first-order logic: Either Luna undergoes advanced training or she withdraws from the program.",
"output": "Training(Luna) ∨ Withdraw(Luna)"
},
{
"input": "Translate into first-order logic: Luna does not withdraw from the program.",
"output": "¬Withdraw(Luna)"
},
{
"input": "Translate into first-order logic: Luna excels in simulations.",
"output": "Simulations(Luna)"
},
{
"input": "Translate into first-order logic: The launch vehicle for Luna passes a safety audit.",
"output": "SafetyAudit(vehicle(Luna))"
},
{
"input": "Translate into first-order logic: The orbital trajectory for Luna's mission is precisely calculated.",
"output": "Trajectory(Luna)"
},
{
"input": "Translate into first-order logic: Mars' radiation levels are within safe limits.",
"output": "SafeRadiation(Mars)"
},
{
"input": "Translate into first-order logic: Luna deploys a functioning rover.",
"output": "Rover(Luna)"
},
{
"input": "Translate into first-order logic: The analysis equipment on Luna's mission is operational.",
"output": "Equipment(Luna)"
},
{
"input": "Translate into first-order logic: If the mission control loses contact, the trajectory cannot be calculated.",
"output": "LoseContact(control) → ¬Trajectory(Luna)"
},
{
"input": "Translate into first-order logic: Mission control does not lose contact.",
"output": "¬LoseContact(control)"
},
{
"input": "Translate into first-order logic: If the rover malfunctions, geological samples cannot be collected.",
"output": "Malfunction(rover(Luna)) → ¬Samples(Luna)"
},
{
"input": "Translate into first-order logic: The rover does not malfunction.",
"output": "¬Malfunction(rover(Luna))"
},
{
"input": "Translate into first-order logic: If radiation exceeds safe limits, a landing is not authorized.",
"output": "ExceedRadiation(Mars) → ¬Landing(Luna)"
},
{
"input": "Translate into first-order logic: Radiation does not exceed safe limits.",
"output": "¬ExceedRadiation(Mars)"
},
{
"input": "Translate into first-order logic: If Luna fails psychological evaluations, she cannot earn flight clearance.",
"output": "FailPsych(Luna) → ¬Clearance(Luna)"
},
{
"input": "Translate into first-order logic: Luna does not fail psychological evaluations.",
"output": "¬FailPsych(Luna)"
},
{
"input": "Translate into first-order logic: If the audit detects a flaw, the launch vehicle is not approved.",
"output": "FlawAudit(vehicle(Luna)) → ¬SafetyAudit(vehicle(Luna))"
},
{
"input": "Translate into first-order logic: The audit does not detect a flaw.",
"output": "¬FlawAudit(vehicle(Luna))"
},
{
"input": "Translate into first-order logic: If the equipment calibration fails, a breakthrough is not possible.",
"output": "FailCalibration(equipment(Luna)) → ¬Breakthrough(Luna)"
},
{
"input": "Translate into first-order logic: The equipment calibration does not fail.",
"output": "¬FailCalibration(equipment(Luna))"
},
{
"input": "Translate into first-order logic: If the expedition is delayed, samples cannot be collected on time.",
"output": "Delayed(expedition) → ¬Samples(Luna)"
},
{
"input": "Translate into first-order logic: The expedition is not delayed.",
"output": "¬Delayed(expedition)"
},
{
"input": "Translate into first-order logic: If a student completes all online modules on a platform with 99% uptime, they master the course content.",
"output": "∀s (∀c ((CompleteModules(s,c) ∧ (Uptime(c, uptimec) ∧ uptimec ≥ 99)) → MasterContent(s,c)))"
},
{
"input": "Translate into first-order logic: If a student masters the course content, they either pass a proctored exam or submit a capstone project.",
"output": "∀s (∀c (MasterContent(s,c) → (PassExam(s,c) ∨ SubmitCapstone(s,c))))"
},
{
"input": "Translate into first-order logic: If a student does not submit a capstone project, they must take the proctored exam.",
"output": "∀s (∀c (¬SubmitCapstone(s,c) → TakeExam(s,c)))"
},
{
"input": "Translate into first-order logic: If a course requires a proctored exam, the platform either provides a secure system or hires an external proctor.",
"output": "∀c (RequireExam(c) → (SecureSystem(c) ∨ ExternalProctor(c)))"
},
{
"input": "Translate into first-order logic: If a student experiences platform downtime exceeding 5 hours, they do not master the course content.",
"output": "∀s (∀c ((Downtime(s,c, downtimec) ∧ downtimec > 5) → ¬MasterContent(s,c)))"
},
{
"input": "Translate into first-order logic: If a student passes 6 or more online courses, they earn a digital certificate.",
"output": "∀s ((PassCount(s, passcounts) ∧ passcounts ≥ 6) → DigitalCertificate(s))"
},
{
"input": "Translate into first-order logic: If a student attends live sessions for a course with 100% participation, they are exempt from the proctored exam.",
"output": "∀s (∀c ((LiveSessions(s,c, livesessions) ∧ livesessions = 100) → ¬TakeExam(s,c)))"
},
{
"input": "Translate into first-order logic: If a student masters content in three courses but fails to submit capstone projects in any, they must take proctored exams for all three.",
"output": "∀s (∀c1 (∀c2 (∀c3 ((MasterContent(s,c1) ∧ MasterContent(s,c2) ∧ MasterContent(s,c3) ∧ ¬SubmitCapstone(s,c1) ∧ ¬SubmitCapstone(s,c2) ∧ ¬SubmitCapstone(s,c3)) → (TakeExam(s,c1) ∧ TakeExam(s,c2) ∧ TakeExam(s,c3))))))"
},
{
"input": "Translate into first-order logic: If a student experiences downtime less than 5 hours and submits a capstone, they still need platform verification if the course is high-stakes.",
"output": "∀s (∀c (((Downtime(s,c,downtimec) ∧ downtimec < 5) ∧ SubmitCapstone(s,c) ∧ HighStakes(c)) → NeedVerification(s,c)))"
},
{
"input": "Translate into first-order logic: If a student completes modules across four courses with 99% uptime and passes all exams, they qualify for an advanced credential.",
"output": "∀s ((CompleteModules(s,c1) ∧ CompleteModules(s,c2) ∧ CompleteModules(s,c3) ∧ CompleteModules(s,c4) ∧ (Uptime(c1, uptimec1) ∧ uptimec1 ≥ 99) ∧ (Uptime(c2, uptimec2) ∧ uptimec2 ≥ 99) ∧ (Uptime(c3. uptimec3) ∧ uptimec3 ≥ 99) ∧ (Uptime(c4, uptimec4) ∧ uptimec4 ≥ 99) ∧ PassExam(s,c1) ∧ PassExam(s,c2) ∧ PassExam(s,c3) ∧ PassExam(s,c4)) → AdvancedCredential(s))"
},
{
"input": "Translate into first-order logic: If the platform provides a secure system but it crashes during the exam, the exam is rescheduled.",
"output": "∀c (SecureSystem(c) ∧ CrashDuringExam(c) → RescheduleExam(c))"
},
{
"input": "Translate into first-order logic: If a student does not master the course content and submits a capstone, the capstone is rejected unless re-enrolled.",
"output": "∀s (∀c ((¬MasterContent(s,c) ∧ SubmitCapstone(s,c)) → (¬AcceptCapstone(s,c) ∨ ReEnroll(s,c))))"
},
{
"input": "Translate into first-order logic: A structured study plan improves consistency in learning.",
"output": "∀s (StructuredPlan(s) → ConsistentLearning(s))"
},
{
"input": "Translate into first-order logic: A student who engages in interdisciplinary studies gains a broader problem-solving perspective.",
"output": "∀s (InterdisciplinaryStudies(s) → BroaderProblemSolving(s))"
},
{
"input": "Translate into first-order logic: Frequent self-assessment helps students identify knowledge gaps.",
"output": "∀s (SelfAssessment(s) → IdentifiedKnowledgeGaps(s))"
},
{
"input": "Translate into first-order logic: Collaborative projects encourage teamwork and communication skills.",
"output": "∀s (CollaborativeProjects(s) → (EnhancedTeamwork(s) ∧ ImprovedCommunication(s)))"
},
{
"input": "Translate into first-order logic: Excessive screen time reduces attention span and increases cognitive fatigue.",
"output": "∀s (ExcessiveScreenTime(s) → (ReducedAttentionSpan(s) ∧ IncreasedCognitiveFatigue(s)))"
},
{
"input": "Translate into first-order logic: Students who learn through hands-on experiments develop better intuition for abstract concepts.",
"output": "∀s (HandsOnExperiments(s) → BetterIntuition(s))"
},
{
"input": "Translate into first-order logic: Engaging in debates sharpens critical thinking skills and argumentation strategies.",
"output": "∀s (Debates(s) → (SharpenedCriticalThinking(s) ∧ ImprovedArgumentation(s)))"
},
{
"input": "Translate into first-order logic: Students who document their learning progress can track improvement effectively.",
"output": "∀s (DocumentLearning(s) → TrackedImprovement(s))"
},
{
"input": "Translate into first-order logic: Studying in an environment with minimal distractions enhances focus.",
"output": "∀s (MinimalDistractions(s) → EnhancedFocus(s))"
},
{
"input": "Translate into first-order logic: Using spaced repetition techniques strengthens long-term memory.",
"output": "∀s (SpacedRepetition(s) → StrengthenedMemory(s))"
},
{
"input": "Translate into first-order logic: Writing summaries after studying reinforces comprehension and retention.",
"output": "∀s (WritingSummaries(s) → ReinforcedComprehension(s))"
},
{
"input": "Translate into first-order logic: Visualizing abstract concepts helps in better recall and understanding.",
"output": "∀s (Visualization(s) → (ImprovedRecall(s) ∧ BetterUnderstanding(s)))"
},
{
"input": "Translate into first-order logic: Physical exercise contributes to improved cognitive function and stress reduction.",
"output": "∀s (PhysicalExercise(s) → (ImprovedCognitiveFunction(s) ∧ ReducedStress(s)))"
},
{
"input": "Translate into first-order logic: Exploring historical perspectives of subjects deepens conceptual appreciation.",
"output": "∀s (HistoricalPerspectives(s) → DeeperConceptualAppreciation(s))"
},
{
"input": "Translate into first-order logic: Balancing leisure activities with study time prevents burnout.",
"output": "∀s (BalancedLeisure(s) → PreventedBurnout(s))"
},
{
"input": "Translate into first-order logic: Regularly changing study locations can improve retention and mental flexibility.",
"output": "∀s (ChangingStudyLocations(s) → (ImprovedRetention(s) ∧ MentalFlexibility(s)))"
},
{
"input": "Translate into first-order logic: Peer tutoring benefits both the tutor and the learner by reinforcing concepts.",
"output": "∀s (PeerTutoring(s) → MutualConceptReinforcement(s))"
},
{
"input": "Translate into first-order logic: Interactive learning tools increase engagement and concept application.",
"output": "∀s (InteractiveTools(s) → (IncreasedEngagement(s) ∧ BetterApplication(s)))"
},
{
"input": "Translate into first-order logic: Learning multiple subjects in parallel enhances cognitive adaptability.",
"output": "∀s (ParallelSubjects(s) → EnhancedCognitiveAdaptability(s))"
},
{
"input": "Translate into first-order logic: Setting specific goals for each study session boosts efficiency and motivation.",
"output": "∀s (GoalOrientedStudy(s) → (IncreasedEfficiency(s) ∧ BoostedMotivation(s)))"
},
{
"input": "Translate into first-order logic: Learning through play enhances engagement and retention.",
"output": "PlayBasedLearning(l) → IncreasedEngagement(l) ∧ BetterRetention(l)"
},
{
"input": "Translate into first-order logic: Gamification elements such as rewards and challenges increase motivation.",
"output": "IncludesGamification(g) → IncreasedMotivation(g)"
},
{
"input": "Translate into first-order logic: If learners actively participate in simulations, they develop problem-solving skills.",
"output": "ParticipatesInSimulations(s) → DevelopsProblemSolving(s)"
},
{
"input": "Translate into first-order logic: Digital learning platforms provide personalized feedback, which improves learning outcomes.",
"output": "UsesDigitalPlatform(p) → ReceivesFeedback(p) → ImprovedOutcomes(p)"
},
{
"input": "Translate into first-order logic: Collaborative online environments foster knowledge sharing and deeper understanding.",
"output": "CollaborativeEnvironment(e) → KnowledgeSharing(e) ∧ DeeperUnderstanding(e)"
},
{
"input": "Translate into first-order logic: If a student interacts with diverse cultural content, they develop a broader worldview.",
"output": "InteractsWithDiverseContent(s) → BroaderWorldview(s)"
},
{
"input": "Translate into first-order logic: Augmented reality (AR) and virtual reality (VR) make abstract concepts more tangible.",
"output": "UsesArVr(t) → MakesAbstractTangible(t)"
},
{
"input": "Translate into first-order logic: If learners set their own goals, they are more likely to persist in their studies.",
"output": "SetsOwnGoals(l) → MorePersistence(l)"
},
{
"input": "Translate into first-order logic: Immediate feedback helps correct misunderstandings before they become ingrained.",
"output": "ReceivesImmediateFeedback(f) → CorrectsMisunderstandings(f)"
},
{
"input": "Translate into first-order logic: If digital learning is well-structured, it can be as effective as traditional classroom learning.",
"output": "WellStructuredDigital(d) → EquivalentToTraditional(d)"
},
{
"input": "Translate into first-order logic: If a learning environment is interactive, students are more likely to engage with the material.",
"output": "InteractiveEnvironment(i) → IncreasedEngagement(i)"
},
{
"input": "Translate into first-order logic: Social learning enhances knowledge retention by encouraging discussion and collaboration.",
"output": "SocialLearning(s) → BetterRetention(s)"
},
{
"input": "Translate into first-order logic: If educational content is presented in multiple formats, comprehension improves.",
"output": "UsesMultipleFormats(c) → ImprovedComprehension(c)"
},
{
"input": "Translate into first-order logic: If a game-based learning platform adapts to a student's progress, they will remain motivated.",
"output": "AdaptiveGameLearning(g) → MaintainsMotivation(g)"
},
{
"input": "Translate into first-order logic: If learners experience real-world applications of knowledge, they are more likely to retain it.",
"output": "RealWorldApplications(r) → BetterRetention(r)"
},
{
"input": "Translate into first-order logic: Repetitive practice in a digital setting reinforces learning through spaced repetition.",
"output": "UsesSpacedRepetition(p) → ReinforcedLearning(p)"
},
{
"input": "Translate into first-order logic: Peer feedback can help learners identify and correct their own mistakes.",
"output": "ReceivesPeerFeedback(f) → IdentifiesMistakes(f)"
},
{
"input": "Translate into first-order logic: If a student reflects on their learning process, they develop metacognitive skills.",
"output": "ReflectsOnLearning(m) → DevelopsMetacognitive(m)"
},
{
"input": "Translate into first-order logic: Students who receive constructive feedback are more likely to improve their performance.",
"output": "ReceivesConstructiveFeedback(f) → PerformanceImprovement(f)"
},
{
"input": "Translate into first-order logic: Engaging digital experiences reduce cognitive overload, making learning more efficient.",
"output": "EngagingDigitalExperience(e) → ReducesOverload(e)"
},
{
"input": "Translate into first-order logic: Schools implement disciplinary policies to maintain a conducive learning environment.",
"output": "StructuredDiscipline(s) → BetterLearningEnvironment(s)"
},
{
"input": "Translate into first-order logic: Students who repeatedly violate rules may face escalating consequences.",
"output": "RepeatedViolations(s) → EscalatedConsequences(s)"
},
{
"input": "Translate into first-order logic: A structured disciplinary system ensures fairness and consistency in enforcement.",
"output": "StructuredDiscipline(s) → FairConsistentEnforcement(s)"
},
{
"input": "Translate into first-order logic: Peer influence plays a role in student behavior and adherence to rules.",
"output": "PeerInfluence(s) → BehaviorImpact(s)"
},
{
"input": "Translate into first-order logic: Restorative justice approaches help students understand the impact of their actions.",
"output": "RestorativeJustice(s) → UnderstandingImpact(s)"
},
{
"input": "Translate into first-order logic: Teachers trained in conflict resolution contribute to a more harmonious school environment.",
"output": "ConflictResolutionTraining(s) → HarmoniousEnvironment(s)"
},
{
"input": "Translate into first-order logic: Consistent enforcement of rules leads to better student compliance over time.",
"output": "ConsistentRuleEnforcement(s) → ImprovedCompliance(s)"
},
{
"input": "Translate into first-order logic: Excessive punishments can lead to resentment and reduced academic motivation.",
"output": "ExcessivePunishments(s) → ResentmentReducedMotivation(s)"
},
{
"input": "Translate into first-order logic: Parental involvement in discipline reinforces school rules at home.",
"output": "ParentalInvolvement(s) → ReinforcedSchoolRules(s)"
},
{
"input": "Translate into first-order logic: Positive reinforcement strategies encourage good behavior more effectively than punishment.",
"output": "PositiveReinforcement(s) → EncouragedGoodBehavior(s)"
},
{
"input": "Translate into first-order logic: Suspension policies should be designed to provide corrective rather than purely punitive measures.",
"output": "CorrectiveSuspensions(s) → BehavioralImprovement(s)"
},
{
"input": "Translate into first-order logic: Alternative disciplinary measures such as counseling and community service reduce recidivism.",
"output": "AlternativeDiscipline(s) → LowerRecidivism(s)"
},
{
"input": "Translate into first-order logic: Students are more likely to comply with rules if they feel rules are fair and justified.",
"output": "PerceivedFairness(s) → HigherRuleCompliance(s)"
},
{
"input": "Translate into first-order logic: A school's disciplinary reputation affects overall student morale and academic performance.",
"output": "DisciplinaryReputation(s) → StudentMoralePerformance(s)"
},
{
"input": "Translate into first-order logic: Schools that promote a culture of respect see fewer disciplinary infractions.",
"output": "RespectCulture(s) → FewerInfractions(s)"
},
{
"input": "Translate into first-order logic: Public recognition of good behavior fosters a positive school climate.",
"output": "RecognitionGoodBehavior(s) → PositiveSchoolClimate(s)"
},
{
"input": "Translate into first-order logic: Clear communication of rules and expectations minimizes misunderstandings and disputes.",
"output": "ClearRuleCommunication(s) → FewerDisputes(s)"
},
{
"input": "Translate into first-order logic: Student-led disciplinary committees promote accountability and fairness.",
"output": "StudentDisciplineCommittees(s) → AccountabilityFairness(s)"
},
{
"input": "Translate into first-order logic: An overly rigid disciplinary system can discourage creativity and independent thinking.",
"output": "RigidDiscipline(s) → LowerCreativityIndependence(s)"
},
{
"input": "Translate into first-order logic: Social-emotional learning programs contribute to better self-regulation and rule compliance.",
"output": "SelPrograms(s) → BetterSelfRegulation(s)"
},
{
"input": "Translate into first-order logic: If a student earns a scholarship and maintains good grades, they can afford to attend university.",
"output": "Scholarship(s) ∧ GoodGrades(s) → AffordUniversity(s)"
},
{
"input": "Translate into first-order logic: If a student attends university and joins a professional network, they gain access to internship opportunities.",
"output": "AttendUniversity(s) ∧ ProfessionalNetwork(s) → InternshipOpportunities(s)"
},
{
"input": "Translate into first-order logic: If a student completes an internship and receives mentorship, they develop professional skills.",
"output": "Internship(s) ∧ Mentorship(s) → ProfessionalSkills(s)"
},
{
"input": "Translate into first-order logic: If a student develops professional skills and participates in career fairs, they secure job offers.",
"output": "ProfessionalSkills(s) ∧ CareerFairs(s) → JobOffers(s)"
},
{
"input": "Translate into first-order logic: If a student secures job offers and graduates with honors, they start a successful career.",
"output": "JobOffers(s) ∧ Honors(s) → SuccessfulCareer(s)"
},
{
"input": "Translate into first-order logic: Either Alex earns a scholarship or he takes out a loan.",
"output": "Scholarship(Alex) ∨ Loan(Alex)"
},
{
"input": "Translate into first-order logic: Alex does not take out a loan.",
"output": "¬Loan(Alex)"
},
{
"input": "Translate into first-order logic: Alex maintains good grades.",
"output": "GoodGrades(Alex)"
},
{
"input": "Translate into first-order logic: Alex joins a professional network.",
"output": "ProfessionalNetwork(Alex)"
},
{
"input": "Translate into first-order logic: Alex completes an internship.",
"output": "Internship(Alex)"
},
{
"input": "Translate into first-order logic: Alex receives mentorship.",
"output": "Mentorship(Alex)"
},
{
"input": "Translate into first-order logic: Alex participates in career fairs.",
"output": "CareerFairs(Alex)"
},
{
"input": "Translate into first-order logic: Alex graduates with honors.",
"output": "Honors(Alex)"
},
{
"input": "Translate into first-order logic: If the scholarship fund is depleted, no student can earn a scholarship.",
"output": "depleted_fund → ¬Scholarship(s)"
},
{
"input": "Translate into first-order logic: The scholarship fund is not depleted.",
"output": "¬depleted_fund"
},
{
"input": "Translate into first-order logic: If the university lacks partnerships, professional networks are limited.",
"output": "LackPartnerships(university) → ¬ProfessionalNetwork(s)"
},
{
"input": "Translate into first-order logic: The university does not lack partnerships.",
"output": "¬LackPartnerships(university)"
},
{
"input": "Translate into first-order logic: If internships are unpaid, students cannot complete them without financial support.",
"output": "unpaid_internships ∧ ¬FinancialSupport(s) → ¬Internship(s)"
},
{
"input": "Translate into first-order logic: Alex has financial support for unpaid internships.",
"output": "FinancialSupport(Alex)"
},
{
"input": "Translate into first-order logic: If mentors are unavailable, students cannot receive mentorship.",
"output": "¬available_mentors → ¬Mentorship(s)"
},
{
"input": "Translate into first-order logic: Mentors are available.",
"output": "available_mentors"
},
{
"input": "Translate into first-order logic: If career fairs are canceled, students cannot participate.",
"output": "canceled_fairs → ¬CareerFairs(s)"
},
{
"input": "Translate into first-order logic: Career fairs are not canceled.",
"output": "¬canceled_fairs"
},
{
"input": "Translate into first-order logic: If the job market is weak, job offers are scarce.",
"output": "weak_market → ¬JobOffers(s)"
},
{
"input": "Translate into first-order logic: The job market is not weak.",
"output": "¬weak_market"
},
{
"input": "Translate into first-order logic: If graduation requirements are not met, students cannot graduate with honors.",
"output": "¬MeetRequirements(s) → ¬Honors(s)"
},
{
"input": "Translate into first-order logic: Alex meets graduation requirements.",
"output": "MeetRequirements(Alex)"
},
{
"input": "Translate into first-order logic: Students are allowed to change majors if their cumulative GPA is 7.0 or higher.",
"output": "ChangeMajor(x) → Gpa(x, gpa) ∧ gpa ≥ 7.0"
},
{
"input": "Translate into first-order logic: Students must complete at least 2 semesters in their current major before changing.",
"output": "ChangeMajor(x) → Semesters(x, semester) ∧ semester ≥ 2"
},
{
"input": "Translate into first-order logic: Accumulated credits must be at least 50% of the total credits of the current program.",
"output": "ChangeMajor(x) → AccumulatedCredits(x, accumulatedcredits) ∧ accumulatedcredits ≥ 0.5 * TotalCredits(x)"
},
{
"input": "Translate into first-order logic: The new major must have a professional similarity of 60% or higher, as determined by the professional council.",
"output": "ChangeMajor(x) → Similarity(x, similarity) ∧ similarity ≥ 0.6"
},
{
"input": "Translate into first-order logic: If students have taken major-specific courses, these courses must be assessed for knowledge equivalence with the new major.",
"output": "MajorCoursesTaken(x) → EquivalentAssessment(x)"
},
{
"input": "Translate into first-order logic: The major change must be approved by the academic council after reviewing grades, professional competence, and personal aspirations.",
"output": "ChangeMajor(x) → CouncilApproval(x)"
},
{
"input": "Translate into first-order logic: The academic council only meets for review in March and September each year.",
"output": "CouncilApproval(x) → March(x) ∨ September(x)"
},
{
"input": "Translate into first-order logic: Students must submit their major change application at least 30 days before the council meeting.",
"output": "ChangeMajor(x) → ApplicationDays(x) ≥ 30"
},
{
"input": "Translate into first-order logic: Late applications require waiting until the next meeting and paying a 10% tuition fee penalty.",
"output": "LateApplication(x) → WaitNextTerm(x) ∧ Penalty(x, penalty) ∧ penalty = 0.1 * Tuition(x)"
},
{
"input": "Translate into first-order logic: The major change fee is 50% of the current semester's tuition, unless the student is eligible for priority policies.",
"output": "ChangeMajor(x) → ChangeFee(x) = 0.5 * Tuition(x) ∧ ¬PolicyEligible(x)"
},
{
"input": "Translate into first-order logic: Scholarship students must be reviewed separately by the finance department before changing majors.",
"output": "Scholarship(x) ∧ ChangeMajor(x) → SeparateReview(x)"
},
{
"input": "Translate into first-order logic: If the scholarship is revoked after changing majors, students must repay 25% of the scholarship value received.",
"output": "Scholarship(x) ∧ ChangeMajor(x) ∧ ScholarshipRevoked(x) → Repayment(x) = 0.25 * ScholarshipValue(x)"
},
{
"input": "Translate into first-order logic: Students must complete missing courses in the new major within 1 year, with a maximum of 15 additional credits.",
"output": "ChangeMajor(x) → MakeUpCourses(x, makeupcourses) ∧ makeupcourses ≤ 1 ∧ MakeUpCredits(x, makeupcredits) ∧ makeupcredits ≤ 15"
},
{
"input": "Translate into first-order logic: Failure to complete make-up courses within the specified time will result in academic suspension.",
"output": "Gpa(x,gpa) ∧ gpa < 6.0 ∧ ChangeMajor(x) → AcademicWarning(x)"
},
{
"input": "Translate into first-order logic: If the cumulative GPA falls below 6.0 after changing majors, students will receive academic warnings for 2 consecutive semesters.",
"output": "AcademicWarning(x) ∧ NextTermGpa(x, nexttermgpa) ∧ nexttermgpa > 6.5 ∧ ¬Violation(x) → LiftWarning(x)"
},
{
"input": "Translate into first-order logic: Academic warnings are only lifted if the GPA is above 6.5 in the next semester and there are no violations of school regulations.",
"output": "ChangeMajor(x) → ChangeCount(x, ccount) ∧ ccount ≤ 1 ∧ ¬SpecialCase(x)"
},
{
"input": "Translate into first-order logic: Students can only change majors a maximum of 1 time, except in special cases approved by the council.",
"output": "ChangeMajor(x) → CreditRetention(x, credits) ∧ credits ≥ 0.7"
},
{
"input": "Translate into first-order logic: Accumulated courses are only retained if they are 70% compatible with the new major, otherwise they must be retaken.",
"output": "PolicyEligible(x) → FeeDiscount(x,feediscount) ∧ feediscount = 0.2 ∧ PriorityReview(x)"
},
{
"input": "Translate into first-order logic: Students eligible for policies or with disabilities receive a 20% discount on the major change fee and priority review.",
"output": "EntranceExam(x) → ExamScore(x, examscore) ∧ excamscore ≥ 0.75 ∧ StandardScore(x)"
},
{
"input": "Translate into first-order logic: If the new major requires an entrance exam, students must achieve at least 75% of the standard score.",
"output": "ApplicationFraud(x) → ¬CouncilApproval(x)"
},
{
"input": "Translate into first-order logic: The academic council can reject major changes if they discover students have falsified their applications.",
"output": "Gpa(Mai,gpaMai) ∧ gpaMai = 7.2 ∧ Semesters(Mai, semesterMai) ∧ semesterMai = 3"
},
{
"input": "Translate into first-order logic: Mai has a cumulative GPA of 7.2 and has completed 3 semesters in Information Technology.",
"output": "ChangeMajor(Mai, IT, BiomedicalEng) ∧ Similarity(Mai, similarityMai) ∧ similarityMai = 0.65"
},
{
"input": "Translate into first-order logic: Mai wants to switch to Biomedical Engineering, which has a 65% similarity.",
"output": "AccumulatedCredits(Mai, accumulatedcredits) ∧ accumulatedcredits = 45 ∧ TotalCredits(Mai, totalcredits) ∧ totalcredits = 90 ∧ ApplicationDays(Mai, applicationdays) ∧ applicationdays = 45"
},
{
"input": "Translate into first-order logic: Mai has completed 45/90 credits in her current major and submitted her application on time in August.",
"output": "Scholarship(Mai, scholarship) ^ scholarship = 0.5 * Tuition(Mai) ∧ ChangeCount(Mai, changecount) ^ changecount = 0"
},
{
"input": "Translate into first-order logic: Mai has a 50% tuition scholarship and has not changed majors before.",
"output": "EntranceExam(Mai) ∧ StandardScore(Mai, standardscore) ∧ standardscore = 80 ∧ ExamScore(Mai, examscore) ∧ examscore = 78"
},
{
"input": "Translate into first-order logic: If an aviation student completes the aircraft theory course, they are allowed to participate in the flight practice course.",
"output": "CompleteTheory(s) → ParticipatePractice(s)"
},
{
"input": "Translate into first-order logic: If the weather is bad on the practice day, the flight will be delayed by at least 2 hours.",
"output": "BadWeather(s) → DelayPractice(s, delay) ∧ delay ≥ 2"
},
{
"input": "Translate into first-order logic: Students must complete a safety test before flight practice within 1 hour.",
"output": "FlightPractice(s) → SafetyTest(s, test) ∧ test ≤ 1"
},
{
"input": "Translate into first-order logic: If they fail the safety test, students cannot fly and must retake the theory course.",
"output": "¬SafetyTest(s) → ¬FlightPractice(s) ∧ RetakeTheory(s)"
},
{
"input": "Translate into first-order logic: If the flight is delayed by more than 3 hours, students are refunded 50% of the practice course fee.",
"output": "DelayPractice(s, delayy) ∧ delay > 3 → Refund(s, refund) ∧ refund = 0.5"
},
{
"input": "Translate into first-order logic: If students fly more than 1 hour late from the schedule, they must submit a supplementary report.",
"output": "FlightLate(s, flightlate) ∧ flightlate > 1 → SubmitReport(s)"
},
{
"input": "Translate into first-order logic: The flight practice course requires at least 2 instructors: a flight instructor and a technician.",
"output": "FlightPractice(s) → Instructors(s, instructor) ∧ instructor  ≥ 2"
},
{
"input": "Translate into first-order logic: If the flight instructor is absent, the course must find a replacement within 1 hour.",
"output": "InstructorAbsent(s) → FindReplacement(s, findreplacement)  ∧ findreplacement ≤ 1"
},
{
"input": "Translate into first-order logic: If no replacement is found, the practice session is canceled and students must re-register.",
"output": "InstructorAbsent(s) ∧ ¬FindReplacement(s) → CancelPractice(s) ∧ Reregister(s)"
},
{
"input": "Translate into first-order logic: Students must submit their practice registration application 7 days in advance for scheduling.",
"output": "FlightPractice(s) → SubmitApplication(s, submitapplication) ∧ submitapplication ≥ 7"
},
{
"input": "Translate into first-order logic: No replacement flight instructor was found within 1 hour.",
"output": "¬FindReplacement(Lan, 1)"
},
{
"input": "Translate into first-order logic: Students must be notified of the practice session cancellation at least 30 minutes before the scheduled 9:00 AM flight.",
"output": "CancelPractice(s) → NotifyCancellation(s, notifycancellation) ∧ notifycacellation ≥ 0.5"
},
{
"input": "Translate into first-order logic: If the practice session is canceled, students must take a make-up session within 2 weeks or lose their flight exam eligibility.",
"output": "CancelPractice(s) → MakeUpSession(s, makeupsession) ∧ makeupsession ≤ 2 ∨ LoseExamEligibility(s)"
},
{
"input": "Translate into first-order logic: If a student's answers are identical to another student's in over 90% of the exam, it may indicate cheating.",
"output": "IdenticalAnswers(s,t,identicalanswer) ∧ identicalanswer > 90 → Cheating(s,t) ∨ FurtherReview(s,t)"
},
{
"input": "Translate into first-order logic: If two students submit their exams within a time difference of less than 1 minute, further review is required.",
"output": "SubmitTime(s, submittime) v SubmitTime(t, submittime) ∧ submittime < 1 → FurtherReview(s,t)"
},
{
"input": "Translate into first-order logic: If a student completes the exam in less than 50% of the class's average time, it may indicate anomalies.",
"output": "CompletionTime(s, completiontime) ∧ completiontime < 0.5 ∧ class_average → Anomalous(s)"
},
{
"input": "Translate into first-order logic: If a student uses rare terms that match reference materials without citation, it may indicate plagiarism.",
"output": "PlagiarizedMaterial(s) ∧ ¬Cited(s) → Plagiarism(s)"
},
{
"input": "Translate into first-order logic: If the monitoring system detects the student's gaze leaving the screen more than 10 times, it may indicate cheating.",
"output": "GazeDeviation(s, gazedeviation) ∧ gazedeviation > 10 → ScreenCheating(s)"
},
{
"input": "Translate into first-order logic: If a student has a history of exam regulation violations, the probability of recurrence increases by 20%.",
"output": "CheatingHistory(s) → RecurrenceProbability(s, recurrence) ∧ recurrence + 0.2"
},
{
"input": "Translate into first-order logic: If the examination board confirms cheating, the student is suspended and receives a score of 0.",
"output": "ConfirmCheating(s) → Suspension(s) ∧ Score(s, score) ∧ score = 0"
},
{
"input": "Translate into first-order logic: If the AI system detects cheating with over 95% confidence, the board must convene within 48 hours.",
"output": "AiDetection(s, aidetection) ∧ aidetection > 95 → BoardMeeting(s, boardmeeting) ∧ boardmeeting ≤ 48"
},
{
"input": "Translate into first-order logic: If a student is not immediately suspended, they can appeal within 7 days.",
"output": "¬ImmediateSuspension(s) → Appeal(s, appeal) ∧ appeal ≤ 7"
},
{
"input": "Translate into first-order logic: If the appeal is denied, the student must retake the course and pay a penalty of 30% of the tuition fee.",
"output": "Appeal(s) ∧ ¬AcceptAppeal(s) → RetakeCourse(s) ∧ Penalty(s, penalty) ∧ penalty = 0.3 ∧ Tuition(s)"
},
{
"input": "Translate into first-order logic: If a student uses a second device during an online exam, it is a serious violation.",
"output": "SecondDevice(s) → SeriousViolation(s)"
},
{
"input": "Translate into first-order logic: If an invigilator detects a student communicating via headphones, the exam is immediately invalidated.",
"output": "HeadphoneCommunication(s) → ExamInvalidation(s)"
},
{
"input": "Translate into first-order logic: If an exam has more than 3 technical errors, the exam will be rescheduled.",
"output": "TechnicalErrors(s, technicalerrors) ∧ technicalerrors > 3 → RescheduleExam(s)"
},
{
"input": "Translate into first-order logic: If a student does not turn on their camera throughout the exam, they are considered to have violated regulations.",
"output": "¬CameraOn(s) → RegulationViolation(s)"
},
{
"input": "Translate into first-order logic: If a student submits their exam more than 5 minutes late, 10% is deducted from their score.",
"output": "LateSubmission(s, late) ∧ late > 5 → ScoreDeduction(s, scorededuction) ∧ scoredetuction = 0.1"
},
{
"input": "Translate into first-order logic: If more than 50% of the class is suspected of cheating, the entire exam will be reinvestigated.",
"output": "ClassCheatingSuspicionRate(s, cheatingrate) ∧ cheatingrate > 0.5 → Reinvestigation(s)"
},
{
"input": "Translate into first-order logic: If a student achieves a perfect score but there are anomalies, cross-checking with AI data is required.",
"output": "PerfectScore(s) ∧ Anomalous(s) → AiCrossCheck(s)"
},
{
"input": "Translate into first-order logic: If the board convenes more than 72 hours after the exam, the student has the right to request a review.",
"output": "LateBoardMeeting(s, lateboardmeet) ∧ lateboardmeet > 72 → ReviewRequest(s)"
},
{
"input": "Translate into first-order logic: If a student has been previously suspended, they cannot appeal this time.",
"output": "PreviouslySuspended(s) → ¬Appeal(s)"
},
{
"input": "Translate into first-order logic: If the AI system malfunctions, cheating results will be manually reviewed.",
"output": "AiFailure(s) → ManualReview(s)"
},
{
"input": "Translate into first-order logic: If a student has a course average below 5.0 before the exam, they are under special surveillance.",
"output": "CourseAverageBefore(s, courseaverage) ∧ courseaverage < 5.0 → SpecialSurveillance(s)"
},
{
"input": "Translate into first-order logic: If a student leaves their seat during an online exam, it is a violation of regulations.",
"output": "LeaveSeat(s) → RegulationViolation(s)"
},
{
"input": "Translate into first-order logic: If a student's exam has an unusual format (font, spacing), technical inspection is required.",
"output": "UnusualFormat(s) → TechnicalInspection(s)"
},
{
"input": "Translate into first-order logic: If a student does not log in with the correct assigned account, the exam is not accepted.",
"output": "¬CorrectLogin(s) → ¬ExamAccepted(s)"
},
{
"input": "Translate into first-order logic: If the board discovers cheating evidence from stored camera footage, the student is subject to an additional fine of 500,000 VND.",
"output": "CameraEvidence(s) → AdditionalFine(s, additionalfine) ∧ additionalfine = 500000"
},
{
"input": "Translate into first-order logic: Students A and B submitted their exams 30 seconds apart.",
"output": "SubmitTime(A) - SubmitTime(B) = 0.5"
},
{
"input": "Translate into first-order logic: Student A's completion time was 15 minutes, the class average was 40 minutes.",
"output": "CompletionTime(A, comletiontime) ∧ completiontime = 15 ∧ class_average = 40"
},
{
"input": "Translate into first-order logic: Student A used rare terms from 'History 101' without citation.",
"output": "PlagiarizedMaterial(A,'History 101') ∧ ¬Cited(A)"
},
{
"input": "Translate into first-order logic: The system recorded A's gaze leaving the screen 12 times.",
"output": "GazeDeviation(A, gazedeviation) ∧ gazedeviation = 12"
},
{
"input": "Translate into first-order logic: The AI system determined A's probability of cheating to be 97%.",
"output": "AiDetection(A, aidetection) ∧ aidetection = 97"
},
{
"input": "Translate into first-order logic: There exists at least one student who completes all assigned exercises",
"output": "∃x (S(x) ∧ E(x))"
},
{
"input": "Translate into first-order logic: All students attend class regularly",
"output": "∀x (S(x) → A(x))"
},
{
"input": "Translate into first-order logic: If a student has a consistent study routine, then they attend class regularly",
"output": "∀x (S(x) → (R(x) → A(x)))"
},
{
"input": "Translate into first-order logic: If a student seeks help from teaching assistants when needed, then they complete all assigned exercises",
"output": "∀x (S(x) → (H(x) → E(x)))"
},
{
"input": "Translate into first-order logic: Every Python project is well-structured.",
"output": "∀x (Project(x) → WellStructured(x))"
},
{
"input": "Translate into first-order logic: If a Python project is well-structured, then it is optimized.",
"output": "∀x (Project(x) ∧ WellStructured(x) → Optimized(x))"
},
{
"input": "Translate into first-order logic: If a Python project is well-tested, then it is optimized.",
"output": "∀x (Project(x) ∧ WellTested(x) → Optimized(x))"
},
{
"input": "Translate into first-order logic: If a Python project is well-tested, then it follows PEP 8 standards.",
"output": "∀x (Project(x) ∧ WellTested(x) → FollowsPEP8(x))"
},
{
"input": "Translate into first-order logic: All Python projects have clean and readable code.",
"output": "∀x (Project(x) → CleanReadable(x))"
},
{
"input": "Translate into first-order logic: All Python projects are easy to maintain.",
"output": "∀x (Project(x) → EasyToMaintain(x))"
},
{
"input": "Translate into first-order logic: If a Python project is easy to maintain, then it is well-tested.",
"output": "∀x (Project(x) ∧ EasyToMaintain(x) → WellTested(x))"
},
{
"input": "Translate into first-order logic: If a student is not motivated, they will not pass the exams.",
"output": "∀x (¬Motivated(X)→¬Pass(x))"
},
{
"input": "Translate into first-order logic: All students submit homework on time.",
"output": "∀x (Submit(X))"
},
{
"input": "Translate into first-order logic: At least one student is registered for an advanced course.",
"output": "∃x (Registered(X))"
},
{
"input": "Translate into first-order logic: At least one student passes the exams.",
"output": "∃x (Pass(X))"
},
{
"input": "Translate into first-order logic: If a student actively participates in class discussions, they submit homework on time.",
"output": "∀x (Participate(X)→Submit(x))"
},
{
"input": "Translate into first-order logic: If a student is not motivated, they will not participate in class discussions.",
"output": "∀x (¬Motivated(X)→¬Participate(x))"
},
{
"input": "Translate into first-order logic: If a student submits homework on time, they pass the exams.",
"output": "∀x (Submit(X)→Pass(x))"
},
{
"input": "Translate into first-order logic: If a student is registered for an advanced course, they are motivated.",
"output": "∀x (Registered(X) → Motivated(x))"
},
{
"input": "Translate into first-order logic: If a student passes the exams, they will successfully graduate.",
"output": "∀x (Pass(X) → Graduate(x))"
},
{
"input": "Translate into first-order logic: If a student graduates, they achieve success.",
"output": "∀x (Graduate(X) → Success(x))"
},
{
"input": "Translate into first-order logic: If a student does not practice solving math problems, they will not be able to solve them correctly.",
"output": "∀x (¬Practice(X) → ¬Solve(x))"
},
{
"input": "Translate into first-order logic: All students attend math lectures regularly.",
"output": "∀x (Attend(X))"
},
{
"input": "Translate into first-order logic: At least one student is enrolled in an advanced math course.",
"output": "∃x (Enrolled(X))"
},
{
"input": "Translate into first-order logic: At least one student can solve math problems correctly.",
"output": "∃x (Solve(X))"
},
{
"input": "Translate into first-order logic: If a student asks questions in math class, they must have attended lectures.",
"output": "∀x (AskQuestions(X) → Attend(x))"
},
{
"input": "Translate into first-order logic: If a student does not practice math problems, they will not ask questions in class.",
"output": "∀x (¬Practice(X) → ¬AskQuestions(x))"
},
{
"input": "Translate into first-order logic: If a student can solve math problems correctly, they will pass the math exam.",
"output": "∀x (Solve(X) → Pass(x))"
},
{
"input": "Translate into first-order logic: If a student is enrolled in an advanced math course, they are motivated to study math.",
"output": "∀x (Enrolled(X) → Motivated(x))"
},
{
"input": "Translate into first-order logic: If a student passes the math exam, they successfully complete the math curriculum.",
"output": "∀x (Pass(X) → Graduate(x))"
},
{
"input": "Translate into first-order logic: If a student successfully completes the math curriculum, they excel in mathematics.",
"output": "∀x (Graduate(X) → Excel(x))"
},
{
"input": "Translate into first-order logic: If a person is not hardworking, they will not be successful in their career.",
"output": "∀x (¬Hardworking(X) → ¬Successful(x))"
},
{
"input": "Translate into first-order logic: All individuals in the company are punctual.",
"output": "∀x (Punctual(X))"
},
{
"input": "Translate into first-order logic: At least one individual has experience in their field.",
"output": "∃x (EXperienced(X))"
},
{
"input": "Translate into first-order logic: At least one person is successful in their career.",
"output": "∃x (Successful(X))"
},
{
"input": "Translate into first-order logic: If a person is responsible, they are punctual.",
"output": "∀x (Responsible(X) → Punctual(x))"
},
{
"input": "Translate into first-order logic: If a person is not hardworking, they will not be responsible.",
"output": "∀x (¬Hardworking(X) → ¬Responsible(x))"
},
{
"input": "Translate into first-order logic: If a person works efficiently, they will be promoted.",
"output": "∀x (Efficient(X) → Promoted(x))"
},
{
"input": "Translate into first-order logic: If a person has experience in their field, they are hardworking.",
"output": "∀x (EXperienced(X) → Hardworking(x))"
},
{
"input": "Translate into first-order logic: If a person is promoted, they will be recognized by their employer.",
"output": "∀x (Promoted(X) → Recognized(x))"
},
{
"input": "Translate into first-order logic: If a person is recognized by their employer, they will become a leader in their organization.",
"output": "∀x (Recognized(X) → Leader(x))"
},
{
"input": "Translate into first-order logic: Every student has a GPA.",
"output": "∀x (HasGPA(X))"
},
{
"input": "Translate into first-order logic: If a student never attends lectures, their GPA will never improve.",
"output": "∀x (¬AttendsLectures(X) → ¬ImprovesGPA(x))"
},
{
"input": "Translate into first-order logic: If a student submits all assignments on time, then their GPA improves.",
"output": "∀x (SubmitsAssignments(X) → ImprovesGPA(x))"
},
{
"input": "Translate into first-order logic: There exists at least one student who is on the honor roll.",
"output": "∃x (HonorRoll(X))"
},
{
"input": "Translate into first-order logic: If a student has a high GPA, then they are eligible for a scholarship.",
"output": "∀x (HighGPA(X) → EligibleForScholarship(x))"
},
{
"input": "Translate into first-order logic: If a student has a high GPA, then they are placed on the honor roll.",
"output": "∀x (HighGPA(X) → HonorRoll(x))"
},
{
"input": "Translate into first-order logic: If we assume that having a high GPA leads to being on the honor roll, then attending all lectures must contribute to improving GPA.",
"output": "∀x ((HighGPA(X) → HonorRoll(x)) → (AttendsLectures(x) → ImprovesGPA(x)))"
},
{
"input": "Translate into first-order logic: There exists at least one student who attends all lectures.",
"output": "∃x (AttendsLectures(X))"
},
{
"input": "Translate into first-order logic: There exists at least one student who is eligible for a scholarship.",
"output": "∃x (EligibleForScholarship(X))"
},
{
"input": "Translate into first-order logic: Every student on the honor roll has a high GPA.",
"output": "∀x (HonorRoll(X) → HighGPA(x))"
},
{
"input": "Translate into first-order logic: If a student improves their grades, they will eventually achieve high grades.",
"output": "∀x (ImprovesGrades(X) → HighGrades(x))"
},
{
"input": "Translate into first-order logic: If a student has high grades, they are eligible for a scholarship.",
"output": "∀x (HighGrades(X) → ScholarshipEligible(x))"
},
{
"input": "Translate into first-order logic: If a student has high grades, they are considered a high achiever.",
"output": "∀x (HighGrades(X) → HighAchiever(x))"
},
{
"input": "Translate into first-order logic: If a student attends lectures, they understand the material.",
"output": "∀x (AttendsLectures(X) → UnderstandsMaterial(x))"
},
{
"input": "Translate into first-order logic: If a student understands the material, they perform well in exams.",
"output": "∀x (UnderstandsMaterial(X) → PerformsWellExams(x))"
},
{
"input": "Translate into first-order logic: If a student is eligible for a scholarship, their tuition fee is reduced.",
"output": "∀x (ScholarshipEligible(X) → ReducedTuitionFee(x))"
},
{
"input": "Translate into first-order logic: If a student has a reduced tuition fee, they experience less financial burden.",
"output": "∀x (ReducedTuitionFee(X) → LessFinancialBurden(x))"
},
{
"input": "Translate into first-order logic: If a student has less financial burden, they have more time to study.",
"output": "∀x (LessFinancialBurden(X) → MoreStudyTime(x))"
},
{
"input": "Translate into first-order logic: If a student has more study time, their grades improve.",
"output": "∀x (MoreStudyTime(X) → ImprovesGrades(x))"
},
{
"input": "Translate into first-order logic: If a student attends lectures regularly, they understand the course material.",
"output": "∀x (AttendsLectures(X) → UnderstandsMaterial(x))"
},
{
"input": "Translate into first-order logic: If a student understands the course material, they perform well in exams.",
"output": "∀x (UnderstandsMaterial(X) → PerformsWellExams(x))"
},
{
"input": "Translate into first-order logic: If a student performs well in exams, they achieve a high GPA.",
"output": "∀x (PerformsWellEXams(X) → HighGPA(x))"
},
{
"input": "Translate into first-order logic: If a student achieves a high GPA, they are eligible for academic awards.",
"output": "∀x (HighGPA(X) → AcademicAwardsEligible(x))"
},
{
"input": "Translate into first-order logic: If a student is eligible for academic awards, they receive financial benefits.",
"output": "∀x (AcademicAwardsEligible(X) → FinancialBenefits(x))"
},
{
"input": "Translate into first-order logic: If a student participates in research projects, they gain practical experience.",
"output": "∀x (ParticipatesResearch(X) → GainsPracticalExperience(x))"
},
{
"input": "Translate into first-order logic: If a student gains practical experience, they have a higher chance of getting internships.",
"output": "∀x (GainsPracticalEXperience(X) → HigherChanceInternship(x))"
},
{
"input": "Translate into first-order logic: If a student secures an internship, they improve their job prospects after graduation.",
"output": "∀x (SecuresInternship(X) → ImprovesJobProspects(x))"
},
{
"input": "Translate into first-order logic: If a student networks with professors, they get strong recommendation letters.",
"output": "∀x (NetworksProfessors(X) → StrongRecommendationLetters(x))"
},
{
"input": "Translate into first-order logic: If a student has strong recommendation letters, they have better opportunities for graduate school.",
"output": "∀x (StrongRecommendationLetters(X) → BetterGraduateSchoolOpportunities(x))"
},
{
"input": "Translate into first-order logic: If a student has better opportunities for graduate school, they can pursue advanced education.",
"output": "∀x (BetterGraduateSchoolOpportunities(X) → CanPursueAdvancedEducation(x))"
},
{
"input": "Translate into first-order logic: If a student pursues advanced education, they increase their earning potential.",
"output": "∀x (CanPursueAdvancedEducation(X) → IncreasesEarningPotential(x))"
},
{
"input": "Translate into first-order logic: If a student applies for internships, they have a chance to secure an internship.",
"output": "∀x (AppliesInternships(X) → ChanceSecuresInternship(x))"
},
{
"input": "Translate into first-order logic: If a student secures an internship, they gain practical experience.",
"output": "∀x (SecuresInternship(X) → GainsPracticalExperience(x))"
},
{
"input": "Translate into first-order logic: If a student gains practical experience, they improve their job prospects after graduation.",
"output": "∀x (GainsPracticalEXperience(X) → ImprovesJobProspects(x))"
},
{
"input": "Translate into first-order logic: If a student performs well in their internship, they may receive a full-time job offer.",
"output": "∀x (PerformsWellInternship(X) → MayReceiveFullTimeJob(x))"
},
{
"input": "Translate into first-order logic: If a student receives a full-time job offer before graduation, they have a smoother transition into the workforce.",
"output": "∀x (ReceivesFullTimeJob(X) → SmoothWorkforceTransition(x))"
},
{
"input": "Translate into first-order logic: If a student has multiple internships, they build a strong resume.",
"output": "∀x (MultipleInternships(X) → BuildsStrongResume(x))"
},
{
"input": "Translate into first-order logic: If a student builds a strong resume, they increase their chances of getting hired after graduation.",
"output": "∀x (BuildsStrongResume(X) → HigherChanceGettingHired(x))"
},
{
"input": "Translate into first-order logic: If a student has industry connections, they have a higher chance of securing an internship.",
"output": "∀x (IndustryConnections(X) → HigherChanceSecuringInternship(x))"
},
{
"input": "Translate into first-order logic: If a student has a mentor in the industry, they receive career guidance.",
"output": "∀x (HasMentor(X) → ReceivesCareerGuidance(x))"
},
{
"input": "Translate into first-order logic: If a student receives career guidance, they make informed career decisions.",
"output": "∀x (ReceivesCareerGuidance(X) → MakesInformedCareerDecisions(x))"
},
{
"input": "Translate into first-order logic: If a student makes informed career decisions, they have better career growth.",
"output": "∀x (MakesInformedCareerDecisions(X) → BetterCareerGrowth(x))"
},
{
"input": "Translate into first-order logic: If a student has better career growth, they increase their earning potential.",
"output": "∀x (BetterCareerGrowth(X) → IncreasesEarningPotential(x))"
},
{
"input": "Translate into first-order logic: If a student builds a strong resume, they increase their chances of securing a job.",
"output": "∀x (BuildsStrongResume(X) → HigherChanceJob(x))"
},
{
"input": "Translate into first-order logic: If a student attends career workshops, they improve their job application skills.",
"output": "∀x (AttendsCareerWorkshops(X) → ImprovesJobApplicationSkills(x))"
},
{
"input": "Translate into first-order logic: If a student improves their job application skills, they perform better in job interviews.",
"output": "∀x (ImprovesJobApplicationSkills(X) → PerformsBetterInterviews(x))"
},
{
"input": "Translate into first-order logic: If a student performs better in job interviews, they have a higher chance of getting hired.",
"output": "∀x (PerformsBetterInterviews(X) → HigherChanceGettingHired(x))"
},
{
"input": "Translate into first-order logic: If a student participates in internships, they gain relevant work experience.",
"output": "∀x (ParticipatesInternships(X) → GainsWorkExperience(x))"
},
{
"input": "Translate into first-order logic: If a student gains relevant work experience, they enhance their employability.",
"output": "∀x (GainsWorkEXperience(X) → EnhancesEmployability(x))"
},
{
"input": "Translate into first-order logic: If a student has professional networking skills, they can connect with potential employers.",
"output": "∀x (HasNetworkingSkills(X) → ConnectsPotentialEmployers(x))"
},
{
"input": "Translate into first-order logic: If a student connects with potential employers, they receive job opportunities.",
"output": "∀x (ConnectsPotentialEmployers(X) → ReceivesJobOpportunities(x))"
},
{
"input": "Translate into first-order logic: If a student has a career mentor, they receive guidance on career decisions.",
"output": "∀x (HasCareerMentor(X) → ReceivesCareerGuidance(x))"
},
{
"input": "Translate into first-order logic: If a student receives guidance on career decisions, they make informed career choices.",
"output": "∀x (ReceivesCareerGuidance(X) → MakesInformedCareerChoices(x))"
},
{
"input": "Translate into first-order logic: If a student makes informed career choices, they have better long-term career growth.",
"output": "∀x (MakesInformedCareerChoices(X) → BetterCareerGrowth(x))"
},
{
"input": "Translate into first-order logic: If a student has better long-term career growth, they achieve financial stability.",
"output": "∀x (BetterCareerGrowth(X) → AchievesFinancialStability(x))"
},
{
"input": "Translate into first-order logic: If a student attends lectures regularly, they have a better understanding of the subject.",
"output": "∀x (AttendsLecturesRegularly(X) → BetterUnderstanding(x))"
},
{
"input": "Translate into first-order logic: If a student understands the subject well, they perform better in exams.",
"output": "∀x (BetterUnderstanding(X) → PerformsBetterExams(x))"
},
{
"input": "Translate into first-order logic: All students have access to academic support services.",
"output": "∀x (Student(X) → HasAccessToAcademicSupport(x))"
},
{
"input": "Translate into first-order logic: If a student uses academic support services, they improve their performance.",
"output": "∀x (UsesAcademicSupport(X) → ImprovesPerformance(x))"
},
{
"input": "Translate into first-order logic: If a student performs well in exams, they have a higher GPA.",
"output": "∀x (PerformsWellEXams(X) → HigherGPA(x))"
},
{
"input": "Translate into first-order logic: All students have access to study materials.",
"output": "∀x (Student(X) → HasAccessToStudyMaterials(x))"
},
{
"input": "Translate into first-order logic: At least one student participates in group study sessions.",
"output": "∃x (ParticipatesGroupStudy(X))"
},
{
"input": "Translate into first-order logic: If participation in group study sessions improves understanding, then all students must engage in them regularly.",
"output": "(∀x (ParticipatesGroupStudy(X) → ImprovesUnderstanding(x)) → ∀x (EngagesInGroupStudy(X)))"
},
{
"input": "Translate into first-order logic: All students receive feedback on their assignments.",
"output": "∀x (Student(X) → ReceivesFeedback(x))"
},
{
"input": "Translate into first-order logic: All students who actively use feedback improve their grades.",
"output": "∀x (UsesFeedback(X) → ImprovesGrades(x))"
},
{
"input": "Translate into first-order logic: All students who manage their time effectively achieve better academic results.",
"output": "∀x (ManagesTimeEffectively(X) → AchievesBetterResults(x))"
},
{
"input": "Translate into first-order logic: If a student has high academic performance, they are more likely to receive job opportunities.",
"output": "∀x (HighAcademicPerformance(X) → MoreJobOpportunities(x))"
},
{
"input": "Translate into first-order logic: At least one student participates in research projects.",
"output": "∃x (ParticipatesResearch(x))"
},
{
"input": "Translate into first-order logic: All students are encouraged to engage in independent study.",
"output": "∀x (Student(x) → EncouragedIndependentStudy(x))"
},
{
"input": "Translate into first-order logic: If a student publishes research, they gain academic recognition.",
"output": "∀x (PublishesResearch(x) → GainsAcademicRecognition(x))"
},
{
"input": "Translate into first-order logic: If a student does not publish research, they do not receive a research grant.",
"output": "∀x (¬PublishesResearch(x) → ¬ReceivesResearchGrant(x))"
},
{
"input": "Translate into first-order logic: All students have access to academic mentorship.",
"output": "∀x (Student(x) → HasAccessToMentorship(x))"
},
{
"input": "Translate into first-order logic: If a student engages in independent study, they are likely to publish research.",
"output": "∀x (EngagesIndependentStudy(x) → LikelyPublishesResearch(x))"
},
{
"input": "Translate into first-order logic: All students benefit from participating in research projects.",
"output": "∀x (Student(x) → BenefitsFromResearch(x))"
},
{
"input": "Translate into first-order logic: If not publishing research leads to no research grant, then all students must engage in independent study.",
"output": "∀x (¬PublishesResearch(x) → ¬ReceivesResearchGrant(x))"
},
{
"input": "Translate into first-order logic: If not publishing research leads to no research grant, then engaging in independent study increases the likelihood of publishing research.",
"output": "∀x (¬PublishesResearch(x) → ¬ReceivesResearchGrant(x))"
},
{
"input": "Translate into first-order logic: If all students are encouraged to engage in independent study, then publishing research leads to academic recognition.",
"output": "∀x (EncouragedIndependentStudy(x))"
},
{
"input": "Translate into first-order logic: If a student engages in independent study, they gain academic recognition.",
"output": "∀x (EngagesIndependentStudy(x) → GainsAcademicRecognition(x))"
},
{
"input": "Translate into first-order logic: If a student does not receive research grants, they cannot access advanced research opportunities.",
"output": "∀x (¬ReceivesResearchGrant(x) → ¬AccessAdvancedResearch(x))"
},
{
"input": "Translate into first-order logic: At least one student receives academic recognition.",
"output": "∃x (ReceivesAcademicRecognition(X))"
},
{
"input": "Translate into first-order logic: All students have the opportunity to participate in academic competitions.",
"output": "∀x (Student(X) → OpportunityAcademicCompetition(x))"
},
{
"input": "Translate into first-order logic: If a student wins an academic competition, they gain academic recognition.",
"output": "∀x (WinsCompetition(X) → GainsAcademicRecognition(x))"
},
{
"input": "Translate into first-order logic: If a student does not win an academic competition, they do not receive a merit award.",
"output": "∀x (¬WinsCompetition(X) → ¬ReceivesMeritAward(x))"
},
{
"input": "Translate into first-order logic: All students can access faculty mentorship.",
"output": "∀x (Student(X) → AccessFacultyMentorship(x))"
},
{
"input": "Translate into first-order logic: If a student engages in research, they increase their chances of winning an academic competition.",
"output": "∀x (EngagesResearch(X) → IncreasedChanceWinsCompetition(x))"
},
{
"input": "Translate into first-order logic: All students benefit from faculty mentorship.",
"output": "∀x (Student(X) → BenefitsFromMentorship(x))"
},
{
"input": "Translate into first-order logic: If failing to win a competition results in no merit award, then all students should seek faculty mentorship.",
"output": "(∀x (¬WinsCompetition(X) → ¬ReceivesMeritAward(x)) → ∀x (SeeksMentorship(X)))"
},
{
"input": "Translate into first-order logic: If failing to win a competition results in no merit award, then engaging in research increases the likelihood of winning.",
"output": "(∀x (¬WinsCompetition(X) → ¬ReceivesMeritAward(x)) → (EngagesResearch(x) → IncreasedChanceWinsCompetition(x)))"
},
{
"input": "Translate into first-order logic: If all students have the opportunity to participate in competitions, then winning leads to academic recognition.",
"output": "(∀x (OpportunityAcademicCompetition(X)) → (WinsCompetition(x) → GainsAcademicRecognition(x)))"
},
{
"input": "Translate into first-order logic: If a student engages in research, they are more likely to receive academic recognition.",
"output": "∀x (EngagesResearch(X) → GainsAcademicRecognition(x))"
},
{
"input": "Translate into first-order logic: If a student does not receive a merit award, they have fewer scholarship opportunities.",
"output": "∀x (¬ReceivesMeritAward(X) → FewerScholarshipOpportunities(x))"
},
{
"input": "Translate into first-order logic: At least one student receives a scholarship.",
"output": "∃x (ReceivesScholarship(X))"
},
{
"input": "Translate into first-order logic: All students have the opportunity to apply for scholarships.",
"output": "∀x (Student(X) → OpportunityApplyScholarship(x))"
},
{
"input": "Translate into first-order logic: If a student maintains a high GPA, they qualify for a merit-based scholarship.",
"output": "∀x (MaintainsHighGPA(X) → QualifiesMeritScholarship(x))"
},
{
"input": "Translate into first-order logic: If a student does not maintain a high GPA, they do not qualify for a merit-based scholarship.",
"output": "∀x (¬MaintainsHighGPA(X) → ¬QualifiesMeritScholarship(x))"
},
{
"input": "Translate into first-order logic: All students can seek financial aid counseling.",
"output": "∀x (Student(X) → CanSeekFinancialAidCounseling(x))"
},
{
"input": "Translate into first-order logic: If a student engages in extracurricular activities, they improve their scholarship eligibility.",
"output": "∀x (EngagesEXtracurriculars(X) → ImprovesScholarshipEligibility(x))"
},
{
"input": "Translate into first-order logic: All students benefit from financial aid counseling.",
"output": "∀x (Student(X) → BenefitsFromFinancialAidCounseling(x))"
},
{
"input": "Translate into first-order logic: If failing to maintain a high GPA results in losing a scholarship, then all students should seek financial aid counseling.",
"output": "(∀x (¬MaintainsHighGPA(X) → ¬ReceivesScholarship(x)) → ∀x (SeeksFinancialAidCounseling(X)))"
},
{
"input": "Translate into first-order logic: If failing to maintain a high GPA results in losing a scholarship, then engaging in extracurricular activities increases the chances of receiving financial aid.",
"output": "(∀x (¬MaintainsHighGPA(X) → ¬ReceivesScholarship(x)) → (EngagesExtracurriculars(x) → IncreasedChanceReceivesFinancialAid(x)))"
},
{
"input": "Translate into first-order logic: If all students have the opportunity to apply for scholarships, then maintaining a high GPA leads to scholarship eligibility.",
"output": "(∀x (OpportunityApplyScholarship(X)) → (MaintainsHighGPA(x) → QualifiesMeritScholarship(x)))"
},
{
"input": "Translate into first-order logic: If a student engages in extracurricular activities, they are more likely to receive a scholarship.",
"output": "∀x (EngagesEXtracurriculars(X) → IncreasedLikelihoodReceivesScholarship(x))"
},
{
"input": "Translate into first-order logic: If a student does not receive a scholarship, they may face financial difficulties in funding their education.",
"output": "∀x (¬ReceivesScholarship(X) → MayFaceFinancialDifficulties(x))"
},
{
"input": "Translate into first-order logic: At least one student receives financial aid.",
"output": "∃x (ReceivesFinancialAid(X))"
},
{
"input": "Translate into first-order logic: All students can apply for financial aid.",
"output": "∀x (Student(X) → CanApplyFinancialAid(x))"
},
{
"input": "Translate into first-order logic: If a student has a low family income, they qualify for need-based financial aid.",
"output": "∀x (LowFamilyIncome(X) → QualifiesNeedBasedAid(x))"
},
{
"input": "Translate into first-order logic: Students from middle- or high-income families are not eligible for need-based aid.",
"output": "∀x (¬LowFamilyIncome(X) → ¬QualifiesNeedBasedAid(x))"
},
{
"input": "Translate into first-order logic: All students can seek financial aid counseling.",
"output": "∀x (Student(X) → CanSeekFinancialAidCounseling(x))"
},
{
"input": "Translate into first-order logic: If a student applies for financial aid, they increase their chances of receiving financial support.",
"output": "∀x (AppliesFinancialAid(X) → IncreasesChanceFinancialSupport(x))"
},
{
"input": "Translate into first-order logic: If a student receives financial aid, their tuition burden is reduced.",
"output": "∀x (ReceivesFinancialAid(X) → ReducedTuitionBurden(x))"
},
{
"input": "Translate into first-order logic: If a student's tuition burden is reduced, they have less financial stress.",
"output": "∀x (ReducedTuitionBurden(X) → LessFinancialStress(x))"
},
{
"input": "Translate into first-order logic: If a student has less financial stress, they can focus better on their studies.",
"output": "∀x (LessFinancialStress(X) → BetterStudyFocus(x))"
},
{
"input": "Translate into first-order logic: If a student focuses better on their studies, their academic performance improves.",
"output": "∀x (BetterStudyFocus(X) → ImprovesAcademicPerformance(x))"
},
{
"input": "Translate into first-order logic: If a student's academic performance improves, they may become eligible for merit-based scholarships.",
"output": "∀x (ImprovesAcademicPerformance(X) → EligibleMeritScholarship(x))"
},
{
"input": "Translate into first-order logic: If a student does not receive financial aid, they may have to take on student loans.",
"output": "∀x (¬ReceivesFinancialAid(X) → MayTakeStudentLoans(x))"
},
{
"input": "Translate into first-order logic: At least one student is learning Python.",
"output": "∃x (LearningPython(x))"
},
{
"input": "Translate into first-order logic: All students can access Python learning resources.",
"output": "∀x (Student(x) → AccessPythonResources(x))"
},
{
"input": "Translate into first-order logic: If a student practices Python regularly, they improve their coding skills.",
"output": "∀x (PracticesPython(x) → ImprovesCodingSkills(x))"
},
{
"input": "Translate into first-order logic: If a student does not practice Python, their coding skills do not improve.",
"output": "∀x (¬PracticesPython(x) → ¬ImprovesCodingSkills(x))"
},
{
"input": "Translate into first-order logic: All students can participate in coding challenges.",
"output": "∀x (Student(x) → CanJoinCodingChallenges(x))"
},
{
"input": "Translate into first-order logic: If a student solves coding challenges, they gain problem-solving skills.",
"output": "∀x (SolvesChallenges(x) → GainsProblemSolvingSkills(x))"
},
{
"input": "Translate into first-order logic: If a student gains problem-solving skills, they become proficient in Python.",
"output": "∀x (GainsProblemSolvingSkills(x) → ProficientPython(x))"
},
{
"input": "Translate into first-order logic: If a student is proficient in Python, they qualify for software development internships.",
"output": "∀x (ProficientPython(x) → QualifiesInternship(x))"
},
{
"input": "Translate into first-order logic: If a student gets an internship, they gain real-world experience.",
"output": "∀x (GetsInternship(x) → GainsRealWorldExperience(x))"
},
{
"input": "Translate into first-order logic: If a student gains real-world experience, their job prospects improve.",
"output": "∀x (GainsRealWorldExperience(x) → ImprovesJobProspects(x))"
},
{
"input": "Translate into first-order logic: If a student does not practice coding, they may struggle in technical interviews.",
"output": "∀x (¬PracticesCoding(x) → StrugglesTechnicalInterviews(x))"
},
{
"input": "Translate into first-order logic: If a student participates in open-source projects, they build a strong portfolio.",
"output": "∀x (ParticipatesOpenSource(x) → BuildsStrongPortfolio(x))"
},
{
"input": "Translate into first-order logic: If a Raspberry Pi system is simple to use, then it is cost-effective.",
"output": "∀x ((RaspberryPiSimpleToUse(x) → RaspberryPiCostEffective(x)))"
},
{
"input": "Translate into first-order logic: There exists at least one Raspberry Pi system that is cost-effective.",
"output": "∃x (RaspberryPiCostEffective(x))"
},
{
"input": "Translate into first-order logic: If a Raspberry Pi system is not simple to use, then it is not versatile.",
"output": "∀x ((¬RaspberryPiSimpleToUse(x) → ¬RaspberryPiVersatile(x)))"
},
{
"input": "Translate into first-order logic: If a Raspberry Pi system is simple to use, then it is versatile.",
"output": "∀x ((RaspberryPiSimpleToUse(x) → RaspberryPiVersatile(x)))"
},
{
"input": "Translate into first-order logic: There exists at least one Raspberry Pi system that is versatile.",
"output": "∃x (RaspberryPiVersatile(x))"
},
{
"input": "Translate into first-order logic: Every Raspberry Pi system is thoroughly tested and well-documented.",
"output": "∀x (RaspberryPiTestedAndDocumented(x))"
},
{
"input": "Translate into first-order logic: If being simple to use implies cost-effectiveness for a Raspberry Pi system, then every Raspberry Pi system is thoroughly tested and well-documented.",
"output": "(∀x (RaspberryPiSimpleToUse(x) → RaspberryPiCostEffective(x))) → ∀x (RaspberryPiTestedAndDocumented(x))"
},
{
"input": "Translate into first-order logic: If there exists at least one cost-effective Raspberry Pi system, then there exists at least one versatile Raspberry Pi system.",
"output": "∃x (RaspberryPiCostEffective(x)) → ∃x (RaspberryPiVersatile(x))"
},
{
"input": "Translate into first-order logic: If a Raspberry Pi system is connected to online resources, then it is thoroughly tested and well-documented.",
"output": "∀x ((RaspberryPiConnectedOnline(x) → RaspberryPiTestedAndDocumented(x)))"
},
{
"input": "Translate into first-order logic: If a Raspberry Pi system is connected to online resources, then it is versatile.",
"output": "∀x ((RaspberryPiConnectedOnline(x) → RaspberryPiVersatile(x)))"
},
{
"input": "Translate into first-order logic: There exists at least one Raspberry Pi system that is connected to online resources and benefits from active community support.",
"output": "∃x (RaspberryPiConnectedOnline(x))"
},
{
"input": "Translate into first-order logic: If a Raspberry Pi system is cost-effective but not thoroughly tested and well-documented, then it might not support all versatile use-cases.",
"output": "∀x (((RaspberryPiCostEffective(x) ∧ ¬RaspberryPiTestedAndDocumented(x)) → ¬SupportsAllVersatileUseCases(x)))"
},
{
"input": "Translate into first-order logic: Every EV charging station supports fast charging.",
"output": "∀x (SupportsFastCharging(x))"
},
{
"input": "Translate into first-order logic: There exists at least one EV charging station that is widely available.",
"output": "∃x (WidelyAvailable(x))"
},
{
"input": "Translate into first-order logic: If an EV charging station supports fast charging, then it is reliable.",
"output": "(SupportsFastCharging(x) → Reliable(x))"
},
{
"input": "Translate into first-order logic: Every EV charging station meets safety standards.",
"output": "∀x (MeetsSafetyStandards(x))"
},
{
"input": "Translate into first-order logic: If an EV charging station is not widely available, then it is not thoroughly maintained.",
"output": "(¬WidelyAvailable(x) → ¬ThoroughlyMaintained(x))"
},
{
"input": "Translate into first-order logic: If an EV charging station is widely available, then it supports fast charging.",
"output": "(WidelyAvailable(x) → SupportsFastCharging(x))"
},
{
"input": "Translate into first-order logic: If not being widely available implies not being thoroughly maintained, then any widely available EV charging station supports fast charging.",
"output": "((¬WidelyAvailable(x) → ¬ThoroughlyMaintained(x)) → (WidelyAvailable(x) → SupportsFastCharging(x)))"
},
{
"input": "Translate into first-order logic: If not being widely available implies not being thoroughly maintained, then every EV charging station meets safety standards.",
"output": "((¬WidelyAvailable(x) → ¬ThoroughlyMaintained(x)) → ∀x (MeetsSafetyStandards(x)))"
},
{
"input": "Translate into first-order logic: If an EV charging station meets safety standards, then it is thoroughly maintained.",
"output": "(MeetsSafetyStandards(x) → ThoroughlyMaintained(x))"
},
{
"input": "Translate into first-order logic: If an EV charging station is not cost-effective, then it is not widely available.",
"output": "(¬CostEffective(x) → ¬WidelyAvailable(x))"
},
{
"input": "Translate into first-order logic: Every EV charging station is thoroughly maintained.",
"output": "∀x (ThoroughlyMaintained(x))"
},
{
"input": "Translate into first-order logic: There exists at least one functional microchip.",
"output": "∃x (Functional(x))"
},
{
"input": "Translate into first-order logic: If a microchip does not have a stable power supply, then it does not operate efficiently.",
"output": "(¬Stable(x) →  ¬OperatesEfficiently(x))"
},
{
"input": "Translate into first-order logic: If a microchip does not operate efficiently, then it does not have a stable power supply.",
"output": "(¬OperatesEfficiently(x) →  ¬Stable(x))"
},
{
"input": "Translate into first-order logic: All microchips pass quality tests.",
"output": "∀x (PassesQualityTests(x))"
},
{
"input": "Translate into first-order logic: There exists at least one microchip that meets performance standards.",
"output": "∃x (MeetsPerformanceStandards(x))"
},
{
"input": "Translate into first-order logic: If a microchip is not functional, then it does not have a stable power supply.",
"output": "(¬Functional(x) →  ¬Stable(x))"
},
{
"input": "Translate into first-order logic: If a microchip is not functional, then it does not meet performance standards.",
"output": "(¬Functional(x) →  ¬MeetsPerformanceStandards(x))"
},
{
"input": "Translate into first-order logic: All microchips are functional.",
"output": "∀x (Functional(x))"
},
{
"input": "Translate into first-order logic: If a microchip is functional, then it is properly integrated into the circuit.",
"output": "(Functional(x) →  ProperlyIntegrated(x))"
},
{
"input": "Translate into first-order logic: There exists at least one properly integrated microchip.",
"output": "∃x (ProperlyIntegrated(x))"
},
{
"input": "Translate into first-order logic: If all microchips pass quality tests, then if a microchip does not have a stable power supply, it will not operate efficiently.",
"output": "(∀x (PassesQualityTests(x)) →  (¬Stable(x) →  ¬OperatesEfficiently(x)))"
},
{
"input": "Translate into first-order logic: If not being functional implies not having a stable power supply, then there exists at least one microchip that meets performance standards.",
"output": "((¬Functional(x) → ¬Stable(x)) →  ∃x (MeetsPerformanceStandards(x)))"
},
{
"input": "Translate into first-order logic: If a microchip is functional, then it has a stable power supply.",
"output": "(Functional(x) →  Stable(x))"
},
{
"input": "Translate into first-order logic: If a microchip is not properly integrated into the circuit, then it does not have a stable power supply.",
"output": "(¬ProperlyIntegrated(x) →  ¬Stable(x))"
},
{
"input": "Translate into first-order logic: All microchips operate efficiently.",
"output": "∀x (OperatesEfficiently(x))"
},
{
"input": "Translate into first-order logic: If a microchip does not meet performance standards, then it is not functional.",
"output": "(¬MeetsPerformanceStandards(x) →  ¬Functional(x))"
},
{
"input": "Translate into first-order logic: If a microchip does not operate efficiently, then it does not meet performance standards.",
"output": "(¬OperatesEfficiently(x) →  ¬MeetsPerformanceStandards(x))"
},
{
"input": "Translate into first-order logic: There exists at least one microchip that passes quality tests.",
"output": "∃x (PassesQualityTests(x))"
},
{
"input": "Translate into first-order logic: If a microchip is properly integrated into the circuit, then it meets performance standards.",
"output": "(ProperlyIntegrated(x) →  MeetsPerformanceStandards(x))"
},
{
"input": "Translate into first-order logic: Every transportation system in the city is equipped with modern technology.",
"output": "∃x (CostEffective(x))"
},
{
"input": "Translate into first-order logic: Every transportation system in the city is safe.",
"output": "∃x (EquippedWithModernTechnology(x))"
},
{
"input": "Translate into first-order logic: There exists at least one transportation system that is cost-effective.",
"output": "∃x (Safe(x))"
},
{
"input": "Translate into first-order logic: If a transportation system is not equipped with modern technology, then it is not cost-effective.",
"output": "∀x (EquippedWithModernTechnology(x))"
},
{
"input": "Translate into first-order logic: If a transportation system is not eco-friendly, then it is not thoroughly tested.",
"output": "∀x (Safe(x))"
},
{
"input": "Translate into first-order logic: If a transportation system is not eco-friendly, then it is not equipped with modern technology.",
"output": "∀x (¬EquippedWithModernTechnology(x) → ¬CostEffective(x))"
},
{
"input": "Translate into first-order logic: If there exists at least one cost-effective transportation system, then every transportation system in the city is safe.",
"output": "∀x (¬EcoFriendly(x) → ¬ThoroughlyTested(x))"
},
{
"input": "Translate into first-order logic: If not being equipped with modern technology implies not being cost-effective, then every transportation system in the city is safe.",
"output": "∀x (¬EcoFriendly(x) → ¬EquippedWithModernTechnology(x))"
},
{
"input": "Translate into first-order logic: If a transportation system is not thoroughly tested, then it is not reliable.",
"output": "(∃x (CostEffective(x)) → ∀x (Safe(x)))"
},
{
"input": "Translate into first-order logic: If a transportation system is not safe, then it is not equipped with modern technology.",
"output": "(∀x (¬EquippedWithModernTechnology(x) → ¬CostEffective(x)) → ∀x (Safe(x)))"
},
{
"input": "Translate into first-order logic: If a transportation system is eco-friendly, then it is cost-effective.",
"output": "∀x (¬ThoroughlyTested(x) → ¬Reliable(x))"
},
{
"input": "Translate into first-order logic: If a transportation system is safe but not eco-friendly, then it is not necessarily cost-effective.",
"output": "∀x (¬Safe(x) → ¬EquippedWithModernTechnology(x))"
},
{
"input": "Translate into first-order logic: There exists at least one hardware component that is thoroughly validated.",
"output": "∃x (ThoroughlyValidated(x))"
},
{
"input": "Translate into first-order logic: Every hardware component is robust.",
"output": "∀x (Robust(x))"
},
{
"input": "Translate into first-order logic: There exists at least one hardware component that delivers high performance.",
"output": "∃x (HighPerformance(x))"
},
{
"input": "Translate into first-order logic: If a hardware component does not meet design specifications, then it does not deliver high performance.",
"output": "∀x (¬MeetsDesignSpecs(x) → ¬HighPerformance(x))"
},
{
"input": "Translate into first-order logic: If a hardware component is power-efficient, then it is thoroughly validated.",
"output": "∀x (PowerEfficient(x) → ThoroughlyValidated(x))"
},
{
"input": "Translate into first-order logic: If a hardware component is power-efficient, then it is robust.",
"output": "∀x (PowerEfficient(x) → Robust(x))"
},
{
"input": "Translate into first-order logic: If a hardware component delivers high performance, then it is easy to integrate.",
"output": "∀x (HighPerformance(x) → EasyToIntegrate(x))"
},
{
"input": "Translate into first-order logic: If there exists at least one power-efficient hardware component, then there exists at least one component that delivers high performance.",
"output": "∃x (PowerEfficient(x))"
},
{
"input": "Translate into first-order logic: If there exists at least one high-performance hardware component, then any power-efficient component is thoroughly validated.",
"output": "∃x (HighPerformance(x))"
},
{
"input": "Translate into first-order logic: Every hardware component is power-efficient.",
"output": "∀x (PowerEfficient(x))"
},
{
"input": "Translate into first-order logic: If a hardware component delivers high performance, then it meets design specifications.",
"output": "∀x (HighPerformance(x) → MeetsDesignSpecs(x))"
},
{
"input": "Translate into first-order logic: There exists at least one hardware component that is easy to integrate.",
"output": "∃x (EasyToIntegrate(x))"
},
{
"input": "Translate into first-order logic: If a hardware component is not thoroughly validated, then it does not meet design specifications.",
"output": "∀x (¬ThoroughlyValidated(x) → ¬MeetsDesignSpecs(x))"
},
{
"input": "Translate into first-order logic: If a hardware component is robust, then it meets design specifications.",
"output": "∀x (Robust(x) → MeetsDesignSpecs(x))"
},
{
"input": "Translate into first-order logic: All drones function correctly.",
"output": "∀x (FunctionsCorrectly(x))"
},
{
"input": "Translate into first-order logic: If a drone does not undergo all required pre-flight checks, then it does not have a stable power supply.",
"output": "∀x (¬UndergoesPreFlightChecks(x) → ¬HasStablePowerSupply(x))"
},
{
"input": "Translate into first-order logic: If a drone is not operating safely, then it does not have a stable power supply.",
"output": "∀x (¬OperatingSafely(x) → ¬HasStablePowerSupply(x))"
},
{
"input": "Translate into first-order logic: If a drone is equipped with a GPS system, then it follows the flight path.",
"output": "∀x (HasGPS(x) → FollowsFlightPath(x))"
},
{
"input": "Translate into first-order logic: If a drone is not equipped with a GPS system, then it does not function correctly.",
"output": "∀x (¬HasGPS(x) → ¬FunctionsCorrectly(x))"
},
{
"input": "Translate into first-order logic: If there exists at least one drone with a stable power supply, then there exists at least one functioning drone.",
"output": "∃x (HasStablePowerSupply(x))"
},
{
"input": "Translate into first-order logic: If there exists at least one drone with a stable power supply, then there exists at least one drone that follows the flight path.",
"output": "∃x (HasStablePowerSupply(x))"
},
{
"input": "Translate into first-order logic: All drones undergo all required pre-flight checks.",
"output": "∀x (UndergoesPreFlightChecks(x))"
},
{
"input": "Translate into first-order logic: All drones have a stable power supply.",
"output": "∀x (HasStablePowerSupply(x))"
},
{
"input": "Translate into first-order logic: All drones follow the flight path.",
"output": "∀x (FollowsFlightPath(x))"
},
{
"input": "Translate into first-order logic: If a drone follows the flight path, then it is equipped with a GPS system.",
"output": "∀x (FollowsFlightPath(x) → HasGPS(x))"
},
{
"input": "Translate into first-order logic: If a drone does not have a stable power supply, then it is not operating safely.",
"output": "∀x (¬HasStablePowerSupply(x) → ¬OperatingSafely(x))"
},
{
"input": "Translate into first-order logic: Every IoT device used in agriculture is connected to the network.",
"output": "∀x (ConnectedToNetwork(x))"
},
{
"input": "Translate into first-order logic: Every IoT device used in agriculture is sensor-enabled.",
"output": "∀x (SensorEnabled(x))"
},
{
"input": "Translate into first-order logic: There exists at least one IoT device used in agriculture that is robust in outdoor conditions.",
"output": "∃x (RobustInOutdoorConditions(x))"
},
{
"input": "Translate into first-order logic: If an IoT device used in agriculture is not connected to the network, then it is not robust in outdoor conditions.",
"output": "∀x (¬ConnectedToNetwork(x) → ¬RobustInOutdoorConditions(x))"
},
{
"input": "Translate into first-order logic: If an IoT device used in agriculture does not provide accurate data, then it is not field-tested.",
"output": "∀x (¬ProvidesAccurateData(x) → ¬FieldTested(x))"
},
{
"input": "Translate into first-order logic: If an IoT device used in agriculture does not provide accurate data, then it is not connected to the network.",
"output": "∀x (¬ProvidesAccurateData(x) → ¬ConnectedToNetwork(x))"
},
{
"input": "Translate into first-order logic: If an IoT device used in agriculture is not field-tested, then it is not energy-efficient.",
"output": "∀x (¬FieldTested(x) → ¬EnergyEfficient(x))"
},
{
"input": "Translate into first-order logic: If the fact that not being connected implies not being robust holds for an IoT device, then every IoT device in agriculture is sensor-enabled.",
"output": "∀x ((¬ConnectedToNetwork(x) → ¬RobustInOutdoorConditions(x)) → ∀y (SensorEnabled(y)))"
},
{
"input": "Translate into first-order logic: If an IoT device used in agriculture is not sensor-enabled, then it is not connected to the network.",
"output": "∀x (¬SensorEnabled(x) → ¬ConnectedToNetwork(x))"
},
{
"input": "Translate into first-order logic: If an IoT device used in agriculture provides accurate data, then it is robust in outdoor conditions.",
"output": "∀x (ProvidesAccurateData(x) → RobustInOutdoorConditions(x))"
},
{
"input": "Translate into first-order logic: If a VR game is engaging, then it is stable.",
"output": "∀x (Engaging(x) → Stable(x))"
},
{
"input": "Translate into first-order logic: If a VR game is not stable, then it does not run smoothly.",
"output": "∀x (¬Stable(x) → ¬Smooth(x))"
},
{
"input": "Translate into first-order logic: If a VR game is not thoroughly tested, then it may not be engaging.",
"output": "∀x (¬Tested(x) → ¬Engaging(x))"
},
{
"input": "Translate into first-order logic: If a VR game is stable, then it runs smoothly.",
"output": "∀x (Stable(x) → Smooth(x))"
},
{
"input": "Translate into first-order logic: There exists at least one VR game that is engaging.",
"output": "∃x (Engaging(x))"
},
{
"input": "Translate into first-order logic: If a VR game meets performance requirements, then it is thoroughly tested.",
"output": "∀x (Performance(x) → Tested(x))"
},
{
"input": "Translate into first-order logic: All VR games run smoothly.",
"output": "∀x (Smooth(x))"
},
{
"input": "Translate into first-order logic: If the absence of thorough testing suggests that a VR game is not engaging, then it does not necessarily mean any engaging VR game is stable.",
"output": "∀x ((¬Tested(x) → ¬Engaging(x)) → ¬∀y (Engaging(y) → Stable(y)))"
},
{
"input": "Translate into first-order logic: If there exists at least one VR game that meets performance requirements, then there does not necessarily exist at least one VR game that is engaging.",
"output": "¬(∃x (Performance(x)) → ∃x (Engaging(x)))"
},
{
"input": "Translate into first-order logic: If a VR game runs smoothly, then it meets performance requirements.",
"output": "∀x (Smooth(x) → Performance(x))"
},
{
"input": "Translate into first-order logic: All VR games are stable.",
"output": "∀x (Stable(x))"
},
{
"input": "Translate into first-order logic: All VR games meet performance requirements.",
"output": "∀x (Performance(x))"
},
{
"input": "Translate into first-order logic: If a VR game is not graphically impressive, then it is not engaging.",
"output": "∀x (¬Graphical(x) → ¬Engaging(x))"
},
{
"input": "Translate into first-order logic: If a VR game meets performance requirements, then it is stable.",
"output": "∀x (Performance(x) → Stable(x))"
},
{
"input": "Translate into first-order logic: If a blockchain network adheres to regulatory standards, then it is robust.",
"output": "∀x (AdheresToRegulatoryStandards(x) → Robust(x))"
},
{
"input": "Translate into first-order logic: If a blockchain network is not transparent, then it is not secure.",
"output": "∀x (¬Transparent(x) → ¬Secure(x))"
},
{
"input": "Translate into first-order logic: If a blockchain network is transparent, then it is secure.",
"output": "∀x (Transparent(x) → Secure(x))"
},
{
"input": "Translate into first-order logic: If a blockchain network is transparent, then it is scalable.",
"output": "∀x (Transparent(x) → Scalable(x))"
},
{
"input": "Translate into first-order logic: All blockchain networks are robust.",
"output": "∀x (Robust(x))"
},
{
"input": "Translate into first-order logic: All blockchain networks are secure.",
"output": "∀x (Secure(x))"
},
{
"input": "Translate into first-order logic: If there exists at least one robust blockchain network, then if a blockchain network is not transparent, it is not secure.",
"output": "(∃x (Robust(x)) → ∀x (¬Transparent(x) → ¬Secure(x)))"
},
{
"input": "Translate into first-order logic: If not being transparent implies not being secure, then there exists at least one robust blockchain network.",
"output": "(∀x (¬Transparent(x) → ¬Secure(x)) → ∃x (Robust(x)))"
},
{
"input": "Translate into first-order logic: If a blockchain network does not adhere to regulatory standards, then it is not efficient.",
"output": "∀x (¬AdheresToRegulatoryStandards(x) → ¬Efficient(x))"
},
{
"input": "Translate into first-order logic: If a blockchain network is secure, then it is efficient.",
"output": "∀x (Secure(x) → Efficient(x))"
},
{
"input": "Translate into first-order logic: There exists at least one blockchain network that adheres to regulatory standards.",
"output": "∃x (AdheresToRegulatoryStandards(x))"
},
{
"input": "Translate into first-order logic: If a blockchain network is not scalable, then it does not adhere to regulatory standards.",
"output": "∀x (¬Scalable(x) → ¬AdheresToRegulatoryStandards(x))"
},
{
"input": "Translate into first-order logic: There exists at least one blockchain network that is transparent.",
"output": "∃x (Transparent(x))"
},
{
"input": "Translate into first-order logic: Every autonomous vehicle is reliable.",
"output": "∀x (Reliable(x))"
},
{
"input": "Translate into first-order logic: If an autonomous vehicle is thoroughly tested, then it is reliable.",
"output": "∀x (ThoroughlyTested(x) → Reliable(x))"
},
{
"input": "Translate into first-order logic: There does not necessarily exist an autonomous vehicle that is thoroughly tested.",
"output": "¬∃x (ThoroughlyTested(x))"
},
{
"input": "Translate into first-order logic: If an autonomous vehicle is safe, then it is thoroughly tested.",
"output": "∀x (Safe(x) → ThoroughlyTested(x))"
},
{
"input": "Translate into first-order logic: If an autonomous vehicle is thoroughly tested, then it is safe.",
"output": "∀x (ThoroughlyTested(x) → Safe(x))"
},
{
"input": "Translate into first-order logic: There exists at least one autonomous vehicle that is energy-efficient.",
"output": "∃x (EnergyEfficient(x))"
},
{
"input": "Translate into first-order logic: If there exists at least one energy-efficient autonomous vehicle, then any safe vehicle is thoroughly tested.",
"output": "∃x (EnergyEfficient(x))"
},
{
"input": "Translate into first-order logic: If every safe vehicle is thoroughly tested, then every thoroughly tested vehicle is not necessarily safe.",
"output": "∀x (Safe(x) → ThoroughlyTested(x))"
},
{
"input": "Translate into first-order logic: If an autonomous vehicle is not reliable, then it is not adopted by the market.",
"output": "∀x (¬Reliable(x) → ¬MarketAdopted(x))"
},
{
"input": "Translate into first-order logic: If an autonomous vehicle is not reliable, then it is not necessarily thoroughly tested.",
"output": "∀x (¬Reliable(x) → ¬ThoroughlyTested(x))"
},
{
"input": "Translate into first-order logic: If an AI application has undergone rigorous testing, then it meets the highest quality standards.",
"output": "∀x (UndergoesRigorousTesting(x) → MeetsHighestQualityStandards(x))"
},
{
"input": "Translate into first-order logic: If an AI application is highly successful, then it is widely adopted in educational institutions.",
"output": "∀x (HighlySuccessful(x) → WidelyAdoptedInEducation(x))"
},
{
"input": "Translate into first-order logic: If an AI application shows great potential, then it has undergone rigorous testing.",
"output": "∀x (ShowsGreatPotential(x) → UndergoesRigorousTesting(x))"
},
{
"input": "Translate into first-order logic: If an AI application is widely adopted in educational institutions, then it is highly successful.",
"output": "∀x (WidelyAdoptedInEducation(x) → HighlySuccessful(x))"
},
{
"input": "Translate into first-order logic: If an AI application is widely adopted in educational institutions, then it receives notable academic recognition.",
"output": "∀x (WidelyAdoptedInEducation(x) → ReceivesAcademicRecognition(x))"
},
{
"input": "Translate into first-order logic: Every AI application meets the highest quality standards.",
"output": "∀x (MeetsHighestQualityStandards(x))"
},
{
"input": "Translate into first-order logic: If it is true that widespread adoption implies high success, then any AI application that shows great potential must have undergone rigorous testing.",
"output": "∀x (WidelyAdoptedInEducation(x) → HighlySuccessful(x))"
},
{
"input": "Translate into first-order logic: If the implication that promising applications are rigorously tested (given that widespread adoption implies success) holds, then it follows that widespread adoption indeed implies high success.",
"output": "(∀x (WidelyAdoptedInEducation(x) → HighlySuccessful(x)) → ∀x (ShowsGreatPotential(x) → UndergoesRigorousTesting(x))) → ∀x (WidelyAdoptedInEducation(x) → HighlySuccessful(x))"
},
{
"input": "Translate into first-order logic: Every AI application is widely adopted in educational institutions.",
"output": "∀x (WidelyAdoptedInEducation(x))"
},
{
"input": "Translate into first-order logic: If a cloud service is not scalable, then it is not reliable.",
"output": "∀x (¬Scalable(x) → ¬Reliable(x))"
},
{
"input": "Translate into first-order logic: All cloud services are scalable.",
"output": "∀x (Scalable(x))"
},
{
"input": "Translate into first-order logic: If a cloud service does not meet performance standards, then it does not adhere to security protocols.",
"output": "∀x (¬MeetsPerformanceStandards(x) → ¬AdheresToSecurityProtocols(x))"
},
{
"input": "Translate into first-order logic: All cloud services are thoroughly tested.",
"output": "∀x (ThoroughlyTested(x))"
},
{
"input": "Translate into first-order logic: If a cloud service meets performance standards, then it is cost-effective.",
"output": "∀x (MeetsPerformanceStandards(x) → CostEffective(x))"
},
{
"input": "Translate into first-order logic: If a cloud service is not thoroughly tested, then it does not meet performance standards.",
"output": "∀x (¬ThoroughlyTested(x) → ¬MeetsPerformanceStandards(x))"
},
{
"input": "Translate into first-order logic: If not being thoroughly tested implies that a cloud service does not meet performance standards, then there exists at least one cloud service that is reliable.",
"output": "(∀x (¬ThoroughlyTested(x) → ¬MeetsPerformanceStandards(x)) → ∃x (Reliable(x)))"
},
{
"input": "Translate into first-order logic: If all cloud services are scalable, then all cloud services are thoroughly tested.",
"output": "∀x (Scalable(x))"
},
{
"input": "Translate into first-order logic: If a cloud service is thoroughly tested, then it is reliable.",
"output": "∀x (ThoroughlyTested(x) → Reliable(x))"
},
{
"input": "Translate into first-order logic: All cloud services meet performance standards.",
"output": "∀x (MeetsPerformanceStandards(x))"
},
{
"input": "Translate into first-order logic: If a cloud service meets performance standards, then it is thoroughly tested.",
"output": "∀x (MeetsPerformanceStandards(x) → ThoroughlyTested(x))"
},
{
"input": "Translate into first-order logic: If a cloud service does not meet performance standards, then it is not cost-effective.",
"output": "∀x (¬MeetsPerformanceStandards(x) → ¬CostEffective(x))"
},
{
"input": "Translate into first-order logic: There exists at least one smart home device that is user-friendly.",
"output": "∃x (UserFriendly(x))"
},
{
"input": "Translate into first-order logic: If a smart home device is not secure, then it is not necessarily energy efficient.",
"output": "∀x (¬Secure(x) → ¬EnergyEfficient(x))"
},
{
"input": "Translate into first-order logic: There exists at least one smart home device that is compatible with the smart home ecosystem.",
"output": "∃x (CompatibleWithEcosystem(x))"
},
{
"input": "Translate into first-order logic: There does not necessarily exist a smart home device that is energy efficient.",
"output": "¬∃x (EnergyEfficient(x))"
},
{
"input": "Translate into first-order logic: If a smart home device is energy efficient, then it is user-friendly.",
"output": "∀x (EnergyEfficient(x) → UserFriendly(x))"
},
{
"input": "Translate into first-order logic: Every smart home device is not necessarily energy efficient.",
"output": "¬∀x (EnergyEfficient(x))"
},
{
"input": "Translate into first-order logic: If the lack of security in a smart home device implies that it is not energy efficient, then it does not necessarily follow that there exists at least one energy-efficient device.",
"output": "(∀x (¬Secure(x) → ¬EnergyEfficient(x)) → ¬∃x (EnergyEfficient(x)))"
},
{
"input": "Translate into first-order logic: If there exists at least one smart home device that is compatible with the smart home ecosystem, then it does not necessarily follow that there exists at least one user-friendly device.",
"output": "∃x (CompatibleWithEcosystem(x))"
},
{
"input": "Translate into first-order logic: If a smart home device is not compatible with the smart home ecosystem, then it is not necessarily user-friendly.",
"output": "∀x (¬CompatibleWithEcosystem(x) → ¬UserFriendly(x))"
},
{
"input": "Translate into first-order logic: There exists at least one smart home device that supports voice control.",
"output": "∃x (SupportsVoiceControl(x))"
},
{
"input": "Translate into first-order logic: Every smart home device is not necessarily compatible with the smart home ecosystem.",
"output": "¬∀x (CompatibleWithEcosystem(x))"
},
{
"input": "Translate into first-order logic: If a smartphone has a high-resolution display, then it has superior screen quality.",
"output": "∀x (HighResDisplay(x) → SuperiorScreenQuality(x))"
},
{
"input": "Translate into first-order logic: If a smartphone does not have long battery life, then it does not have superior screen quality.",
"output": "∀x (¬LongBatteryLife(x) → ¬SuperiorScreenQuality(x))"
},
{
"input": "Translate into first-order logic: There exists at least one smartphone that supports advanced camera features.",
"output": "∃x (AdvancedCameraFeatures(x))"
},
{
"input": "Translate into first-order logic: Every smartphone is equipped with the latest processor.",
"output": "∀x (LatestProcessor(x))"
},
{
"input": "Translate into first-order logic: If a smartphone is equipped with the latest processor, then it is highly efficient.",
"output": "∀x (LatestProcessor(x) → HighlyEfficient(x))"
},
{
"input": "Translate into first-order logic: If there exists at least one smartphone with the latest processor, then any smartphone with a high-resolution display has superior screen quality.",
"output": "∃x (LatestProcessor(x))"
},
{
"input": "Translate into first-order logic: If there exists at least one smartphone that supports advanced camera features, then, provided there is at least one smartphone with the latest processor, any smartphone with a high-resolution display has superior screen quality.",
"output": "∃x (AdvancedCameraFeatures(x))"
},
{
"input": "Translate into first-order logic: If a smartphone has superior screen quality, then it supports advanced camera features.",
"output": "∀x (SuperiorScreenQuality(x) → AdvancedCameraFeatures(x))"
},
{
"input": "Translate into first-order logic: There exists at least one smartphone with a high-resolution display.",
"output": "∃x (HighResDisplay(x))"
},
{
"input": "Translate into first-order logic: If a smartphone has superior screen quality, then it is equipped with the latest processor.",
"output": "∀x (SuperiorScreenQuality(x) → LatestProcessor(x))"
},
{
"input": "Translate into first-order logic: If a course is offered online, then it is engaging.",
"output": "∀x (OfferedOnline(x) → Engaging(x))"
},
{
"input": "Translate into first-order logic: If a course is not engaging, then it does not meet curriculum standards.",
"output": "∀x (¬Engaging(x) → ¬MeetsStandards(x))"
},
{
"input": "Translate into first-order logic: There does not exist any course that is engaging.",
"output": "¬∃x (Engaging(x))"
},
{
"input": "Translate into first-order logic: Not every course is offered online.",
"output": "¬∀x (OfferedOnline(x))"
},
{
"input": "Translate into first-order logic: If a course is well-structured, then it does not meet curriculum standards.",
"output": "∀x (WellStructured(x) → ¬MeetsStandards(x))"
},
{
"input": "Translate into first-order logic: Not every course has sufficient resources.",
"output": "¬∀x (SufficientResources(x))"
},
{
"input": "Translate into first-order logic: If offering a course online implies that it is engaging, then a well-structured course does not meet curriculum standards.",
"output": "(∀x (OfferedOnline(x) → Engaging(x)) → ∀x (WellStructured(x) → ¬MeetsStandards(x)))"
},
{
"input": "Translate into first-order logic: If a well-structured course meets curriculum standards, then offering a course online does not imply that it is engaging.",
"output": "(∀x (WellStructured(x) → MeetsStandards(x)) → ¬∀x (OfferedOnline(x) → Engaging(x)))"
},
{
"input": "Translate into first-order logic: If a course has sufficient resources, then it is not well-structured.",
"output": "∀x (SufficientResources(x) → ¬WellStructured(x))"
},
{
"input": "Translate into first-order logic: Not every course meets curriculum standards.",
"output": "¬∀x (MeetsStandards(x))"
},
{
"input": "Translate into first-order logic: If a course is engaging, then it does not receive positive reviews.",
"output": "∀x (Engaging(x) → ¬PositiveReviews(x))"
},
{
"input": "Translate into first-order logic: Every research project is recognized as innovative.",
"output": "∀x (RecognizedInnovative(x))"
},
{
"input": "Translate into first-order logic: Every research project is well-funded.",
"output": "∀x (WellFunded(x))"
},
{
"input": "Translate into first-order logic: Every research project is thoroughly tested.",
"output": "∀x (ThoroughlyTested(x))"
},
{
"input": "Translate into first-order logic: If a research project is not well-funded, then it does not meet academic standards.",
"output": "∀x (¬WellFunded(x) → ¬MeetsAcademicStandards(x))"
},
{
"input": "Translate into first-order logic: If a research project does not meet academic standards, then it is not well-funded.",
"output": "∀x (¬MeetsAcademicStandards(x) → ¬WellFunded(x))"
},
{
"input": "Translate into first-order logic: If a research project is not successful, then it does not meet academic standards.",
"output": "∀x (¬Successful(x) → ¬MeetsAcademicStandards(x))"
},
{
"input": "Translate into first-order logic: Every research project is published.",
"output": "∀x (Published(x))"
},
{
"input": "Translate into first-order logic: If every research project is published, then every research project is thoroughly tested.",
"output": "∀x (Published(x))"
},
{
"input": "Translate into first-order logic: If the fact that a research project not being successful implies it does not meet academic standards, then not meeting academic standards implies that it is not well-funded.",
"output": "(∀x (¬Successful(x) → ¬MeetsAcademicStandards(x)) → ∀x (¬MeetsAcademicStandards(x) → ¬WellFunded(x)))"
},
{
"input": "Translate into first-order logic: If a research project is thoroughly tested, then it is recognized as innovative.",
"output": "∀x (ThoroughlyTested(x) → RecognizedInnovative(x))"
},
{
"input": "Translate into first-order logic: There exists at least one research project that is successful.",
"output": "∃x (Successful(x))"
},
{
"input": "Translate into first-order logic: If a research project meets academic standards, then it is published.",
"output": "∀x (MeetsAcademicStandards(x) → Published(x))"
},
{
"input": "Translate into first-order logic: Every academic work is rigorously researched.",
"output": "∀x (RigorouslyResearched(x))"
},
{
"input": "Translate into first-order logic: If an academic work is thoroughly tested, then it is scientifically sound.",
"output": "∀x (ThoroughlyTested(x) → ScientificallySound(x))"
},
{
"input": "Translate into first-order logic: If an academic work is rigorously researched, then it is thoroughly tested.",
"output": "∀x (RigorouslyResearched(x) → ThoroughlyTested(x))"
},
{
"input": "Translate into first-order logic: If an academic work meets quality standards, then it is scientifically sound.",
"output": "∀x (MeetsQualityStandards(x) → ScientificallySound(x))"
},
{
"input": "Translate into first-order logic: There exists at least one academic work that meets quality standards.",
"output": "∃x (MeetsQualityStandards(x))"
},
{
"input": "Translate into first-order logic: Every academic work is thoroughly tested.",
"output": "∀x (ThoroughlyTested(x))"
},
{
"input": "Translate into first-order logic: Every academic work is published.",
"output": "∀x (Published(x))"
},
{
"input": "Translate into first-order logic: If an academic work is not current, then it is not accepted for publication.",
"output": "∀x (¬Current(x) → ¬Published(x))"
},
{
"input": "Translate into first-order logic: If an academic work is not current, then it does not meet quality standards.",
"output": "∀x (¬Current(x) → ¬MeetsQualityStandards(x))"
},
{
"input": "Translate into first-order logic: If there exists at least one academic work that is thoroughly tested, then there exists at least one academic work that meets quality standards.",
"output": "∃x (ThoroughlyTested(x))"
},
{
"input": "Translate into first-order logic: If every academic work that is thoroughly tested is scientifically sound, then there exists at least one academic work that meets quality standards.",
"output": "(∀x (ThoroughlyTested(x) → ScientificallySound(x)) → ∃x (MeetsQualityStandards(x)))"
},
{
"input": "Translate into first-order logic: Every academic work is scientifically sound.",
"output": "∀x (ScientificallySound(x))"
},
{
"input": "Translate into first-order logic: If an academic work does not meet quality standards, then it is not rigorously researched.",
"output": "∀x (¬MeetsQualityStandards(x) → ¬RigorouslyResearched(x))"
},
{
"input": "Translate into first-order logic: If an academic work is not current, then it is not rigorously researched.",
"output": "∀x (¬Current(x) → ¬RigorouslyResearched(x))"
},
{
"input": "Translate into first-order logic: If an academic work is not scientifically sound, then it does not meet quality standards.",
"output": "∀x (¬ScientificallySound(x) → ¬MeetsQualityStandards(x))"
},
{
"input": "Translate into first-order logic: If an academic work does not meet quality standards, then it is not thoroughly tested.",
"output": "∀x (¬MeetsQualityStandards(x) → ¬ThoroughlyTested(x))"
},
{
"input": "Translate into first-order logic: Every C++ project is thoroughly tested.",
"output": "∀x (ThoroughlyTested(x))"
},
{
"input": "Translate into first-order logic: If a C++ project is thoroughly tested, then it is highly efficient.",
"output": "∀x (ThoroughlyTested(x) → HighlyEfficient(x))"
},
{
"input": "Translate into first-order logic: If a C++ project is well-designed and maintainable, then it is robust.",
"output": "∀x (WellDesignedMaintainable(x) → Robust(x))"
},
{
"input": "Translate into first-order logic: If a C++ project is well-designed and maintainable, then it adheres to modern C++ standards.",
"output": "∀x (WellDesignedMaintainable(x) → ModernCppStandards(x))"
},
{
"input": "Translate into first-order logic: Every C++ project is well-designed and maintainable.",
"output": "∀x (WellDesignedMaintainable(x))"
},
{
"input": "Translate into first-order logic: If a C++ project is portable, then it is well-designed and maintainable.",
"output": "∀x (Portable(x) → WellDesignedMaintainable(x))"
},
{
"input": "Translate into first-order logic: If a C++ project is highly efficient, then it is well-designed and maintainable.",
"output": "∀x (HighlyEfficient(x) → WellDesignedMaintainable(x))"
},
{
"input": "Translate into first-order logic: Every C++ project is robust.",
"output": "∀x (Robust(x))"
},
{
"input": "Translate into first-order logic: If every well-designed C++ project is robust, then every C++ project is robust.",
"output": "(∀x (WellDesignedMaintainable(x) → Robust(x)) → ∀x (Robust(x)))"
},
{
"input": "Translate into first-order logic: If well-designed C++ projects adhere to modern C++ standards, then any C++ project that is highly efficient is well-designed and maintainable.",
"output": "(∀x (WellDesignedMaintainable(x) → ModernCppStandards(x)) → ∀x (HighlyEfficient(x) → WellDesignedMaintainable(x)))"
},
{
"input": "Translate into first-order logic: There exists at least one C++ project that is portable.",
"output": "∃x (Portable(x))"
},
{
"input": "Translate into first-order logic: If a C++ project is thoroughly tested, then it is portable.",
"output": "∀x (ThoroughlyTested(x) → Portable(x))"
},
{
"input": "Translate into first-order logic: If a C++ project is highly efficient, then it is thoroughly tested.",
"output": "∀x (HighlyEfficient(x) → ThoroughlyTested(x))"
},
{
"input": "Translate into first-order logic: If a C++ project is thoroughly tested, then it is well-designed and maintainable.",
"output": "∀x (ThoroughlyTested(x) → WellDesignedMaintainable(x))"
},
{
"input": "Translate into first-order logic: If a C++ project is not thoroughly tested, then it does not adhere to modern C++ standards.",
"output": "∀x (¬ThoroughlyTested(x) → ¬ModernCppStandards(x))"
},
{
"input": "Translate into first-order logic: If a C++ project is not highly efficient, then it is not portable.",
"output": "∀x (¬HighlyEfficient(x) → ¬Portable(x))"
},
{
"input": "Translate into first-order logic: Every C++ project is highly efficient.",
"output": "∀x (HighlyEfficient(x))"
},
{
"input": "Translate into first-order logic: If a biometric system can detect presentation attacks, then it is secure.",
"output": "∀x (DetectsAttack(x) -> Secure(x))"
},
{
"input": "Translate into first-order logic: If a biometric system is not secure, then it cannot detect presentation attacks.",
"output": "∀x (~Secure(x) -> ~DetectsAttack(x))"
},
{
"input": "Translate into first-order logic: There exists at least one biometric system that cannot detect presentation attacks.",
"output": "∃x (~DetectsAttack(x))"
},
{
"input": "Translate into first-order logic: Every biometric system has a machine learning algorithm.",
"output": "∀x (MachineLearning(x))"
},
{
"input": "Translate into first-order logic: If a biometric system has a machine learning algorithm, then it can detect presentation attacks.",
"output": "∀x (MachineLearning(x) -> DetectsAttack(x))"
},
{
"input": "Translate into first-order logic: If a biometric system has a machine learning algorithm, then it is not necessarily secure.",
"output": "∃x (MachineLearning(x) & ~Secure(x))"
},
{
"input": "Translate into first-order logic: If a biometric system has a machine learning algorithm but cannot detect presentation attacks, then it is not secure.",
"output": "∀x ((MachineLearning(x) & ~DetectsAttack(x)) -> ~Secure(x))"
},
{
"input": "Translate into first-order logic: If a biometric system has a machine learning algorithm and can detect presentation attacks, then it is secure.",
"output": "∀x ((MachineLearning(x) & DetectsAttack(x)) -> Secure(x))"
},
{
"input": "Translate into first-order logic: There is at least one excellent student.",
"output": "∃x (P(x))"
},
{
"input": "Translate into first-order logic: If a student is not excellent, then that student does not receive a scholarship.",
"output": "(¬P(x) → ¬U(x))"
},
{
"input": "Translate into first-order logic: If a student does not participate in extracurricular activities, then that student does not receive a scholarship.",
"output": "(¬S(x) → ¬U(x))"
},
{
"input": "Translate into first-order logic: If there is at least one excellent student, then if a student is not excellent, that student does not receive a scholarship.",
"output": "(∃x (P(x)) → (¬P(x) → ¬U(x)))"
},
{
"input": "Translate into first-order logic: There is at least one student who fully participates in conduct training.",
"output": "∃x (R(x))"
},
{
"input": "Translate into first-order logic: If x is enrolled in the university, then x is an excellent student.",
"output": "(Q(x) → P(x))"
},
{
"input": "Translate into first-order logic: All students must complete the foundational courses.",
"output": "∀x (CompletesFundamentalCourses(x))"
},
{
"input": "Translate into first-order logic: Every student must submit their research paper.",
"output": "∀x (SubmitsResearchPaper(x))"
},
{
"input": "Translate into first-order logic: There is at least one student participating in extracurricular activities.",
"output": "∃x (S(x))"
},
{
"input": "Translate into first-order logic: If a student does not participate in extracurricular activities, they will not develop leadership skills.",
"output": "(¬S(x) → ¬DevelopsLeadershipSkills(x))"
},
{
"input": "Translate into first-order logic: If a student does not complete the foundational courses, they will not be eligible for graduation.",
"output": "(¬CompletesFundamentalCourses(x) → ¬EligibleGraduation(x))"
},
{
"input": "Translate into first-order logic: If a student enrolls in the honors program, they gain access to advanced research materials.",
"output": "(EnrolledHonorsProgram(x) → HasAccessAdvancedMaterials(x))"
},
{
"input": "Translate into first-order logic: All students in the honors program must maintain a high GPA.",
"output": "∀x (EnrolledHonorsProgram(x) → HighGPA(x))"
},
{
"input": "Translate into first-order logic: If a student does not participate in extracurricular activities, they cannot join the student council.",
"output": "(¬S(x) → ¬JoinsStudentCouncil(x))"
},
{
"input": "Translate into first-order logic: If failing to complete foundational courses leads to ineligibility for graduation, then students in the honors program must gain access to advanced materials.",
"output": "((¬CompletesFundamentalCourses(x) → ¬EligibleGraduation(x)) → (EnrolledHonorsProgram(x) → HasAccessAdvancedMaterials(x)))"
},
{
"input": "Translate into first-order logic: If students who do not complete foundational courses cannot graduate, then all students in the honors program must maintain a high GPA.",
"output": "((¬CompletesFundamentalCourses(x) → ¬EligibleGraduation(x)) → ∀x (EnrolledHonorsProgram(x) → HighGPA(x)))"
},
{
"input": "Translate into first-order logic: If students who do not participate in extracurricular activities cannot develop leadership skills, then if students who do not complete foundational courses cannot graduate, all students in the honors program must maintain a high GPA.",
"output": "((¬S(x) → ¬DevelopsLeadershipSkills(x)) → ((¬CompletesFundamentalCourses(x) → ¬EligibleGraduation(x)) → ∀x (EnrolledHonorsProgram(x) → HighGPA(x))))"
},
{
"input": "Translate into first-order logic: If (if students who do not participate in extracurricular activities lack leadership skills then if students who do not complete foundational courses cannot graduate, all students in the honors program must maintain a high GPA), then students in the honors program must gain access to advanced materials.",
"output": "(((¬S(x) → ¬DevelopsLeadershipSkills(x)) → ((¬CompletesFundamentalCourses(x) → ¬EligibleGraduation(x)) → ∀x (EnrolledHonorsProgram(x) → HighGPA(x)))) → (EnrolledHonorsProgram(x) → HasAccessAdvancedMaterials(x)))"
},
{
"input": "Translate into first-order logic: If (if students who do not complete foundational courses cannot graduate then students in the honors program gain access to advanced materials), then all students must complete the foundational courses.",
"output": "(((¬CompletesFundamentalCourses(x) → ¬EligibleGraduation(x)) → (EnrolledHonorsProgram(x) → HasAccessAdvancedMaterials(x))) → ∀x (CompletesFundamentalCourses(x)))"
},
{
"input": "Translate into first-order logic: If a student enrolls in the honors program, they must also complete foundational courses.",
"output": "(EnrolledHonorsProgram(x) → CompletesFundamentalCourses(x))"
},
{
"input": "Translate into first-order logic: All students must participate in group projects.",
"output": "∀x (ParticipatesGroupProject(x))"
},
{
"input": "Translate into first-order logic: If a student does not submit their research paper, they will not receive a passing grade.",
"output": "(¬SubmitsResearchPaper(x) → ¬ReceivesPassingGrade(x))"
},
{
"input": "Translate into first-order logic: There is at least one school that has students.",
"output": "∃x (T(x))"
},
{
"input": "Translate into first-order logic: There is at least one school that has a principal.",
"output": "∃x (P(x))"
},
{
"input": "Translate into first-order logic: If there is at least one school that has a principal, then there is at least one school that has teachers.",
"output": "(∃x (P(x)) → ∃x (R(x)))"
},
{
"input": "Translate into first-order logic: There is at least one school that has staff.",
"output": "∃x (Q(x))"
},
{
"input": "Translate into first-order logic: Every school has a principal.",
"output": "∀x (P(x))"
},
{
"input": "Translate into first-order logic: Every school has staff.",
"output": "∀x (Q(x))"
},
{
"input": "Translate into first-order logic: There is at least one school that has both students and teachers.",
"output": "∃x ((T(x) ∧ R(x)))"
},
{
"input": "Translate into first-order logic: If there is at least one school that has students, then there is at least one school that has staff.",
"output": "(∃x (T(x)) → ∃x (Q(x)))"
},
{
"input": "Translate into first-order logic: If a school does not have teachers, then it does not have students.",
"output": "(¬R(x) → ¬T(x))"
},
{
"input": "Translate into first-order logic: If (if there is at least one school that has a principal, then there is at least one school that has teachers), then every school has a principal.",
"output": "((∃x (P(x)) → ∃x (R(x))) → ∀x (P(x)))"
},
{
"input": "Translate into first-order logic: If there is at least one school that has staff, then there is at least one school that has teachers.",
"output": "(∃x (Q(x)) → ∃x (R(x)))"
},
{
"input": "Translate into first-order logic: If (if there is at least one school that has students, then there is at least one school that has teachers), then there is at least one school that has a principal.",
"output": "((∃x (T(x)) → ∃x (R(x))) → ∃x (P(x)))"
},
{
"input": "Translate into first-order logic: There is at least one researcher.",
"output": "∃x (R(x))"
},
{
"input": "Translate into first-order logic: Everyone is a teacher.",
"output": "∀x (T(x))"
},
{
"input": "Translate into first-order logic: If everyone is a teacher, then there is at least one researcher.",
"output": "(∀x (T(x)) → ∃x (R(x)))"
},
{
"input": "Translate into first-order logic: Everyone is a student.",
"output": "∀x (P(x))"
},
{
"input": "Translate into first-order logic: If someone is not a student, then they are not a teacher.",
"output": "(¬P(x) → ¬T(x))"
},
{
"input": "Translate into first-order logic: There is at least one person who is both a teacher and a university staff member.",
"output": "∃x ((T(x) ∧ S(x)))"
},
{
"input": "Translate into first-order logic: If everyone is a university staff member, then there is at least one teacher.",
"output": "(∀x (S(x)) → ∃x (T(x)))"
},
{
"input": "Translate into first-order logic: If there is at least one researcher, then everyone is a university staff member.",
"output": "(∃x (R(x)) → ∀x (S(x)))"
},
{
"input": "Translate into first-order logic: If someone is not a university staff member, then they are not a researcher.",
"output": "(¬S(x) → ¬R(x))"
},
{
"input": "Translate into first-order logic: If (if everyone is a student, then everyone is a teacher), then there is at least one researcher.",
"output": "((∀x (P(x)) → ∀x (T(x))) → ∃x (R(x)))"
},
{
"input": "Translate into first-order logic: If everyone is a teacher, then everyone is a student.",
"output": "(∀x (T(x)) → ∀x (P(x)))"
},
{
"input": "Translate into first-order logic: If (if someone is not a student, then they are not a teacher), then everyone is a university staff member.",
"output": "((¬P(x) → ¬T(x)) → ∀x (S(x)))"
},
{
"input": "Translate into first-order logic: Everyone in the university is a student.",
"output": "∀x (S(x))"
},
{
"input": "Translate into first-order logic: Every student fully participates in conduct training.",
"output": "∀x (R(x))"
},
{
"input": "Translate into first-order logic: If x fully participates in conduct training, then x is a student.",
"output": "(R(x) → S(x))"
},
{
"input": "Translate into first-order logic: If every student fully participates in conduct training, then if x fully participates in conduct training, x is a student.",
"output": "(∀x (R(x)) → (R(x) → S(x)))"
},
{
"input": "Translate into first-order logic: If x does not fully participate in social work, then x is not eligible for graduation.",
"output": "(¬T(x) → ¬P(x))"
},
{
"input": "Translate into first-order logic: There is at least one student eligible for graduation.",
"output": "∃x (P(x))"
},
{
"input": "Translate into first-order logic: There is at least one student who fully participates in conduct training.",
"output": "∃x ((S(x) ∧ R(x)))"
},
{
"input": "Translate into first-order logic: If everyone in the university is a student, then there is at least one student eligible for graduation.",
"output": "(∀x (S(x)) → ∃x (P(x)))"
},
{
"input": "Translate into first-order logic: If there is at least one student who fully participates in social work, then everyone is a student.",
"output": "(∃x (T(x)) → ∀x (S(x)))"
},
{
"input": "Translate into first-order logic: If x does not fully participate in conduct training, then x is not eligible for graduation.",
"output": "(¬R(x) → ¬P(x))"
},
{
"input": "Translate into first-order logic: If (if every student fully participates in conduct training, then everyone is a student), then there is at least one student who fully participates in social work.",
"output": "((∀x (R(x)) → ∀x (S(x))) → ∃x (T(x)))"
},
{
"input": "Translate into first-order logic: If everyone in the university is a student, then everyone fully participates in social work.",
"output": "(∀x (S(x)) → ∀x (T(x)))"
},
{
"input": "Translate into first-order logic: If (if x does not fully participate in social work, then x is not eligible for graduation), then every student fully participates in conduct training.",
"output": "((¬T(x) → ¬P(x)) → ∀x (R(x)))"
},
{
"input": "Translate into first-order logic: If x participates in social work, then x meets extracurricular requirements.",
"output": "(T(x) → U(x))"
},
{
"input": "Translate into first-order logic: If x meets academic requirements, then x is a student.",
"output": "(P(x) → S(x))"
},
{
"input": "Translate into first-order logic: If (if x meets academic requirements then x is a student), then (if x fully participates in conduct training then x is eligible for graduation).",
"output": "((P(x) → S(x)) → (R(x) → Q(x)))"
},
{
"input": "Translate into first-order logic: There is at least one student who participates in social work.",
"output": "∃x ((S(x) ∧ T(x)))"
},
{
"input": "Translate into first-order logic: Every student fully participates in conduct training.",
"output": "∀x ((S(x) → R(x)))"
},
{
"input": "Translate into first-order logic: Every student completes the fundamental courses.",
"output": "∀x (CompletesFundamentalCourses(x))"
},
{
"input": "Translate into first-order logic: If a student submits their assignments on time, then they achieve good grades.",
"output": "(SubmitsAssignmentsOnTime(x) → AchievesGoodGrades(x))"
},
{
"input": "Translate into first-order logic: If submitting assignments on time implies achieving good grades, then not attending review sessions implies not completing the fundamental courses.",
"output": "((SubmitsAssignmentsOnTime(x) → AchievesGoodGrades(x)) → (¬AttendsReviewSessions(x) → ¬CompletesFundamentalCourses(x)))"
},
{
"input": "Translate into first-order logic: If a student does not attend review sessions, then they do not earn extra credit.",
"output": "(¬AttendsReviewSessions(x) → ¬EarnsExtraCredit(x))"
},
{
"input": "Translate into first-order logic: If a student participates in study groups, then they achieve good grades.",
"output": "(ParticipatesInStudyGroups(x) → AchievesGoodGrades(x))"
},
{
"input": "Translate into first-order logic: If a student attends classes, then they receive extra credit.",
"output": "(AttendsClasses(x) → ReceivesExtraCredit(x))"
},
{
"input": "Translate into first-order logic: If a student achieves good grades, then they study regularly.",
"output": "(AchievesGoodGrades(x) → StudiesRegularly(x))"
},
{
"input": "Translate into first-order logic: If not receiving extra credit implies not submitting assignments on time, then if a student achieves good grades, they study regularly.",
"output": "((¬ReceivesExtraCredit(x) → ¬SubmitsAssignmentsOnTime(x)) → (AchievesGoodGrades(x) → StudiesRegularly(x)))"
},
{
"input": "Translate into first-order logic: If achieving good grades implies studying regularly, then not receiving extra credit implies that the student does not submit assignments on time.",
"output": "((AchievesGoodGrades(x) → StudiesRegularly(x)) → (¬ReceivesExtraCredit(x) → ¬SubmitsAssignmentsOnTime(x)))"
},
{
"input": "Translate into first-order logic: There exists at least one student who submits assignments on time.",
"output": "∃x (SubmitsAssignmentsOnTime(x))"
},
{
"input": "Translate into first-order logic: There exists at least one student who attends classes.",
"output": "∃x (AttendsClasses(x))"
},
{
"input": "Translate into first-order logic: Every student attends classes.",
"output": "∀x (AttendsClasses(x))"
},
{
"input": "Translate into first-order logic: If a student does not study regularly, then they do not achieve high scores.",
"output": "(¬StudiesRegularly(x) → ¬AchievesHighScores(x))"
},
{
"input": "Translate into first-order logic: If every student completes their assignments, then if a student does not study regularly, they do not achieve high scores.",
"output": "(∀x (CompletesAssignments(x)) → (¬StudiesRegularly(x) → ¬AchievesHighScores(x)))"
},
{
"input": "Translate into first-order logic: If not studying regularly implies not achieving high scores, then every student attends classes.",
"output": "((¬StudiesRegularly(x) → ¬AchievesHighScores(x)) → ∀x (AttendsClasses(x)))"
},
{
"input": "Translate into first-order logic: If a student studies regularly, then they complete their assignments.",
"output": "(StudiesRegularly(x) → CompletesAssignments(x))"
},
{
"input": "Translate into first-order logic: If a student does not submit their homework on time, then they do not receive bonus points.",
"output": "(¬SubmitsHomeworkOnTime(x) → ¬ReceivesBonusPoints(x))"
},
{
"input": "Translate into first-order logic: If a student studies regularly, then they achieve good grades.",
"output": "(StudiesRegularly(x) → AchievesGoodGrades(x))"
},
{
"input": "Translate into first-order logic: There exists at least one student who submits assignments on time.",
"output": "∃x (SubmitsAssignmentsOnTime(x))"
},
{
"input": "Translate into first-order logic: If at least one student submits assignments on time, then for any student, not receiving extra credit implies not submitting assignments on time.",
"output": "(∃x (SubmitsAssignmentsOnTime(x)) → (¬ReceivesExtraCredit(x) → ¬SubmitsAssignmentsOnTime(x)))"
},
{
"input": "Translate into first-order logic: There exists at least one student who studies regularly.",
"output": "∃x (StudiesRegularly(x))"
},
{
"input": "Translate into first-order logic: If a student submits assignments on time, then they receive extra credit.",
"output": "(SubmitsAssignmentsOnTime(x) → ReceivesExtraCredit(x))"
},
{
"input": "Translate into first-order logic: Every student receives extra credit.",
"output": "∀x (ReceivesExtraCredit(x))"
},
{
"input": "Translate into first-order logic: Every student attends classes.",
"output": "∀x (AttendsClasses(x))"
},
{
"input": "Translate into first-order logic: If a student does not submit assignments on time, then they do not attend classes.",
"output": "(¬SubmitsAssignmentsOnTime(x) → ¬AttendsClasses(x))"
},
{
"input": "Translate into first-order logic: If not submitting assignments on time implies not attending classes, then every student attends classes.",
"output": "((¬SubmitsAssignmentsOnTime(x) → ¬AttendsClasses(x)) → ∀x (AttendsClasses(x)))"
},
{
"input": "Translate into first-order logic: If a student attends classes, then they receive extra credit.",
"output": "(AttendsClasses(x) → ReceivesExtraCredit(x))"
},
{
"input": "Translate into first-order logic: If a student does not achieve good grades, then they do not submit assignments on time.",
"output": "(¬AchievesGoodGrades(x) → ¬SubmitsAssignmentsOnTime(x))"
},
{
"input": "Translate into first-order logic: If a student does not take advanced courses, then they do not participate in research.",
"output": "(¬TakesAdvancedCourses(x) → ¬ParticipatesInResearch(x))"
},
{
"input": "Translate into first-order logic: Every student takes advanced courses.",
"output": "∀x (TakesAdvancedCourses(x))"
},
{
"input": "Translate into first-order logic: If at least one student wins a scholarship, then every student takes advanced courses.",
"output": "(∃x (WinsScholarship(x)) → ∀x (TakesAdvancedCourses(x)))"
},
{
"input": "Translate into first-order logic: If every student takes advanced courses, then at least one student wins a scholarship.",
"output": "(∀x (TakesAdvancedCourses(x)) → ∃x (WinsScholarship(x)))"
},
{
"input": "Translate into first-order logic: Every student wins a scholarship.",
"output": "∀x (WinsScholarship(x))"
},
{
"input": "Translate into first-order logic: Every student participates in research.",
"output": "∀x (ParticipatesInResearch(x))"
},
{
"input": "Translate into first-order logic: If x is a student, then x takes advanced courses.",
"output": "(Student(x) → TakesAdvancedCourses(x))"
},
{
"input": "Translate into first-order logic: If x takes advanced courses, then x wins a scholarship.",
"output": "(TakesAdvancedCourses(x) → WinsScholarship(x))"
},
{
"input": "Translate into first-order logic: If all students take advanced courses, then everyone takes advanced courses.",
"output": "((Student(x) → TakesAdvancedCourses(x)) → ∀x (TakesAdvancedCourses(x)))"
},
{
"input": "Translate into first-order logic: If x wins a scholarship, then x publishes research.",
"output": "(WinsScholarship(x) → PublishesResearch(x))"
},
{
"input": "Translate into first-order logic: At least one person publishes research.",
"output": "∃x (PublishesResearch(x))"
},
{
"input": "Translate into first-order logic: There exists at least one student.",
"output": "∃x (Student(x))"
},
{
"input": "Translate into first-order logic: Everyone takes courses.",
"output": "∀x (TakesCourses(x))"
},
{
"input": "Translate into first-order logic: If x is a student, then x is a researcher.",
"output": "(Student(x) → Researcher(x))"
},
{
"input": "Translate into first-order logic: If x is not qualified, then x is not a researcher.",
"output": "(¬Qualified(x) → ¬Researcher(x))"
},
{
"input": "Translate into first-order logic: If x is a professor, then x teaches.",
"output": "(Professor(x) → Teaches(x))"
},
{
"input": "Translate into first-order logic: Everyone takes courses.",
"output": "∀x (TakesCourses(x))"
},
{
"input": "Translate into first-order logic: If x is not qualified, then x does not pass the exam.",
"output": "(¬Qualified(x) → ¬Passes(x))"
},
{
"input": "Translate into first-order logic: If 'not being a student implies not taking courses' is true, then everyone takes courses.",
"output": "((¬Student(x) → ¬TakesCourses(x)) → ∀x (TakesCourses(x)))"
},
{
"input": "Translate into first-order logic: Everyone understands the lectures.",
"output": "∀x (Understands(x))"
},
{
"input": "Translate into first-order logic: If x is not a student, then x does not understand the lectures.",
"output": "(¬Student(x) → ¬Understands(x))"
},
{
"input": "Translate into first-order logic: If x understands the lecture, then x passes the exam.",
"output": "∀x (U(x) → P(x))"
},
{
"input": "Translate into first-order logic: There exists at least one student.",
"output": "∃x S(x)"
},
{
"input": "Translate into first-order logic: If 'understanding the lecture implies taking the course' is true, then 'understanding the lecture implies passing the exam' is also true.",
"output": "(∀x (U(x) → T(x)) → ∀x (U(x) → P(x)))"
},
{
"input": "Translate into first-order logic: If x is not registered for the course, then x does not take the course.",
"output": "∀x (¬R(x) → ¬T(x))"
},
{
"input": "Translate into first-order logic: If x is registered for the course, then x is a student.",
"output": "∀x (R(x) → S(x))"
},
{
"input": "Translate into first-order logic: At least one person is registered for a course.",
"output": "∃x (R(x))"
},
{
"input": "Translate into first-order logic: Everyone understands the lecture.",
"output": "∀x (U(x))"
},
{
"input": "Translate into first-order logic: If at least one person is registered for a course, then everyone understands the lecture.",
"output": "(∃x (R(x)) → ∀x (U(x)))"
},
{
"input": "Translate into first-order logic: If a person is qualified, then they are registered.",
"output": "(Q(x) → R(x))"
},
{
"input": "Translate into first-order logic: If a person does not take a course, then they are not a student.",
"output": "(¬T(x) → ¬S(x))"
},
{
"input": "Translate into first-order logic: If a person is not registered, then they are not qualified.",
"output": "(¬R(x) → ¬Q(x))"
},
{
"input": "Translate into first-order logic: If a person studies, then they are qualified.",
"output": "(S(x) → Q(x))"
},
{
"input": "Translate into first-order logic: If a person trains, then they are qualified.",
"output": "(T(x) → Q(x))"
},
{
"input": "Translate into first-order logic: If training makes someone qualified, then studying should also make them qualified.",
"output": "((T(x) → Q(x)) → (S(x) → Q(x)))"
},
{
"input": "Translate into first-order logic: If a person is not registered, then they do not study.",
"output": "(¬R(x) → ¬S(x))"
},
{
"input": "Translate into first-order logic: If a person is not qualified, then they are not registered.",
"output": "(¬Q(x) → ¬R(x))"
},
{
"input": "Translate into first-order logic: If a person is an undergraduate, then they must be registered.",
"output": "(U(x) → R(x))"
},
{
"input": "Translate into first-order logic: Everyone is registered.",
"output": "∀x (R(x))"
},
{
"input": "Translate into first-order logic: If undergraduates are required to register, then everyone must register.",
"output": "((U(x) → R(x)) → ∀x (R(x)))"
},
{
"input": "Translate into first-order logic: If a person does not study, then they are not registered.",
"output": "(¬S(x) → ¬R(x))"
},
{
"input": "Translate into first-order logic: Everyone is an undergraduate.",
"output": "∀x (U(x))"
},
{
"input": "Translate into first-order logic: At least one student has submitted their final project before the deadline.",
"output": "∃x (SubmittedFinalProjectBeforeDeadline(x))"
},
{
"input": "Translate into first-order logic: Every student enrolled in the course is required to complete at least 80% of the assignments.",
"output": "∀x ((EnrolledInCourse(x) → CompletedAtLeast80PercentAssignments(x)))"
},
{
"input": "Translate into first-order logic: If a student attends all lectures, then they have a higher chance of passing the final exam.",
"output": "(AttendsAllLectures(x) → HigherChancePassingFinalExam(x))"
},
{
"input": "Translate into first-order logic: If a student does not participate in class discussions, then they are less likely to receive a high participation grade.",
"output": "(¬ParticipatesInClassDiscussions(x) → LessLikelyToReceiveHighParticipationGrade(x))"
},
{
"input": "Translate into first-order logic: Every teacher in the school has at least a master's degree in their subject area.",
"output": "∀x ((Teacher(x) → HasMastersDegreeInSubject(x)))"
},
{
"input": "Translate into first-order logic: At least one student has received a scholarship based on academic excellence.",
"output": "∃x (ReceivedScholarshipForAcademicExcellence(x))"
},
{
"input": "Translate into first-order logic: If all students complete their homework regularly, then the overall class performance improves.",
"output": "(∀x (CompletesHomeworkRegularly(x)) → ImprovesOverallClassPerformance(x))"
},
{
"input": "Translate into first-order logic: If a student fails two or more courses in a semester, then they are placed on academic probation.",
"output": "(FailsTwoOrMoreCourses(x) → PlacedOnAcademicProbation(x))"
},
{
"input": "Translate into first-order logic: If a student attends a tutoring session, then they are more likely to improve their grades.",
"output": "(AttendsTutoringSession(x) → MoreLikelyToImproveGrades(x))"
},
{
"input": "Translate into first-order logic: If a student does not submit their research paper, then they automatically fail the course.",
"output": "(¬SubmitsResearchPaper(x) → AutomaticallyFailsCourse(x))"
},
{
"input": "Translate into first-order logic: If a teacher provides detailed feedback on assignments, then students are more likely to improve their writing skills.",
"output": "(ProvidesDetailedFeedback(x) → StudentsMoreLikelyToImproveWritingSkills(x))"
},
{
"input": "Translate into first-order logic: Every university student is required to complete an internship before graduation.",
"output": "∀x ((UniversityStudent(x) → RequiredToCompleteInternship(x)))"
},
{
"input": "Translate into first-order logic: All students must complete the foundational courses.",
"output": "∀x (CompletesFundamentalCourses(x))"
},
{
"input": "Translate into first-order logic: Every student must submit their research paper.",
"output": "∀x (SubmitsResearchPaper(x))"
},
{
"input": "Translate into first-order logic: There is at least one student participating in extracurricular activities.",
"output": "∃x (ParticipatesExtracurricular(x))"
},
{
"input": "Translate into first-order logic: If a student does not participate in extracurricular activities, they will not develop leadership skills.",
"output": "(¬ParticipatesExtracurricular(x) → ¬DevelopsLeadershipSkills(x))"
},
{
"input": "Translate into first-order logic: If a student does not complete the foundational courses, they will not be eligible for graduation.",
"output": "(¬CompletesFundamentalCourses(x) → ¬EligibleGraduation(x))"
},
{
"input": "Translate into first-order logic: If a student enrolls in the honors program, they gain access to advanced research materials.",
"output": "(EnrolledHonorsProgram(x) → HasAccessAdvancedMaterials(x))"
},
{
"input": "Translate into first-order logic: All students in the honors program must maintain a high GPA.",
"output": "∀x (EnrolledHonorsProgram(x))"
},
{
"input": "Translate into first-order logic: If a student does not participate in extracurricular activities, they cannot join the student council.",
"output": "(¬ParticipatesExtracurricular(x) → ¬JoinsStudentCouncil(x))"
},
{
"input": "Translate into first-order logic: If failing to complete foundational courses leads to ineligibility for graduation, then students in the honors program must maintain a high GPA.",
"output": "((¬CompletesFundamentalCourses(x) → ¬EligibleGraduation(x)) → (EnrolledHonorsProgram(x) → HasAccessAdvancedMaterials(x)))"
},
{
"input": "Translate into first-order logic: If students who do not complete foundational courses cannot graduate, then all students in the honors program must maintain a high GPA.",
"output": "((¬CompletesFundamentalCourses(x) → ¬EligibleGraduation(x)) → ∀x (EnrolledHonorsProgram(x)))"
},
{
"input": "Translate into first-order logic: If students who do not participate in extracurricular activities cannot develop leadership skills, then students who do not complete foundational courses will also not meet requirements.",
"output": "((¬ParticipatesExtracurricular(x) → ¬DevelopsLeadershipSkills(x)) → ((¬CompletesFundamentalCourses(x) → ¬EligibleGraduation(x)) → ∀x (EnrolledHonorsProgram(x))))"
},
{
"input": "Translate into first-order logic: If students who do not participate in extracurricular activities lack leadership skills, then all students in the honors program must complete additional coursework.",
"output": "(((¬ParticipatesExtracurricular(x) → ¬DevelopsLeadershipSkills(x)) → ((¬CompletesFundamentalCourses(x) → ¬EligibleGraduation(x)) → ∀x (EnrolledHonorsProgram(x)))) → (EnrolledHonorsProgram(x) → HasAccessAdvancedMaterials(x)))"
},
{
"input": "Translate into first-order logic: If students who do not complete foundational courses cannot graduate, then all students must complete the foundational courses.",
"output": "(((¬CompletesFundamentalCourses(x) → ¬EligibleGraduation(x)) → (EnrolledHonorsProgram(x) → HasAccessAdvancedMaterials(x))) → ∀x (CompletesFundamentalCourses(x)))"
},
{
"input": "Translate into first-order logic: If a student enrolls in the honors program, they must also complete additional coursework.",
"output": "(EnrolledHonorsProgram(x) → CompletesFundamentalCourses(x))"
},
{
"input": "Translate into first-order logic: All students must participate in group projects.",
"output": "∀x (ParticipatesGroupProject(x))"
},
{
"input": "Translate into first-order logic: If a student does not submit their research paper, they will not receive a passing grade.",
"output": "(¬SubmitsResearchPaper(x) → ¬ReceivesPassingGrade(x))"
},
{
"input": "Translate into first-order logic: All students must complete their coursework.",
"output": "∀x (Coursework(x))"
},
{
"input": "Translate into first-order logic: If a student participates in research projects, they gain academic recognition.",
"output": "(Research(x) → Recognition(x))"
},
{
"input": "Translate into first-order logic: If a student does not maintain a high GPA, they will not be eligible for scholarships.",
"output": "(¬HighGPA(x) → ¬Scholarship(x))"
},
{
"input": "Translate into first-order logic: If a student attends academic conferences, they gain knowledge in their field.",
"output": "(Conference(x) → Knowledge(x))"
},
{
"input": "Translate into first-order logic: If a student does not receive academic recognition, they will not be selected for advanced research programs.",
"output": "(¬Recognition(x) → ¬AdvancedResearch(x))"
},
{
"input": "Translate into first-order logic: If a student maintains a high GPA, they will be eligible for scholarships.",
"output": "(HighGPA(x) → Scholarship(x))"
},
{
"input": "Translate into first-order logic: All students must follow the university's academic regulations.",
"output": "∀x (Regulations(x))"
},
{
"input": "Translate into first-order logic: If students who do not receive academic recognition are not selected for advanced research programs, then students who do not maintain a high GPA will not be eligible for scholarships.",
"output": "((¬Recognition(x) → ¬AdvancedResearch(x)) → (¬HighGPA(x) → ¬Scholarship(x)))"
},
{
"input": "Translate into first-order logic: If attending academic conferences leads to gaining knowledge, then students who do not maintain a high GPA will not be eligible for scholarships.",
"output": "((Conference(x) → Knowledge(x)) → (¬HighGPA(x) → ¬Scholarship(x)))"
},
{
"input": "Translate into first-order logic: If maintaining a high GPA leads to eligibility for scholarships, then attending academic conferences leads to gaining knowledge.",
"output": "((HighGPA(x) → Scholarship(x)) → (Conference(x) → Knowledge(x)))"
},
{
"input": "Translate into first-order logic: If all students must complete their coursework, then students who do not receive academic recognition will not be selected for advanced research programs.",
"output": "(∀x (Coursework(x)) → (¬Recognition(x) → ¬AdvancedResearch(x)))"
},
{
"input": "Translate into first-order logic: If attending academic conferences leads to gaining knowledge, then maintaining a high GPA leads to eligibility for scholarships.",
"output": "((Conference(x) → Knowledge(x)) → (HighGPA(x) → Scholarship(x)))"
},
{
"input": "Translate into first-order logic: If a student follows the university's academic regulations, they will gain academic recognition.",
"output": "(Regulations(x) → Recognition(x))"
},
{
"input": "Translate into first-order logic: All students must participate in at least one extracurricular activity.",
"output": "∀x (Extracurricular(x))"
},
{
"input": "Translate into first-order logic: If a student does not attend classes, they will not pass the exams.",
"output": "(¬AttendsClass(x) → ¬PassExam(x))"
},
{
"input": "Translate into first-order logic: If a student does not attend classes, they will not complete assignments.",
"output": "(¬AttendsClass(x) → ¬CompleteAssignment(x))"
},
{
"input": "Translate into first-order logic: All students must complete assignments.",
"output": "∀x (CompleteAssignment(x))"
},
{
"input": "Translate into first-order logic: If a student completes assignments, they will pass the exams.",
"output": "(CompleteAssignment(x) → PassExam(x))"
},
{
"input": "Translate into first-order logic: If a student conducts research, they will receive academic recognition.",
"output": "(ConductsResearch(x) → ReceivesRecognition(x))"
},
{
"input": "Translate into first-order logic: If a student completes assignments, they will conduct research.",
"output": "(CompleteAssignment(x) → ConductsResearch(x))"
},
{
"input": "Translate into first-order logic: If a student passes the exams, they will conduct research.",
"output": "(PassExam(x) → ConductsResearch(x))"
},
{
"input": "Translate into first-order logic: There exists at least one student who attends classes.",
"output": "∃x (AttendsClass(x))"
},
{
"input": "Translate into first-order logic: There exists at least one student who passes the exams.",
"output": "∃x (PassExam(x))"
},
{
"input": "Translate into first-order logic: If conducting research leads to academic recognition, then students who do not attend classes will not pass the exams.",
"output": "((ConductsResearch(x) → ReceivesRecognition(x)) → (¬AttendsClass(x) → ¬PassExam(x)))"
},
{
"input": "Translate into first-order logic: If students who do not attend classes do not pass exams, then completing assignments ensures passing exams.",
"output": "((¬AttendsClass(x) → ¬PassExam(x)) → (CompleteAssignment(x) → PassExam(x)))"
},
{
"input": "Translate into first-order logic: If at least one student passes the exams, then students who do not attend classes will not pass the exams.",
"output": "(∃x (PassExam(x)) → (¬AttendsClass(x) → ¬PassExam(x)))"
},
{
"input": "Translate into first-order logic: If all students must complete assignments, then students who do not attend classes will not pass the exams.",
"output": "(∀x (CompleteAssignment(x)) → (¬AttendsClass(x) → ¬PassExam(x)))"
},
{
"input": "Translate into first-order logic: All students attend classes.",
"output": "∀x (AttendsClass(x))"
},
{
"input": "Translate into first-order logic: All students pass the exams.",
"output": "∀x (PassExam(x))"
},
{
"input": "Translate into first-order logic: If a student attends classes, they will pass the exams.",
"output": "(AttendsClass(x) → PassExam(x))"
},
{
"input": "Translate into first-order logic: If a student passes the exams, they will complete assignments.",
"output": "(PassExam(x) → CompleteAssignment(x))"
},
{
"input": "Translate into first-order logic: If a student does not study, they will not pass the test.",
"output": "(¬Studies(x) → ¬PassTest(x))"
},
{
"input": "Translate into first-order logic: There exists at least one student who participates in extracurricular activities.",
"output": "∃x (Participates(x))"
},
{
"input": "Translate into first-order logic: All students are required to complete coursework.",
"output": "∀x (Coursework(x))"
},
{
"input": "Translate into first-order logic: If a student does not submit assignments, they will not receive a grade.",
"output": "(¬SubmitsAssignment(x) → ¬ReceivesGrade(x))"
},
{
"input": "Translate into first-order logic: All students participate in extracurricular activities.",
"output": "∀x (Participates(x))"
},
{
"input": "Translate into first-order logic: There exists at least one student who submits assignments.",
"output": "∃x (SubmitsAssignment(x))"
},
{
"input": "Translate into first-order logic: All students pass the test.",
"output": "∀x (PassTest(x))"
},
{
"input": "Translate into first-order logic: If a student passes the test, then they have studied.",
"output": "(PassTest(x) → Studies(x))"
},
{
"input": "Translate into first-order logic: If all students complete coursework, then all students participate in extracurricular activities.",
"output": "(∀x (Coursework(x)) → ∀x (Participates(x)))"
},
{
"input": "Translate into first-order logic: If all students completing coursework implies that all students participate in extracurricular activities, then at least one student participates in extracurricular activities.",
"output": "((∀x (Coursework(x)) → ∀x (Participates(x))) → ∃x (Participates(x)))"
},
{
"input": "Translate into first-order logic: If at least one student participates in extracurricular activities, then at least one student submits assignments.",
"output": "(∃x (Participates(x)) → ∃x (SubmitsAssignment(x)))"
},
{
"input": "Translate into first-order logic: If at least one student participating in extracurricular activities implies that at least one student submits assignments, then the same implication holds itself.",
"output": "((∃x (Participates(x)) → ∃x (SubmitsAssignment(x))) → (∃x (Participates(x)) → ∃x (SubmitsAssignment(x))))"
},
{
"input": "Translate into first-order logic: If a student not studying leads to failing the test, then a student not submitting assignments leads to not receiving a grade.",
"output": "((¬Studies(x) → ¬PassTest(x)) → (¬SubmitsAssignment(x) → ¬ReceivesGrade(x)))"
},
{
"input": "Translate into first-order logic: If a student completes coursework, then they submit assignments.",
"output": "(Coursework(x) → SubmitsAssignment(x))"
},
{
"input": "Translate into first-order logic: All students submit assignments.",
"output": "∀x (SubmitsAssignment(x))"
},
{
"input": "Translate into first-order logic: If a student does not participate in extracurricular activities, they will not pass the test.",
"output": "(¬Participates(x) → ¬PassTest(x))"
},
{
"input": "Translate into first-order logic: All students are required to submit assignments.",
"output": "∀x (SubmitAssignment(x))"
},
{
"input": "Translate into first-order logic: If a student qualifies for a scholarship, they must have good academic standing.",
"output": "(QualifiesScholarship(x) → GoodAcademicStanding(x))"
},
{
"input": "Translate into first-order logic: If a student participates in extracurricular activities, then they qualify for a scholarship.",
"output": "(Extracurricular(x) → QualifiesScholarship(x))"
},
{
"input": "Translate into first-order logic: If a student does not submit assignments, then they cannot participate in extracurricular activities.",
"output": "(¬SubmitAssignment(x) → ¬Extracurricular(x))"
},
{
"input": "Translate into first-order logic: If a student participates in extracurricular activities, then they must maintain good academic performance.",
"output": "(Extracurricular(x) → GoodAcademicPerformance(x))"
},
{
"input": "Translate into first-order logic: There exists at least one student who submits assignments.",
"output": "∃x (SubmitAssignment(x))"
},
{
"input": "Translate into first-order logic: All students participate in extracurricular activities.",
"output": "∀x (Extracurricular(x))"
},
{
"input": "Translate into first-order logic: If all students participate in extracurricular activities, then all students must submit assignments.",
"output": "(∀x (Extracurricular(x)) → ∀x (SubmitAssignment(x)))"
},
{
"input": "Translate into first-order logic: If at least one student submits assignments, then this is always true.",
"output": "(∃x (SubmitAssignment(x)) → ∃x (SubmitAssignment(x)))"
},
{
"input": "Translate into first-order logic: If the above statement is always true, then it remains valid for all cases.",
"output": "((∃x (SubmitAssignment(x)) → ∃x (SubmitAssignment(x))) → (∃x (SubmitAssignment(x)) → ∃x (SubmitAssignment(x))))"
},
{
"input": "Translate into first-order logic: There exists at least one student who qualifies for a scholarship.",
"output": "∃x (QualifiesScholarship(x))"
},
{
"input": "Translate into first-order logic: If a student does not submit assignments, then they cannot maintain good academic performance.",
"output": "(¬SubmitAssignment(x) → ¬GoodAcademicPerformance(x))"
},
{
"input": "Translate into first-order logic: All students must complete their coursework.",
"output": "∀x (CourseworkCompleted(x))"
},
{
"input": "Translate into first-order logic: If a student is not enrolled in a course, they cannot receive a grade.",
"output": "(¬Enrolled(x) → ¬GradeReceived(x))"
},
{
"input": "Translate into first-order logic: If a student qualifies for an advanced placement class, they must have high academic performance.",
"output": "(AdvancedPlacement(x) → HighPerformance(x))"
},
{
"input": "Translate into first-order logic: If a student is part of the honor program, then they qualify for an advanced placement class.",
"output": "(HonorProgram(x) → AdvancedPlacement(x))"
},
{
"input": "Translate into first-order logic: At least one student has completed their coursework.",
"output": "∃x (CourseworkCompleted(x))"
},
{
"input": "Translate into first-order logic: At least one student has received a grade.",
"output": "∃x (GradeReceived(x))"
},
{
"input": "Translate into first-order logic: If a student has completed their coursework, then they are part of the honor program.",
"output": "(CourseworkCompleted(x) → HonorProgram(x))"
},
{
"input": "Translate into first-order logic: If a student qualifies for an advanced placement class, then they must have completed their coursework.",
"output": "(AdvancedPlacement(x) → CourseworkCompleted(x))"
},
{
"input": "Translate into first-order logic: If all students qualifying for advanced placement must have high academic performance, then they must also have completed their coursework.",
"output": "((AdvancedPlacement(x) → HighPerformance(x)) → (AdvancedPlacement(x) → CourseworkCompleted(x)))"
},
{
"input": "Translate into first-order logic: If completing coursework ensures that students are part of the honor program, then at least one student must have completed their coursework.",
"output": "((CourseworkCompleted(x) → HonorProgram(x)) → ∃x (CourseworkCompleted(x)))"
},
{
"input": "Translate into first-order logic: If all students qualifying for advanced placement must have high academic performance, and that leads to completing coursework, then all students who have completed coursework must be in the honor program.",
"output": "(((AdvancedPlacement(x) → HighPerformance(x)) → (AdvancedPlacement(x) → CourseworkCompleted(x))) → (CourseworkCompleted(x) → HonorProgram(x)))"
},
{
"input": "Translate into first-order logic: If a student qualifies for an advanced placement class, then they will receive a grade.",
"output": "(AdvancedPlacement(x) → GradeReceived(x))"
},
{
"input": "Translate into first-order logic: If a student has high academic performance, then they will receive a grade.",
"output": "(HighPerformance(x) → GradeReceived(x))"
},
{
"input": "Translate into first-order logic: All students have high academic performance.",
"output": "∀x (HighPerformance(x))"
},
{
"input": "Translate into first-order logic: All students must comply with the university's rules and regulations.",
"output": "∀x (Student(x) → ComplyWithRules(x))"
},
{
"input": "Translate into first-order logic: Students who do not comply with the rules will be subject to disciplinary action.",
"output": "∀x (¬ComplyWithRules(x) → DisciplinaryAction(x))"
},
{
"input": "Translate into first-order logic: All students must complete the mandatory courses in the curriculum.",
"output": "∀x (Student(x) → CompleteMandatoryCourses(x))"
},
{
"input": "Translate into first-order logic: Students who do not complete the mandatory courses will not be eligible for graduation.",
"output": "∀x (¬CompleteMandatoryCourses(x) → ¬EligibleForGraduation(x))"
},
{
"input": "Translate into first-order logic: All lecturers must be familiar with the university's admission regulations.",
"output": "∀x (Lecturer(x) → UnderstandAdmissionRegulations(x))"
},
{
"input": "Translate into first-order logic: Lecturers who do not meet the requirements regarding admission regulations must take additional assessments.",
"output": "∀x (¬UnderstandAdmissionRegulations(x) → AdditionalTesting(x))"
},
{
"input": "Translate into first-order logic: Students may extend their study duration up to twice the standard program duration.",
"output": "∀x (Student(x) → MaxStudyDuration(x, 2 * StandardDuration))"
},
{
"input": "Translate into first-order logic: Students who exceed the maximum study duration but have not met graduation requirements can complete the remaining conditions within 3 years.",
"output": "∀x ((StudyDurationExceeded(x) ∧ ¬EligibleForGraduation(x)) → CompleteRequirementsWithin3Years(x))"
},
{
"input": "Translate into first-order logic: Tuition fees are determined based on the academic field and may change annually.",
"output": "∀x (TuitionFee(x) → DeterminedByFieldAndYear(x))"
},
{
"input": "Translate into first-order logic: Students must fulfill their tuition payment obligations to continue their studies.",
"output": "∀x (Student(x) → CompleteTuitionPayment(x))"
},
{
"input": "Translate into first-order logic: There exists at least one student who has received a scholarship.",
"output": "∃x (Scholarship(x))"
},
{
"input": "Translate into first-order logic: All students must follow the university’s academic policies.",
"output": "∀x (Policy(x))"
},
{
"input": "Translate into first-order logic: There exists at least one student who follows the university’s academic policies.",
"output": "∃x (Policy(x))"
},
{
"input": "Translate into first-order logic: If a course is not accredited, it cannot be counted towards graduation requirements.",
"output": "(¬Accredited(x) → ¬GraduationCredit(x))"
},
{
"input": "Translate into first-order logic: There exists at least one student who has passed all required courses.",
"output": "∃x (Passed(x))"
},
{
"input": "Translate into first-order logic: If a student meets the academic excellence criteria, they are eligible for scholarships.",
"output": "(Excellence(x) → Scholarship(x))"
},
{
"input": "Translate into first-order logic: If a student does not follow the university’s academic policies, they cannot receive a scholarship.",
"output": "(¬Policy(x) → ¬Scholarship(x))"
},
{
"input": "Translate into first-order logic: All courses must meet the accreditation standards.",
"output": "∀x (Accredited(x))"
},
{
"input": "Translate into first-order logic: If at least one student has passed all required courses, then at least one student is eligible for a scholarship.",
"output": "(∃x (Passed(x)) → ∃x (Scholarship(x)))"
},
{
"input": "Translate into first-order logic: If all students follow the university’s academic policies, then at least one student follows them.",
"output": "(∀x (Policy(x)) → ∃x (Policy(x)))"
},
{
"input": "Translate into first-order logic: If meeting academic excellence criteria guarantees eligibility for scholarships, then at least one student has passed all required courses.",
"output": "((Excellence(x) → Scholarship(x)) → ∃x (Passed(x)))"
},
{
"input": "Translate into first-order logic: If at least one student has received a scholarship, then failing to follow academic policies results in no scholarship.",
"output": "(∃x (Scholarship(x)) → (¬Policy(x) → ¬Scholarship(x)))"
},
{
"input": "Translate into first-order logic: If failing to follow academic policies prevents students from receiving scholarships, then at least one student follows them.",
"output": "((¬Policy(x) → ¬Scholarship(x)) → ∃x (Policy(x)))"
},
{
"input": "Translate into first-order logic: If a student does not follow the university’s academic policies, they cannot take accredited courses.",
"output": "(¬Policy(x) → ¬Accredited(x))"
},
{
"input": "Translate into first-order logic: There exists at least one accredited course.",
"output": "∃x (Accredited(x))"
},
{
"input": "Translate into first-order logic: If a student meets the academic excellence criteria, they have passed all required courses.",
"output": "(Excellence(x) → Passed(x))"
},
{
"input": "Translate into first-order logic: All students must comply with the university's examination regulations.",
"output": "∀x (Student(x) → ExamCompliant(x))"
},
{
"input": "Translate into first-order logic: If a student violates the examination regulations, they will be subject to disciplinary action.",
"output": "∀x (ViolateExam(x) → DisciplinaryAction(x))"
},
{
"input": "Translate into first-order logic: At least one student has been found violating the examination regulations.",
"output": "∃x (ViolateExam(x))"
},
{
"input": "Translate into first-order logic: At least one student has achieved outstanding academic performance.",
"output": "∃x (OutstandingPerformance(x))"
},
{
"input": "Translate into first-order logic: If a student achieves outstanding academic performance, they will receive a scholarship.",
"output": "∀x (OutstandingPerformance(x) → Scholarship(x))"
},
{
"input": "Translate into first-order logic: If a student is subject to disciplinary action, they are not eligible to receive a scholarship.",
"output": "∀x (DisciplinaryAction(x) → ¬Scholarship(x))"
},
{
"input": "Translate into first-order logic: At least one student complies with the examination regulations.",
"output": "∃x (ExamCompliant(x))"
},
{
"input": "Translate into first-order logic: If at least one student achieves outstanding academic performance, then at least one student receives a scholarship.",
"output": "(∃x (OutstandingPerformance(x)) → ∃x (Scholarship(x)))"
},
{
"input": "Translate into first-order logic: If at least one student is found violating the examination regulations, the university will take disciplinary action.",
"output": "(∃x (ViolateExam(x)) → ∃x (DisciplinaryAction(x)))"
},
{
"input": "Translate into first-order logic: If all students comply with the examination regulations, then no student will be subject to disciplinary action.",
"output": "(∀x (ExamCompliant(x)) → ¬∃x (DisciplinaryAction(x)))"
},
{
"input": "Translate into first-order logic: If having at least one student achieve outstanding academic performance leads to at least one student receiving a scholarship, then all students must comply with the examination regulations.",
"output": "((∃x (OutstandingPerformance(x)) → ∃x (Scholarship(x))) → ∀x (ExamCompliant(x)))"
},
{
"input": "Translate into first-order logic: If at least one student is subject to disciplinary action, then at least one student has violated the examination regulations.",
"output": "(∃x (DisciplinaryAction(x)) → ∃x (ViolateExam(x)))"
},
{
"input": "Translate into first-order logic: All students have the opportunity to achieve outstanding academic performance.",
"output": "∀x (Student(x) → CanAchievePerformance(x))"
},
{
"input": "Translate into first-order logic: If a student achieves outstanding academic performance, they are eligible to participate in an international exchange program.",
"output": "∀x (OutstandingPerformance(x) → ExchangeEligible(x))"
},
{
"input": "Translate into first-order logic: All students must enroll in at least one core subject.",
"output": "∀x (EnrollsCoreSubject(x))"
},
{
"input": "Translate into first-order logic: If a student attends all lectures, they will have a higher chance of passing the course.",
"output": "(AttendsLectures(x) → HigherChancePass(x))"
},
{
"input": "Translate into first-order logic: If a student does not attend all lectures, they might struggle to understand key concepts.",
"output": "(¬AttendsLectures(x) → StrugglesUnderstanding(x))"
},
{
"input": "Translate into first-order logic: If a student submits all assignments on time, they are likely to achieve a good grade.",
"output": "(SubmitsAssignments(x) → GoodGrade(x))"
},
{
"input": "Translate into first-order logic: If a student does not submit assignments, they will not receive a passing grade.",
"output": "(¬SubmitsAssignments(x) → ¬PassesCourse(x))"
},
{
"input": "Translate into first-order logic: There exists at least one student who participates in an academic competition.",
"output": "∃x (ParticipatesAcademicCompetition(x))"
},
{
"input": "Translate into first-order logic: If a student joins the research group, they gain access to laboratory resources.",
"output": "(JoinsResearchGroup(x) → HasLabAccess(x))"
},
{
"input": "Translate into first-order logic: If a student joins the research group, they must contribute to at least one published paper.",
"output": "((JoinsResearchGroup(x) → ContributesPublishedPaper(x)))"
},
{
"input": "Translate into first-order logic: If failing to submit assignments results in failing the course, then all students must complete their coursework.",
"output": "((¬SubmitsAssignments(x) → ¬PassesCourse(x)) → ∀x (CompletesCoursework(x)))"
},
{
"input": "Translate into first-order logic: If participating in academic competitions leads to skill improvement, then students with strong skills are more likely to receive scholarships.",
"output": "((ParticipatesAcademicCompetition(x) → ImprovesSkills(x)) → (StrongSkills(x) → ReceivesScholarship(x)))"
},
{
"input": "Translate into first-order logic: If at least one student participates in an academic competition, then engaging in research ensures deeper knowledge.",
"output": "(∃x (ParticipatesAcademicCompetition(x)) → (EngagesResearch(x) → GainsDeeperKnowledge(x)))"
},
{
"input": "Translate into first-order logic: If joining the research group requires contributing to a published paper, then at least one student must be involved in research.",
"output": "((JoinsResearchGroup(x) → ContributesPublishedPaper(x)) → ∃x (EngagesResearch(x)))"
},
{
"input": "Translate into first-order logic: If a student does not participate in academic competitions, they might not gain additional learning experiences.",
"output": "(¬ParticipatesAcademicCompetition(x) → ¬GainsAdditionalLearning(x))"
},
{
"input": "Translate into first-order logic: If a student enrolls in core subjects, they build a strong academic foundation.",
"output": "(EnrollsCoreSubject(x) → BuildsStrongFoundation(x))"
},
{
"input": "Translate into first-order logic: If a student attends all lectures and submits assignments on time, they will pass the course.",
"output": "((AttendsLectures(x) ∧ SubmitsAssignments(x)) → PassesCourse(x))"
},
{
"input": "Translate into first-order logic: If a student joins the research group, they must contribute to at least one published paper and actively participate in group discussions. Additionally, if they participate in academic competitions, they can receive academic recognition.",
"output": "((JoinsResearchGroup(x) → (ContributesPublishedPaper(x) ∧ ParticipatesDiscussions(x))) ∧ (ParticipatesAcademicCompetition(x) → ReceivesAcademicRecognition(x)))"
},
{
"input": "Translate into first-order logic: Every student with a GPA of 4.0 is eligible for a full scholarship.",
"output": "∀x (GPA4.0(x) → EligibleForFullScholarship(x))"
},
{
"input": "Translate into first-order logic: If a student receives a full scholarship, they do not have to pay tuition fees.",
"output": "∀x (ReceivesFullScholarship(x) → ¬PaysTuition(x))"
},
{
"input": "Translate into first-order logic: A student who maintains a GPA of 4.0 for all semesters will graduate with honors.",
"output": "∀x (MaintainsGPA4.0(x) → GraduatesWithHonors(x))"
},
{
"input": "Translate into first-order logic: There exists at least one student who has received a full scholarship.",
"output": "∃x (ReceivesFullScholarship(x))"
},
{
"input": "Translate into first-order logic: If a student participates in research, they have a higher chance of receiving a scholarship.",
"output": "∀x (ParticipatesInResearch(x) → HigherChanceOfScholarship(x))"
},
{
"input": "Translate into first-order logic: Students who engage in extracurricular activities have a better chance of getting scholarships.",
"output": "∀x (EngagesInExtracurriculars(x) → BetterChanceOfScholarship(x))"
},
{
"input": "Translate into first-order logic: At least one student who received a full scholarship has participated in research.",
"output": "∃x (ReceivesFullScholarship(x) ∧ ParticipatesInResearch(x))"
},
{
"input": "Translate into first-order logic: If maintaining a GPA of 4.0 leads to graduating with honors, then every honors graduate must have a high GPA.",
"output": "(∀x (MaintainsGPA4.0(x) → GraduatesWithHonors(x)) → ∀x (GraduatesWithHonors(x) → HighGPA(x)))"
},
{
"input": "Translate into first-order logic: If research participation improves scholarship chances, then at least one research student has a scholarship.",
"output": "(∀x (ParticipatesInResearch(x) → HigherChanceOfScholarship(x)) → ∃x (ResearchStudent(x) ∧ ReceivesScholarship(x)))"
},
{
"input": "Translate into first-order logic: If all students with a GPA of 4.0 are eligible for scholarships, then top students are financially supported.",
"output": "(∀x (GPA4.0(x) → EligibleForFullScholarship(x)) → ∀x (TopStudent(x) → FinanciallySupported(x)))"
},
{
"input": "Translate into first-order logic: If a student has received a full scholarship, they must have demonstrated academic excellence.",
"output": "∀x (ReceivesFullScholarship(x) → DemonstratedAcademicExcellence(x))"
},
{
"input": "Translate into first-order logic: If a student does not maintain a high GPA, they might lose their scholarship.",
"output": "∀x (¬MaintainsHighGPA(x) → MightLoseScholarship(x))"
},
{
"input": "Translate into first-order logic: There exists at least one student who has lost a scholarship due to a GPA drop.",
"output": "∃x (LostScholarship(x) ∧ ¬MaintainsHighGPA(x))"
},
{
"input": "Translate into first-order logic: If a student does not follow the school rules, the student will be disciplined.",
"output": "(¬FollowSchoolRules(x) → Discipline(x))"
},
{
"input": "Translate into first-order logic: Every student must arrive at school on time.",
"output": "∀x (OnTime(x))"
},
{
"input": "Translate into first-order logic: If a student violates the school rules, the student will be banned from extracurricular activities.",
"output": "(ViolateSchoolRules(x) → BanExtracurricular(x))"
},
{
"input": "Translate into first-order logic: There exists at least one student who has been disciplined for violating the school rules.",
"output": "∃x (Discipline(x))"
},
{
"input": "Translate into first-order logic: If a student does not follow the dress code, the student will be asked to change their clothes.",
"output": "(¬FollowDressCode(x) → AskToChangeClothes(x))"
},
{
"input": "Translate into first-order logic: Every student must maintain cleanliness in the classroom and around the school premises.",
"output": "∀x (MaintainCleanliness(x))"
},
{
"input": "Translate into first-order logic: If a student does not complete the assigned tasks in class, the student will not be allowed to participate in after-school activities.",
"output": "(¬CompleteTasks(x) → NoAfterSchoolActivities(x))"
},
{
"input": "Translate into first-order logic: If a student violates the mobile phone policy in class, the student's phone will be confiscated.",
"output": "(ViolateMobilePhonePolicy(x) → ConfiscatePhone(x))"
},
{
"input": "Translate into first-order logic: If a student does not follow the attendance policy, the student will lose participation points.",
"output": "(¬FollowAttendancePolicy(x) → LoseParticipationPoints(x))"
},
{
"input": "Translate into first-order logic: If a student violates traffic safety rules, the student will be fined according to the school's regulations.",
"output": "(ViolateTrafficSafety(x) → FineAccordingToRules(x))"
},
{
"input": "Translate into first-order logic: Every student participates in class according to the class schedule.",
"output": "∀x (ParticipateInClass(x))"
},
{
"input": "Translate into first-order logic: If a student completes assignments, then the student will receive points.",
"output": "(CompleteAssignments(x) → ReceivePoints(x))"
},
{
"input": "Translate into first-order logic: If a student does not complete assignments, the student will lose points.",
"output": "(¬CompleteAssignments(x) → LosePoints(x))"
},
{
"input": "Translate into first-order logic: There exists at least one student who participates in extracurricular activities.",
"output": "∃x (ParticipateInExtracurricular(x))"
},
{
"input": "Translate into first-order logic: There exists at least one student who has completed their final project.",
"output": "∃x (CompletedFinalProject(x))"
},
{
"input": "Translate into first-order logic: If a student participates in extracurricular activities, then the student will gain additional points.",
"output": "(ParticipateInExtracurricular(x) → GainPoints(x))"
},
{
"input": "Translate into first-order logic: There exists at least one student who has failed to complete their assignments.",
"output": "∃x (FailedToCompleteAssignments(x))"
},
{
"input": "Translate into first-order logic: If a student violates the school policy on mobile phones, the student will receive a warning.",
"output": "(ViolateMobilePolicy(x) → Warning(x))"
},
{
"input": "Translate into first-order logic: If a student has completed their assignments, then the student is eligible for extra participation points.",
"output": "(CompletedAssignments(x) → EligibleForExtraPoints(x))"
},
{
"input": "Translate into first-order logic: If a student does not follow the attendance policy, then the student will lose participation points.",
"output": "(¬FollowAttendancePolicy(x) → LoseParticipationPoints(x))"
},
{
"input": "Translate into first-order logic: If a student violates the school rules on mobile phones, then the student will be penalized.",
"output": "(ViolateMobilePolicy(x) → Penalized(x))"
},
{
"input": "Translate into first-order logic: Every student must follow the attendance policy.",
"output": "∀x (FollowAttendancePolicy(x))"
},
{
"input": "Translate into first-order logic: Every student must participate in group projects.",
"output": "∀x (ParticipateInGroupProjects(x))"
},
{
"input": "Translate into first-order logic: There exists at least one student who has completed their assignments.",
"output": "∃x (CompletedAssignments(x))"
},
{
"input": "Translate into first-order logic: There exists at least one student who participates in extracurricular activities.",
"output": "∃x (ParticipateInExtracurricular(x))"
},
{
"input": "Translate into first-order logic: If a student follows the study plan, then they will pass the exam.",
"output": "(FollowStudyPlan(x) → PassExam(x))"
},
{
"input": "Translate into first-order logic: Every student follows the attendance policy.",
"output": "∀x (FollowAttendancePolicy(x))"
},
{
"input": "Translate into first-order logic: There exists at least one student who has achieved high marks.",
"output": "∃x (AchievedHighMarks(x))"
},
{
"input": "Translate into first-order logic: If a student does not complete assignments, they will not pass the exam.",
"output": "(¬CompleteAssignments(x) → ¬PassExam(x))"
},
{
"input": "Translate into first-order logic: If a student follows the attendance policy, then they will be eligible for participation points.",
"output": "(FollowAttendancePolicy(x) → EligibleForParticipationPoints(x))"
},
{
"input": "Translate into first-order logic: If a student has completed assignments, then they will be eligible for extra credit.",
"output": "(CompletedAssignments(x) → EligibleForExtraCredit(x))"
},
{
"input": "Translate into first-order logic: If a student follows the attendance policy, then they are eligible for participation points.",
"output": "(FollowAttendancePolicy(x) → EligibleForParticipationPoints(x))"
},
{
"input": "Translate into first-order logic: If a student participates in extracurricular activities, then they will gain extra credit.",
"output": "(ParticipateInExtracurricular(x) → GainExtraCredit(x))"
},
{
"input": "Translate into first-order logic: If a student does not follow the attendance policy, then they will lose participation points.",
"output": "(¬FollowAttendancePolicy(x) → LoseParticipationPoints(x))"
},
{
"input": "Translate into first-order logic: Every student participates in group projects.",
"output": "∀x (ParticipateInGroupProjects(x))"
},
{
"input": "Translate into first-order logic: All students must complete their coursework.",
"output": "∀x (Coursework(x))"
},
{
"input": "Translate into first-order logic: If a student completes their coursework, they will graduate.",
"output": "∀x (Coursework(x) → Graduate(x))"
},
{
"input": "Translate into first-order logic: At least one student is enrolled in an advanced seminar.",
"output": "∃x (Seminar(x))"
},
{
"input": "Translate into first-order logic: If all students must complete their coursework, then at least one student is enrolled in an advanced seminar.",
"output": "∀x (Coursework(x))"
},
{
"input": "Translate into first-order logic: If all students must complete their coursework implies at least one student is enrolled in an advanced seminar, then completing coursework implies graduation.",
"output": "(∀x (Coursework(x)) → ∃x (Seminar(x))) → ∀x (Coursework(x) → Graduate(x))"
},
{
"input": "Translate into first-order logic: If a student is in a thesis program, they will graduate.",
"output": "∀x (Thesis(x) → Graduate(x))"
},
{
"input": "Translate into first-order logic: If a student completes their coursework, they will be eligible to enroll in an advanced seminar.",
"output": "∀x (Coursework(x) → Seminar(x))"
},
{
"input": "Translate into first-order logic: If a person is not trained, then they are not skilled.",
"output": "∀x (¬Trained(x) → ¬Skilled(x))"
},
{
"input": "Translate into first-order logic: There exists at least one person who asks questions.",
"output": "∃x (AsksQuestions(x))"
},
{
"input": "Translate into first-order logic: If there exists someone who asks questions, then there exists someone who is a researcher.",
"output": "∃x (AsksQuestions(x))"
},
{
"input": "Translate into first-order logic: If there exists someone who is a researcher, then there exists someone who asks questions.",
"output": "∃x (Researcher(x))"
},
{
"input": "Translate into first-order logic: If a person is not a student, then they are not skilled.",
"output": "∀x (¬Student(x) → ¬Skilled(x))"
},
{
"input": "Translate into first-order logic: All individuals are researchers.",
"output": "∀x (Researcher(x))"
},
{
"input": "Translate into first-order logic: All students attend lectures.",
"output": "∀x (AttendLecture(x))"
},
{
"input": "Translate into first-order logic: At least one student is part of a research group.",
"output": "∃x (ResearchGroup(x))"
},
{
"input": "Translate into first-order logic: All students complete their assignments.",
"output": "∀x (CompleteAssignments(x))"
},
{
"input": "Translate into first-order logic: If at least one student is part of a research group, then all students attend lectures.",
"output": "∃x (ResearchGroup(x))"
},
{
"input": "Translate into first-order logic: If all students attending lectures implies that all students complete their assignments, then all students complete their assignments.",
"output": "(∀x (AttendLecture(x)) → ∀x (CompleteAssignments(x))) → ∀x (CompleteAssignments(x))"
},
{
"input": "Translate into first-order logic: At least one student participates in extracurricular activities.",
"output": "∃x (Extracurricular(x))"
},
{
"input": "Translate into first-order logic: If a student is part of a research group, then they also complete their assignments.",
"output": "∀x (ResearchGroup(x) → CompleteAssignments(x))"
},
{
"input": "Translate into first-order logic: If a student is enrolled in a specific course, then they have access to university resources.",
"output": "(Enrolled(x) → Resources(x))"
},
{
"input": "Translate into first-order logic: Every student is required to complete a research project.",
"output": "∀x (ResearchProject(x))"
},
{
"input": "Translate into first-order logic: Every student must participate in extracurricular activities.",
"output": "∀x (Extracurricular(x))"
},
{
"input": "Translate into first-order logic: If all students participate in extracurricular activities, then enrolling in a specific course grants access to university resources.",
"output": "(Enrolled(x) → Resources(x))"
},
{
"input": "Translate into first-order logic: If all students must complete a research project, then participation in extracurricular activities ensures that enrolling in a specific course grants access to university resources.",
"output": "(Enrolled(x) → Resources(x))"
},
{
"input": "Translate into first-order logic: If a student is not enrolled in the course, then they cannot receive a particular scholarship.",
"output": "(¬Enrolled(x) → ¬Scholarship(x))"
},
{
"input": "Translate into first-order logic: Every student is required to complete a qualifying exam.",
"output": "∀x (QualifyingExam(x))"
},
{
"input": "Translate into first-order logic: There exists at least one student who is enrolled in a specific course.",
"output": "∃x (Enrolled(x))"
},
{
"input": "Translate into first-order logic: Every student must complete a qualifying exam.",
"output": "∀x (QualifyingExam(x))"
},
{
"input": "Translate into first-order logic: Every student is enrolled in the specific course.",
"output": "∀x (Enrolled(x))"
},
{
"input": "Translate into first-order logic: If every student must complete a qualifying exam, then every student is enrolled in the specific course.",
"output": "(∀x (QualifyingExam(x)) → ∀x (Enrolled(x)))"
},
{
"input": "Translate into first-order logic: If at least one student is enrolled in the course, then all students must be enrolled in the course.",
"output": "(∃x (Enrolled(x)) → ∀x (Enrolled(x)))"
},
{
"input": "Translate into first-order logic: There exists at least one student who has received a scholarship.",
"output": "∃x (Scholarship(x))"
},
{
"input": "Translate into first-order logic: Every student has received a scholarship.",
"output": "∀x (Scholarship(x))"
},
{
"input": "Translate into first-order logic: If a student attends class regularly, then they complete their assignments.",
"output": "∀x (AttendsClass(x) → CompletesAssignments(x))"
},
{
"input": "Translate into first-order logic: If a student is not motivated, then they do not participate in discussions.",
"output": "∀x (¬Motivated(x) → ¬Participates(x))"
},
{
"input": "Translate into first-order logic: All students attend class regularly.",
"output": "∀x (AttendsClass(x))"
},
{
"input": "Translate into first-order logic: If all students attend class regularly, then attending class regularly implies completing assignments.",
"output": "(∀x (AttendsClass(x)) → (AttendsClass(x) → CompletesAssignments(x)))"
},
{
"input": "Translate into first-order logic: If the lack of motivation leads to not participating in discussions, then all students attending class regularly ensures that attending class implies completing assignments.",
"output": "((¬Motivated(x) → ¬Participates(x)) → (∀x (AttendsClass(x)) → (AttendsClass(x) → CompletesAssignments(x))))"
},
{
"input": "Translate into first-order logic: If a student does not participate in discussions, then they are not motivated.",
"output": "∀x (¬Participates(x) → ¬Motivated(x))"
},
{
"input": "Translate into first-order logic: If a student does not study, then they are not motivated.",
"output": "∀x (¬Studies(x) → ¬Motivated(x))"
},
{
"input": "Translate into first-order logic: If a person is a researcher, then they are a professional.",
"output": "R(x) → P(x)"
},
{
"input": "Translate into first-order logic: If a person is a professional, then they are a scholar.",
"output": "P(x) → S(x)"
},
{
"input": "Translate into first-order logic: All individuals are university members.",
"output": "∀x U(x)"
},
{
"input": "Translate into first-order logic: If being a professional implies being a scholar, then all individuals are university members.",
"output": "(P(x) → S(x)) → ∀x U(x)"
},
{
"input": "Translate into first-order logic: If all individuals are university members, then being a researcher implies being a professional.",
"output": "(∀x U(x)) → (R(x) → P(x))"
},
{
"input": "Translate into first-order logic: If a person is a university member, then they are a professional.",
"output": "U(x) → P(x)"
},
{
"input": "Translate into first-order logic: There exists at least one university member.",
"output": "∃x U(x)"
},
{
"input": "Translate into first-order logic: If a student does not complete their homework, they will not pass the course.",
"output": "∀x (¬DoesHomework(x) → ¬Passes(x))"
},
{
"input": "Translate into first-order logic: All students complete their homework.",
"output": "∀x (DoesHomework(x))"
},
{
"input": "Translate into first-order logic: All students attend class regularly.",
"output": "∀x (AttendsClass(x))"
},
{
"input": "Translate into first-order logic: If all students complete their homework, then all students complete their homework (tautology).",
"output": "(∀x (DoesHomework(x)) → ∀x (DoesHomework(x)))"
},
{
"input": "Translate into first-order logic: If not completing homework leads to failing the course, then all students attend class regularly.",
"output": "((¬DoesHomework(x) → ¬Passes(x)) → ∀x (AttendsClass(x)))"
},
{
"input": "Translate into first-order logic: If a student does not join a study group, they will not complete their homework.",
"output": "∀x (¬JoinsStudyGroup(x) → ¬DoesHomework(x))"
},
{
"input": "Translate into first-order logic: There exists at least one student who is reviewing for the exam.",
"output": "∃x (ReviewsForExam(x))"
},
{
"input": "Translate into first-order logic: All students attend class.",
"output": "∀x (AttendsClass(x))"
},
{
"input": "Translate into first-order logic: There exists at least one student who is conducting research.",
"output": "∃x (Researches(x))"
},
{
"input": "Translate into first-order logic: If a student does not do their homework, then they will not attend class.",
"output": "∀x (¬DoesHomework(x) → ¬AttendsClass(x))"
},
{
"input": "Translate into first-order logic: If there exists at least one student conducting research, then there exists at least one student conducting research (tautology).",
"output": "(∃x (Researches(x)) → ∃x (Researches(x)))"
},
{
"input": "Translate into first-order logic: If all students attend class, then at least one student is conducting research.",
"output": "(∀x (AttendsClass(x)) → ∃x (Researches(x)))"
},
{
"input": "Translate into first-order logic: If a student does not conduct research, then they cannot pass the test.",
"output": "∀x (¬Researches(x) → ¬PassesTest(x))"
},
{
"input": "Translate into first-order logic: If a student does their homework, then they will score well.",
"output": "∀x (DoesHomework(x) → ScoresWell(x))"
},
{
"input": "Translate into first-order logic: If a student studies, then they will pass the exam.",
"output": "∀x (Studies(x) → PassesExam(x))"
},
{
"input": "Translate into first-order logic: There exists at least one student who does research.",
"output": "∃x (Researches(x))"
},
{
"input": "Translate into first-order logic: If a student takes a test, then they will pass the exam.",
"output": "∀x (TakesTest(x) → PassesExam(x))"
},
{
"input": "Translate into first-order logic: If taking a test leads to passing the exam, then studying also leads to passing the exam.",
"output": "(∀x (TakesTest(x) → PassesExam(x))) → (∀x (Studies(x) → PassesExam(x)))"
},
{
"input": "Translate into first-order logic: If studying leads to passing the exam, then the previous rule (if taking a test leads to passing the exam, then studying also leads to passing the exam) holds.",
"output": "(∀x (Studies(x) → PassesExam(x))) → ((∀x (TakesTest(x) → PassesExam(x))) → (∀x (Studies(x) → PassesExam(x))))"
},
{
"input": "Translate into first-order logic: All students are enrolled in the university.",
"output": "∀x (EnrolledInUniversity(x))"
},
{
"input": "Translate into first-order logic: All students conduct research.",
"output": "∀x (Researches(x))"
},
{
"input": "Translate into first-order logic: If a student participates in extracurricular activities, then they develop leadership skills.",
"output": "∀x (ParticipatesExtracurricular(x) → LeadershipSkills(x))"
},
{
"input": "Translate into first-order logic: If a student does not receive a scholarship, then they do not participate in extracurricular activities.",
"output": "∀x (¬ReceivesScholarship(x) → ¬ParticipatesExtracurricular(x))"
},
{
"input": "Translate into first-order logic: If a student does not develop leadership skills, then they do not excel academically.",
"output": "∀x (¬LeadershipSkills(x) → ¬ExcelsAcademically(x))"
},
{
"input": "Translate into first-order logic: If participation in extracurricular activities leads to leadership skills, then not receiving a scholarship leads to not participating in extracurricular activities.",
"output": "∀x (ParticipatesExtracurricular(x) → LeadershipSkills(x))"
},
{
"input": "Translate into first-order logic: If not developing leadership skills leads to not excelling academically, then participation in extracurricular activities leading to leadership skills must also mean that not receiving a scholarship leads to not participating in extracurricular activities.",
"output": "∀x (¬LeadershipSkills(x) → ¬ExcelsAcademically(x))"
},
{
"input": "Translate into first-order logic: If a student does not receive a scholarship, then they do not take advanced courses.",
"output": "∀x (¬ReceivesScholarship(x) → ¬TakesAdvancedCourses(x))"
},
{
"input": "Translate into first-order logic: If a student does not develop leadership skills, then they do not take advanced courses.",
"output": "∀x (¬LeadershipSkills(x) → ¬TakesAdvancedCourses(x))"
},
{
"input": "Translate into first-order logic: If a student studies, then they will understand the material.",
"output": "∀x (Study(x) → Understand(x))"
},
{
"input": "Translate into first-order logic: If a student does not take the test, then they will not pass.",
"output": "∀x (¬TakeTest(x) → ¬Pass(x))"
},
{
"input": "Translate into first-order logic: There exists at least one student who takes the test.",
"output": "∃x (TakeTest(x))"
},
{
"input": "Translate into first-order logic: If not taking the test leads to not passing, then studying leads to understanding.",
"output": "∀x (¬TakeTest(x) → ¬Pass(x))"
},
{
"input": "Translate into first-order logic: If not taking the test leads to not passing, then at least one student takes the test.",
"output": "∀x (¬TakeTest(x) → ¬Pass(x))"
},
{
"input": "Translate into first-order logic: If a student does not review, then they will not study.",
"output": "∀x (¬Review(x) → ¬Study(x))"
},
{
"input": "Translate into first-order logic: Every student must review.",
"output": "∀x (Review(x))"
},
{
"input": "Translate into first-order logic: If a student does not pass the exam, then they will not qualify for the scholarship.",
"output": "∀x (¬PassExam(x) → ¬QualifyScholarship(x))"
},
{
"input": "Translate into first-order logic: If a student attends tutoring sessions, then they will pass the exam.",
"output": "∀x (AttendTutoring(x) → PassExam(x))"
},
{
"input": "Translate into first-order logic: If a student passes the exam, then they will graduate.",
"output": "∀x (PassExam(x) → Graduate(x))"
},
{
"input": "Translate into first-order logic: If passing the exam leads to graduation, then attending tutoring sessions leads to passing the exam.",
"output": "∀x (PassExam(x) → Graduate(x))"
},
{
"input": "Translate into first-order logic: If passing the exam leads to graduation, then not passing the exam leads to not qualifying for the scholarship.",
"output": "∀x (PassExam(x) → Graduate(x))"
},
{
"input": "Translate into first-order logic: Every student must submit a final project.",
"output": "∀x (SubmitFinalProject(x))"
},
{
"input": "Translate into first-order logic: If a student does not graduate, then they did not attend tutoring sessions.",
"output": "∀x (¬Graduate(x) → ¬AttendTutoring(x))"
},
{
"input": "Translate into first-order logic: If a student studies, then they will understand the material.",
"output": "∀x (Study(x) → Understand(x))"
},
{
"input": "Translate into first-order logic: There exists at least one student who participates in extracurricular activities.",
"output": "∃x (ParticipateExtracurricular(x))"
},
{
"input": "Translate into first-order logic: All students must complete their assignments.",
"output": "∀x (CompleteAssignments(x))"
},
{
"input": "Translate into first-order logic: If studying leads to understanding, then all students must complete their assignments.",
"output": "∀x (Study(x) → Understand(x))"
},
{
"input": "Translate into first-order logic: If the previous statement holds, then at least one student will join a study group.",
"output": "(∀x (Study(x) → Understand(x)) → ∀x (CompleteAssignments(x))) → ∃x (JoinStudyGroup(x))"
},
{
"input": "Translate into first-order logic: There exists at least one student who is preparing for an exam.",
"output": "∃x (PreparingForExam(x))"
},
{
"input": "Translate into first-order logic: There exists at least one student who understands the material.",
"output": "∃x (Understand(x))"
},
{
"input": "Translate into first-order logic: If a student is not studying, then they are not ready.",
"output": "∀x (¬Study(x) → ¬Ready(x))"
},
{
"input": "Translate into first-order logic: Every student is studying.",
"output": "∀x (Study(x))"
},
{
"input": "Translate into first-order logic: If at least one student is studying, then if a student is not studying, they are not ready.",
"output": "∃x (Study(x))"
},
{
"input": "Translate into first-order logic: If at least one student is studying, then the previous statement is true.",
"output": "∃x (Study(x))"
},
{
"input": "Translate into first-order logic: If a student is ready, then they are studying.",
"output": "∀x (Ready(x) → Study(x))"
},
{
"input": "Translate into first-order logic: There exists at least one student who is questioning.",
"output": "∃x (Questioning(x))"
},
{
"input": "Translate into first-order logic: There exists at least one student who has completed a research project.",
"output": "∃x (CompletedResearch(x))"
},
{
"input": "Translate into first-order logic: There exists at least one student who has taken a qualifying exam.",
"output": "∃x (TookExam(x))"
},
{
"input": "Translate into first-order logic: If a student has completed a research project, then they have submitted a thesis.",
"output": "∀x (CompletedResearch(x) → SubmittedThesis(x))"
},
{
"input": "Translate into first-order logic: If at least one student has taken a qualifying exam, then at least one student has completed a research project.",
"output": "∃x (TookExam(x))"
},
{
"input": "Translate into first-order logic: If completing a research project ensures submitting a thesis, then the existence of a student taking a qualifying exam guarantees that at least one student has completed a research project.",
"output": "∀x (CompletedResearch(x) → SubmittedThesis(x))"
},
{
"input": "Translate into first-order logic: If a student has not completed a research project, then they have not taken a qualifying exam.",
"output": "∀x (¬CompletedResearch(x) → ¬TookExam(x))"
},
{
"input": "Translate into first-order logic: Every student is required to participate in extracurricular activities.",
"output": "∀x (ParticipatesInActivities(x))"
},
{
"input": "Translate into first-order logic: Every student is enrolled in a specific course.",
"output": "∀x (EnrolledInCourse(x))"
},
{
"input": "Translate into first-order logic: Every student has completed the qualifying exam.",
"output": "∀x (CompletedExam(x))"
},
{
"input": "Translate into first-order logic: Every student participates in extracurricular activities.",
"output": "∀x (ParticipatesInActivities(x))"
},
{
"input": "Translate into first-order logic: If every student is enrolled in a specific course, then every student participates in extracurricular activities.",
"output": "∀x (EnrolledInCourse(x))"
},
{
"input": "Translate into first-order logic: If every student is enrolled in a specific course and participates in extracurricular activities, then every student participates in extracurricular activities.",
"output": "(∀x (EnrolledInCourse(x)) → ∀x (ParticipatesInActivities(x))) → ∀x (ParticipatesInActivities(x))"
},
{
"input": "Translate into first-order logic: At least one student has received a scholarship.",
"output": "∃x (ReceivedScholarship(x))"
},
{
"input": "Translate into first-order logic: If a student has completed the qualifying exam, then they have received a scholarship.",
"output": "∀x (CompletedExam(x) → ReceivedScholarship(x))"
},
{
"input": "Translate into first-order logic: Every student has completed the qualifying exam.",
"output": "∀x (CompletedExam(x))"
},
{
"input": "Translate into first-order logic: Every student is enrolled in a specific course.",
"output": "∀x (EnrolledInCourse(x))"
},
{
"input": "Translate into first-order logic: If at least one student is enrolled in a specific course, then every student is enrolled in a specific course.",
"output": "∃x (EnrolledInCourse(x))"
},
{
"input": "Translate into first-order logic: If at least one student is enrolled in a specific course, then every student has completed the qualifying exam.",
"output": "(∃x (EnrolledInCourse(x)) → ∀x (EnrolledInCourse(x))) → ∀x (CompletedExam(x))"
},
{
"input": "Translate into first-order logic: If a student has completed the qualifying exam, then they are eligible for a scholarship.",
"output": "∀x (CompletedExam(x) → EligibleForScholarship(x))"
},
{
"input": "Translate into first-order logic: At least one student has participated in extracurricular activities.",
"output": "∃x (ParticipatesInActivities(x))"
},
{
"input": "Translate into first-order logic: If a student has not passed the qualifying exam, then they are not eligible for the scholarship.",
"output": "∀x (¬PassedExam(x) → ¬EligibleForScholarship(x))"
},
{
"input": "Translate into first-order logic: At least one student is eligible for the scholarship.",
"output": "∃x (EligibleForScholarship(x))"
},
{
"input": "Translate into first-order logic: If a student is eligible for the scholarship, then they must have passed the qualifying exam.",
"output": "∃x (EligibleForScholarship(x))"
},
{
"input": "Translate into first-order logic: If a student is eligible for the scholarship, then they must have participated in extracurricular activities.",
"output": "∃x (EligibleForScholarship(x))"
},
{
"input": "Translate into first-order logic: Every student has participated in extracurricular activities.",
"output": "∀x (ParticipatesInActivities(x))"
},
{
"input": "Translate into first-order logic: If a student has participated in extracurricular activities, they are eligible for the scholarship.",
"output": "∀x (ParticipatesInActivities(x) → EligibleForScholarship(x))"
},
{
"input": "Translate into first-order logic: If someone completes the safety training, then they are allowed to operate heavy machinery.",
"output": "∀x (CompletedTraining(x) → AllowedMachinery(x))"
},
{
"input": "Translate into first-order logic: If someone is allowed to operate heavy machinery, then they must have signed the safety compliance form.",
"output": "∀x (AllowedMachinery(x) → SignedCompliance(x))"
},
{
"input": "Translate into first-order logic: All employees receive regular safety reminders.",
"output": "∀x (ReceivesReminders(x))"
},
{
"input": "Translate into first-order logic: If someone takes the advanced training course, then they receive safety reminders.",
"output": "∀x (TookAdvancedTraining(x) → ReceivesReminders(x))"
},
{
"input": "Translate into first-order logic: If someone has a supervisor's recommendation, then they have completed the safety training.",
"output": "∀x (HasSupervisorRecommendation(x) → CompletedTraining(x))"
},
{
"input": "Translate into first-order logic: If someone is allowed to operate heavy machinery, then they have taken the advanced training course.",
"output": "∀x (AllowedMachinery(x) → TookAdvancedTraining(x))"
},
{
"input": "Translate into first-order logic: If someone has signed the safety compliance form, then they have taken the advanced training course.",
"output": "∀x (SignedCompliance(x) → TookAdvancedTraining(x))"
},
{
"input": "Translate into first-order logic: All employees have completed the safety training.",
"output": "∀x (CompletedTraining(x))"
},
{
"input": "Translate into first-order logic: If someone has signed the safety compliance form, then they received a supervisor’s recommendation.",
"output": "∀x (SignedCompliance(x) → HasSupervisorRecommendation(x))"
},
{
"input": "Translate into first-order logic: If someone does not receive safety reminders, then they did not receive a supervisor’s recommendation.",
"output": "∀x (¬ReceivesReminders(x) → ¬HasSupervisorRecommendation(x))"
},
{
"input": "Translate into first-order logic: If someone receives safety reminders, then they have completed the safety training.",
"output": "∀x (ReceivesReminders(x) → CompletedTraining(x))"
},
{
"input": "Translate into first-order logic: If being allowed to operate heavy machinery implies taking the advanced training course, then all employees receive regular safety reminders.",
"output": "∀x (AllowedMachinery(x) → TookAdvancedTraining(x))"
},
{
"input": "Translate into first-order logic: If there exists someone with a supervisor’s recommendation, then there exists someone who receives safety reminders.",
"output": "∃x (HasSupervisorRecommendation(x))"
},
{
"input": "Translate into first-order logic: If someone has signed the safety compliance form, then if someone has a supervisor’s recommendation, someone receives safety reminders.",
"output": "∀x (SignedCompliance(x) → (∀x (HasSupervisorRecommendation(x) → ∃x (ReceivesReminders(x)))))"
},
{
"input": "Translate into first-order logic: If taking the advanced training means receiving safety reminders, then not receiving reminders means not having a supervisor’s recommendation.",
"output": "∀x (TookAdvancedTraining(x) → ReceivesReminders(x))"
},
{
"input": "Translate into first-order logic: If being allowed to operate machinery means signing the safety compliance, then if being allowed to operate machinery means taking the advanced training course, then all employees receive safety reminders.",
"output": "∀x (AllowedMachinery(x) → SignedCompliance(x))"
},
{
"input": "Translate into first-order logic: If someone has signed the safety compliance form, then they have completed the safety training.",
"output": "∀x (SignedCompliance(x) → CompletedTraining(x))"
},
{
"input": "Translate into first-order logic: If someone has not signed the safety compliance form, then they do not have a supervisor’s recommendation.",
"output": "∀x (¬SignedCompliance(x) → ¬HasSupervisorRecommendation(x))"
},
{
"input": "Translate into first-order logic: All employees are allowed to operate heavy machinery.",
"output": "∀x (AllowedMachinery(x))"
},
{
"input": "Translate into first-order logic: If someone does not have a supervisor’s recommendation, then they are not allowed to operate heavy machinery.",
"output": "∀x (¬HasSupervisorRecommendation(x) → ¬AllowedMachinery(x))"
},
{
"input": "Translate into first-order logic: If someone has not completed the safety training, then they have not taken the advanced training course.",
"output": "∀x (¬CompletedTraining(x) → ¬TookAdvancedTraining(x))"
},
{
"input": "Translate into first-order logic: There exists at least one AI model that can make predictions.",
"output": "∃x (Predicts(x))"
},
{
"input": "Translate into first-order logic: All AI models require training data.",
"output": "∀x (RequiresTrainingData(x))"
},
{
"input": "Translate into first-order logic: If an AI system does not use deep learning, then it cannot make predictions.",
"output": "(¬UsesDeepLearning(x) → ¬Predicts(x))"
},
{
"input": "Translate into first-order logic: All AI models utilize deep learning.",
"output": "∀x (UsesDeepLearning(x))"
},
{
"input": "Translate into first-order logic: There exists at least one AI model that performs classification.",
"output": "∃x (PerformsClassification(x))"
},
{
"input": "Translate into first-order logic: If an AI model is trained, then it can achieve high accuracy.",
"output": "(Trained(x) → HighAccuracy(x))"
},
{
"input": "Translate into first-order logic: If an AI model does not perform classification, then it does not utilize deep learning.",
"output": "(¬PerformsClassification(x) → ¬UsesDeepLearning(x))"
},
{
"input": "Translate into first-order logic: If an AI model cannot make predictions, then it does not perform classification.",
"output": "(¬Predicts(x) → ¬PerformsClassification(x))"
},
{
"input": "Translate into first-order logic: If an AI model does not use deep learning, then it does not have sufficient data.",
"output": "(¬UsesDeepLearning(x) → ¬HasSufficientData(x))"
},
{
"input": "Translate into first-order logic: If the inability to use deep learning implies a lack of sufficient data, then all AI models require training data.",
"output": "((¬UsesDeepLearning(x) → ¬HasSufficientData(x)) → ∀x (RequiresTrainingData(x)))"
},
{
"input": "Translate into first-order logic: If an AI model uses deep learning, then it has sufficient data.",
"output": "(UsesDeepLearning(x) → HasSufficientData(x))"
},
{
"input": "Translate into first-order logic: All AI models perform classification.",
"output": "∀x (PerformsClassification(x))"
},
{
"input": "Translate into first-order logic: If an AI model can make predictions, then it has sufficient data.",
"output": "(Predicts(x) → HasSufficientData(x))"
},
{
"input": "Translate into first-order logic: If an AI model cannot make predictions, then it does not require training data.",
"output": "(¬Predicts(x) → ¬RequiresTrainingData(x))"
},
{
"input": "Translate into first-order logic: If an AI model performs classification, then it requires training data.",
"output": "(PerformsClassification(x) → RequiresTrainingData(x))"
},
{
"input": "Translate into first-order logic: All fundamental concepts in C++ are important for problem-solving.",
"output": "∀x (FundamentalConcepts(x) → ImportantForProblemSolving(x))"
},
{
"input": "Translate into first-order logic: If a programmer understands variables, then they can understand data types.",
"output": "(UnderstandsVariables(x) → UnderstandsDataTypes(x))"
},
{
"input": "Translate into first-order logic: If a programmer understands functions, then they understand modular programming.",
"output": "(UnderstandsFunctions(x) → UnderstandsModularProgramming(x))"
},
{
"input": "Translate into first-order logic: If a programmer understands loops, then they can apply them to problem-solving.",
"output": "(UnderstandsLoops(x) → CanApplyToProblemSolving(x))"
},
{
"input": "Translate into first-order logic: All programmers who practice coding improve their C++ skills.",
"output": "∀x (PracticesCoding(x) → ImprovesCppSkills(x))"
},
{
"input": "Translate into first-order logic: If a programmer does not understand pointers, then they will struggle with dynamic memory allocation.",
"output": "(¬UnderstandsPointers(x) → StrugglesWithMemoryAllocation(x))"
},
{
"input": "Translate into first-order logic: If a programmer does not understand loops, then they will not understand recursion.",
"output": "(¬UnderstandsLoops(x) → ¬UnderstandsRecursion(x))"
},
{
"input": "Translate into first-order logic: If a programmer does not understand C++, then they will struggle with object-oriented programming.",
"output": "(¬UnderstandsCpp(x) → StrugglesWithOOP(x))"
},
{
"input": "Translate into first-order logic: If a programmer understands loops, then they will understand C++.",
"output": "(UnderstandsLoops(x) → UnderstandsCpp(x))"
},
{
"input": "Translate into first-order logic: If all programmers who study regularly improve their debugging skills, then if a programmer does not understand loops, they will not understand recursion.",
"output": "(∀x (StudiesRegularly(x) → ImprovesDebuggingSkills(x)) → (¬UnderstandsLoops(x) → ¬UnderstandsRecursion(x)))"
},
{
"input": "Translate into first-order logic: If all fundamental concepts in C++ are important for problem-solving, then if a programmer understands variables, they can understand data types.",
"output": "(∀x (FundamentalConcepts(x) → ImportantForProblemSolving(x)) → (UnderstandsVariables(x) → UnderstandsDataTypes(x)))"
},
{
"input": "Translate into first-order logic: All programmers should practice coding.",
"output": "∀x (ShouldPracticeCoding(x))"
},
{
"input": "Translate into first-order logic: There exists at least one programmer who understands loops.",
"output": "∃x (UnderstandsLoops(x))"
},
{
"input": "Translate into first-order logic: If a programmer understands C++, then they understand object-oriented programming.",
"output": "(UnderstandsCpp(x) → UnderstandsOOP(x))"
},
{
"input": "Translate into first-order logic: There exists at least one programmer who understands C++.",
"output": "∃x (UnderstandsCpp(x))"
},
{
"input": "Translate into first-order logic: If a student does not submit the exam, then they fail.",
"output": "∀x (¬Submitted(x) → Fail(x))"
},
{
"input": "Translate into first-order logic: All students who study regularly pass the exam.",
"output": "∀x (StudyRegularly(x) → Pass(x))"
},
{
"input": "Translate into first-order logic: There exists at least one student who passed the exam.",
"output": "∃x (Pass(x))"
},
{
"input": "Translate into first-order logic: If a student passes the exam, then they meet the course requirements.",
"output": "∀x (Pass(x) → MeetCourseReq(x))"
},
{
"input": "Translate into first-order logic: If a student fails the exam, then they must retake the course.",
"output": "∀x (Fail(x) → RetakeCourse(x))"
},
{
"input": "Translate into first-order logic: If a student scores exactly 100%, then they receive a distinction.",
"output": "∀x (Score(x, score) ∧ score = 100 → Distinction(x))"
},
{
"input": "Translate into first-order logic: If a student does not study, then they do not pass.",
"output": "∀x (¬Study(x) → ¬Pass(x))"
},
{
"input": "Translate into first-order logic: There exists at least one student who scored above 90%.",
"output": "∃x (Score(x, score) ∧ score > 90)"
},
{
"input": "Translate into first-order logic: If a student scores above 90%, then they receive a certificate of excellence.",
"output": "∀x (Score(x, score) ∧ score > 90 → CertificateExcellence(x))"
},
{
"input": "Translate into first-order logic: If passing implies meeting course requirements, then all passing students meet the course requirements.",
"output": "((∀x (Pass(x) → MeetCourseReq(x))) → ∀x (Pass(x)))"
},
{
"input": "Translate into first-order logic: If scoring above 90% implies receiving a certificate, then students who do not receive a certificate did not score above 90%.",
"output": "((∀x (Score(x, score) ∧ score > 90 → CertificateExcellence(x))) → (∀x (¬CertificateExcellence(x) → Score(x, score) ∧ score <= 90)))"
},
{
"input": "Translate into first-order logic: If a student does not submit the exam, then they do not pass.",
"output": "∀x (¬Submitted(x) → ¬Pass(x))"
},
{
"input": "Translate into first-order logic: If a student receives a distinction, then they have a high academic standing.",
"output": "∀x (Distinction(x) → HighAcademicStanding(x))"
},
{
"input": "Translate into first-order logic: All students who receive a certificate of excellence are honored.",
"output": "∀x (CertificateExcellence(x) → Honored(x))"
},
{
"input": "Translate into first-order logic: There exists at least one student who studied but did not pass.",
"output": "∃x (StudyButFail(x))"
},
{
"input": "Translate into first-order logic: There exists at least one student who failed but improved later.",
"output": "∃x (FailThenImprove(x))"
},
{
"input": "Translate into first-order logic: If a student does not pass, then they do not meet the course requirements.",
"output": "∀x (¬Pass(x) → ¬MeetCourseReq(x))"
},
{
"input": "Translate into first-order logic: If a student completes all required courses, then they are eligible for graduation.",
"output": "∀x (CompletedCourses(x) → EligibleForGraduation(x))"
},
{
"input": "Translate into first-order logic: If a student has a GPA below 2.0, then they are not eligible for graduation.",
"output": "∀x (GPA(x) < 2.0 → ¬EligibleForGraduation(x))"
},
{
"input": "Translate into first-order logic: All students must complete a final project.",
"output": "∀x (MustCompleteFinalProject(x))"
},
{
"input": "Translate into first-order logic: If a student is eligible for graduation, then they receive a diploma.",
"output": "∀x (EligibleForGraduation(x) → ReceivesDiploma(x))"
},
{
"input": "Translate into first-order logic: If a student completes an internship, then they have completed all required courses.",
"output": "∀x (InternshipCompleted(x) → CompletedCourses(x))"
},
{
"input": "Translate into first-order logic: There exists at least one student who graduates with honors.",
"output": "∃x (GraduatesWithHonors(x))"
},
{
"input": "Translate into first-order logic: If a student has a GPA of at least 3.5, then they graduate with honors.",
"output": "∀x (GPA(x, gpa) ∧ gpa >= 3.5 → GraduatesWithHonors(x))"
},
{
"input": "Translate into first-order logic: There exists at least one student who has completed an internship.",
"output": "∃x (InternshipCompleted(x))"
},
{
"input": "Translate into first-order logic: If a student has completed all required courses, then they meet the academic requirements.",
"output": "∀x (CompletedCourses(x) → MeetsAcademicRequirements(x))"
},
{
"input": "Translate into first-order logic: If all students with a GPA of at least 3.5 graduate with honors, then all students eligible for honors have a good GPA.",
"output": "((∀x (GPA(x, gpa) ∧ gpa >= 3.5 → GraduatesWithHonors(x))) → ∀x (EligibleForHonors(x) → GoodGPA(x)))"
},
{
"input": "Translate into first-order logic: If all students who complete an internship fulfill the graduation requirements, then those who have not completed an internship are not eligible for graduation.",
"output": "((∀x (InternshipCompleted(x) → MeetsGraduationRequirements(x))) → ∀x (¬InternshipCompleted(x) → ¬EligibleForGraduation(x)))"
},
{
"input": "Translate into first-order logic: If a student completes a final project, then they meet the academic requirements.",
"output": "∀x (FinalProjectCompleted(x) → MeetsAcademicRequirements(x))"
},
{
"input": "Translate into first-order logic: If a student meets the academic requirements, then they receive a diploma.",
"output": "∀x (MeetsAcademicRequirements(x) → ReceivesDiploma(x))"
},
{
"input": "Translate into first-order logic: All students must meet the academic requirements.",
"output": "∀x (MustMeetAcademicRequirements(x))"
},
{
"input": "Translate into first-order logic: All students who receive a diploma must have completed all graduation requirements.",
"output": "∀x (ReceivesDiploma(x) → CompletedGraduationRequirements(x))"
},
{
"input": "Translate into first-order logic: There exists at least one student who graduates with a distinction.",
"output": "∃x (GraduatesWithDistinction(x))"
},
{
"input": "Translate into first-order logic: There exists at least one student who is eligible for graduation.",
"output": "∃x (EligibleForGraduation(x))"
},
{
"input": "Translate into first-order logic: If a student does not complete a final project, then they do not meet the academic requirements.",
"output": "∀x (¬FinalProjectCompleted(x) → ¬MeetsAcademicRequirements(x))"
},
{
"input": "Translate into first-order logic: If a Python code is not well-tested, then it is not optimized.",
"output": "∀x (¬WellTested(x) → ¬Optimized(x))"
},
{
"input": "Translate into first-order logic: All Python projects are easy to maintain.",
"output": "∀x (EasyToMaintain(x))"
},
{
"input": "Translate into first-order logic: All Python code follows PEP 8 standards.",
"output": "∀x (FollowsPEP8(x))"
},
{
"input": "Translate into first-order logic: If a Python project is easy to maintain, then it is well-tested.",
"output": "∀x (EasyToMaintain(x) → WellTested(x))"
},
{
"input": "Translate into first-order logic: There exists at least one Python project that is well-tested.",
"output": "∃x (WellTested(x))"
},
{
"input": "Translate into first-order logic: All Python code is well-tested.",
"output": "∀x (WellTested(x))"
},
{
"input": "Translate into first-order logic: If a Python code does not follow PEP 8 standards, then it is not well-tested.",
"output": "∀x (¬FollowsPEP8(x) → ¬WellTested(x))"
},
{
"input": "Translate into first-order logic: If a Python project is not optimized, then it is not well-tested.",
"output": "∀x (¬Optimized(x) → ¬WellTested(x))"
},
{
"input": "Translate into first-order logic: If a Python code is easy to maintain, then it follows PEP 8 standards.",
"output": "∀x (EasyToMaintain(x) → FollowsPEP8(x))"
},
{
"input": "Translate into first-order logic: If a Python code is well-tested, then it follows PEP 8 standards.",
"output": "∀x (WellTested(x) → FollowsPEP8(x))"
},
{
"input": "Translate into first-order logic: If a Python project is easy to maintain, then it is well-tested.",
"output": "∀x (EasyToMaintain(x) → WellTested(x))"
},
{
"input": "Translate into first-order logic: All Python projects have clean and readable code.",
"output": "∀x (CleanReadableCode(x))"
},
{
"input": "Translate into first-order logic: If a Python project is well-tested, then it is optimized.",
"output": "∀x (WellTested(x) → Optimized(x))"
},
{
"input": "Translate into first-order logic: If a chemical reaction is not balanced, then it is not stoichiometrically correct.",
"output": "∀x (¬Balanced(x) → ¬StoichiometricallyCorrect(x))"
},
{
"input": "Translate into first-order logic: All chemical equations must follow the law of conservation of mass.",
"output": "∀x (ChemicalEquation(x) → FollowsConservationOfMass(x))"
},
{
"input": "Translate into first-order logic: All chemical reactions involve energy changes.",
"output": "∀x (ChemicalReaction(x) → InvolvesEnergyChange(x))"
},
{
"input": "Translate into first-order logic: If a reaction is balanced, then it is stoichiometrically correct.",
"output": "∀x (Balanced(x) → StoichiometricallyCorrect(x))"
},
{
"input": "Translate into first-order logic: There exists at least one reaction that is exothermic.",
"output": "∃x (Exothermic(x))"
},
{
"input": "Translate into first-order logic: All chemical reactions are exothermic or endothermic.",
"output": "∀x ((Exothermic(x) ∨ Endothermic(x)))"
},
{
"input": "Translate into first-order logic: If a reaction involves energy changes, then it is either exothermic or endothermic.",
"output": "∀x (InvolvesEnergyChange(x) → (Exothermic(x) ∨ Endothermic(x)))"
},
{
"input": "Translate into first-order logic: If a reaction is exothermic, then it releases heat.",
"output": "∀x (Exothermic(x) → ReleasesHeat(x))"
},
{
"input": "Translate into first-order logic: If a reaction is balanced, then it follows the law of conservation of mass.",
"output": "∀x (Balanced(x) → FollowsConservationOfMass(x))"
},
{
"input": "Translate into first-order logic: If a reaction involves energy changes, then it is balanced.",
"output": "∀x (InvolvesEnergyChange(x) → Balanced(x))"
},
{
"input": "Translate into first-order logic: All chemical reactions follow the law of conservation of mass.",
"output": "∀x (FollowsConservationOfMass(x))"
},
{
"input": "Translate into first-order logic: If a reaction is stoichiometrically correct, then it is balanced.",
"output": "∀x (StoichiometricallyCorrect(x) → Balanced(x))"
},
{
"input": "Translate into first-order logic: If a person reads a book, then they gain knowledge.",
"output": "(ReadsBook(x) → GainsKnowledge(x))"
},
{
"input": "Translate into first-order logic: All people who read books gain knowledge.",
"output": "∀x (ReadsBook(x) → GainsKnowledge(x))"
},
{
"input": "Translate into first-order logic: If a person does not understand the content, they do not gain knowledge.",
"output": "(¬UnderstandsContent(x) → ¬GainsKnowledge(x))"
},
{
"input": "Translate into first-order logic: If a person reads a book, they gain wisdom.",
"output": "(ReadsBook(x) → GainsWisdom(x))"
},
{
"input": "Translate into first-order logic: All people who read books gain wisdom.",
"output": "∀x (ReadsBook(x) → GainsWisdom(x))"
},
{
"input": "Translate into first-order logic: If a person gains wisdom, they gain knowledge.",
"output": "(GainsWisdom(x) → GainsKnowledge(x))"
},
{
"input": "Translate into first-order logic: If a person does not gain knowledge, they have not understood the content.",
"output": "(¬GainsKnowledge(x) → ¬UnderstandsContent(x))"
},
{
"input": "Translate into first-order logic: If a person reads a book and gains wisdom, they gain knowledge.",
"output": "(ReadsBook(x) ∧ GainsWisdom(x) → GainsKnowledge(x))"
},
{
"input": "Translate into first-order logic: Everyone who reads books gains knowledge.",
"output": "∀x (ReadsBook(x) → GainsKnowledge(x))"
},
{
"input": "Translate into first-order logic: If a person has gained knowledge and wisdom, they have mastered the content.",
"output": "(GainsKnowledge(x) ∧ GainsWisdom(x) → MasteredContent(x))"
},
{
"input": "Translate into first-order logic: Everyone who has gained knowledge has read a book.",
"output": "∀x (GainsKnowledge(x) → ReadsBook(x))"
},
{
"input": "Translate into first-order logic: All machine learning models require data preprocessing.",
"output": "∀x (Model(x) → ∃y (Dataset(y) ∧ TrainedOn(y, x) ∧ PreprocessingRequired(y)))"
},
{
"input": "Translate into first-order logic: If a dataset has missing values, then the model's performance decreases.",
"output": "∀x (Dataset(x) ∧ MissingValues(x) → ∃y (Model(y) ∧ TrainedOn(x, y) ∧ DecreasedPerformance(y)))"
},
{
"input": "Translate into first-order logic: If a dataset is not normalized, then it affects model accuracy.",
"output": "∀x (Dataset(x) ∧ ¬Normalized(x) → ∃y (Model(y) ∧ TrainedOn(x, y) ∧ AffectsAccuracy(y)))"
},
{
"input": "Translate into first-order logic: If a model performs well, then its dataset is properly preprocessed.",
"output": "∀x (Model(x) ∧ GoodPerformance(x) → ∃y (Dataset(y) ∧ TrainedOn(y, x) ∧ ProperlyPreprocessed(y)))"
},
{
"input": "Translate into first-order logic: If a dataset is not normalized, then it has missing values.",
"output": "∀x (Dataset(x) ∧ ¬Normalized(x) → MissingValues(x))"
},
{
"input": "Translate into first-order logic: There exists at least one singular matrix.",
"output": "∃x (Matrix(x) ∧ SingularMatrix(x))"
},
{
"input": "Translate into first-order logic: If a matrix has a nonzero determinant, then it is invertible.",
"output": "∀x (Matrix(x) ∧ NonzeroDet(x) → Invertible(x))"
},
{
"input": "Translate into first-order logic: If a matrix is symmetric, then it is orthogonally diagonalizable.",
"output": "∀x (Matrix(x) ∧ Symmetric(x) → OrthogonallyDiagonalizable(x))"
},
{
"input": "Translate into first-order logic: If a matrix is orthogonally diagonalizable, then it is symmetric.",
"output": "∀x (Matrix(x) ∧ OrthogonallyDiagonalizable(x) → Symmetric(x))"
},
{
"input": "Translate into first-order logic: All diagonal matrices are invertible.",
"output": "∀x (Matrix(x) ∧ DiagonalMatrix(x) → Invertible(x))"
},
{
"input": "Translate into first-order logic: All students eventually learn C++.",
"output": "∀x (Student(x) → LearnsCPP(x))"
},
{
"input": "Translate into first-order logic: If a student learns C++, then they will understand object-oriented programming.",
"output": "∀x (Student(x) ∧ LearnsCPP(x) → UnderstandsOOP(x))"
},
{
"input": "Translate into first-order logic: All students eventually understand memory management.",
"output": "∀x (Student(x) → UnderstandsMemoryManagement(x))"
},
{
"input": "Translate into first-order logic: If a student does not understand pointers, then they will not understand memory management.",
"output": "∀x (Student(x) ∧ ¬UnderstandsPointers(x) → ¬UnderstandsMemoryManagement(x))"
},
{
"input": "Translate into first-order logic: If a student does not understand pointers, then they will not understand C++.",
"output": "∀x (Student(x) ∧ ¬UnderstandsPointers(x) → ¬UnderstandsCPP(x))"
},
{
"input": "Translate into first-order logic: If a student does not understand pointers, then they will not understand data structures.",
"output": "∀x (Student(x) ∧ ¬UnderstandsPointers(x) → ¬UnderstandsDataStructures(x))"
},
{
"input": "Translate into first-order logic: If a student understands concepts, then they practice regularly.",
"output": "∀x (Student(x) ∧ UnderstandsConcepts(x) → PracticesRegularly(x))"
},
{
"input": "Translate into first-order logic: If a student practices regularly, then they improve their skills.",
"output": "∀x (Student(x) ∧ PracticesRegularly(x) → ImprovesSkills(x))"
},
{
"input": "Translate into first-order logic: All students take notes.",
"output": "∀x (Student(x) → TakesNotes(x))"
},
{
"input": "Translate into first-order logic: If a student takes notes, then they study theory.",
"output": "∀x (Student(x) ∧ TakesNotes(x) → StudiesTheory(x))"
},
{
"input": "Translate into first-order logic: If a student submits an assignment, then they receive a score.",
"output": "∀x (Student(x) ∧ SubmitsAssignment(x) → ReceivesScore(x))"
},
{
"input": "Translate into first-order logic: All students submit work.",
"output": "∀x (Student(x) → SubmitsWork(x))"
},
{
"input": "Translate into first-order logic: If a student submits work, then they follow the guidelines.",
"output": "∀x (Student(x) ∧ SubmitsWork(x) → FollowsGuidelines(x))"
},
{
"input": "Translate into first-order logic: If a student follows the guidelines, then they complete all requirements.",
"output": "∀x (Student(x) ∧ FollowsGuidelines(x) → CompletesRequirements(x))"
},
{
"input": "Translate into first-order logic: If a model is trained on a dataset, then it learns representations.",
"output": "∀x (Model(x) ∧ Trained(x) → LearnsRepresentations(x))"
},
{
"input": "Translate into first-order logic: If a model learns representations, then it can extract features.",
"output": "∀x (Model(x) ∧ LearnsRepresentations(x) → ExtractsFeatures(x))"
},
{
"input": "Translate into first-order logic: If a model extracts features, then it has been trained.",
"output": "∀x (Model(x) ∧ ExtractsFeatures(x) → Trained(x))"
},
{
"input": "Translate into first-order logic: There exists a neural network that has been trained.",
"output": "∃x (Model(x) ∧ NeuralNetwork(x) ∧ Trained(x))"
},
{
"input": "Translate into first-order logic: If a student studies regularly, then they understand key concepts.",
"output": "∀x (Student(x) ∧ StudyRegularly(x) → UnderstandsKeyConcepts(x))"
},
{
"input": "Translate into first-order logic: If a student understands key concepts, then they perform well in the test.",
"output": "∀x (Student(x) ∧ UnderstandsKeyConcepts(x) → PerformsWell(x))"
},
{
"input": "Translate into first-order logic: All students who study regularly pass the semester test.",
"output": "∀x (Student(x) ∧ StudyRegularly(x) → PassesSemesterTest(x))"
},
{
"input": "Translate into first-order logic: There exists a student who studies effectively and passes the test.",
"output": "∃x (Student(x) ∧ StudiesEffectively(x) ∧ PassesSemesterTest(x))"
},
{
"input": "Translate into first-order logic: If a student completes assignments on time, then they understand the material.",
"output": "∀x (Student(x) ∧ CompletesAssignmentsOnTime(x) → UnderstandsMaterial(x))"
},
{
"input": "Translate into first-order logic: If a student understands the material, then they perform well on exams.",
"output": "∀x (Student(x) ∧ UnderstandsMaterial(x) → PerformsWellOnExams(x))"
},
{
"input": "Translate into first-order logic: If a student practices regularly, then they study effectively.",
"output": "∀x (Student(x) ∧ PracticesRegularly(x) → StudiesEffectively(x))"
},
{
"input": "Translate into first-order logic: If a student completes assignments on time, then they achieve an A grade.",
"output": "∀x (Student(x) ∧ CompletesAssignmentsOnTime(x) → AchievesAGrade(x))"
},
{
"input": "Translate into first-order logic: If a person studies hard, then they can pass the test.",
"output": "∀x (StudyHard(x) → PassTest(x))"
},
{
"input": "Translate into first-order logic: If a person passes the test, they graduate the school.",
"output": "∀x (PassTest(x) → Graduate(x))"
},
{
"input": "Translate into first-order logic: If they graduate the school, they are happy.",
"output": "∀x (Graduate(x) → Happy(x))"
},
{
"input": "Translate into first-order logic: Bob never lazy.",
"output": "∀x (Bob(x) → StudyHard(x))"
},
{
"input": "Translate into first-order logic: All students who are freshmen have to pass Calculus 1 and Calculus 2.",
"output": "∀x (Freshman(x) → (Pass(x, Calculus1) ∧ Pass(x, Calculus2)))"
},
{
"input": "Translate into first-order logic: If they don't achieve 4 points or over on Calculus 1, they cannot attend Calculus 2.",
"output": "∀x (Student(x) ∧ ≥(Score(x, Calculus1), 4) → Took(x, Calculus2))"
},
{
"input": "Translate into first-order logic: Jake has learned Calculus 2.",
"output": "Took(Jake, Calculus2)"
},
{
"input": "Translate into first-order logic: All students at BK university need to gain at least 15 social work days.",
"output": "∀x (AtBK(x) → ∃d (SocialWorkDays(x, d) ∧ d ≥ 15))"
},
{
"input": "Translate into first-order logic: They cannot graduate from school if they don't have enough 15 social work days.",
"output": "∀x (AtBK(x) ∧ ¬∃d (SocialWorkDays(x, d) ∧ d ≥ 15) → ¬Graduate(x))"
},
{
"input": "Translate into first-order logic: If they cannot graduate from school in 6 years, they are out of school.",
"output": "∀x (AtBK(x) ∧ ¬Graduate(x) ∧ TimeSpent(x) ≥ 6 → OutOfSchool(x))"
},
{
"input": "Translate into first-order logic: If they are out of school, they have to spend more time studying at school.",
"output": "∀x (OutOfSchool(x) → StudyMore(x))"
},
{
"input": "Translate into first-order logic: John is a BK student.",
"output": "AtBK(John)"
},
{
"input": "Translate into first-order logic: In a subject, students can get scores through the midterm exam, project, and final exam.",
"output": "∀x ∀s (Student(x) ∧ Subject(s) → ∃m ∃p ∃f (Score(x, s, Midterm, m) ∧ Score(x, s, Project, p) ∧ Score(x, s, Final, f)))"
},
{
"input": "Translate into first-order logic: If the average of those scores is higher than 8, students can get an A grade.",
"output": "∀x ∀s ∀m ∀p ∀f ((Score(x, s, Midterm, m) ∧ Score(x, s, Project, p) ∧ Score(x, s, Final, f) ∧ Average(x, s, (m + p + f) / 3) ≥ 8) → Grade(x, s, A))"
},
{
"input": "Translate into first-order logic: Mary got an A grade.",
"output": "∀s (Grade(Mary, s, A))"
},
{
"input": "Translate into first-order logic: Mary got 7 on the midterm exam, 10 on the project, and 9 on the final exam.",
"output": "∀s (Score(Mary, s, Midterm, 7) ∧ Score(Mary, s, Project, 10) ∧ Score(Mary, s, Final, 9))"
},
{
"input": "Translate into first-order logic: If a person is a freshman, they need to attend 2 physics courses: PE1 and PE2.",
"output": "∀x (Freshman(x) → (Register(x, PE1) ∧ Register(x, PE2)))"
},
{
"input": "Translate into first-order logic: Nobody can register for PE2 if they don't pass PE1.",
"output": "∀x (¬Pass(x, PE1) → ¬Register(x, PE2))"
},
{
"input": "Translate into first-order logic: A person cannot register for PE1 twice.",
"output": "∀x (Register(x, PE1) → ¬RegisterTwice(x, PE1))"
},
{
"input": "Translate into first-order logic: All people need to pass both PE physics courses in order to meet the condition for graduating school.",
"output": "∀x ((Pass(x, PE1) ∧ Pass(x, PE2)) → GraduateCondition(x))"
},
{
"input": "Translate into first-order logic: Peter Griffin is a freshman.",
"output": "Freshman(PeterGriffin)"
},
{
"input": "Translate into first-order logic: Peter Griffin passed PE1.",
"output": "Pass(PeterGriffin, PE1)"
},
{
"input": "Translate into first-order logic: Every member in the club will gain experience through events.",
"output": "∀x (Member(x) ∧ ∃e (Event(e) ∧ Attend(x, e)) → Experience(x))"
},
{
"input": "Translate into first-order logic: If they gain experience, they get better and improve their skills.",
"output": "∀x (Experience(x) → ImproveSkill(x))"
},
{
"input": "Translate into first-order logic: Improving their skills lets them become confident.",
"output": "∀x (ImproveSkill(x) → Confident(x))"
},
{
"input": "Translate into first-order logic: They have to attend at least 2 events to gain experience.",
"output": "∀x ((Events(x, e) ∧ e ≥ 2) → Experience(x))"
},
{
"input": "Translate into first-order logic: Tu attended 5 events.",
"output": "∀e (Event(e) → Attend(Tu, e)) ∧ TotalEvents(Tu, 5)"
},
{
"input": "Translate into first-order logic: Students in BK university can register in BK dormitory if they have a studying schedule.",
"output": "∀x (AtBK(x) ∧ StudySchedule(x) → RegisterDorm(x))"
},
{
"input": "Translate into first-order logic: To have a studying schedule, they need to register subjects or be registered by the school for the first semester.",
"output": "∀x (StudySchedule(x) ↔ (RegisterSubject(x) ∨ FirstSemester(x)))"
},
{
"input": "Translate into first-order logic: They cannot stay in BK dormitory if they fail or drop out of school.",
"output": "∀x ((Fail(x) ∨ Dropout(x)) → ¬RegisterDorm(x))"
},
{
"input": "Translate into first-order logic: Tuan is in the first semester.",
"output": "FirstSemester(Tuan)"
},
{
"input": "Translate into first-order logic: BK students can participate in the lab of a lecturer to gain guidance to do a science article.",
"output": "∀x (AtBK(x) ∧ LabMember(x) → Guidance(x))"
},
{
"input": "Translate into first-order logic: If they are a member of the lab, they can get training.",
"output": "∀x (LabMember(x) → Training(x))"
},
{
"input": "Translate into first-order logic: Training helps them to broaden knowledge.",
"output": "∀x (Training(x) → Knowledge(x))"
},
{
"input": "Translate into first-order logic: With guidance and knowledge, they can do a science article.",
"output": "∀x (Guidance(x) ∧ Knowledge(x) → ScienceArticle(x))"
},
{
"input": "Translate into first-order logic: If the science article is successfully published, they get plus points in their graduation thesis.",
"output": "∀x ∀a (ScienceArticle(x) ∧ Published(x, a) → PlusPoint(x))"
},
{
"input": "Translate into first-order logic: Kahne is a member of the lab.",
"output": "LabMember(Kahne)"
},
{
"input": "Translate into first-order logic: The third-year students can get an internship at a company or go to work.",
"output": "∀x (Year(x, n) ∧ n ≥ 3 → (Internship(x) ∨ Work(x)))"
},
{
"input": "Translate into first-order logic: If they get an internship, they get a good CV.",
"output": "∀x (Internship(x) → GoodCV(x))"
},
{
"input": "Translate into first-order logic: A good CV means they are easily able to get a job.",
"output": "∀x (GoodCV(x) → EasyJob(x))"
},
{
"input": "Translate into first-order logic: Coke is a fourth-year student.",
"output": "Year(Coke, 4)"
},
{
"input": "Translate into first-order logic: A computer with a fast processor can run complex software.",
"output": "∀x (FastProcessor(x) → RunsComplexSoftware(x))"
},
{
"input": "Translate into first-order logic: If a computer has enough RAM, it supports multitasking efficiently.",
"output": "∀x (EnoughRAM(x) → SupportsMultitasking(x))"
},
{
"input": "Translate into first-order logic: A system that runs complex software and supports multitasking efficiently requires a strong cooling unit.",
"output": "∀x ((RunsComplexSoftware(x) ∧ SupportsMultitasking(x)) → StrongCoolingUnit(x))"
},
{
"input": "Translate into first-order logic: Only systems with a strong cooling unit remain stable during heavy use.",
"output": "∀x (RemainsStable(x) → StrongCoolingUnit(x))"
},
{
"input": "Translate into first-order logic: The Titan computer runs complex software.",
"output": "RunsComplexSoftware(Titan)"
},
{
"input": "Translate into first-order logic: The Titan computer supports multitasking efficiently.",
"output": "SupportsMultitasking(Titan)"
},
{
"input": "Translate into first-order logic: Models trained with large datasets achieve high accuracy.",
"output": "∀x (LargeDatasets(x) → HighAccuracy(x))"
},
{
"input": "Translate into first-order logic: If a model uses a powerful GPU, it can process large datasets quickly.",
"output": "∀x (PowerfulGPU(x) → ProcessesQuickly(x))"
},
{
"input": "Translate into first-order logic: A model that achieves high accuracy and processes data quickly requires extensive hyperparameter tuning.",
"output": "∀x ((HighAccuracy(x) ∧ ProcessesQuickly(x)) → ExtensiveTuning(x))"
},
{
"input": "Translate into first-order logic: Only models with extensive hyperparameter tuning perform consistently on new data.",
"output": "∀x (ConsistentPerformance(x) → ExtensiveTuning(x))"
},
{
"input": "Translate into first-order logic: The AlphaNet model achieves high accuracy.",
"output": "HighAccuracy(AlphaNet)"
},
{
"input": "Translate into first-order logic: The AlphaNet model processes data quickly.",
"output": "ProcessesQuickly(AlphaNet)"
},
{
"input": "Translate into first-order logic: In JavaScript, a variable can be declared using 'let', 'const', or 'var'.",
"output": "∀x (VarDeclaredWith(x, 'let') → BlockScoped(x))"
},
{
"input": "Translate into first-order logic: If a variable is declared with 'let', it is block-scoped.",
"output": "∀x (VarDeclaredWith(x, 'const') → ImmutableValue(x))"
},
{
"input": "Translate into first-order logic: If a variable is declared with 'const', its value cannot be reassigned.",
"output": "∀x (VarDeclaredWith(x, 'var') → FunctionScoped(x))"
},
{
"input": "Translate into first-order logic: A function can be declared using the 'function' keyword or using arrow syntax.",
"output": "∀x (FunctionDeclaredWith(x, 'function') ∨ FunctionDeclaredWith(x, 'arrow') → Callable(x))"
},
{
"input": "Translate into first-order logic: JavaScript supports asynchronous programming with promises and async/await.",
"output": "∀x (SupportsAsyncProgramming(x) → (Promise(x) ∨ AsyncAwait(x)))"
},
{
"input": "Translate into first-order logic: If a promise is resolved, the 'then' block will be executed.",
"output": "∀x (Resolved(Promise(x)) → ExecutesThenBlock(x))"
},
{
"input": "Translate into first-order logic: If a promise is rejected, the 'catch' block will be executed.",
"output": "∀x (Rejected(Promise(x)) → ExecutesCatchBlock(x))"
},
{
"input": "Translate into first-order logic: A closure in JavaScript allows a function to access variables from its outer scope even after the outer function has finished execution.",
"output": "∀x (Closure(x) → (AccessOuterScopeVariables(x) ∧ AfterOuterFunctionEnds(x)))"
},
{
"input": "Translate into first-order logic: The DOM in JavaScript allows manipulation of HTML elements on the page.",
"output": "∀x (ManipulateDOM(x) → CanModifyHTML(x))"
},
{
"input": "Translate into first-order logic: JavaScript supports event handling to respond to user interactions.",
"output": "∀x (HandlesEvent(x) → RespondToUserAction(x))"
},
{
"input": "Translate into first-order logic: In C++, variables need to be declared with a type before they can be used.",
"output": "∀x (DeclaredWithType(x) → Type(x))"
},
{
"input": "Translate into first-order logic: C++ supports both primitive data types, such as int, char, and float, and user-defined types like structs and classes.",
"output": "∀x (SupportsPrimitiveTypes(x) → (Int(x) ∨ Char(x) ∨ Float(x))) ∧ ∀x (SupportsUserDefinedTypes(x) → (Struct(x) ∨ Class(x)))"
},
{
"input": "Translate into first-order logic: Functions in C++ can return a value and are declared with a return type.",
"output": "∀x (FunctionReturn(x) → ReturnType(x))"
},
{
"input": "Translate into first-order logic: C++ supports function overloading, allowing multiple functions with the same name but different parameters.",
"output": "∀x (FunctionOverloading(x) → MultipleFunctionsWithSameName(x))"
},
{
"input": "Translate into first-order logic: Classes in C++ are defined with the 'class' keyword and support encapsulation, inheritance, and polymorphism.",
"output": "∀x (ClassDefinedWith(x, 'class') → SupportsEncapsulation(x) ∧ SupportsInheritance(x) ∧ SupportsPolymorphism(x))"
},
{
"input": "Translate into first-order logic: C++ uses pointers to reference memory locations, and pointers can be used to dynamically allocate memory.",
"output": "∀x (UsesPointer(x) → ReferencesMemoryLocation(x)) ∧ ∀x (UsesPointer(x) → CanDynamicallyAllocateMemory(x))"
},
{
"input": "Translate into first-order logic: In C++, the 'new' keyword is used to dynamically allocate memory, and 'delete' is used to deallocate it.",
"output": "∀x (UsesNewKeyword(x) → DynamicallyAllocatedMemory(x))"
},
{
"input": "Translate into first-order logic: C++ supports exception handling with 'try', 'catch', and 'throw' keywords.",
"output": "∀x (UsesDeleteKeyword(x) → DeallocatedMemory(x))"
},
{
"input": "Translate into first-order logic: Templates in C++ allow generic programming by defining functions and classes that work with any data type.",
"output": "∀x (ExceptionHandling(x) → (TryBlock(x) ∧ CatchBlock(x) ∧ ThrowKeyword(x)))"
},
{
"input": "Translate into first-order logic: The Standard Template Library (STL) in C++ includes data structures like vectors, maps, and sets, and algorithms like sort and find.",
"output": "∀x (SupportsTemplates(x) → (FunctionTemplate(x) ∨ ClassTemplate(x)))"
},
{
"input": "Translate into first-order logic: If a person does not have a university degree, then they are not eligible for a senior job.",
"output": "∀x (¬HasDegree(x) → ¬SeniorJob(x))"
},
{
"input": "Translate into first-order logic: Everyone has completed training.",
"output": "∀x (CompletedTraining(x))"
},
{
"input": "Translate into first-order logic: If someone does not have a university degree, then they have not completed training.",
"output": "∀x (¬HasDegree(x) → ¬CompletedTraining(x))"
},
{
"input": "Translate into first-order logic: Everyone has passed the qualification test.",
"output": "∀x (PassedTest(x))"
},
{
"input": "Translate into first-order logic: If someone has a university degree, then they have completed training.",
"output": "∀x (HasDegree(x) → CompletedTraining(x))"
},
{
"input": "Translate into first-order logic: Everyone has attended the onboarding program.",
"output": "∀x (AttendedOnboarding(x))"
},
{
"input": "Translate into first-order logic: If someone has not completed training, then they do not have a university degree.",
"output": "∀x (¬CompletedTraining(x) → ¬HasDegree(x))"
},
{
"input": "Translate into first-order logic: If someone is eligible for a senior job, then they are eligible for a raise.",
"output": "∀x (SeniorJob(x) → EligibleRaise(x))"
},
{
"input": "Translate into first-order logic: Everyone has a university degree.",
"output": "∀x (HasDegree(x))"
},
{
"input": "Translate into first-order logic: If someone is not eligible for a senior job, then they do not have a university degree.",
"output": "∀x (¬SeniorJob(x) → ¬HasDegree(x))"
},
{
"input": "Translate into first-order logic: If someone attended the onboarding program, then they passed the qualification test.",
"output": "∀x (AttendedOnboarding(x) → PassedTest(x))"
},
{
"input": "Translate into first-order logic: If someone did not pass the qualification test, then they are not eligible for a senior job.",
"output": "∀x (¬PassedTest(x) → ¬SeniorJob(x))"
},
{
"input": "Translate into first-order logic: If someone has a university degree, then they attended the onboarding program.",
"output": "∀x (HasDegree(x) → AttendedOnboarding(x))"
},
{
"input": "Translate into first-order logic: If it is true that 'if someone does not have a university degree, then they are not eligible for a senior job', then it also follows that 'if someone is eligible for a senior job, then they are eligible for a raise'.",
"output": "∀x (¬HasDegree(x) → ¬SeniorJob(x))"
},
{
"input": "Translate into first-order logic: If everyone passed the qualification test, then it follows that 'if someone does not have a university degree, then they are not eligible for a senior job' implies 'if someone is eligible for a senior job, then they are eligible for a raise'.",
"output": "∀x (PassedTest(x))"
},
{
"input": "Translate into first-order logic: If it is true that 'if someone does not have a university degree, then they are not eligible for a senior job', then it follows that 'if everyone passed the qualification test, then the conclusion from (14) holds true'.",
"output": "∀x (¬HasDegree(x) → ¬SeniorJob(x))"
},
{
"input": "Translate into first-order logic: If everyone has a university degree, then anyone who attended the onboarding program must have passed the qualification test.",
"output": "∀x (HasDegree(x))"
},
{
"input": "Translate into first-order logic: If everyone attended the onboarding program, then anyone who attended it must have passed the qualification test.",
"output": "∀x (AttendedOnboarding(x))"
},
{
"input": "Translate into first-order logic: Everyone is eligible for a senior job.",
"output": "∀x (SeniorJob(x))"
},
{
"input": "Translate into first-order logic: If someone does not have a university degree, then they did not attend the onboarding program.",
"output": "∀x (¬HasDegree(x) → ¬AttendedOnboarding(x))"
},
{
"input": "Translate into first-order logic: If someone attended the onboarding program, then they have a university degree.",
"output": "∀x (AttendedOnboarding(x) → HasDegree(x))"
},
{
"input": "Translate into first-order logic: Every student at the university is enrolled in at least one course.",
"output": "∀x (Student(x) → EnrolledInCourse(x))"
},
{
"input": "Translate into first-order logic: If a person is not registered, then they are not allowed to take an exam.",
"output": "∀x (¬Registered(x) → ¬AllowedToTakeExam(x))"
},
{
"input": "Translate into first-order logic: If someone is not a paying student, then they are not registered.",
"output": "∀x (¬PayingStudent(x) → ¬Registered(x))"
},
{
"input": "Translate into first-order logic: All students have access to the university library.",
"output": "∀x (Student(x) → HasLibraryAccess(x))"
},
{
"input": "Translate into first-order logic: There is at least one person who has completed their assignments.",
"output": "∃x (CompletedAssignments(x))"
},
{
"input": "Translate into first-order logic: If a person is a paying student, then they are enrolled in a course.",
"output": "∀x (PayingStudent(x) → EnrolledInCourse(x))"
},
{
"input": "Translate into first-order logic: Everyone is allowed to take exams.",
"output": "∀x (AllowedToTakeExam(x))"
},
{
"input": "Translate into first-order logic: If a person doesn’t have access to the library, then they are not registered.",
"output": "∀x (¬HasLibraryAccess(x) → ¬Registered(x))"
},
{
"input": "Translate into first-order logic: If someone has access to the library, then they have completed their assignments.",
"output": "∀x (HasLibraryAccess(x) → CompletedAssignments(x))"
},
{
"input": "Translate into first-order logic: If someone has access to the library, then they are registered.",
"output": "∀x (HasLibraryAccess(x) → Registered(x))"
},
{
"input": "Translate into first-order logic: Everyone is registered.",
"output": "∀x (Registered(x))"
},
{
"input": "Translate into first-order logic: If someone is allowed to take an exam, then they have access to the library.",
"output": "∀x (AllowedToTakeExam(x) → HasLibraryAccess(x))"
},
{
"input": "Translate into first-order logic: If someone has access to the library, then they are allowed to take an exam.",
"output": "∀x (HasLibraryAccess(x) → AllowedToTakeExam(x))"
},
{
"input": "Translate into first-order logic: If not being registered implies not being allowed to take an exam, then not being a paying student implies not being registered.",
"output": "∀x (¬Registered(x) → ¬AllowedToTakeExam(x))"
},
{
"input": "Translate into first-order logic: If not being a paying student implies not being registered, then having access to the library implies being allowed to take an exam.",
"output": "∀x (¬PayingStudent(x) → ¬Registered(x))"
},
{
"input": "Translate into first-order logic: If there exists someone who is registered, then everyone has access to the library.",
"output": "∃x (Registered(x))"
},
{
"input": "Translate into first-order logic: If paying students are enrolled in courses, then those without library access are not registered.",
"output": "∀x (PayingStudent(x) → EnrolledInCourse(x))"
},
{
"input": "Translate into first-order logic: If having access to the library implies assignment completion, then someone must be registered.",
"output": "∀x (HasLibraryAccess(x) → CompletedAssignments(x))"
},
{
"input": "Translate into first-order logic: If someone is not registered, then they are not a paying student.",
"output": "∀x (¬Registered(x) → ¬PayingStudent(x))"
},
{
"input": "Translate into first-order logic: If someone is enrolled in a course, then they have completed their assignments.",
"output": "∀x (EnrolledInCourse(x) → CompletedAssignments(x))"
},
{
"input": "Translate into first-order logic: If someone has completed their assignments, then they are allowed to take an exam.",
"output": "∀x (CompletedAssignments(x) → AllowedToTakeExam(x))"
},
{
"input": "Translate into first-order logic: If a student has enrolled in a course, then they have passed the prerequisite.",
"output": "∀x (Enrolled(x) → PassedPrerequisite(x))"
},
{
"input": "Translate into first-order logic: All students have a valid registration.",
"output": "∀x (Registered(x))"
},
{
"input": "Translate into first-order logic: If a student has completed the qualifying test, then they have passed the prerequisite.",
"output": "∀x (QualifyingTest(x) → PassedPrerequisite(x))"
},
{
"input": "Translate into first-order logic: If a student has attended the tutorial, then they have submitted the assignment.",
"output": "∀x (AttendedTutorial(x) → SubmittedAssignment(x))"
},
{
"input": "Translate into first-order logic: All students have completed the qualifying test.",
"output": "∀x (QualifyingTest(x))"
},
{
"input": "Translate into first-order logic: If a student has completed the qualifying test, then they have attended the tutorial.",
"output": "∀x (QualifyingTest(x) → AttendedTutorial(x))"
},
{
"input": "Translate into first-order logic: If a student has not completed the qualifying test, then they have not passed the prerequisite.",
"output": "∀x (¬QualifyingTest(x) → ¬PassedPrerequisite(x))"
},
{
"input": "Translate into first-order logic: If a student is not registered, then they have not enrolled in a course.",
"output": "∀x (¬Registered(x) → ¬Enrolled(x))"
},
{
"input": "Translate into first-order logic: All students have submitted the assignment.",
"output": "∀x (SubmittedAssignment(x))"
},
{
"input": "Translate into first-order logic: If a student has enrolled in a course, then they have completed the qualifying test.",
"output": "∀x (Enrolled(x) → QualifyingTest(x))"
},
{
"input": "Translate into first-order logic: If a student has not attended the tutorial, then they have not enrolled in a course.",
"output": "∀x (¬AttendedTutorial(x) → ¬Enrolled(x))"
},
{
"input": "Translate into first-order logic: If the statement 'If a student has not completed the qualifying test then they have not passed the prerequisite' is true, then there exists at least one student who has submitted the assignment.",
"output": "∀x (¬QualifyingTest(x) → ¬PassedPrerequisite(x))"
},
{
"input": "Translate into first-order logic: If the statement 'If a student is not registered then they have not enrolled in a course' is true, then it follows that if a student has completed the qualifying test, they have attended the tutorial.",
"output": "∀x (¬Registered(x) → ¬Enrolled(x))"
},
{
"input": "Translate into first-order logic: If it is true that 'If a student has attended the tutorial, then they have submitted the assignment', then it must be that if a student is not registered, they have not enrolled in a course.",
"output": "∀x (AttendedTutorial(x) → SubmittedAssignment(x))"
},
{
"input": "Translate into first-order logic: If it is true that 'If a student has completed the qualifying test, then they have attended the tutorial', then it must be that if a student has not completed the qualifying test, they have not passed the prerequisite.",
"output": "∀x (QualifyingTest(x) → AttendedTutorial(x))"
},
{
"input": "Translate into first-order logic: If the statement 'If a student has not completed the qualifying test then they have not passed the prerequisite' implies that some student submitted the assignment, then there exists at least one student who attended the tutorial.",
"output": "(∀x (¬QualifyingTest(x) → ¬PassedPrerequisite(x)) → ∃x (SubmittedAssignment(x))) → ∃x (AttendedTutorial(x))"
},
{
"input": "Translate into first-order logic: If a student is registered, then they have enrolled in a course.",
"output": "∀x (Registered(x) → Enrolled(x))"
},
{
"input": "Translate into first-order logic: If a student has not passed the prerequisite, then they are not registered.",
"output": "∀x (¬PassedPrerequisite(x) → ¬Registered(x))"
},
{
"input": "Translate into first-order logic: If a student is registered, then they have completed the qualifying test.",
"output": "∀x (Registered(x) → QualifyingTest(x))"
},
{
"input": "Translate into first-order logic: If a student has passed the prerequisite, then they have completed the qualifying test.",
"output": "∀x (PassedPrerequisite(x) → QualifyingTest(x))"
},
{
"input": "Translate into first-order logic: All students have enrolled in a course.",
"output": "∀x (Enrolled(x))"
},
{
"input": "Translate into first-order logic: Everyone in the company has received a security clearance.",
"output": "∀x (SecurityClearance(x))"
},
{
"input": "Translate into first-order logic: If someone is a manager, then they have received a security clearance.",
"output": "∀x (Manager(x) → SecurityClearance(x))"
},
{
"input": "Translate into first-order logic: All employees in the company have completed cybersecurity training.",
"output": "∀x (CyberTraining(x))"
},
{
"input": "Translate into first-order logic: If a person is not a manager, then they have not received a security clearance.",
"output": "∀x (¬Manager(x) → ¬SecurityClearance(x))"
},
{
"input": "Translate into first-order logic: If a person has not received a security clearance, then they do not work in the security department.",
"output": "∀x (¬SecurityClearance(x) → ¬SecurityDept(x))"
},
{
"input": "Translate into first-order logic: If a person does not have permission to access confidential files, then they have not received a security clearance.",
"output": "∀x (¬Permission(x) → ¬SecurityClearance(x))"
},
{
"input": "Translate into first-order logic: If a person is not assigned a security token, then they are not a manager.",
"output": "∀x (¬Token(x) → ¬Manager(x))"
},
{
"input": "Translate into first-order logic: If a person is assigned a security token, then they are a manager.",
"output": "∀x (Token(x) → Manager(x))"
},
{
"input": "Translate into first-order logic: Everyone in the company has been assigned a security token.",
"output": "∀x (Token(x))"
},
{
"input": "Translate into first-order logic: If someone works in the security department, then they are a manager.",
"output": "∀x (SecurityDept(x) → Manager(x))"
},
{
"input": "Translate into first-order logic: If someone has completed cybersecurity training, then they have received a security clearance.",
"output": "∀x (CyberTraining(x) → SecurityClearance(x))"
},
{
"input": "Translate into first-order logic: If there is at least one manager, then everyone has completed cybersecurity training.",
"output": "∃x (Manager(x))"
},
{
"input": "Translate into first-order logic: If everyone has been assigned a security token, then anyone without permission to access confidential files has not received a security clearance.",
"output": "∀x (Token(x))"
},
{
"input": "Translate into first-order logic: If being assigned a security token implies being a manager, then not having a token implies not being a manager.",
"output": "∀x (Token(x) → Manager(x))"
},
{
"input": "Translate into first-order logic: If everyone has completed cybersecurity training, then being assigned a security token implies being a manager.",
"output": "∀x (CyberTraining(x))"
},
{
"input": "Translate into first-order logic: If the fact that having at least one manager implies everyone has completed cybersecurity training, then being assigned a token implies being a manager.",
"output": "(∃x (Manager(x)) → ∀x (CyberTraining(x))) → ∀x (Token(x) → Manager(x))"
},
{
"input": "Translate into first-order logic: If someone is a manager, then they have permission to access confidential files.",
"output": "∀x (Manager(x) → Permission(x))"
},
{
"input": "Translate into first-order logic: If a person is assigned a security token, then they have received a security clearance.",
"output": "∀x (Token(x) → SecurityClearance(x))"
},
{
"input": "Translate into first-order logic: If a person is assigned a security token, then they work in the security department.",
"output": "∀x (Token(x) → SecurityDept(x))"
},
{
"input": "Translate into first-order logic: If someone has received a security clearance, then they have completed cybersecurity training.",
"output": "∀x (SecurityClearance(x) → CyberTraining(x))"
},
{
"input": "Translate into first-order logic: If someone has received a security clearance, then they are a manager.",
"output": "∀x (SecurityClearance(x) → Manager(x))"
},
{
"input": "Translate into first-order logic: Everyone in the company is trained.",
"output": "∀x (Trained(x))"
},
{
"input": "Translate into first-order logic: Everyone in the company is up to date with the latest tools.",
"output": "∀x (UpToDate(x))"
},
{
"input": "Translate into first-order logic: If someone is not qualified, then they are not trained.",
"output": "∀x (¬Qualified(x) → ¬Trained(x))"
},
{
"input": "Translate into first-order logic: If someone is not qualified, then they are not productive.",
"output": "∀x (¬Qualified(x) → ¬Productive(x))"
},
{
"input": "Translate into first-order logic: If someone is skilled, then they are qualified.",
"output": "∀x (Skilled(x) → Qualified(x))"
},
{
"input": "Translate into first-order logic: If someone is skilled, then they are up to date with the latest tools.",
"output": "∀x (Skilled(x) → UpToDate(x))"
},
{
"input": "Translate into first-order logic: If someone is qualified, then they are skilled.",
"output": "∀x (Qualified(x) → Skilled(x))"
},
{
"input": "Translate into first-order logic: If someone is not productive, then they are not qualified.",
"output": "∀x (¬Productive(x) → ¬Qualified(x))"
},
{
"input": "Translate into first-order logic: If someone is not trained, then they are not qualified.",
"output": "∀x (¬Trained(x) → ¬Qualified(x))"
},
{
"input": "Translate into first-order logic: Everyone in the company is qualified.",
"output": "∀x (Qualified(x))"
},
{
"input": "Translate into first-order logic: Everyone in the company follows the rules.",
"output": "∀x (FollowsRules(x))"
},
{
"input": "Translate into first-order logic: If someone is qualified, then they follow the rules.",
"output": "∀x (Qualified(x) → FollowsRules(x))"
},
{
"input": "Translate into first-order logic: If everyone is up to date with the latest tools, then everyone is qualified.",
"output": "∀x (UpToDate(x))"
},
{
"input": "Translate into first-order logic: If everyone follows the rules, then if someone is not productive, they are not qualified.",
"output": "∀x (FollowsRules(x))"
},
{
"input": "Translate into first-order logic: If qualified people follow the rules, then if someone is not trained, they are not qualified.",
"output": "∀x (Qualified(x) → FollowsRules(x))"
},
{
"input": "Translate into first-order logic: If everyone is up to date with the latest tools, then this implies that if everyone is up to date with the latest tools, then everyone is qualified.",
"output": "∀x (UpToDate(x))"
},
{
"input": "Translate into first-order logic: If the statement 'everyone up to date with tools implies everyone is qualified' is true, then it must be that if someone is not qualified, they are not trained.",
"output": "(∀x (UpToDate(x)) → ∀x (Qualified(x))) → ∀x (¬Qualified(x) → ¬Trained(x))"
},
{
"input": "Translate into first-order logic: If someone is not trained, then they are not skilled.",
"output": "∀x (¬Trained(x) → ¬Skilled(x))"
},
{
"input": "Translate into first-order logic: If someone is up to date with the latest tools, then they follow the rules.",
"output": "∀x (UpToDate(x) → FollowsRules(x))"
},
{
"input": "Translate into first-order logic: If someone is not productive, then they do not follow the rules.",
"output": "∀x (¬Productive(x) → ¬FollowsRules(x))"
},
{
"input": "Translate into first-order logic: If someone is qualified, then they are up to date with the latest tools.",
"output": "∀x (Qualified(x) → UpToDate(x))"
},
{
"input": "Translate into first-order logic: Every student attends the university.",
"output": "∀x (Student(x) → AttendsUniversity(x))"
},
{
"input": "Translate into first-order logic: If a student doesn't pass the project, then they will not pass the university course.",
"output": "∀x (¬PassesProject(x) → ¬PassesUniversityCourse(x))"
},
{
"input": "Translate into first-order logic: If a student doesn't complete the quiz, they won’t pass the university course.",
"output": "∀x (¬CompletesQuiz(x) → ¬PassesUniversityCourse(x))"
},
{
"input": "Translate into first-order logic: If a student takes the test, then they pass the university course.",
"output": "∀x (TakesTest(x) → PassesUniversityCourse(x))"
},
{
"input": "Translate into first-order logic: All students pass the university course.",
"output": "∀x (Student(x) → PassesUniversityCourse(x))"
},
{
"input": "Translate into first-order logic: If a student attends the review session, then they pass the project.",
"output": "∀x (AttendsReviewSession(x) → PassesProject(x))"
},
{
"input": "Translate into first-order logic: Every student attends the review session.",
"output": "∀x (Student(x) → AttendsReviewSession(x))"
},
{
"input": "Translate into first-order logic: If a student doesn’t complete the quiz, they don’t attend the university.",
"output": "∀x (¬CompletesQuiz(x) → ¬Student(x))"
},
{
"input": "Translate into first-order logic: If a student doesn’t attend the university, they don’t take the test.",
"output": "∀x (¬AttendsUniversity(x) → ¬TakesTest(x))"
},
{
"input": "Translate into first-order logic: If a student attends the review session, then they take the test.",
"output": "∀x (AttendsReviewSession(x) → TakesTest(x))"
},
{
"input": "Translate into first-order logic: If it's true that 'If a student doesn't pass the project, then they don’t pass the university course', then it's also true that 'If a student doesn't complete the quiz, then they don’t attend the university.'",
"output": "∀x (¬PassesProject(x) → ¬PassesUniversityCourse(x))"
},
{
"input": "Translate into first-order logic: If all students pass the university course, then all students attend the university.",
"output": "∀x (Student(x) → PassesUniversityCourse(x))"
},
{
"input": "Translate into first-order logic: If all students attend the review session, then it's true that 'If a student doesn't complete the quiz, then they don’t pass the university course.'",
"output": "∀x (Student(x) → AttendsReviewSession(x))"
},
{
"input": "Translate into first-order logic: If 'If a student doesn't pass the project, then they don’t pass the university course' is true, then at least one student attends the university.",
"output": "∀x (¬PassesProject(x) → ¬PassesUniversityCourse(x))"
},
{
"input": "Translate into first-order logic: If the implication 'If a student doesn't pass the project, then they don’t pass the university course' implies 'If a student doesn't complete the quiz, then they don’t attend the university', then any student who attends the review session must take the test.",
"output": "(∀x (¬PassesProject(x) → ¬PassesUniversityCourse(x)) → ∀x (¬CompletesQuiz(x) → ¬Student(x))) → ∀x (AttendsReviewSession(x) → TakesTest(x))"
},
{
"input": "Translate into first-order logic: If a student passes the project, then they also complete the quiz.",
"output": "∀x (PassesProject(x) → CompletesQuiz(x))"
},
{
"input": "Translate into first-order logic: If a student passes the university course, then they attend the university.",
"output": "∀x (PassesUniversityCourse(x) → AttendsUniversity(x))"
},
{
"input": "Translate into first-order logic: All students pass the project.",
"output": "∀x (Student(x) → PassesProject(x))"
},
{
"input": "Translate into first-order logic: If a student doesn't pass the project, then they didn’t attend the review session.",
"output": "∀x (¬PassesProject(x) → ¬AttendsReviewSession(x))"
},
{
"input": "Translate into first-order logic: If a student passes the university course, then they complete the quiz.",
"output": "∀x (PassesUniversityCourse(x) → CompletesQuiz(x))"
},
{
"input": "Translate into first-order logic: Everyone is punctual.",
"output": "∀x (Punctual(x))"
},
{
"input": "Translate into first-order logic: Everyone is qualified.",
"output": "∀x (Qualified(x))"
},
{
"input": "Translate into first-order logic: If someone is not talented, then they are not qualified.",
"output": "∀x (¬Talented(x) → ¬Qualified(x))"
},
{
"input": "Translate into first-order logic: If someone is talented, then they are punctual.",
"output": "∀x (Talented(x) → Punctual(x))"
},
{
"input": "Translate into first-order logic: Everyone is a student.",
"output": "∀x (Student(x))"
},
{
"input": "Translate into first-order logic: Everyone is unemployed.",
"output": "∀x (Unemployed(x))"
},
{
"input": "Translate into first-order logic: Everyone is talented.",
"output": "∀x (Talented(x))"
},
{
"input": "Translate into first-order logic: Everyone is responsible.",
"output": "∀x (Responsible(x))"
},
{
"input": "Translate into first-order logic: If someone is not unemployed, then they are not punctual.",
"output": "∀x (¬Unemployed(x) → ¬Punctual(x))"
},
{
"input": "Translate into first-order logic: If someone is unemployed, then they are qualified.",
"output": "∀x (Unemployed(x) → Qualified(x))"
},
{
"input": "Translate into first-order logic: If someone is not a student, then they are not talented.",
"output": "∀x (¬Student(x) → ¬Talented(x))"
},
{
"input": "Translate into first-order logic: If someone is responsible, then they are unemployed.",
"output": "∀x (Responsible(x) → Unemployed(x))"
},
{
"input": "Translate into first-order logic: If everyone is a student, then if someone is not talented, they are not qualified.",
"output": "∀x (Student(x))"
},
{
"input": "Translate into first-order logic: If the previous statement is true, then everyone is qualified.",
"output": "(∀x (Student(x)) → ∀x (¬Talented(x) → ¬Qualified(x))) → ∀x (Qualified(x))"
},
{
"input": "Translate into first-order logic: If there is at least one qualified person, then everyone is punctual.",
"output": "∃x (Qualified(x))"
},
{
"input": "Translate into first-order logic: If the implication from everyone being a student to the previous rule implies everyone is qualified, then everyone is a student.",
"output": "((∀x (Student(x)) → ∀x (¬Talented(x) → ¬Qualified(x))) → ∀x (Qualified(x))) → ∀x (Student(x))"
},
{
"input": "Translate into first-order logic: If not being unemployed implies not being punctual, then the implication from everyone being a student to the rule that not being talented implies not being qualified leads to everyone being qualified.",
"output": "∀x (¬Unemployed(x) → ¬Punctual(x))"
},
{
"input": "Translate into first-order logic: If someone is not punctual, then they are not a student.",
"output": "∀x (¬Punctual(x) → ¬Student(x))"
},
{
"input": "Translate into first-order logic: If someone is not qualified, then they are not talented.",
"output": "∀x (¬Qualified(x) → ¬Talented(x))"
},
{
"input": "Translate into first-order logic: If someone is qualified, then they are punctual.",
"output": "∀x (Qualified(x) → Punctual(x))"
},
{
"input": "Translate into first-order logic: If someone is responsible, then they are qualified.",
"output": "∀x (Responsible(x) → Qualified(x))"
},
{
"input": "Translate into first-order logic: If someone is unemployed, then they are responsible.",
"output": "∀x (Unemployed(x) → Responsible(x))"
},
{
"input": "Translate into first-order logic: If a student is eligible, then they must have taken the required test.",
"output": "∀x (Eligible(x) → Test(x))"
},
{
"input": "Translate into first-order logic: If a student does not pass the prerequisite, then they won't be allowed to graduate.",
"output": "∀x (¬Prereq(x) → ¬Graduate(x))"
},
{
"input": "Translate into first-order logic: All students are eligible.",
"output": "∀x (Eligible(x))"
},
{
"input": "Translate into first-order logic: If a student has taken the required test, then their GPA requirement is met.",
"output": "∀x (Test(x) → GPA(x))"
},
{
"input": "Translate into first-order logic: All students have passed the prerequisite.",
"output": "∀x (Prereq(x))"
},
{
"input": "Translate into first-order logic: If a student has not taken the required test, then they are not eligible.",
"output": "∀x (¬Test(x) → ¬Eligible(x))"
},
{
"input": "Translate into first-order logic: If a student has taken the test, then they must have passed the prerequisite.",
"output": "∀x (Test(x) → Prereq(x))"
},
{
"input": "Translate into first-order logic: If a student’s GPA requirement is not met, then they have not taken the test.",
"output": "∀x (¬GPA(x) → ¬Test(x))"
},
{
"input": "Translate into first-order logic: If a student is eligible, then their GPA requirement is met.",
"output": "∀x (Eligible(x) → GPA(x))"
},
{
"input": "Translate into first-order logic: If a student has passed the prerequisite, then they are allowed to graduate.",
"output": "∀x (Prereq(x) → Graduate(x))"
},
{
"input": "Translate into first-order logic: If a student is not allowed to graduate, then they have not taken the test.",
"output": "∀x (¬Graduate(x) → ¬Test(x))"
},
{
"input": "Translate into first-order logic: If it's true that 'if a student's GPA is not met then they haven't taken the test', then it must also be true that 'if the student is eligible then they’ve taken the test'.",
"output": "∀x (¬GPA(x) → ¬Test(x))"
},
{
"input": "Translate into first-order logic: If it's true that 'if a student isn't allowed to graduate then they haven't taken the test', then it must also be true that 'if the student is eligible then they’ve taken the test'.",
"output": "∀x (¬Graduate(x) → ¬Test(x))"
},
{
"input": "Translate into first-order logic: If there is some student who is allowed to graduate, then any student who takes the test will meet the GPA requirement.",
"output": "∃x (Graduate(x))"
},
{
"input": "Translate into first-order logic: If passing the prerequisite guarantees graduation, then there must exist at least one student who is allowed to graduate.",
"output": "∀x (Prereq(x) → Graduate(x))"
},
{
"input": "Translate into first-order logic: If eligibility guarantees test-taking, then not passing the prerequisite guarantees not graduating.",
"output": "∀x (Eligible(x) → Test(x))"
},
{
"input": "Translate into first-order logic: If a student meets the GPA requirement, then they are allowed to graduate.",
"output": "∀x (GPA(x) → Graduate(x))"
},
{
"input": "Translate into first-order logic: If a student does not meet the GPA requirement, then they are not recommended.",
"output": "∀x (¬GPA(x) → ¬Recommended(x))"
},
{
"input": "Translate into first-order logic: If a student is not eligible, then they do not meet the GPA requirement.",
"output": "∀x (¬Eligible(x) → ¬GPA(x))"
},
{
"input": "Translate into first-order logic: If a student has not taken the test, then they are not recommended.",
"output": "∀x (¬Test(x) → ¬Recommended(x))"
},
{
"input": "Translate into first-order logic: Every committee member agrees that the thesis is acceptable.",
"output": "∀x (CommitteeMember(x) → Acceptable(x))"
},
{
"input": "Translate into first-order logic: At least one professor has raised a concern about the thesis.",
"output": "∃x (Professor(x) ∧ Concern(x))"
},
{
"input": "Translate into first-order logic: At least one observer found the thesis presentation clear.",
"output": "∃x (Observer(x) ∧ ClearPresentation(x))"
},
{
"input": "Translate into first-order logic: If a committee member agrees the thesis is acceptable, then they also approve the methodology.",
"output": "∀x (CommitteeMember(x) ∧ Acceptable(x) → ApproveMethodology(x))"
},
{
"input": "Translate into first-order logic: Every reviewer approves the methodology used in the thesis.",
"output": "∀x (Reviewer(x) → ApproveMethodology(x))"
},
{
"input": "Translate into first-order logic: If someone found the thesis presentation clear, they also approve the methodology.",
"output": "∀x (ClearPresentation(x) → ApproveMethodology(x))"
},
{
"input": "Translate into first-order logic: If a faculty member believes the thesis should be revised, then they think the topic is weak.",
"output": "∀x (Faculty(x) ∧ Revise(x) → WeakTopic(x))"
},
{
"input": "Translate into first-order logic: If someone thinks the topic is weak, then they believe the thesis should be revised.",
"output": "∀x (WeakTopic(x) → Revise(x))"
},
{
"input": "Translate into first-order logic: If a professor raises a concern about the thesis, then they also approve the methodology.",
"output": "∀x (Professor(x) ∧ Concern(x) → ApproveMethodology(x))"
},
{
"input": "Translate into first-order logic: If a professor doesn’t raise a concern, then they don’t think the topic is weak.",
"output": "∀x (Professor(x) ∧ ¬Concern(x) → ¬WeakTopic(x))"
},
{
"input": "Translate into first-order logic: Every faculty member believes the thesis should be revised.",
"output": "∀x (Faculty(x) → Revise(x))"
},
{
"input": "Translate into first-order logic: If someone thinks the topic is weak, then they approve the methodology.",
"output": "∀x (WeakTopic(x) → ApproveMethodology(x))"
},
{
"input": "Translate into first-order logic: If the statement 'If a professor doesn’t raise a concern, then they don’t think the topic is weak' is true, then it implies that if a professor raises a concern, they approve the methodology.",
"output": "∀x (Professor(x) ∧ ¬Concern(x) → ¬WeakTopic(x))"
},
{
"input": "Translate into first-order logic: If a professor raising a concern implies they approve the methodology, then at least one faculty member believes the thesis should be revised.",
"output": "∀x (Professor(x) ∧ Concern(x) → ApproveMethodology(x))"
},
{
"input": "Translate into first-order logic: If the implication 'If a professor doesn’t raise a concern, then they don’t think the topic is weak' leads to the implication 'If a professor raises a concern, they approve the methodology', then it also means that if a committee member agrees the thesis is acceptable, they approve the methodology.",
"output": "(∀x (Professor(x) ∧ ¬Concern(x) → ¬WeakTopic(x)) → ∀x (Professor(x) ∧ Concern(x) → ApproveMethodology(x))) → ∀x (CommitteeMember(x) ∧ Acceptable(x) → ApproveMethodology(x))"
},
{
"input": "Translate into first-order logic: If all committee members agree that the thesis is acceptable, then at least one observer found the presentation clear.",
"output": "∀x (CommitteeMember(x) → Acceptable(x))"
},
{
"input": "Translate into first-order logic: If there is at least one person who approves the methodology, then if someone thinks the topic is weak, they also believe the thesis should be revised.",
"output": "∃x (ApproveMethodology(x))"
},
{
"input": "Translate into first-order logic: If someone doesn’t believe the thesis should be revised, then they don’t agree the thesis is acceptable.",
"output": "∀x (¬Revise(x) → ¬Acceptable(x))"
},
{
"input": "Translate into first-order logic: Everyone thinks the thesis topic is weak.",
"output": "∀x (WeakTopic(x))"
},
{
"input": "Translate into first-order logic: If a professor doesn’t raise a concern, then they don’t believe the thesis should be revised.",
"output": "∀x (Professor(x) ∧ ¬Concern(x) → ¬Revise(x))"
},
{
"input": "Translate into first-order logic: If someone didn’t find the presentation clear, then they don’t believe the thesis should be revised.",
"output": "∀x (¬ClearPresentation(x) → ¬Revise(x))"
},
{
"input": "Translate into first-order logic: If someone is not a library user, then they cannot borrow books.",
"output": "∀x (¬LibraryUser(x) → ¬CanBorrowBooks(x))"
},
{
"input": "Translate into first-order logic: Everyone has a library card.",
"output": "∀x (HasLibraryCard(x))"
},
{
"input": "Translate into first-order logic: If someone is allowed to borrow books, then they are allowed to take a book home.",
"output": "∀x (CanBorrowBooks(x) → CanTakeBookHome(x))"
},
{
"input": "Translate into first-order logic: Everyone is allowed to borrow books.",
"output": "∀x (CanBorrowBooks(x))"
},
{
"input": "Translate into first-order logic: If someone has a valid reservation, then they are allowed to borrow books.",
"output": "∀x (ValidReservation(x) → CanBorrowBooks(x))"
},
{
"input": "Translate into first-order logic: If someone is not allowed to take a book home, then they don’t have a library card.",
"output": "∀x (¬CanTakeBookHome(x) → ¬HasLibraryCard(x))"
},
{
"input": "Translate into first-order logic: If someone is not allowed to borrow books, then they are not allowed to take a book home.",
"output": "∀x (¬CanBorrowBooks(x) → ¬CanTakeBookHome(x))"
},
{
"input": "Translate into first-order logic: If someone is not a library user, then they don’t have a library card.",
"output": "∀x (¬LibraryUser(x) → ¬HasLibraryCard(x))"
},
{
"input": "Translate into first-order logic: If someone is not allowed to borrow books, then they are not a library user.",
"output": "∀x (¬CanBorrowBooks(x) → ¬LibraryUser(x))"
},
{
"input": "Translate into first-order logic: If someone does not have a library card, then they are not allowed to borrow books.",
"output": "∀x (¬HasLibraryCard(x) → ¬CanBorrowBooks(x))"
},
{
"input": "Translate into first-order logic: If someone is allowed to borrow books, then they must have a valid reservation.",
"output": "∀x (CanBorrowBooks(x) → ValidReservation(x))"
},
{
"input": "Translate into first-order logic: If valid reservations lead to borrowing privileges, then everyone can borrow books.",
"output": "∀x (ValidReservation(x) → CanBorrowBooks(x))"
},
{
"input": "Translate into first-order logic: If valid reservations lead to borrowing privileges, then non-library users cannot borrow books.",
"output": "∀x (ValidReservation(x) → CanBorrowBooks(x))"
},
{
"input": "Translate into first-order logic: If everyone can borrow books, then any valid reservation leads to borrowing privileges.",
"output": "∀x (CanBorrowBooks(x))"
},
{
"input": "Translate into first-order logic: If non-library users not having library cards implies valid reservation leads to borrowing privileges.",
"output": "∀x (¬LibraryUser(x) → ¬HasLibraryCard(x))"
},
{
"input": "Translate into first-order logic: If being allowed to borrow books means being allowed to take books home, then non-library users don't have library cards.",
"output": "∀x (CanBorrowBooks(x) → CanTakeBookHome(x))"
},
{
"input": "Translate into first-order logic: If someone is not allowed to borrow books, then they don’t have a library card.",
"output": "∀x (¬CanBorrowBooks(x) → ¬HasLibraryCard(x))"
},
{
"input": "Translate into first-order logic: Everyone is allowed to take books home",
"output": "∀x (CanTakeBookHome(x))"
},
{
"input": "Translate into first-order logic: Every student is required to get a passing grade in the reading section.",
"output": "∀x (RequiredToPassReading(x))"
},
{
"input": "Translate into first-order logic: If a student doesn't pass the practice test, then they won't pass the TOEFL exam.",
"output": "∀x (¬PassedPracticeTest(x) → ¬PassedTOEFL(x))"
},
{
"input": "Translate into first-order logic: All students are required to attend the IELTS preparation class.",
"output": "∀x (AttendsIELTSClass(x))"
},
{
"input": "Translate into first-order logic: If a student studies using the university's official guide, then they are required to get a passing grade in reading.",
"output": "∀x (StudiesFromOfficialGuide(x) → RequiredToPassReading(x))"
},
{
"input": "Translate into first-order logic: If a student attends the IELTS preparation class, then they will understand the reading material.",
"output": "∀x (AttendsIELTSClass(x) → UnderstandsReading(x))"
},
{
"input": "Translate into first-order logic: If a student is not required to pass the reading section, then they won't understand the reading material.",
"output": "∀x (¬RequiredToPassReading(x) → ¬UnderstandsReading(x))"
},
{
"input": "Translate into first-order logic: If a student doesn't study using the university's official guide, then they won't understand the reading material.",
"output": "∀x (¬StudiesFromOfficialGuide(x) → ¬UnderstandsReading(x))"
},
{
"input": "Translate into first-order logic: If a student doesn't study using the university's official guide, then they won't attend the IELTS preparation class.",
"output": "∀x (¬StudiesFromOfficialGuide(x) → ¬AttendsIELTSClass(x))"
},
{
"input": "Translate into first-order logic: If a student attends the IELTS class, then they are required to get a passing grade in reading.",
"output": "∀x (AttendsIELTSClass(x) → RequiredToPassReading(x))"
},
{
"input": "Translate into first-order logic: If a student is not required to get a passing grade in reading, then they won't pass the practice test.",
"output": "∀x (¬RequiredToPassReading(x) → ¬PassedPracticeTest(x))"
},
{
"input": "Translate into first-order logic: If a student passes the practice test, then they will pass the TOEFL exam.",
"output": "∀x (PassedPracticeTest(x) → PassedTOEFL(x))"
},
{
"input": "Translate into first-order logic: If a student doesn't pass the TOEFL exam, then they won't understand the reading material.",
"output": "∀x (¬PassedTOEFL(x) → ¬UnderstandsReading(x))"
},
{
"input": "Translate into first-order logic: If attending the IELTS class implies being required to pass reading, then not using the official guide implies not attending the IELTS class.",
"output": "∀x (AttendsIELTSClass(x) → RequiredToPassReading(x))"
},
{
"input": "Translate into first-order logic: If studying using the university's official guide implies being required to pass reading, then not using the guide implies not understanding the reading material.",
"output": "∀x (StudiesFromOfficialGuide(x) → RequiredToPassReading(x))"
},
{
"input": "Translate into first-order logic: If there is at least one student who studies using the official guide, then if a student doesn't pass the TOEFL exam, they won't understand the reading material.",
"output": "∃x (StudiesFromOfficialGuide(x))"
},
{
"input": "Translate into first-order logic: If not using the official guide implies not attending the IELTS class, then the existence of a student using the guide implies that not passing the TOEFL exam leads to not understanding the reading material.",
"output": "∀x (¬StudiesFromOfficialGuide(x) → ¬AttendsIELTSClass(x)) → (∃x (StudiesFromOfficialGuide(x)) → ∀x (¬PassedTOEFL(x) → ¬UnderstandsReading(x)))"
},
{
"input": "Translate into first-order logic: If not passing the TOEFL exam implies not understanding the reading material, then not being required to pass reading implies not passing the practice test.",
"output": "∀x (¬PassedTOEFL(x) → ¬UnderstandsReading(x))"
},
{
"input": "Translate into first-order logic: If a student doesn't understand the reading material, then they didn't study using the official guide.",
"output": "∀x (¬UnderstandsReading(x) → ¬StudiesFromOfficialGuide(x))"
},
{
"input": "Translate into first-order logic: If a student is required to pass reading, then they must attend the IELTS class.",
"output": "∀x (RequiredToPassReading(x) → AttendsIELTSClass(x))"
},
{
"input": "Translate into first-order logic: Every student passed the TOEFL exam.",
"output": "∀x (PassedTOEFL(x))"
},
{
"input": "Translate into first-order logic: If a student doesn't understand the reading material, then they are not required to pass the reading section.",
"output": "∀x (¬UnderstandsReading(x) → ¬RequiredToPassReading(x))"
},
{
"input": "Translate into first-order logic: Every student has completed the IELTS requirement.",
"output": "∀x (CompletedIELTS(x))"
},
{
"input": "Translate into first-order logic: If a student hasn't submitted their application, then they haven't received their test results.",
"output": "∀x (¬SubmittedApplication(x) → ¬ReceivedTestResults(x))"
},
{
"input": "Translate into first-order logic: Every student has submitted their coursework.",
"output": "∀x (SubmittedCoursework(x))"
},
{
"input": "Translate into first-order logic: If a student has received a university offer, then they have completed the IELTS requirement.",
"output": "∀x (ReceivedOffer(x) → CompletedIELTS(x))"
},
{
"input": "Translate into first-order logic: If a student has submitted their coursework, then they are eligible for a scholarship.",
"output": "∀x (SubmittedCoursework(x) → EligibleScholarship(x))"
},
{
"input": "Translate into first-order logic: If a student hasn't completed the IELTS requirement, then they are not eligible for a scholarship.",
"output": "∀x (¬CompletedIELTS(x) → ¬EligibleScholarship(x))"
},
{
"input": "Translate into first-order logic: If a student hasn't received a university offer, then they are not eligible for a scholarship.",
"output": "∀x (¬ReceivedOffer(x) → ¬EligibleScholarship(x))"
},
{
"input": "Translate into first-order logic: If a student hasn't received a university offer, then they haven't submitted their coursework.",
"output": "∀x (¬ReceivedOffer(x) → ¬SubmittedCoursework(x))"
},
{
"input": "Translate into first-order logic: If a student has submitted their coursework, then they have completed the IELTS requirement.",
"output": "∀x (SubmittedCoursework(x) → CompletedIELTS(x))"
},
{
"input": "Translate into first-order logic: If a student hasn't completed the IELTS requirement, then they haven't submitted their application.",
"output": "∀x (¬CompletedIELTS(x) → ¬SubmittedApplication(x))"
},
{
"input": "Translate into first-order logic: If a student has submitted their application, then they have received their test results.",
"output": "∀x (SubmittedApplication(x) → ReceivedTestResults(x))"
},
{
"input": "Translate into first-order logic: If a student hasn't received their test results, then they are not eligible for a scholarship.",
"output": "∀x (¬ReceivedTestResults(x) → ¬EligibleScholarship(x))"
},
{
"input": "Translate into first-order logic: If it is true that 'if a student has submitted their coursework, then they have completed the IELTS requirement', then it must also be true that 'if a student hasn't received a university offer, then they haven't submitted their coursework'.",
"output": "∀x (SubmittedCoursework(x) → CompletedIELTS(x))"
},
{
"input": "Translate into first-order logic: If it is true that 'if a student has received a university offer, then they have completed the IELTS requirement', then it must also be true that 'if a student hasn't received a university offer, then they are not eligible for a scholarship'.",
"output": "∀x (ReceivedOffer(x) → CompletedIELTS(x))"
},
{
"input": "Translate into first-order logic: If there is at least one student who has received a university offer, then it must be true that 'if a student hasn't received their test results, then they are not eligible for a scholarship'.",
"output": "∃x (ReceivedOffer(x))"
},
{
"input": "Translate into first-order logic: If it is true that 'if a student hasn't received a university offer, then they haven't submitted their coursework', then it must be true that 'if there is at least one student who has received a university offer, then if a student hasn't received their test results, they are not eligible for a scholarship'.",
"output": "∀x (¬ReceivedOffer(x) → ¬SubmittedCoursework(x))"
},
{
"input": "Translate into first-order logic: If it is true that 'if a student hasn't received their test results, then they are not eligible for a scholarship', then it must be true that 'if a student hasn't completed the IELTS requirement, then they haven't submitted their application'.",
"output": "∀x (¬ReceivedTestResults(x) → ¬EligibleScholarship(x))"
},
{
"input": "Translate into first-order logic: If a student is not eligible for a scholarship, then they haven't received a university offer.",
"output": "∀x (¬EligibleScholarship(x) → ¬ReceivedOffer(x))"
},
{
"input": "Translate into first-order logic: If a student has completed the IELTS requirement, then they have submitted their coursework.",
"output": "∀x (CompletedIELTS(x) → SubmittedCoursework(x))"
},
{
"input": "Translate into first-order logic: Every student has received their test results.",
"output": "∀x (ReceivedTestResults(x))"
},
{
"input": "Translate into first-order logic: If a student is not eligible for a scholarship, then they haven't completed the IELTS requirement.",
"output": "∀x (¬EligibleScholarship(x) → ¬CompletedIELTS(x))"
},
{
"input": "Translate into first-order logic: If a person studies, then they will pass the exam.",
"output": "∀x (Studies(x) → PassesExam(x))"
},
{
"input": "Translate into first-order logic: If a person does not prepare, then they will not pass the exam.",
"output": "∀x (¬Prepares(x) → ¬PassesExam(x))"
},
{
"input": "Translate into first-order logic: If a person trains regularly, they will become fit.",
"output": "∀x (TrainsRegularly(x) → BecomesFit(x))"
},
{
"input": "Translate into first-order logic: If a person is not motivated, then they will not become fit.",
"output": "∀x (¬Motivated(x) → ¬BecomesFit(x))"
},
{
"input": "Translate into first-order logic: If a person becomes fit, then they study.",
"output": "∀x (BecomesFit(x) → Studies(x))"
},
{
"input": "Translate into first-order logic: If a person does not train regularly, then they are not motivated.",
"output": "∀x (¬TrainsRegularly(x) → ¬Motivated(x))"
},
{
"input": "Translate into first-order logic: If a person does not prepare, then they do not study.",
"output": "∀x (¬Prepares(x) → ¬Studies(x))"
},
{
"input": "Translate into first-order logic: Everyone prepares.",
"output": "∀x (Prepares(x))"
},
{
"input": "Translate into first-order logic: Everyone becomes fit.",
"output": "∀x (BecomesFit(x))"
},
{
"input": "Translate into first-order logic: If a person does not study, then they are not motivated.",
"output": "∀x (¬Studies(x) → ¬Motivated(x))"
},
{
"input": "Translate into first-order logic: If a person is not motivated, then they do not train regularly.",
"output": "∀x (¬Motivated(x) → ¬TrainsRegularly(x))"
},
{
"input": "Translate into first-order logic: If it is true that 'if a person does not study then they are not motivated', then it is also true that 'if a person does not train regularly then they are not motivated.'",
"output": "∀x (¬Studies(x) → ¬Motivated(x))"
},
{
"input": "Translate into first-order logic: If someone passes the exam, then it follows that if a person does not train regularly, they are not motivated.",
"output": "∃x (PassesExam(x))"
},
{
"input": "Translate into first-order logic: If everyone prepares, then if it's true that 'if a person does not study then they are not motivated', then it is also true that 'if a person does not train regularly then they are not motivated.'",
"output": "∀x (Prepares(x))"
},
{
"input": "Translate into first-order logic: If the previous implication holds, then it must be true that if a person studies, they will pass the exam.",
"output": "(∀x (Prepares(x)) → (∀x (¬Studies(x) → ¬Motivated(x)) → ∀x (¬TrainsRegularly(x) → ¬Motivated(x)))) → ∀x (Studies(x) → PassesExam(x))"
},
{
"input": "Translate into first-order logic: If becoming fit leads to studying, then if a person does not train regularly, they are not motivated.",
"output": "∀x (BecomesFit(x) → Studies(x))"
},
{
"input": "Translate into first-order logic: If a person is motivated, then they train regularly.",
"output": "∀x (Motivated(x) → TrainsRegularly(x))"
},
{
"input": "Translate into first-order logic: If a person is not motivated, then they do not prepare.",
"output": "∀x (¬Motivated(x) → ¬Prepares(x))"
},
{
"input": "Translate into first-order logic: If a person becomes fit, then they train regularly.",
"output": "∀x (BecomesFit(x) → TrainsRegularly(x))"
},
{
"input": "Translate into first-order logic: Everyone passes the exam.",
"output": "∀x (PassesExam(x))"
},
{
"input": "Translate into first-order logic: Every student is stressed during exam season.",
"output": "∀x (Stressed(x))"
},
{
"input": "Translate into first-order logic: If a student reviews regularly, then they understand the material.",
"output": "∀x (ReviewsRegularly(x) → Understands(x))"
},
{
"input": "Translate into first-order logic: If a student understands the material, then they are not stressed.",
"output": "∀x (Understands(x) → ¬Stressed(x))"
},
{
"input": "Translate into first-order logic: If a student does not understand the material, then they must have procrastinated.",
"output": "∀x (¬Understands(x) → Procrastinates(x))"
},
{
"input": "Translate into first-order logic: If a student does not review regularly, then they did not procrastinate.",
"output": "∀x (¬ReviewsRegularly(x) → ¬Procrastinates(x))"
},
{
"input": "Translate into first-order logic: All students procrastinate.",
"output": "∀x (Procrastinates(x))"
},
{
"input": "Translate into first-order logic: If a student is stressed, then they must have procrastinated.",
"output": "∀x (Stressed(x) → Procrastinates(x))"
},
{
"input": "Translate into first-order logic: If a student joins a study group, then they understand the material.",
"output": "∀x (JoinsStudyGroup(x) → Understands(x))"
},
{
"input": "Translate into first-order logic: All students drink coffee during exams.",
"output": "∀x (DrinksCoffee(x))"
},
{
"input": "Translate into first-order logic: If a student does not review regularly, then they do not drink coffee.",
"output": "∀x (¬ReviewsRegularly(x) → ¬DrinksCoffee(x))"
},
{
"input": "Translate into first-order logic: If a student procrastinates, then they join a study group.",
"output": "∀x (Procrastinates(x) → JoinsStudyGroup(x))"
},
{
"input": "Translate into first-order logic: If at least one student drinks coffee, then at least one student reviews regularly.",
"output": "∃x (DrinksCoffee(x))"
},
{
"input": "Translate into first-order logic: If reviewing leads to understanding, then all students drink coffee.",
"output": "∀x (ReviewsRegularly(x) → Understands(x))"
},
{
"input": "Translate into first-order logic: If procrastinating leads to joining a study group, then not understanding leads to procrastination.",
"output": "∀x (Procrastinates(x) → JoinsStudyGroup(x))"
},
{
"input": "Translate into first-order logic: If at least one student drinks coffee, then all students procrastinate.",
"output": "∃x (DrinksCoffee(x))"
},
{
"input": "Translate into first-order logic: (If procrastinating implies joining a study group leads to not understanding implies procrastination), then every student must be stressed.",
"output": "(∀x (Procrastinates(x) → JoinsStudyGroup(x)) → ∀x (¬Understands(x) → Procrastinates(x))) → ∀x (Stressed(x))"
},
{
"input": "Translate into first-order logic: If a student joins a study group, then they review regularly.",
"output": "∀x (JoinsStudyGroup(x) → ReviewsRegularly(x))"
},
{
"input": "Translate into first-order logic: If a student does not join a study group, then they do not review regularly.",
"output": "∀x (¬JoinsStudyGroup(x) → ¬ReviewsRegularly(x))"
},
{
"input": "Translate into first-order logic: Every student joins a study group.",
"output": "∀x (JoinsStudyGroup(x))"
},
{
"input": "Translate into first-order logic: If a student is stressed, then they join a study group.",
"output": "∀x (Stressed(x) → JoinsStudyGroup(x))"
},
{
"input": "Translate into first-order logic: Every student is stressed during exam season.",
"output": "∀x (Stressed(x))"
},
{
"input": "Translate into first-order logic: If a student reviews regularly, then they understand the material.",
"output": "∀x (ReviewsRegularly(x) → Understands(x))"
},
{
"input": "Translate into first-order logic: If a student understands the material, then they are not stressed.",
"output": "∀x (Understands(x) → ¬Stressed(x))"
},
{
"input": "Translate into first-order logic: If a student does not understand the material, then they must have procrastinated.",
"output": "∀x (¬Understands(x) → Procrastinates(x))"
},
{
"input": "Translate into first-order logic: If a student does not review regularly, then they did not procrastinate.",
"output": "∀x (¬ReviewsRegularly(x) → ¬Procrastinates(x))"
},
{
"input": "Translate into first-order logic: All students procrastinate.",
"output": "∀x (Procrastinates(x))"
},
{
"input": "Translate into first-order logic: If a student is stressed, then they must have procrastinated.",
"output": "∀x (Stressed(x) → Procrastinates(x))"
},
{
"input": "Translate into first-order logic: If a student joins a study group, then they understand the material.",
"output": "∀x (JoinsStudyGroup(x) → Understands(x))"
},
{
"input": "Translate into first-order logic: All students drink coffee during exams.",
"output": "∀x (DrinksCoffee(x))"
},
{
"input": "Translate into first-order logic: If a student does not review regularly, then they do not drink coffee.",
"output": "∀x (¬ReviewsRegularly(x) → ¬DrinksCoffee(x))"
},
{
"input": "Translate into first-order logic: If a student procrastinates, then they join a study group.",
"output": "∀x (Procrastinates(x) → JoinsStudyGroup(x))"
},
{
"input": "Translate into first-order logic: If at least one student drinks coffee, then at least one student reviews regularly.",
"output": "∃x (DrinksCoffee(x))"
},
{
"input": "Translate into first-order logic: If reviewing leads to understanding, then all students drink coffee.",
"output": "∀x (ReviewsRegularly(x) → Understands(x))"
},
{
"input": "Translate into first-order logic: If procrastinating leads to joining a study group, then not understanding leads to procrastination.",
"output": "∀x (Procrastinates(x) → JoinsStudyGroup(x))"
},
{
"input": "Translate into first-order logic: If at least one student drinks coffee, then all students procrastinate.",
"output": "∃x (DrinksCoffee(x))"
},
{
"input": "Translate into first-order logic: (If procrastinating implies joining a study group leads to not understanding implies procrastination), then every student must be stressed.",
"output": "(∀x (Procrastinates(x) → JoinsStudyGroup(x)) → ∀x (¬Understands(x) → Procrastinates(x))) → ∀x (Stressed(x))"
},
{
"input": "Translate into first-order logic: If a student joins a study group, then they review regularly.",
"output": "∀x (JoinsStudyGroup(x) → ReviewsRegularly(x))"
},
{
"input": "Translate into first-order logic: If a student does not join a study group, then they do not review regularly.",
"output": "∀x (¬JoinsStudyGroup(x) → ¬ReviewsRegularly(x))"
},
{
"input": "Translate into first-order logic: Every student joins a study group.",
"output": "∀x (JoinsStudyGroup(x))"
},
{
"input": "Translate into first-order logic: If a student is stressed, then they join a study group.",
"output": "∀x (Stressed(x) → JoinsStudyGroup(x))"
},
{
"input": "Translate into first-order logic: If a person does not pass the test, then they did not take the training.",
"output": "∀x (¬PassesTest(x) → ¬TookTraining(x))"
},
{
"input": "Translate into first-order logic: If a person is qualified, then they are recommended.",
"output": "∀x (IsQualified(x) → IsRecommended(x))"
},
{
"input": "Translate into first-order logic: If a person studies, then they will pass the test.",
"output": "∀x (Studies(x) → PassesTest(x))"
},
{
"input": "Translate into first-order logic: If someone takes the training, then they are qualified.",
"output": "∀x (TookTraining(x) → IsQualified(x))"
},
{
"input": "Translate into first-order logic: Everyone is enrolled in the program.",
"output": "∀x (IsEnrolled(x))"
},
{
"input": "Translate into first-order logic: If someone studies, then they are recommended.",
"output": "∀x (Studies(x) → IsRecommended(x))"
},
{
"input": "Translate into first-order logic: If someone takes the training, then they are recommended.",
"output": "∀x (TookTraining(x) → IsRecommended(x))"
},
{
"input": "Translate into first-order logic: If someone is not enrolled in the program, then they will not pass the test.",
"output": "∀x (¬IsEnrolled(x) → ¬PassesTest(x))"
},
{
"input": "Translate into first-order logic: If someone is enrolled in the program, then they are qualified.",
"output": "∀x (IsEnrolled(x) → IsQualified(x))"
},
{
"input": "Translate into first-order logic: If someone is recommended, then they are qualified.",
"output": "∀x (IsRecommended(x) → IsQualified(x))"
},
{
"input": "Translate into first-order logic: If a person is not qualified, then they did not study.",
"output": "∀x (¬IsQualified(x) → ¬Studies(x))"
},
{
"input": "Translate into first-order logic: Everyone passes the test.",
"output": "∀x (PassesTest(x))"
},
{
"input": "Translate into first-order logic: Everyone studies.",
"output": "∀x (Studies(x))"
},
{
"input": "Translate into first-order logic: If everyone is enrolled in the program, then everyone studies.",
"output": "∀x (IsEnrolled(x))"
},
{
"input": "Translate into first-order logic: If being qualified leads to being recommended, then being enrolled leads to being qualified.",
"output": "∀x (IsQualified(x) → IsRecommended(x))"
},
{
"input": "Translate into first-order logic: (If being qualified leads to being recommended implies being enrolled leads to being qualified), then everyone passes the test.",
"output": "(∀x (IsQualified(x) → IsRecommended(x)) → ∀x (IsEnrolled(x) → IsQualified(x))) → ∀x (PassesTest(x))"
},
{
"input": "Translate into first-order logic: If everyone is enrolled in the program, then everyone passes the test.",
"output": "∀x (IsEnrolled(x))"
},
{
"input": "Translate into first-order logic: If being qualified leads to being recommended, then everyone passes the test.",
"output": "∀x (IsQualified(x) → IsRecommended(x))"
},
{
"input": "Translate into first-order logic: If someone is qualified, then they pass the test.",
"output": "∀x (IsQualified(x) → PassesTest(x))"
},
{
"input": "Translate into first-order logic: If someone passes the test, then they took the training.",
"output": "∀x (PassesTest(x) → TookTraining(x))"
},
{
"input": "Translate into first-order logic: If someone passes the test, then they studied.",
"output": "∀x (PassesTest(x) → Studies(x))"
},
{
"input": "Translate into first-order logic: If someone is not qualified, then they did not take the training.",
"output": "∀x (¬IsQualified(x) → ¬TookTraining(x))"
},
{
"input": "Translate into first-order logic: If an employee has not passed the safety exam, then they are not certified to operate machinery.",
"output": "∀x (¬PassedSafetyExam(x) → ¬CertifiedMachinery(x))"
},
{
"input": "Translate into first-order logic: If an employee has not completed the teamwork module, then they are not eligible for a leadership role.",
"output": "∀x (¬CompletedTeamwork(x) → ¬EligibleLeadership(x))"
},
{
"input": "Translate into first-order logic: All employees have passed the safety exam.",
"output": "∀x (PassedSafetyExam(x))"
},
{
"input": "Translate into first-order logic: If an employee has not completed the required training, then they have not completed the teamwork module.",
"output": "∀x (¬CompletedTraining(x) → ¬CompletedTeamwork(x))"
},
{
"input": "Translate into first-order logic: If an employee is not eligible for a leadership role, then they have not completed the required training.",
"output": "∀x (¬EligibleLeadership(x) → ¬CompletedTraining(x))"
},
{
"input": "Translate into first-order logic: If an employee has not completed the teamwork module, then they are not certified to operate machinery.",
"output": "∀x (¬CompletedTeamwork(x) → ¬CertifiedMachinery(x))"
},
{
"input": "Translate into first-order logic: There exists at least one employee who has submitted a feedback form.",
"output": "∃x (SubmittedFeedback(x))"
},
{
"input": "Translate into first-order logic: If an employee is not eligible for a leadership role, then they are not certified to operate machinery.",
"output": "∀x (¬EligibleLeadership(x) → ¬CertifiedMachinery(x))"
},
{
"input": "Translate into first-order logic: All employees have completed the teamwork module.",
"output": "∀x (CompletedTeamwork(x))"
},
{
"input": "Translate into first-order logic: If an employee has passed the safety exam, then they are certified to operate machinery.",
"output": "∀x (PassedSafetyExam(x) → CertifiedMachinery(x))"
},
{
"input": "Translate into first-order logic: If an employee is not certified to operate machinery, then they are not eligible for a leadership role.",
"output": "∀x (¬CertifiedMachinery(x) → ¬EligibleLeadership(x))"
},
{
"input": "Translate into first-order logic: If an employee is certified to operate machinery, then they have completed the teamwork module.",
"output": "∀x (CertifiedMachinery(x) → CompletedTeamwork(x))"
},
{
"input": "Translate into first-order logic: If it is true that 'if an employee has not completed the teamwork module, then they are not eligible for a leadership role', then there exists at least one employee who has passed the safety exam.",
"output": "∀x (¬CompletedTeamwork(x) → ¬EligibleLeadership(x))"
},
{
"input": "Translate into first-order logic: If there exists at least one employee who has completed the required training, then it must be true that if an employee is not eligible for a leadership role, they are not certified to operate machinery.",
"output": "∃x (CompletedTraining(x))"
},
{
"input": "Translate into first-order logic: If there exists at least one employee who has passed the safety exam, then it must be true that if an employee is not certified to operate machinery, they are not eligible for a leadership role.",
"output": "∃x (PassedSafetyExam(x))"
},
{
"input": "Translate into first-order logic: If it is true that 'if an employee has not completed the teamwork module, then they are not eligible for a leadership role', then it must also be true that if they are certified to operate machinery, they must have completed the teamwork module.",
"output": "∀x (¬CompletedTeamwork(x) → ¬EligibleLeadership(x))"
},
{
"input": "Translate into first-order logic: If it is true that 'if an employee has passed the safety exam, then they are certified to operate machinery', then it logically follows that all employees have completed the teamwork module.",
"output": "∀x (PassedSafetyExam(x) → CertifiedMachinery(x))"
},
{
"input": "Translate into first-order logic: All employees have completed the required training.",
"output": "∀x (CompletedTraining(x))"
},
{
"input": "Translate into first-order logic: If an employee is eligible for a leadership role, then they have submitted a feedback form.",
"output": "∀x (EligibleLeadership(x) → SubmittedFeedback(x))"
},
{
"input": "Translate into first-order logic: If an employee has not passed the safety exam, then they have not submitted a feedback form.",
"output": "∀x (¬PassedSafetyExam(x) → ¬SubmittedFeedback(x))"
},
{
"input": "Translate into first-order logic: If an employee is eligible for a leadership role, then they have completed the teamwork module.",
"output": "∀x (EligibleLeadership(x) → CompletedTeamwork(x))"
},
{
"input": "Translate into first-order logic: If an employee has not completed the teamwork module, then they have not passed the safety exam.",
"output": "∀x (¬CompletedTeamwork(x) → ¬PassedSafetyExam(x))"
},
{
"input": "Translate into first-order logic: If someone studies computer science, then they know how to program.",
"output": "∀x (StudiesCS(x) → KnowsProgramming(x))"
},
{
"input": "Translate into first-order logic: If someone uses a computer, then they understand technology.",
"output": "∀x (UsesComputer(x) → UnderstandsTech(x))"
},
{
"input": "Translate into first-order logic: If someone knows how to program, then they can solve real-world problems.",
"output": "∀x (KnowsProgramming(x) → SolvesProblems(x))"
},
{
"input": "Translate into first-order logic: If someone doesn't understand technology, then they don't use a computer.",
"output": "∀x (¬UnderstandsTech(x) → ¬UsesComputer(x))"
},
{
"input": "Translate into first-order logic: If someone doesn't ask questions, then they don't solve real-world problems.",
"output": "∀x (¬AsksQuestions(x) → ¬SolvesProblems(x))"
},
{
"input": "Translate into first-order logic: If someone doesn't use a computer, then they can't solve real-world problems.",
"output": "∀x (¬UsesComputer(x) → ¬SolvesProblems(x))"
},
{
"input": "Translate into first-order logic: If someone doesn't study computer science, then they don't know how to program.",
"output": "∀x (¬StudiesCS(x) → ¬KnowsProgramming(x))"
},
{
"input": "Translate into first-order logic: If someone doesn't study computer science, then they don't ask questions.",
"output": "∀x (¬StudiesCS(x) → ¬AsksQuestions(x))"
},
{
"input": "Translate into first-order logic: If someone can solve real-world problems, then they use a computer.",
"output": "∀x (SolvesProblems(x) → UsesComputer(x))"
},
{
"input": "Translate into first-order logic: If someone understands technology, then they can solve real-world problems.",
"output": "∀x (UnderstandsTech(x) → SolvesProblems(x))"
},
{
"input": "Translate into first-order logic: If someone can solve real-world problems, then they ask questions.",
"output": "∀x (SolvesProblems(x) → AsksQuestions(x))"
},
{
"input": "Translate into first-order logic: Everyone knows how to program.",
"output": "∀x (KnowsProgramming(x))"
},
{
"input": "Translate into first-order logic: If someone knows how to program, then they understand technology.",
"output": "∀x (KnowsProgramming(x) → UnderstandsTech(x))"
},
{
"input": "Translate into first-order logic: If it's true that not using a computer implies not being able to solve real-world problems, then it's also true that not understanding technology implies not using a computer.",
"output": "∀x (¬UsesComputer(x) → ¬SolvesProblems(x))"
},
{
"input": "Translate into first-order logic: If studying computer science leads to knowing how to program, then everyone knows how to program.",
"output": "∀x (StudiesCS(x) → KnowsProgramming(x))"
},
{
"input": "Translate into first-order logic: If assuming that not using a computer means not solving real-world problems leads to the idea that not understanding technology means not using a computer, then understanding technology leads to solving real-world problems.",
"output": "(∀x (¬UsesComputer(x) → ¬SolvesProblems(x)) → ∀x (¬UnderstandsTech(x) → ¬UsesComputer(x))) → ∀x (UnderstandsTech(x) → SolvesProblems(x))"
},
{
"input": "Translate into first-order logic: If not asking questions means not solving real-world problems, then using a computer means understanding technology.",
"output": "∀x (¬AsksQuestions(x) → ¬SolvesProblems(x))"
},
{
"input": "Translate into first-order logic: If the above is true—that not asking questions implying not solving real-world problems leads to using a computer implying understanding technology—then understanding technology leads to solving real-world problems.",
"output": "(∀x (¬AsksQuestions(x) → ¬SolvesProblems(x)) → ∀x (UsesComputer(x) → UnderstandsTech(x))) → ∀x (UnderstandsTech(x) → SolvesProblems(x))"
},
{
"input": "Translate into first-order logic: If someone knows how to program, then they ask questions.",
"output": "∀x (KnowsProgramming(x) → AsksQuestions(x))"
},
{
"input": "Translate into first-order logic: If someone doesn't study computer science, then they don't understand technology.",
"output": "∀x (¬StudiesCS(x) → ¬UnderstandsTech(x))"
},
{
"input": "Translate into first-order logic: If someone studies computer science, then they understand technology.",
"output": "∀x (StudiesCS(x) → UnderstandsTech(x))"
},
{
"input": "Translate into first-order logic: Everyone in the company is required to follow the safety regulations.",
"output": "∀x (FollowsSafetyRegulations(x))"
},
{
"input": "Translate into first-order logic: Everyone in the company must attend the monthly team meeting.",
"output": "∀x (AttendsMonthlyMeeting(x))"
},
{
"input": "Translate into first-order logic: If someone does not complete the compliance training, they are not allowed to operate machinery.",
"output": "∀x (¬CompletedComplianceTraining(x) → ¬OperatesMachinery(x))"
},
{
"input": "Translate into first-order logic: If someone has not received the safety certification, then they have not completed the compliance training.",
"output": "∀x (¬HasSafetyCertification(x) → ¬CompletedComplianceTraining(x))"
},
{
"input": "Translate into first-order logic: All employees are assigned to a department.",
"output": "∀x (AssignedToDepartment(x))"
},
{
"input": "Translate into first-order logic: If someone has received the safety certification, then they have completed the compliance training.",
"output": "∀x (HasSafetyCertification(x) → CompletedComplianceTraining(x))"
},
{
"input": "Translate into first-order logic: If someone has not received the safety certification, then they have not attended the monthly team meeting.",
"output": "∀x (¬HasSafetyCertification(x) → ¬AttendsMonthlyMeeting(x))"
},
{
"input": "Translate into first-order logic: Everyone in the company has completed the compliance training.",
"output": "∀x (CompletedComplianceTraining(x))"
},
{
"input": "Translate into first-order logic: If someone follows the safety regulations, then they must have received the safety certification.",
"output": "∀x (FollowsSafetyRegulations(x) → HasSafetyCertification(x))"
},
{
"input": "Translate into first-order logic: If someone has completed the compliance training, then they have attended the monthly team meeting.",
"output": "∀x (CompletedComplianceTraining(x) → AttendsMonthlyMeeting(x))"
},
{
"input": "Translate into first-order logic: If someone has completed the compliance training, then they follow the safety regulations.",
"output": "∀x (CompletedComplianceTraining(x) → FollowsSafetyRegulations(x))"
},
{
"input": "Translate into first-order logic: If everyone who completed the compliance training follows the safety regulations, then everyone in the company has completed the compliance training.",
"output": "∀x (CompletedComplianceTraining(x) → FollowsSafetyRegulations(x))"
},
{
"input": "Translate into first-order logic: If those who completed the compliance training attended the monthly meeting, then those who did not receive the safety certification did not attend either.",
"output": "∀x (CompletedComplianceTraining(x) → AttendsMonthlyMeeting(x))"
},
{
"input": "Translate into first-order logic: If at least one person follows the safety regulations, then everyone follows them.",
"output": "∃x (FollowsSafetyRegulations(x))"
},
{
"input": "Translate into first-order logic: (If those who completed compliance training attended the monthly meeting implies those who did not receive safety certification didn’t attend), then those who completed compliance training must have attended the meeting.",
"output": "(∀x (CompletedComplianceTraining(x) → AttendsMonthlyMeeting(x)) → ∀x (¬HasSafetyCertification(x) → ¬AttendsMonthlyMeeting(x))) → ∀x (CompletedComplianceTraining(x) → AttendsMonthlyMeeting(x))"
},
{
"input": "Translate into first-order logic: If not completing compliance training implies not completing the safety certification, then the implication that 'those who completed the training attended the meeting' leads to 'those who did not receive safety certification didn’t attend' must also lead to the conclusion that they attended the meeting.",
"output": "∀x (¬CompletedComplianceTraining(x) → ¬HasSafetyCertification(x))"
},
{
"input": "Translate into first-order logic: If someone has not completed the compliance training, then they have not attended the monthly team meeting.",
"output": "∀x (¬CompletedComplianceTraining(x) → ¬AttendsMonthlyMeeting(x))"
},
{
"input": "Translate into first-order logic: If someone has not completed the compliance training, then they do not follow the safety regulations.",
"output": "∀x (¬CompletedComplianceTraining(x) → ¬FollowsSafetyRegulations(x))"
},
{
"input": "Translate into first-order logic: If someone does not follow the safety regulations, then they have not completed the compliance training.",
"output": "∀x (¬FollowsSafetyRegulations(x) → ¬CompletedComplianceTraining(x))"
},
{
"input": "Translate into first-order logic: If someone has not attended the monthly meeting, then they are not assigned to a department.",
"output": "∀x (¬AttendsMonthlyMeeting(x) → ¬AssignedToDepartment(x))"
},
{
"input": "Translate into first-order logic: Everyone in the company is required to follow the safety regulations.",
"output": "∀x (FollowsSafetyRegulations(x))"
},
{
"input": "Translate into first-order logic: Everyone in the company must attend the monthly team meeting.",
"output": "∀x (AttendsMonthlyMeeting(x))"
},
{
"input": "Translate into first-order logic: If someone does not complete the compliance training, they are not allowed to operate machinery.",
"output": "∀x (¬CompletedComplianceTraining(x) → ¬OperatesMachinery(x))"
},
{
"input": "Translate into first-order logic: If someone has not received the safety certification, then they have not completed the compliance training.",
"output": "∀x (¬HasSafetyCertification(x) → ¬CompletedComplianceTraining(x))"
},
{
"input": "Translate into first-order logic: All employees are assigned to a department.",
"output": "∀x (AssignedToDepartment(x))"
},
{
"input": "Translate into first-order logic: If someone has received the safety certification, then they have completed the compliance training.",
"output": "∀x (HasSafetyCertification(x) → CompletedComplianceTraining(x))"
},
{
"input": "Translate into first-order logic: If someone has not received the safety certification, then they have not attended the monthly team meeting.",
"output": "∀x (¬HasSafetyCertification(x) → ¬AttendsMonthlyMeeting(x))"
},
{
"input": "Translate into first-order logic: Everyone in the company has completed the compliance training.",
"output": "∀x (CompletedComplianceTraining(x))"
},
{
"input": "Translate into first-order logic: If someone follows the safety regulations, then they must have received the safety certification.",
"output": "∀x (FollowsSafetyRegulations(x) → HasSafetyCertification(x))"
},
{
"input": "Translate into first-order logic: If someone has completed the compliance training, then they have attended the monthly team meeting.",
"output": "∀x (CompletedComplianceTraining(x) → AttendsMonthlyMeeting(x))"
},
{
"input": "Translate into first-order logic: If someone has completed the compliance training, then they follow the safety regulations.",
"output": "∀x (CompletedComplianceTraining(x) → FollowsSafetyRegulations(x))"
},
{
"input": "Translate into first-order logic: If everyone who completed the compliance training follows the safety regulations, then everyone in the company has completed the compliance training.",
"output": "∀x (CompletedComplianceTraining(x) → FollowsSafetyRegulations(x))"
},
{
"input": "Translate into first-order logic: If those who completed the compliance training attended the monthly meeting, then those who did not receive the safety certification did not attend either.",
"output": "∀x (CompletedComplianceTraining(x) → AttendsMonthlyMeeting(x))"
},
{
"input": "Translate into first-order logic: If at least one person follows the safety regulations, then everyone follows them.",
"output": "∃x (FollowsSafetyRegulations(x))"
},
{
"input": "Translate into first-order logic: (If those who completed compliance training attended the monthly meeting implies those who did not receive safety certification didn’t attend), then those who completed compliance training must have attended the meeting.",
"output": "(∀x (CompletedComplianceTraining(x) → AttendsMonthlyMeeting(x)) → ∀x (¬HasSafetyCertification(x) → ¬AttendsMonthlyMeeting(x))) → ∀x (CompletedComplianceTraining(x) → AttendsMonthlyMeeting(x))"
},
{
"input": "Translate into first-order logic: If not completing compliance training implies not completing the safety certification, then the implication that 'those who completed the training attended the meeting' leads to 'those who did not receive safety certification didn’t attend' must also lead to the conclusion that they attended the meeting.",
"output": "∀x (¬CompletedComplianceTraining(x) → ¬HasSafetyCertification(x))"
},
{
"input": "Translate into first-order logic: If someone has not completed the compliance training, then they have not attended the monthly team meeting.",
"output": "∀x (¬CompletedComplianceTraining(x) → ¬AttendsMonthlyMeeting(x))"
},
{
"input": "Translate into first-order logic: If someone has not completed the compliance training, then they do not follow the safety regulations.",
"output": "∀x (¬CompletedComplianceTraining(x) → ¬FollowsSafetyRegulations(x))"
},
{
"input": "Translate into first-order logic: If someone does not follow the safety regulations, then they have not completed the compliance training.",
"output": "∀x (¬FollowsSafetyRegulations(x) → ¬CompletedComplianceTraining(x))"
},
{
"input": "Translate into first-order logic: If someone has not attended the monthly meeting, then they are not assigned to a department.",
"output": "∀x (¬AttendsMonthlyMeeting(x) → ¬AssignedToDepartment(x))"
},
{
"input": "Translate into first-order logic: If a student fails 4 or more theory sessions, they are not allowed to participate in future practice sessions.",
"output": "∀x (FailTheoryCount(x) ≥ 4 → ¬AllowedFuturePractice(x))"
},
{
"input": "Translate into first-order logic: If a student fails more than 3 theory quizzes, they are not allowed to participate in future practice sessions.",
"output": "∀x (TheoryQuizFailCount(x) > 3 → ¬AllowedFuturePractice(x))"
},
{
"input": "Translate into first-order logic: If a student does not attend the corresponding theory session, they are not eligible for the related practice session.",
"output": "∀x ∀t ∀p (¬Attended(x, t) ∧ CorrespondsTo(t, p) → ¬Eligible(x, p))"
},
{
"input": "Translate into first-order logic: If 2 or more group members fail the oral check, the session fails.",
"output": "∀g ∀s (CountFails(g, s) ≥ 2 → SessionFail(s))"
},
{
"input": "Translate into first-order logic: If the data calculation fails, the session fails.",
"output": "∀g ∀s (FailedCalculation(g, s) → SessionFail(s))"
},
{
"input": "Translate into first-order logic: If a student is assigned to a group and the group is assigned to a session, the session’s failure status applies to the student.",
"output": "∀x ∀g ∀s ((AssignedTo(x, g) ∧ AssignedToSession(g, s) ∧ SessionFail(s)) → SessionFailForStudent(x, s))"
},
{
"input": "Translate into first-order logic: If a student does not attend a theory session, they fail it.",
"output": "∀x ∀t (¬Attended(x, t) → FailsSession(x, t))"
},
{
"input": "Translate into first-order logic: Bob failed at least 3 theory sessions.",
"output": "FailTheoryCount(Bob) ≥ 3"
},
{
"input": "Translate into first-order logic: Bob failed at least 3 theory quizzes.",
"output": "TheoryQuizFailCount(Bob) ≥ 3"
},
{
"input": "Translate into first-order logic: Bob did not attend theory session T3.",
"output": "¬Attended(Bob, T3)"
},
{
"input": "Translate into first-order logic: Theory session T3 corresponds to practice session P3.",
"output": "CorrespondsTo(T3, P3)"
},
{
"input": "Translate into first-order logic: Bob is assigned to group G1.",
"output": "AssignedTo(Bob, G1)"
},
{
"input": "Translate into first-order logic: Group G1 is assigned to session P3.",
"output": "AssignedToSession(G1, P3)"
},
{
"input": "Translate into first-order logic: If a student fails a theory session corresponding to a practice session, they fail the oral check for that session.",
"output": "∀x ∀t ∀p (FailsSession(x, t) ∧ CorrespondsTo(t, p) → FailsOralCheck(x, p))"
},
{
"input": "Translate into first-order logic: At least one group member in G1 failed the oral check for P3.",
"output": "CountFails(G1, P3) ≥ 1"
},
{
"input": "Translate into first-order logic: If a student does not attend the corresponding theory session, they are not eligible for the related practice session.",
"output": "∀x ∀t ∀p (Student(x) ∧ ¬Attended(x, t) ∧ CorrespondsTo(t, p) → ¬Eligible(x, p))"
},
{
"input": "Translate into first-order logic: Linh did not attend theory session T5.",
"output": "Student(Linh) ∧ ¬Attended(Linh, T5)"
},
{
"input": "Translate into first-order logic: Theory session T5 corresponds to practice session P5.",
"output": "CorrespondsTo(T5, P5)"
},
{
"input": "Translate into first-order logic: If a group is assigned to a session, passes the oral check, has sufficient data, and passes the calculation, then the session does not fail.",
"output": "∀g ∀s (Group(g) ∧ AssignedToSession(g, s) ∧ OralCheckPass(g, s) ∧ SufficientData(g, s) ∧ CalculationPass(g, s) → ¬SessionFail(s))"
},
{
"input": "Translate into first-order logic: Group G3 is assigned to session P5.",
"output": "Group(G3) ∧ AssignedToSession(G3, P5)"
},
{
"input": "Translate into first-order logic: Group G3 passed the oral check and had sufficient data for P5.",
"output": "Group(G3) ∧ OralCheckPass(G3, P5) ∧ SufficientData(G3, P5)"
},
{
"input": "Translate into first-order logic: If a group passes the oral check and has sufficient data, they pass the calculation.",
"output": "∀g ∀s (Group(g) ∧ OralCheckPass(g, s) ∧ SufficientData(g, s) → CalculationPass(g, s))"
},
{
"input": "Translate into first-order logic: If a student does not attend the corresponding theory session, they are not eligible for the related practice session.",
"output": "∀x ∀t ∀p (Student(x) ∧ ¬Attended(x, t) ∧ CorrespondsTo(t, p) → ¬Eligible(x, p))"
},
{
"input": "Translate into first-order logic: Linh did not attend theory session T5.",
"output": "Student(Linh) ∧ ¬Attended(Linh, T5)"
},
{
"input": "Translate into first-order logic: Theory session T5 corresponds to practice session P5.",
"output": "CorrespondsTo(T5, P5)"
},
{
"input": "Translate into first-order logic: If a group is assigned to a session, passes the oral check, has sufficient data, and passes the calculation, then the session does not fail.",
"output": "∀g ∀s (Group(g) ∧ AssignedToSession(g, s) ∧ OralCheckPass(g, s) ∧ SufficientData(g, s) ∧ CalculationPass(g, s) → ¬SessionFail(s))"
},
{
"input": "Translate into first-order logic: Group G3 is assigned to session P5.",
"output": "Group(G3) ∧ AssignedToSession(G3, P5)"
},
{
"input": "Translate into first-order logic: Group G3 passed the oral check and had sufficient data for P5.",
"output": "Group(G3) ∧ OralCheckPass(G3, P5) ∧ SufficientData(G3, P5)"
},
{
"input": "Translate into first-order logic: If a group passes the oral check and has sufficient data, they pass the calculation.",
"output": "∀g ∀s (Group(g) ∧ OralCheckPass(g, s) ∧ SufficientData(g, s) → CalculationPass(g, s))"
},
{
"input": "Translate into first-order logic: If a student does not attend the corresponding theory session, they are not eligible for the related practice session.",
"output": "∀x ∀t ∀p (Student(x) ∧ ¬Attended(x, t) ∧ CorrespondsTo(t, p) → ¬Eligible(x, p))"
},
{
"input": "Translate into first-order logic: Linh did not attend theory session T5.",
"output": "Student(Linh) ∧ ¬Attended(Linh, T5)"
},
{
"input": "Translate into first-order logic: Theory session T5 corresponds to practice session P5.",
"output": "CorrespondsTo(T5, P5)"
},
{
"input": "Translate into first-order logic: If a group is assigned to a session, passes the oral check, has sufficient data, and passes the calculation, then the session does not fail.",
"output": "∀g ∀s (Group(g) ∧ AssignedToSession(g, s) ∧ OralCheckPass(g, s) ∧ SufficientData(g, s) ∧ CalculationPass(g, s) → ¬SessionFail(s))"
},
{
"input": "Translate into first-order logic: Group G3 is assigned to session P5.",
"output": "Group(G3) ∧ AssignedToSession(G3, P5)"
},
{
"input": "Translate into first-order logic: Group G3 passed the oral check and had sufficient data for P5.",
"output": "Group(G3) ∧ OralCheckPass(G3, P5) ∧ SufficientData(G3, P5)"
},
{
"input": "Translate into first-order logic: If a group passes the oral check and has sufficient data, they pass the calculation.",
"output": "∀g ∀s (Group(g) ∧ OralCheckPass(g, s) ∧ SufficientData(g, s) → CalculationPass(g, s))"
},
{
"input": "Translate into first-order logic: Students with unpaid tuition cannot have valid withdrawals.",
"output": "∀s ∀c ∀sem (Student(s) ∧ Course(c) ∧ Semester(sem) ∧ ¬PaidTuition(s, c, sem) → ¬IsValidWithdrawal(s, c, sem))"
},
{
"input": "Translate into first-order logic: Lan has unpaid tuition fees for C3 in Fall.",
"output": "Student(Lan) ∧ Course(C3) ∧ Semester(Fall) ∧ ¬PaidTuition(Lan, C3, Fall)"
},
{
"input": "Translate into first-order logic: If a withdrawal is valid, the student receives an R grade and the course is excluded from their transcript.",
"output": "∀s ∀c ∀sem (Student(s) ∧ Course(c) ∧ Semester(sem) ∧ IsValidWithdrawal(s, c, sem) → GetsWithdrawnGrade(s, c, sem) ∧ ¬IsInTranscript(s, c, sem))"
},
{
"input": "Translate into first-order logic: Invalid withdrawals do not result in an R grade.",
"output": "∀s ∀c ∀sem (Student(s) ∧ Course(c) ∧ Semester(sem) ∧ ¬IsValidWithdrawal(s, c, sem) → ¬GetsWithdrawnGrade(s, c, sem))"
},
{
"input": "Translate into first-order logic: Invalid withdrawals result in the course remaining on the transcript.",
"output": "∀s ∀c ∀sem (Student(s) ∧ Course(c) ∧ Semester(sem) ∧ ¬IsValidWithdrawal(s, c, sem) → IsInTranscript(s, c, sem))"
},
{
"input": "Translate into first-order logic: Students with unpaid tuition cannot have valid withdrawals.",
"output": "∀s ∀c ∀sem (Student(s) ∧ Course(c) ∧ Semester(sem) ∧ ¬PaidTuition(s, c, sem) → ¬IsValidWithdrawal(s, c, sem))"
},
{
"input": "Translate into first-order logic: Lan has unpaid tuition fees for C3 in Fall.",
"output": "Student(Lan) ∧ Course(C3) ∧ Semester(Fall) ∧ ¬PaidTuition(Lan, C3, Fall)"
},
{
"input": "Translate into first-order logic: If a withdrawal is valid, the student receives an R grade and the course is excluded from their transcript.",
"output": "∀s ∀c ∀sem (Student(s) ∧ Course(c) ∧ Semester(sem) ∧ IsValidWithdrawal(s, c, sem) → GetsWithdrawnGrade(s, c, sem) ∧ ¬IsInTranscript(s, c, sem))"
},
{
"input": "Translate into first-order logic: Invalid withdrawals do not result in an R grade.",
"output": "∀s ∀c ∀sem (Student(s) ∧ Course(c) ∧ Semester(sem) ∧ ¬IsValidWithdrawal(s, c, sem) → ¬GetsWithdrawnGrade(s, c, sem))"
},
{
"input": "Translate into first-order logic: Invalid withdrawals result in the course remaining on the transcript.",
"output": "∀s ∀c ∀sem (Student(s) ∧ Course(c) ∧ Semester(sem) ∧ ¬IsValidWithdrawal(s, c, sem) → IsInTranscript(s, c, sem))"
},
{
"input": "Translate into first-order logic: Students with unpaid tuition cannot have valid withdrawals.",
"output": "∀s ∀c ∀sem (Student(s) ∧ Course(c) ∧ Semester(sem) ∧ ¬PaidTuition(s, c, sem) → ¬IsValidWithdrawal(s, c, sem))"
},
{
"input": "Translate into first-order logic: Lan has unpaid tuition fees for C3 in Fall.",
"output": "Student(Lan) ∧ Course(C3) ∧ Semester(Fall) ∧ ¬PaidTuition(Lan, C3, Fall)"
},
{
"input": "Translate into first-order logic: If a withdrawal is valid, the student receives an R grade and the course is excluded from their transcript.",
"output": "∀s ∀c ∀sem (Student(s) ∧ Course(c) ∧ Semester(sem) ∧ IsValidWithdrawal(s, c, sem) → GetsWithdrawnGrade(s, c, sem) ∧ ¬IsInTranscript(s, c, sem))"
},
{
"input": "Translate into first-order logic: Invalid withdrawals do not result in an R grade.",
"output": "∀s ∀c ∀sem (Student(s) ∧ Course(c) ∧ Semester(sem) ∧ ¬IsValidWithdrawal(s, c, sem) → ¬GetsWithdrawnGrade(s, c, sem))"
},
{
"input": "Translate into first-order logic: Invalid withdrawals result in the course remaining on the transcript.",
"output": "∀s ∀c ∀sem (Student(s) ∧ Course(c) ∧ Semester(sem) ∧ ¬IsValidWithdrawal(s, c, sem) → IsInTranscript(s, c, sem))"
},
{
"input": "Translate into first-order logic: Students with unpaid tuition cannot have valid withdrawals.",
"output": "∀s ∀c ∀sem (Student(s) ∧ Course(c) ∧ Semester(sem) ∧ ¬PaidTuition(s, c, sem) → ¬IsValidWithdrawal(s, c, sem))"
},
{
"input": "Translate into first-order logic: Lan has unpaid tuition fees for C3 in Fall.",
"output": "Student(Lan) ∧ Course(C3) ∧ Semester(Fall) ∧ ¬PaidTuition(Lan, C3, Fall)"
},
{
"input": "Translate into first-order logic: If a withdrawal is valid, the student receives an R grade and the course is excluded from their transcript.",
"output": "∀s ∀c ∀sem (Student(s) ∧ Course(c) ∧ Semester(sem) ∧ IsValidWithdrawal(s, c, sem) → GetsWithdrawnGrade(s, c, sem) ∧ ¬IsInTranscript(s, c, sem))"
},
{
"input": "Translate into first-order logic: Invalid withdrawals do not result in an R grade.",
"output": "∀s ∀c ∀sem (Student(s) ∧ Course(c) ∧ Semester(sem) ∧ ¬IsValidWithdrawal(s, c, sem) → ¬GetsWithdrawnGrade(s, c, sem))"
},
{
"input": "Translate into first-order logic: Invalid withdrawals result in the course remaining on the transcript.",
"output": "∀s ∀c ∀sem (Student(s) ∧ Course(c) ∧ Semester(sem) ∧ ¬IsValidWithdrawal(s, c, sem) → IsInTranscript(s, c, sem))"
},
{
"input": "Translate into first-order logic: There exists at least one person who has submitted a scholarship application.",
"output": "∃x (SubmittedScholarshipApplication(x))"
},
{
"input": "Translate into first-order logic: If a person has submitted a scholarship application, then they meet the scholarship eligibility criteria.",
"output": "∀x (SubmittedScholarshipApplication(x) → MeetsScholarshipEligibility(x))"
},
{
"input": "Translate into first-order logic: There exists at least one student.",
"output": "∃x (Student(x))"
},
{
"input": "Translate into first-order logic: If there exists a student, then someone has submitted a scholarship application.",
"output": "∃x (Student(x))"
},
{
"input": "Translate into first-order logic: If there exists a student, then (if there exists a student, then someone has submitted a scholarship application).",
"output": "∃x (Student(x))"
},
{
"input": "Translate into first-order logic: Every person is a student.",
"output": "∀x (Person(x) → Student(x))"
},
{
"input": "Translate into first-order logic: If a person meets the scholarship eligibility criteria, then they are a student.",
"output": "∀x (MeetsScholarshipEligibility(x) → Student(x))"
},
{
"input": "Translate into first-order logic: If a person has not complied with the new attendance rule, then they are not allowed to attend class.",
"output": "∀x (¬CompliedWithRule(x) → ¬AllowedToAttendClass(x))"
},
{
"input": "Translate into first-order logic: Everyone is allowed to attend class.",
"output": "∀x (AllowedToAttendClass(x))"
},
{
"input": "Translate into first-order logic: If a person received a warning for previous absences, then they acknowledged the new attendance policy.",
"output": "∀x (ReceivedWarning(x) → AcknowledgedPolicy(x))"
},
{
"input": "Translate into first-order logic: If everyone is allowed to attend class, then if a person has not complied with the new attendance rule, then they are not allowed to attend class.",
"output": "∀x (∀y (AllowedToAttendClass(y)) → (¬CompliedWithRule(x) → ¬AllowedToAttendClass(x)))"
},
{
"input": "Translate into first-order logic: If (a person received a warning for previous absences implies they acknowledged the new attendance policy), then (a person not complying with the new rule implies they are not allowed to attend class).",
"output": "∀x ((ReceivedWarning(x) → AcknowledgedPolicy(x)) → (¬CompliedWithRule(x) → ¬AllowedToAttendClass(x)))"
},
{
"input": "Translate into first-order logic: There exists someone who has complied with the new attendance rule.",
"output": "∃x (CompliedWithRule(x))"
},
{
"input": "Translate into first-order logic: If a person is not allowed to attend class, then they have not complied with the new attendance rule.",
"output": "∀x (¬AllowedToAttendClass(x) → ¬CompliedWithRule(x))"
},
{
"input": "Translate into first-order logic: If a person registered to attend the AI seminar, then they are allowed to attend the seminar.",
"output": "∀x (Registered(x) → AllowedToAttend(x))"
},
{
"input": "Translate into first-order logic: All individuals are part of the educational institution.",
"output": "∀x (PartOfInstitution(x))"
},
{
"input": "Translate into first-order logic: If a person did not submit the seminar participation form, then they did not register to attend the seminar.",
"output": "∀x (¬SubmittedForm(x) → ¬Registered(x))"
},
{
"input": "Translate into first-order logic: If (a person did not submit the form implies they did not register), then (a person registered implies they are allowed to attend).",
"output": "∀x ((¬SubmittedForm(x) → ¬Registered(x)) → (Registered(x) → AllowedToAttend(x)))"
},
{
"input": "Translate into first-order logic: If (a person not submitting the form implies they did not register) implies ((a person not submitting implies they did not register) implies (a person registering implies being allowed to attend)).",
"output": "∀x ((¬SubmittedForm(x) → ¬Registered(x)) → ((¬SubmittedForm(x) → ¬Registered(x)) → (Registered(x) → AllowedToAttend(x))))"
},
{
"input": "Translate into first-order logic: If a person is not allowed to attend the seminar, then they did not register.",
"output": "∀x (¬AllowedToAttend(x) → ¬Registered(x))"
},
{
"input": "Translate into first-order logic: There exists someone who submitted the seminar participation form.",
"output": "∃x (SubmittedForm(x))"
},
{
"input": "Translate into first-order logic: If a person attends the English club, then they improve English communication skills.",
"output": "∀x (AttendsClub(x) → ImprovesCommunication(x))"
},
{
"input": "Translate into first-order logic: There exists someone who signed up for the English club.",
"output": "∃x (SignedUpForClub(x))"
},
{
"input": "Translate into first-order logic: Everyone attends the English club.",
"output": "∀x (AttendsClub(x))"
},
{
"input": "Translate into first-order logic: If everyone attends the English club, then if a person attends the club, they improve their communication skills.",
"output": "∀x (∀y (AttendsClub(y)) → (AttendsClub(x) → ImprovesCommunication(x)))"
},
{
"input": "Translate into first-order logic: If (a person attending the club implies they improve their communication), then someone has signed up for the club.",
"output": "∀x ((AttendsClub(x) → ImprovesCommunication(x)) → ∃y (SignedUpForClub(y)))"
},
{
"input": "Translate into first-order logic: Everyone improves their English communication skills.",
"output": "∀x (ImprovesCommunication(x))"
},
{
"input": "Translate into first-order logic: If a person was invited by a teacher, then they attend the English club.",
"output": "∀x (InvitedByTeacher(x) → AttendsClub(x))"
},
{
"input": "Translate into first-order logic: There exists someone who is eligible for the exchange program.",
"output": "∃x (Eligible(x))"
},
{
"input": "Translate into first-order logic: If a person applied for the exchange opportunity, then they are eligible for the exchange program.",
"output": "∀x (Applied(x) → Eligible(x))"
},
{
"input": "Translate into first-order logic: If a person is not eligible, then they were not selected for the exchange program.",
"output": "∀x (¬Eligible(x) → ¬Selected(x))"
},
{
"input": "Translate into first-order logic: If (a person applying implies they are eligible), then (a person not eligible implies they were not selected).",
"output": "∀x ((Applied(x) → Eligible(x)) → (¬Eligible(x) → ¬Selected(x)))"
},
{
"input": "Translate into first-order logic: If ((a person applying implies eligibility) implies (not eligible implies not selected)), then (a person applying implies eligibility).",
"output": "∀x (((Applied(x) → Eligible(x)) → (¬Eligible(x) → ¬Selected(x))) → (Applied(x) → Eligible(x)))"
},
{
"input": "Translate into first-order logic: If a person did not apply, then they were not contacted by the international office.",
"output": "∀x (¬Applied(x) → ¬Contacted(x))"
},
{
"input": "Translate into first-order logic: If a person did not complete all required documents, then they did not apply.",
"output": "∀x (¬CompletedDocuments(x) → ¬Applied(x))"
},
{
"input": "Translate into first-order logic: If a person did not participate in organizing the cultural festival, then they did not present any performance or exhibit.",
"output": "∀x (¬ParticipatedInOrganizing(x) → ¬Presented(x))"
},
{
"input": "Translate into first-order logic: There exists someone who learned about different cultures through the festival.",
"output": "∃x (LearnedAboutCultures(x))"
},
{
"input": "Translate into first-order logic: There exists someone who attended the cultural festival.",
"output": "∃x (AttendedFestival(x))"
},
{
"input": "Translate into first-order logic: If someone attended the cultural festival, then someone learned about different cultures.",
"output": "∃x (AttendedFestival(x))"
},
{
"input": "Translate into first-order logic: If (a person not participating in organizing implies they did not present), then there exists someone who learned about different cultures.",
"output": "∀x ((¬ParticipatedInOrganizing(x) → ¬Presented(x)) → ∃y (LearnedAboutCultures(y)))"
},
{
"input": "Translate into first-order logic: If a person participated in organizing the festival, then they developed teamwork skills.",
"output": "∀x (ParticipatedInOrganizing(x) → DevelopedTeamworkSkills(x))"
},
{
"input": "Translate into first-order logic: Everyone learned about different cultures through the festival.",
"output": "∀x (LearnedAboutCultures(x))"
},
{
"input": "Translate into first-order logic: If a person did not do regular exercise, then they did not receive bonus points.",
"output": "∀x (¬DidRegularExercise(x) → ¬ReceivedBonusPoints(x))"
},
{
"input": "Translate into first-order logic: If a person did not follow the school’s physical activity schedule, then they did not avoid penalty points.",
"output": "∀x (¬FollowedActivitySchedule(x) → ¬AvoidedPenaltyPoints(x))"
},
{
"input": "Translate into first-order logic: Everyone received bonus points.",
"output": "∀x (ReceivedBonusPoints(x))"
},
{
"input": "Translate into first-order logic: If everyone received bonus points, then if a person did not follow the activity schedule, they did not avoid penalty points.",
"output": "∀x (∀y (ReceivedBonusPoints(y)) → (¬FollowedActivitySchedule(x) → ¬AvoidedPenaltyPoints(x)))"
},
{
"input": "Translate into first-order logic: If (a person not following the activity schedule implies they did not avoid penalties), then everyone received bonus points.",
"output": "∀x ((¬FollowedActivitySchedule(x) → ¬AvoidedPenaltyPoints(x)) → ∀y (ReceivedBonusPoints(y)))"
},
{
"input": "Translate into first-order logic: All individuals are students.",
"output": "∀x (Student(x))"
},
{
"input": "Translate into first-order logic: If a person did not submit the exercise log, then they did not receive bonus points.",
"output": "∀x (¬SubmittedExerciseLog(x) → ¬ReceivedBonusPoints(x))"
},
{
"input": "Translate into first-order logic: All students are active in school activities.",
"output": "∀x (Student(x) → ActiveInSchoolActivities(x))"
},
{
"input": "Translate into first-order logic: If a person participated in the school’s leadership skills workshop, then they improved their teamwork ability.",
"output": "∀x (ParticipatedInWorkshop(x) → ImprovedTeamwork(x))"
},
{
"input": "Translate into first-order logic: If a person did not participate in the leadership workshop, then they did not lead a team project in class.",
"output": "∀x (¬ParticipatedInWorkshop(x) → ¬LedTeamProject(x))"
},
{
"input": "Translate into first-order logic: If (participating in the workshop implies teamwork improvement), then (not participating implies not leading a team project).",
"output": "∀x ((ParticipatedInWorkshop(x) → ImprovedTeamwork(x)) → (¬ParticipatedInWorkshop(x) → ¬LedTeamProject(x)))"
},
{
"input": "Translate into first-order logic: If all students are active in school activities, then participating in the workshop implies teamwork improvement.",
"output": "∀x (∀y (ActiveInSchoolActivities(y)) → (ParticipatedInWorkshop(x) → ImprovedTeamwork(x)))"
},
{
"input": "Translate into first-order logic: There exists someone who received positive feedback from peers.",
"output": "∃x (ReceivedPositiveFeedback(x))"
},
{
"input": "Translate into first-order logic: If a person did not improve their teamwork ability, then they were not selected to represent the class in a school event.",
"output": "∀x (¬ImprovedTeamwork(x) → ¬SelectedToRepresent(x))"
},
{
"input": "Translate into first-order logic: All individuals attend soft skill seminars.",
"output": "∀x (AttendsSeminar(x))"
},
{
"input": "Translate into first-order logic: If a person learns new soft skills in the seminar, then they improve their communication or leadership skills.",
"output": "∀x (LearnedNewSkills(x) → (ImprovedCommunication(x) ∨ ImprovedLeadership(x)))"
},
{
"input": "Translate into first-order logic: If a person did not participate in the previous seminar, then they did not learn new soft skills in the seminar.",
"output": "∀x (¬ParticipatedInPreviousSeminar(x) → ¬LearnedNewSkills(x))"
},
{
"input": "Translate into first-order logic: If (not participating in the previous seminar implies not learning new skills), then (learning new skills implies improving communication or leadership skills).",
"output": "∀x ((¬ParticipatedInPreviousSeminar(x) → ¬LearnedNewSkills(x)) → (LearnedNewSkills(x) → (ImprovedCommunication(x) ∨ ImprovedLeadership(x))))"
},
{
"input": "Translate into first-order logic: If all individuals attend soft skill seminars, then learning new skills implies improving communication or leadership skills.",
"output": "∀x (∀y (AttendsSeminar(y)) → (LearnedNewSkills(x) → (ImprovedCommunication(x) ∨ ImprovedLeadership(x))))"
},
{
"input": "Translate into first-order logic: Everyone learns new soft skills in the seminar.",
"output": "∀x (LearnedNewSkills(x))"
},
{
"input": "Translate into first-order logic: If a person participated in the seminar, then they successfully apply the soft skills in their daily activities.",
"output": "∀x (ParticipatedInSeminar(x) → SuccessfullyAppliedSkills(x))"
},
{
"input": "Translate into first-order logic: All students attend the course.",
"output": "∀x (Student(x) → AttendsCourse(x))"
},
{
"input": "Translate into first-order logic: There exists someone who attended the midterm exam.",
"output": "∃x (AttendedMidterm(x))"
},
{
"input": "Translate into first-order logic: If a person did not complete the required attendance, then they did not attend the course.",
"output": "∀x (¬CompletedAttendance(x) → ¬AttendsCourse(x))"
},
{
"input": "Translate into first-order logic: If all students attend the course, then (not completing attendance implies not attending the course).",
"output": "∀x (∀y (AttendsCourse(y)) → (¬CompletedAttendance(x) → ¬AttendsCourse(x)))"
},
{
"input": "Translate into first-order logic: If there exists someone who attended the midterm exam, then all students attend the course.",
"output": "∃x (AttendedMidterm(x))"
},
{
"input": "Translate into first-order logic: If a person did not attend the course, then they did not attend the final exam.",
"output": "∀x (¬AttendsCourse(x) → ¬AttendedFinal(x))"
},
{
"input": "Translate into first-order logic: There exists someone who attended the final exam.",
"output": "∃x (AttendedFinal(x))"
},
{
"input": "Translate into first-order logic: There exists someone who lends money to a friend.",
"output": "∃x (LendsMoney(x))"
},
{
"input": "Translate into first-order logic: If a person has the maturity to lend money, then they lend money to a friend.",
"output": "∀x (HasMaturityToLend(x) → LendsMoney(x))"
},
{
"input": "Translate into first-order logic: If a person can make responsible financial decisions, then they are mature.",
"output": "∀x (CanMakeResponsibleDecisions(x) → Mature(x))"
},
{
"input": "Translate into first-order logic: If there exists someone who lends money to a friend, then (a person having the maturity to lend money implies they lend money to a friend).",
"output": "∃x (LendsMoney(x))"
},
{
"input": "Translate into first-order logic: If (someone lending money to a friend implies maturity), then a person lends money to a friend.",
"output": "∀x ((LendsMoney(x) → Mature(x)) → LendsMoney(x))"
},
{
"input": "Translate into first-order logic: If a person is reckless with money, then they cannot make responsible financial decisions.",
"output": "∀x (RecklessWithMoney(x) → ¬CanMakeResponsibleDecisions(x))"
},
{
"input": "Translate into first-order logic: If a person lends money to a friend, then they have learned from the experience.",
"output": "∀x (LendsMoney(x) → LearnedFromExperience(x))"
},
{
"input": "Translate into first-order logic: There exists someone who uses university facilities responsibly.",
"output": "∃x (UsesFacilitiesResponsibly(x))"
},
{
"input": "Translate into first-order logic: If a person has the maturity to use facilities responsibly, then they use university facilities responsibly.",
"output": "∀x (HasMaturityToUseFacilities(x) → UsesFacilitiesResponsibly(x))"
},
{
"input": "Translate into first-order logic: If a person understands the proper rules and usage of facilities, then they are mature in using them.",
"output": "∀x (UnderstandsRules(x) → MatureInUsingFacilities(x))"
},
{
"input": "Translate into first-order logic: If there exists someone who uses university facilities responsibly, then (a person having the maturity to use facilities responsibly implies they use them responsibly).",
"output": "∃x (UsesFacilitiesResponsibly(x))"
},
{
"input": "Translate into first-order logic: If (using facilities responsibly implies maturity), then a person uses university facilities responsibly.",
"output": "∀x ((UsesFacilitiesResponsibly(x) → MatureInUsingFacilities(x)) → UsesFacilitiesResponsibly(x))"
},
{
"input": "Translate into first-order logic: If a person misuses university facilities, then they cannot understand the proper rules and usage.",
"output": "∀x (MisusesFacilities(x) → ¬UnderstandsRules(x))"
},
{
"input": "Translate into first-order logic: If a person uses university facilities responsibly, then they respect the university’s policies.",
"output": "∀x (UsesFacilitiesResponsibly(x) → RespectsPolicies(x))"
},
{
"input": "Translate into first-order logic: Everyone studies independently at home.",
"output": "∀x (StudiesIndependentlyAtHome(x))"
},
{
"input": "Translate into first-order logic: Everyone engages in self-study regularly.",
"output": "∀x (EngagesInSelfStudy(x))"
},
{
"input": "Translate into first-order logic: There exists someone who has the discipline to self-study at home.",
"output": "∃x (HasDisciplineToSelfStudy(x))"
},
{
"input": "Translate into first-order logic: If there exists someone with the discipline to self-study at home, then everyone studies independently at home.",
"output": "∃x (HasDisciplineToSelfStudy(x))"
},
{
"input": "Translate into first-order logic: If everyone engages in self-study regularly, then there exists someone who has the discipline to self-study at home.",
"output": "∀x (EngagesInSelfStudy(x)) → ∃y (HasDisciplineToSelfStudy(y))"
},
{
"input": "Translate into first-order logic: If a person does not engage in self-study regularly, then they do not improve their academic performance.",
"output": "∀x (¬EngagesInSelfStudy(x) → ¬ImprovesAcademicPerformance(x))"
},
{
"input": "Translate into first-order logic: If a person does not study independently at home, then they do not improve their academic performance.",
"output": "∀x (¬StudiesIndependentlyAtHome(x) → ¬ImprovesAcademicPerformance(x))"
},
{
"input": "Translate into first-order logic: There exists a student who is allowed to borrow books from the library.",
"output": "∃x (Student(x) ∧ AllowedToBorrowBooks(x))"
},
{
"input": "Translate into first-order logic: If a person has not borrowed more than 5 books at once, then they are allowed to borrow books.",
"output": "∀x (¬BorrowedMoreThan5Books(x) → AllowedToBorrowBooks(x))"
},
{
"input": "Translate into first-order logic: If a person has permission to borrow books from the library, then they are a student allowed to borrow books.",
"output": "∀x (HasPermissionToBorrowBooks(x) → (Student(x) ∧ AllowedToBorrowBooks(x)))"
},
{
"input": "Translate into first-order logic: If (a person having permission to borrow books implies they are allowed to borrow books), then (not borrowing more than 5 books implies they are allowed to borrow books).",
"output": "∀x ((HasPermissionToBorrowBooks(x) → AllowedToBorrowBooks(x)) → (¬BorrowedMoreThan5Books(x) → AllowedToBorrowBooks(x)))"
},
{
"input": "Translate into first-order logic: If (a person having permission to borrow books implies being allowed to borrow books), then there exists a student who is allowed to borrow books.",
"output": "∀x ((HasPermissionToBorrowBooks(x) → AllowedToBorrowBooks(x)) → ∃y (Student(y) ∧ AllowedToBorrowBooks(y)))"
},
{
"input": "Translate into first-order logic: If a person does not have permission to borrow books, then they are not allowed to borrow books.",
"output": "∀x (¬HasPermissionToBorrowBooks(x) → ¬AllowedToBorrowBooks(x))"
},
{
"input": "Translate into first-order logic: If a person is not allowed to borrow books, then they have not borrowed more than 5 books.",
"output": "∀x (¬AllowedToBorrowBooks(x) → ¬BorrowedMoreThan5Books(x))"
},
{
"input": "Translate into first-order logic: If a person is participating in the buddy program, then they gain 5 bonus points and money.",
"output": "∀x (ParticipatesInBuddyProgram(x) → (GainsBonusPoints(x) ∧ GainsMoney(x)))"
},
{
"input": "Translate into first-order logic: All students are receiving help through the buddy program.",
"output": "∀x (Student(x) → ReceivesHelp(x))"
},
{
"input": "Translate into first-order logic: If a person is participating in the buddy program, then they are a student receiving help.",
"output": "∀x (ParticipatesInBuddyProgram(x) → (Student(x) ∧ ReceivesHelp(x)))"
},
{
"input": "Translate into first-order logic: If all students are receiving help, then if a person is participating in the buddy program, then they gain 5 bonus points and money.",
"output": "∀x (∀y (ReceivesHelp(y)) → (ParticipatesInBuddyProgram(x) → (GainsBonusPoints(x) ∧ GainsMoney(x))))"
},
{
"input": "Translate into first-order logic: If participating in the buddy program implies receiving help, then all students are receiving help.",
"output": "∀x ((ParticipatesInBuddyProgram(x) → ReceivesHelp(x)) → ∀y (ReceivesHelp(y)))"
},
{
"input": "Translate into first-order logic: There exists a student who gains 5 bonus points and money through the program.",
"output": "∃x ((Student(x) ∧ GainsBonusPoints(x) ∧ GainsMoney(x)))"
},
{
"input": "Translate into first-order logic: All students are participating in the buddy program.",
"output": "∀x (Student(x) → ParticipatesInBuddyProgram(x))"
},
{
"input": "Translate into first-order logic: All students are enrolled in the PE course.",
"output": "∀x (Student(x) → EnrolledInPE(x))"
},
{
"input": "Translate into first-order logic: If a person has not attended the PE course, then they are not attending the PE course this semester.",
"output": "∀x (¬AttendedPE(x) → ¬AttendingPEThisSemester(x))"
},
{
"input": "Translate into first-order logic: There exists a student who is enrolled in the PE course.",
"output": "∃x (Student(x) ∧ EnrolledInPE(x))"
},
{
"input": "Translate into first-order logic: If (not attending the PE course implies not attending this semester), then there exists a student who is enrolled in the PE course.",
"output": "∀x ((¬AttendedPE(x) → ¬AttendingPEThisSemester(x)) → ∃y (Student(y) ∧ EnrolledInPE(y)))"
},
{
"input": "Translate into first-order logic: If (there exists a student in the PE course implies not attending the PE course), then (not attending implies not attending this semester).",
"output": "∀x ((∃y (Student(y) ∧ EnrolledInPE(y)) → ¬AttendedPE(x)) → (¬AttendedPE(x) → ¬AttendingPEThisSemester(x)))"
},
{
"input": "Translate into first-order logic: If a person has not attended the PE course, then they have not fulfilled all course requirements.",
"output": "∀x (¬AttendedPE(x) → ¬FulfilledRequirements(x))"
},
{
"input": "Translate into first-order logic: There exists a student who attended at least 2 PE courses during the 9 semesters.",
"output": "∃x (Student(x) ∧ AttendedAtLeast2PE(x))"
},
{
"input": "Translate into first-order logic: All students are enrolled in the PE course.",
"output": "∀x (Student(x) → EnrolledInPE(x))"
},
{
"input": "Translate into first-order logic: If a person has not attended the PE course, then they are not attending the PE course this semester.",
"output": "∀x (¬AttendedPE(x) → ¬AttendingPEThisSemester(x))"
},
{
"input": "Translate into first-order logic: There exists a student who is enrolled in the PE course.",
"output": "∃x (Student(x) ∧ EnrolledInPE(x))"
},
{
"input": "Translate into first-order logic: If (not attending the PE course implies not attending this semester), then there exists a student who is enrolled in the PE course.",
"output": "∀x ((¬AttendedPE(x) → ¬AttendingPEThisSemester(x)) → ∃y (Student(y) ∧ EnrolledInPE(y)))"
},
{
"input": "Translate into first-order logic: If (there exists a student in the PE course implies not attending the PE course), then (not attending implies not attending this semester).",
"output": "∀x ((∃y (Student(y) ∧ EnrolledInPE(y)) → ¬AttendedPE(x)) → (¬AttendedPE(x) → ¬AttendingPEThisSemester(x)))"
},
{
"input": "Translate into first-order logic: If a person has not attended the PE course, then they have not fulfilled all course requirements.",
"output": "∀x (¬AttendedPE(x) → ¬FulfilledRequirements(x))"
},
{
"input": "Translate into first-order logic: There exists a student who attended at least 2 PE courses during the 9 semesters.",
"output": "∃x (Student(x) ∧ AttendedAtLeast2PE(x))"
},
{
"input": "Translate into first-order logic: If a person has an English certificate, then they have at least 6.0 IELTS or a TOEFL score above 600.",
"output": "∀x (HasEnglishCertificate(x) → (IELTS(x) ≥ 6.0 ∨ TOEFL(x) > 600))"
},
{
"input": "Translate into first-order logic: There exists someone who has successfully obtained the English certificate.",
"output": "∃x (HasEnglishCertificate(x))"
},
{
"input": "Translate into first-order logic: Everyone is required to have the English certificate.",
"output": "∀x (RequiredToHaveEnglishCertificate(x))"
},
{
"input": "Translate into first-order logic: If there exists someone who has obtained the English certificate, then everyone is required to have the English certificate.",
"output": "∃x (HasEnglishCertificate(x))"
},
{
"input": "Translate into first-order logic: If (having an English certificate implies having at least 6.0 IELTS or a TOEFL score), then everyone is required to have the English certificate.",
"output": "∀x ((HasEnglishCertificate(x) → (IELTS(x) ≥ 6.0 ∨ TOEFL(x) > 600)) → ∀y (RequiredToHaveEnglishCertificate(y)))"
},
{
"input": "Translate into first-order logic: There exists someone who has completed the language proficiency test.",
"output": "∃x (CompletedLanguageProficiencyTest(x))"
},
{
"input": "Translate into first-order logic: There exists someone eligible for a language proficiency scholarship.",
"output": "∃x (EligibleForLanguageScholarship(x))"
},
{
"input": "Translate into first-order logic: There exists someone who has obtained both MOS certifications in Word and Excel.",
"output": "∃x HasBothCertifications(x)"
},
{
"input": "Translate into first-order logic: If x did not register for the seminar, then x is not allowed to submit the report.",
"output": "∀x (¬RegisteredSeminar(x) → ¬AllowedSubmitReport(x))"
},
{
"input": "Translate into first-order logic: If x registered for the seminar, then x has completed all requirements to register for the seminar.",
"output": "∀x (RegisteredSeminar(x) → CompletedRequirements(x))"
},
{
"input": "Translate into first-order logic: If x did not submit the required report, then x is not allowed to submit the report for the seminar.",
"output": "∀x (¬SubmittedReport(x) → ¬AllowedSubmitReport(x))"
},
{
"input": "Translate into first-order logic: If x is eligible to attend the seminar, then x has the required certifications.",
"output": "∀x (EligibleSeminar(x) → HasBothCertifications(x))"
},
{
"input": "Translate into first-order logic: If x does not attend the orientation, then x is not eligible to register for the next academic year",
"output": "∀x (¬AttendsOrientation(x) → ¬EligibleToRegister(x))"
},
{
"input": "Translate into first-order logic: All students are required to attend the orientation",
"output": "∀x (Student(x) → RequiredToAttend(x))"
},
{
"input": "Translate into first-order logic: If all students are required to attend the orientation, then if x does not attend, then x is not eligible to register",
"output": "∀x (Student(x) → RequiredToAttend(x))"
},
{
"input": "Translate into first-order logic: If (all students required to attend implies non-attendance leads to ineligibility), then non-attendance leads to ineligibility",
"output": "(∀x (Student(x) → RequiredToAttend(x)) → ∀x (¬AttendsOrientation(x) → ¬EligibleToRegister(x))) → ∀x (¬AttendsOrientation(x) → ¬EligibleToRegister(x))"
},
{
"input": "Translate into first-order logic: If a student is not required to attend the orientation, then they are not eligible to register",
"output": "∀x (Student(x) ∧ ¬RequiredToAttend(x) → ¬EligibleToRegister(x))"
},
{
"input": "Translate into first-order logic: If x is not required to attend the healthcare appointment, then x does not attend the appointment",
"output": "∀x (¬RequiredToAttend(x) → ¬AttendsAppointment(x))"
},
{
"input": "Translate into first-order logic: If x is not eligible for healthcare services, then x is not registered for healthcare services",
"output": "∀x (¬EligibleForServices(x) → ¬RegisteredForServices(x))"
},
{
"input": "Translate into first-order logic: All individuals are required to attend the healthcare appointment",
"output": "∀x (RequiredToAttend(x))"
},
{
"input": "Translate into first-order logic: If (not required to attend the appointment implies not attending), then all individuals are required to attend the appointment",
"output": "∀x (¬RequiredToAttend(x) → ¬AttendsAppointment(x))"
},
{
"input": "Translate into first-order logic: If (not required to attend implies not attending) then all individuals must attend the appointment",
"output": "∀x (¬RequiredToAttend(x) → ¬AttendsAppointment(x))"
},
{
"input": "Translate into first-order logic: If x is required to attend the appointment, then x is eligible for healthcare services",
"output": "∀x (RequiredToAttend(x) → EligibleForServices(x))"
},
{
"input": "Translate into first-order logic: Everyone is registered for healthcare services",
"output": "∀x (RegisteredForServices(x))"
},
{
"input": "Translate into first-order logic: If x attends the lab for the subject, then x is required to attend the lab for the subject.",
"output": "∀x (A(x) → R(x))"
},
{
"input": "Translate into first-order logic: There exists a student who is enrolled in the subject.",
"output": "∃x (S(x) ∧ E(x))"
},
{
"input": "Translate into first-order logic: If (being enrolled in the subject implies attending the lab), then (not being enrolled implies not attending the lab).",
"output": "(∀x (E(x) → A(x))) → ∀x (¬E(x) → ¬A(x)))"
},
{
"input": "Translate into first-order logic: If x attends the lab, then x completes the subject successfully.",
"output": "∀x (A(x) → C(x))"
},
{
"input": "Translate into first-order logic: If x attends the lab, then x is enrolled in the subject.",
"output": "∀x (A(x) → E(x)))"
},
{
"input": "Translate into first-order logic: There exists a student who actively searches for lectures to help in studying.",
"output": "∃x (S(x) ∧ A(x))"
},
{
"input": "Translate into first-order logic: All students are actively engaged in studying.",
"output": "∀x (S(x) → E(x))"
},
{
"input": "Translate into first-order logic: There exists a student who successfully finds lectures to help in studying.",
"output": "∃x (S(x) ∧ F(x))"
},
{
"input": "Translate into first-order logic: If a student actively searches for lectures, then they successfully find them.",
"output": "∀x ((S(x) ∧ A(x)) → F(x))"
},
{
"input": "Translate into first-order logic: If x attends classes regularly, then x improves their understanding by finding lectures.",
"output": "∀x (C(x) → (I(x) ∧ F(x)))"
},
{
"input": "Translate into first-order logic: If x does not improve their understanding, then x has not found lectures to help in studying.",
"output": "∀x (¬I(x) → ¬F(x))"
},
{
"input": "Translate into first-order logic: There exists a student who has received the company stamp for their internship.",
"output": "∃x (S(x) ∧ T(x))"
},
{
"input": "Translate into first-order logic: There exists a student who has received feedback from the company for their internship.",
"output": "∃x (S(x) ∧ F(x))"
},
{
"input": "Translate into first-order logic: If x completes the necessary internship requirements, then x has received the company stamp for their internship.",
"output": "∀x (C(x) → T(x))"
},
{
"input": "Translate into first-order logic: If x completes the necessary internship requirements, then x has received feedback from the company.",
"output": "∀x (C(x) → F(x))"
},
{
"input": "Translate into first-order logic: If x has received the company stamp, then x has received feedback from the company.",
"output": "∀x (T(x) → F(x))"
},
{
"input": "Translate into first-order logic: If x has not paid the fees, then x raised an issue about paying fees.",
"output": "∀x (¬P(x) → I(x))"
},
{
"input": "Translate into first-order logic: All students have paid the fees.",
"output": "∀x (S(x) → P(x))"
},
{
"input": "Translate into first-order logic: All students are required to pay the fees.",
"output": "∀x (S(x) → R(x))"
},
{
"input": "Translate into first-order logic: If x completed the payment, then x received confirmation of payment.",
"output": "∀x (C(x) → F(x))"
},
{
"input": "Translate into first-order logic: If x did not pay the fees, then x is not eligible for training.",
"output": "∀x (¬P(x) → ¬T(x))"
},
{
"input": "Translate into first-order logic: All students complete exercises.",
"output": "∀x (S(x) → E(x))"
},
{
"input": "Translate into first-order logic: All students complete assignments.",
"output": "∀x (S(x) → A(x))"
},
{
"input": "Translate into first-order logic: If x has completed all course activities, then x has passed the course.",
"output": "∀x (C(x) → P(x))"
},
{
"input": "Translate into first-order logic: If x does not donate blood on the university campus, then x does not receive social work points for graduation.",
"output": "∀x (¬D(x) → ¬P(x))"
},
{
"input": "Translate into first-order logic: If x is not involved in social work, then x does not donate blood on the university campus.",
"output": "∀x (¬W(x) → ¬D(x))"
},
{
"input": "Translate into first-order logic: If x is eligible for receiving social work points, then x is involved in social work activities.",
"output": "∀x (E(x) → W(x))"
},
{
"input": "Translate into first-order logic: All students donate blood on the university campus.",
"output": "∀x (S(x) → D(x))"
},
{
"input": "Translate into first-order logic: If x participates in university activities, then x earns graduation points.",
"output": "∀x (A(x) → G(x))"
},
{
"input": "Translate into first-order logic: All students pay the required fees within the specified period.",
"output": "∀x (S(x) → P(x))"
},
{
"input": "Translate into first-order logic: If x does not pay the required fees, then x is not allowed to continue studies at the university.",
"output": "∀x (¬P(x) → ¬C(x))"
},
{
"input": "Translate into first-order logic: If x is not allowed to continue studying, then x has not paid the fees.",
"output": "∀x (¬C(x) → ¬P(x))"
},
{
"input": "Translate into first-order logic: All students have completed all quizzes.",
"output": "∀x (S(x) → Q(x))"
},
{
"input": "Translate into first-order logic: If x finishes all quizzes, then x is eligible for the final exam.",
"output": "∀x (Q(x) → E(x))"
},
{
"input": "Translate into first-order logic: If x completes all course requirements, then x is eligible for the final exam.",
"output": "∀x (C(x) → E(x))"
},
{
"input": "Translate into first-order logic: If x has not completed all course requirements, then x has not completed all quizzes.",
"output": "∀x (¬C(x) → ¬Q(x))"
},
{
"input": "Translate into first-order logic: If x has not finished all quizzes, then x is not eligible for the final exam.",
"output": "∀x (¬Q(x) → ¬E(x))"
},
{
"input": "Translate into first-order logic: All students are required to wear a blouse in the chemistry lab.",
"output": "∀x (S(x) → B(x))"
},
{
"input": "Translate into first-order logic: If x is enrolled in the chemistry course, then x has met the safety requirements for the lab.",
"output": "∀x (E(x) → R(x))"
},
{
"input": "Translate into first-order logic: All students are enrolled in the chemistry course.",
"output": "∀x (S(x) → E(x))"
},
{
"input": "Translate into first-order logic: If x does not wear a blouse, then x is not enrolled in the chemistry course.",
"output": "∀x (¬B(x) → ¬E(x))"
},
{
"input": "Translate into first-order logic: There exists a student who is careful with the food at the university canteen.",
"output": "∃x (S(x) ∧ C(x))"
},
{
"input": "Translate into first-order logic: If x does not consume food at the canteen, then x does not get sick from eating the food.",
"output": "∀x (¬E(x) → ¬K(x))"
},
{
"input": "Translate into first-order logic: There exists a student who eats food from the canteen.",
"output": "∃x (S(x) ∧ E(x))"
},
{
"input": "Translate into first-order logic: If x is not careful with the food, then x is not careful with the food at the university canteen.",
"output": "∀x (¬F(x) → ¬C(x))"
},
{
"input": "Translate into first-order logic: If x is enrolled in a course, then x completes the course successfully.",
"output": "∀x (E(x) → C(x))"
},
{
"input": "Translate into first-order logic: All students complete the course successfully.",
"output": "∀x (S(x) → C(x))"
},
{
"input": "Translate into first-order logic: There exists a student who is eligible for graduation.",
"output": "∃x (S(x) ∧ G(x))"
},
{
"input": "Translate into first-order logic: If x has completed all course requirements, then x is eligible for graduation.",
"output": "∀x (R(x) → G(x))"
},
{
"input": "Translate into first-order logic: There exists a student who is enrolled in a course.",
"output": "∃x (S(x) ∧ E(x))"
},
{
"input": "Translate into first-order logic: If x is enrolled in a course, then x has passed the course.",
"output": "∀x (E(x) → P(x))"
},
{
"input": "Translate into first-order logic: If x has not completed the prerequisite for the course, then x is not eligible for the next course.",
"output": "∀x (¬R(x) → ¬N(x))"
},
{
"input": "Translate into first-order logic: If x is working on a project, then x completes the project successfully.",
"output": "∀x (W(x) → C(x))"
},
{
"input": "Translate into first-order logic: All students use the library from 12:00 PM to 1:00 PM for sleeping.",
"output": "∀x (S(x) → U(x))"
},
{
"input": "Translate into first-order logic: If x uses the library for sleeping, then x sleeps in the library during the designated time.",
"output": "∀x (U(x) → L(x))"
},
{
"input": "Translate into first-order logic: If x does not use the library for sleeping, then x is not allowed to sleep in the library.",
"output": "∀x (¬U(x) → ¬A(x))"
},
{
"input": "Translate into first-order logic: If x is not enrolled in the university, then x does not complete their studies successfully",
"output": "∀x (¬E(x) → ¬C(x))"
},
{
"input": "Translate into first-order logic: There exists a student who is enrolled in the university",
"output": "∃x (S(x) ∧ E(x))"
},
{
"input": "Translate into first-order logic: All students are actively studying",
"output": "∀x (S(x) → A(x))"
},
{
"input": "Translate into first-order logic: All students attend all required lectures",
"output": "∀x (S(x) → L(x))"
},
{
"input": "Translate into first-order logic: All individuals are engaged in educational activities",
"output": "∀x E(x)"
},
{
"input": "Translate into first-order logic: If x does not complete assignments, then x has not successfully completed a task or requirement",
"output": "∀x (¬A(x) → ¬T(x))"
},
{
"input": "Translate into first-order logic: All individuals have successfully completed tasks or requirements",
"output": "∀x T(x)"
},
{
"input": "Translate into first-order logic: If x is enrolled in a course, then x is engaged in an educational activity",
"output": "∀x (C(x) → E(x))"
},
{
"input": "Translate into first-order logic: There exists an individual enrolled in a course",
"output": "∃x C(x)"
},
{
"input": "Translate into first-order logic: There exists a student who is applying for a scholarship",
"output": "∃x (S(x) ∧ A(x))"
},
{
"input": "Translate into first-order logic: If x has not completed all required tasks for the scholarship, then x has not received a scholarship",
"output": "∀x (¬T(x) → ¬R(x))"
},
{
"input": "Translate into first-order logic: If x is applying for a scholarship, then x has received a scholarship",
"output": "∀x (A(x) → R(x))"
},
{
"input": "Translate into first-order logic: There exists a student who has completed all required tasks for the scholarship",
"output": "∃x (S(x) ∧ T(x))"
},
{
"input": "Translate into first-order logic: If x is eligible for the scholarship, then x has received a scholarship",
"output": "∀x (E(x) → R(x))"
},
{
"input": "Translate into first-order logic: If x is not studying offline, then x does not successfully complete offline study tasks",
"output": "∀x (¬F(x) → ¬T(x))"
},
{
"input": "Translate into first-order logic: If x is not studying online, then x does not successfully complete online study tasks",
"output": "∀x (¬N(x) → ¬O(x))"
},
{
"input": "Translate into first-order logic: There exists a student who successfully completes offline study tasks",
"output": "∃x (S(x) ∧ T(x))"
},
{
"input": "Translate into first-order logic: If x is studying online, then x is able to effectively manage offline and online study time",
"output": "∀x (N(x) → M(x))"
},
{
"input": "Translate into first-order logic: If x is not successfully completing offline study tasks, then x is not completing online study tasks",
"output": "∀x (¬T(x) → ¬O(x))"
},
{
"input": "Translate into first-order logic: If x is not studying offline, then x does not successfully complete offline study tasks",
"output": "∀x (¬F(x) → ¬T(x))"
},
{
"input": "Translate into first-order logic: If x is not studying online, then x does not successfully complete online study tasks",
"output": "∀x (¬N(x) → ¬O(x))"
},
{
"input": "Translate into first-order logic: There exists a student who successfully completes offline study tasks",
"output": "∃x (S(x) ∧ T(x))"
},
{
"input": "Translate into first-order logic: If x is studying online, then x is able to effectively manage offline and online study time",
"output": "∀x (N(x) → M(x))"
},
{
"input": "Translate into first-order logic: If x is not successfully completing offline study tasks, then x is not completing online study tasks",
"output": "∀x (¬T(x) → ¬O(x))"
},
{
"input": "Translate into first-order logic: If a student lacks training, then they lack problem-solving skills.",
"output": "∀x (Student(x) ∧ ¬ParticipatesTraining(x) → ¬ProblemSolvingSkills(x))"
},
{
"input": "Translate into first-order logic: All students are undergoing training.",
"output": "∀x (Student(x) → ParticipatesTraining(x))"
},
{
"input": "Translate into first-order logic: If a student has problem-solving skills, then they have foundational knowledge.",
"output": "∀x (Student(x) ∧ ProblemSolvingSkills(x) → FoundationalKnowledge(x))"
},
{
"input": "Translate into first-order logic: If a student has university readiness, then they have problem-solving skills.",
"output": "∀x (Student(x) ∧ UniversityReady(x) → ProblemSolvingSkills(x))"
},
{
"input": "Translate into first-order logic: If a student has training, then they have skills.",
"output": "∀x (Student(x) ∧ Training(x) → Skills(x))"
},
{
"input": "Translate into first-order logic: All students have training.",
"output": "∀x (Student(x) → Training(x))"
},
{
"input": "Translate into first-order logic: Some students have reasoning skills if any student has skills.",
"output": "∀x (Student(x) ∧ Skills(x) → ∃y (Student(y) ∧ ReasoningSkills(y)))"
},
{
"input": "Translate into first-order logic: All students have proficiency.",
"output": "∀x (Student(x) → Proficiency(x))"
},
{
"input": "Translate into first-order logic: If a student has proficiency, then they have qualifications.",
"output": "∀x (Student(x) ∧ Proficiency(x) → Qualifications(x))"
},
{
"input": "Translate into first-order logic: If a student lacks qualifications, then they lack understanding.",
"output": "∀x (Student(x) ∧ ¬Qualifications(x) → ¬Understanding(x))"
},
{
"input": "Translate into first-order logic: If a student has training, then they have skills.",
"output": "∀x (Student(x) ∧ Training(x) → Skills(x))"
},
{
"input": "Translate into first-order logic: All students have training.",
"output": "∀x (Student(x) → Training(x))"
},
{
"input": "Translate into first-order logic: Some students have reasoning skills if any student has skills.",
"output": "∀x (Student(x) ∧ Skills(x) → ∃y (Student(y) ∧ ReasoningSkills(y)))"
},
{
"input": "Translate into first-order logic: All students have proficiency.",
"output": "∀x (Student(x) → Proficiency(x))"
},
{
"input": "Translate into first-order logic: If a student has proficiency, then they have qualifications.",
"output": "∀x (Student(x) ∧ Proficiency(x) → Qualifications(x))"
},
{
"input": "Translate into first-order logic: If a student lacks qualifications, then they lack understanding.",
"output": "∀x (Student(x) ∧ ¬Qualifications(x) → ¬Understanding(x))"
},
{
"input": "Translate into first-order logic: All students receive training.",
"output": "∀x Student(x) → ReceivesTraining(x)"
},
{
"input": "Translate into first-order logic: If a student does not receive training, then they do not have a research foundation.",
"output": "∀x (¬ReceivesTraining(x) → ¬ResearchFoundation(x))"
},
{
"input": "Translate into first-order logic: At least one student has completed a course.",
"output": "∃x CompletedCourse(x)"
},
{
"input": "Translate into first-order logic: At least one student is certified.",
"output": "∃x Certified(x)"
},
{
"input": "Translate into first-order logic: If a student does not receive training, then they do not have pedagogical skills.",
"output": "∀x (¬ReceivesTraining(x) → ¬PedagogicalSkills(x))"
},
{
"input": "Translate into first-order logic: If a student does not receive training, then they are not certified.",
"output": "∀x (¬ReceivesTraining(x) → ¬Certified(x))"
},
{
"input": "Translate into first-order logic: If a student lacks pedagogical skills, then they cannot teach.",
"output": "∀x (¬PedagogicalSkills(x) → ¬CanTeach(x))"
},
{
"input": "Translate into first-order logic: If a student is not certified, then they cannot teach.",
"output": "∀x (¬Certified(x) → ¬CanTeach(x))"
},
{
"input": "Translate into first-order logic: If a student has pedagogical skills, then they have received training.",
"output": "∀x (PedagogicalSkills(x) → ReceivesTraining(x))"
},
{
"input": "Translate into first-order logic: All students have pedagogical skills.",
"output": "∀x PedagogicalSkills(x)"
},
{
"input": "Translate into first-order logic: If a student cannot teach, then they lack a research foundation.",
"output": "∀x (¬CanTeach(x) → ¬ResearchFoundation(x))"
},
{
"input": "Translate into first-order logic: If at least one student is certified, then if a lack of research foundation leads to not being certified, then not being able to teach leads to a lack of research foundation.",
"output": "(∃x Certified(x)) → ((∀x (¬ResearchFoundation(x) → ¬Certified(x))) → (∀x (¬CanTeach(x) → ¬ResearchFoundation(x))))"
},
{
"input": "Translate into first-order logic: If a student has completed a course, then the above logical rule holds true.",
"output": "∀x (CompletedCourse(x) → ((∃x Certified(x)) → ((∀x (¬ResearchFoundation(x) → ¬Certified(x))) → (∀x (¬CanTeach(x) → ¬ResearchFoundation(x))))))"
},
{
"input": "Translate into first-order logic: All students are certified.",
"output": "∀x Certified(x)"
},
{
"input": "Translate into first-order logic: All students have knowledge.",
"output": "∀x Knowledge(x)"
},
{
"input": "Translate into first-order logic: At least one student conducts research.",
"output": "∃x ConductsResearch(x)"
},
{
"input": "Translate into first-order logic: If a student conducts research, then they publish papers.",
"output": "∀x (ConductsResearch(x) → PublishesPapers(x))"
},
{
"input": "Translate into first-order logic: At least one student publishes papers.",
"output": "∃x PublishesPapers(x)"
},
{
"input": "Translate into first-order logic: If a student teaches, then they conduct research.",
"output": "∀x (Teaches(x) → ConductsResearch(x))"
},
{
"input": "Translate into first-order logic: All students conduct research.",
"output": "∀x ConductsResearch(x)"
},
{
"input": "Translate into first-order logic: If a student has knowledge, then they teach.",
"output": "∀x (Knowledge(x) → Teaches(x))"
},
{
"input": "Translate into first-order logic: If a student does not publish papers, then they do not give seminars.",
"output": "∀x (¬PublishesPapers(x) → ¬GivesSeminars(x))"
},
{
"input": "Translate into first-order logic: If a student does not teach, then they do not understand the subject.",
"output": "∀x (¬Teaches(x) → ¬UnderstandsSubject(x))"
},
{
"input": "Translate into first-order logic: At least one student teaches.",
"output": "∃x Teaches(x)"
},
{
"input": "Translate into first-order logic: If a student publishes papers, then they conduct research.",
"output": "∀x (PublishesPapers(x) → ConductsResearch(x))"
},
{
"input": "Translate into first-order logic: At least one student has knowledge.",
"output": "∃x Knowledge(x)"
},
{
"input": "Translate into first-order logic: If having knowledge leads to teaching, then teaching leads to conducting research.",
"output": "(∀x (Knowledge(x) → Teaches(x))) → (∀x (Teaches(x) → ConductsResearch(x)))"
},
{
"input": "Translate into first-order logic: If at least one student teaches, then at least one student conducts research.",
"output": "(∃x Teaches(x)) → (∃x ConductsResearch(x))"
},
{
"input": "Translate into first-order logic: All students teach.",
"output": "∀x Teaches(x)"
},
{
"input": "Translate into first-order logic: If a student has knowledge, then they give seminars.",
"output": "∀x (Knowledge(x) → GivesSeminars(x))"
},
{
"input": "Translate into first-order logic: If a student completes prerequisite courses, then they are eligible for advanced training.",
"output": "∀x (C(x) → E(x))"
},
{
"input": "Translate into first-order logic: There exists at least one student who is eligible for advanced training.",
"output": "∃x E(x)"
},
{
"input": "Translate into first-order logic: There exists at least one student who has received a qualification.",
"output": "∃x P(x)"
},
{
"input": "Translate into first-order logic: If a student does not meet the requirements, then they do not receive a qualification.",
"output": "∀x (¬Q(x) → ¬P(x))"
},
{
"input": "Translate into first-order logic: If a student completes prerequisite courses, then they are able to conduct research.",
"output": "∀x (C(x) → R(x))"
},
{
"input": "Translate into first-order logic: If a student does not meet the requirements, then they do not engage in training.",
"output": "∀x (¬Q(x) → ¬T(x))"
},
{
"input": "Translate into first-order logic: All students complete prerequisite courses.",
"output": "∀x C(x)"
},
{
"input": "Translate into first-order logic: If a student meets the requirements, then they engage in independent learning.",
"output": "∀x (Q(x) → U(x))"
},
{
"input": "Translate into first-order logic: If a student meets the requirements, then they receive a qualification.",
"output": "∀x (Q(x) → P(x))"
},
{
"input": "Translate into first-order logic: If a student receives a qualification, then they meet the requirements.",
"output": "∀x (P(x) → Q(x))"
},
{
"input": "Translate into first-order logic: All students meet the requirements.",
"output": "∀x Q(x)"
},
{
"input": "Translate into first-order logic: If a student meets the requirements, then they engage in training.",
"output": "∀x (Q(x) → T(x))"
},
{
"input": "Translate into first-order logic: If the inability to meet the requirements leads to the inability to receive a qualification, then the inability to receive a qualification leads to the inability to conduct research.",
"output": "∀x ((¬Q(x) → ¬P(x)) → (¬P(x) → ¬R(x)))"
},
{
"input": "Translate into first-order logic: If the inability to engage in training leads to the inability to receive a qualification, then the inability to receive a qualification leads to the inability to conduct research.",
"output": "∀x ((¬T(x) → ¬P(x)) → (¬P(x) → ¬R(x)))"
},
{
"input": "Translate into first-order logic: If a student meets the requirements, then they engage in training.",
"output": "∀x (Q(x) → T(x))"
},
{
"input": "Translate into first-order logic: If a student completes prerequisite courses, then they can engage in training.",
"output": "∀x (C(x) → T(x))"
},
{
"input": "Translate into first-order logic: If a student does not receive a qualification, then they cannot conduct research.",
"output": "∀x (¬P(x) → ¬R(x))"
},
{
"input": "Translate into first-order logic: There exists at least one student who is engaged in training.",
"output": "∃x T(x)"
},
{
"input": "Translate into first-order logic: If a student does not meet the requirements, then they do not receive a qualification.",
"output": "∀x (¬Q(x) → ¬P(x))"
},
{
"input": "Translate into first-order logic: There exists at least one student who has received a qualification.",
"output": "∃x P(x)"
},
{
"input": "Translate into first-order logic: If a student does not receive a qualification, then they cannot participate in advanced seminars.",
"output": "∀x (¬P(x) → ¬S(x))"
},
{
"input": "Translate into first-order logic: If a student does not engage in independent learning, then they cannot conduct research.",
"output": "∀x (¬U(x) → ¬R(x))"
},
{
"input": "Translate into first-order logic: If a student is engaged in training, then they receive a qualification.",
"output": "∀x (T(x) → P(x))"
},
{
"input": "Translate into first-order logic: If a student engages in independent learning, then they meet the requirements.",
"output": "∀x (U(x) → Q(x))"
},
{
"input": "Translate into first-order logic: There exists at least one student who is participating in advanced seminars.",
"output": "∃x S(x)"
},
{
"input": "Translate into first-order logic: If a student does not receive a qualification, then they do not engage in independent learning.",
"output": "∀x (¬P(x) → ¬U(x))"
},
{
"input": "Translate into first-order logic: There exists at least one student who is conducting research.",
"output": "∃x R(x)"
},
{
"input": "Translate into first-order logic: All students receive qualifications.",
"output": "∀x P(x)"
},
{
"input": "Translate into first-order logic: If independent learning leads to meeting the requirements, then lack of qualification leads to inability to conduct research.",
"output": "∀x ((U(x) → Q(x)) → (¬P(x) → ¬R(x)))"
},
{
"input": "Translate into first-order logic: If the lack of meeting requirements leads to no qualification, then lack of qualification leads to no participation in advanced seminars.",
"output": "∀x ((¬Q(x) → ¬P(x)) → (¬P(x) → ¬S(x)))"
},
{
"input": "Translate into first-order logic: If a student does not participate in advanced seminars, then they cannot conduct research.",
"output": "∀x (¬S(x) → ¬R(x))"
},
{
"input": "Translate into first-order logic: All students are engaged in training.",
"output": "∀x T(x)"
},
{
"input": "Translate into first-order logic: All students must undergo training.",
"output": "∀x T(x)"
},
{
"input": "Translate into first-order logic: If a student is trained, then they can conduct research.",
"output": "∀x (T(x) → R(x))"
},
{
"input": "Translate into first-order logic: If a student is trained, then they can participate in a seminar.",
"output": "∀x (T(x) → U(x))"
},
{
"input": "Translate into first-order logic: All students are trained.",
"output": "∀x T(x)"
},
{
"input": "Translate into first-order logic: If a student conducts research, then they receive a qualification.",
"output": "∀x (R(x) → P(x))"
},
{
"input": "Translate into first-order logic: There exists at least one student who has received a qualification.",
"output": "∃x P(x)"
},
{
"input": "Translate into first-order logic: There exists at least one student who is trained.",
"output": "∃x T(x)"
},
{
"input": "Translate into first-order logic: All students conduct research.",
"output": "∀x R(x)"
},
{
"input": "Translate into first-order logic: There exists at least one student who is conducting research.",
"output": "∃x R(x)"
},
{
"input": "Translate into first-order logic: If a student does not participate in training, then they cannot conduct research.",
"output": "∀x (¬T(x) → ¬R(x))"
},
{
"input": "Translate into first-order logic: If a student does not participate in self-study, then they cannot conduct research.",
"output": "∀x (¬S(x) → ¬R(x))"
},
{
"input": "Translate into first-order logic: All students participate in self-study.",
"output": "∀x S(x)"
},
{
"input": "Translate into first-order logic: If participating in self-study leads to conducting research, then students who do not participate in self-study cannot conduct research.",
"output": "∀x ((S(x) → R(x)) → (¬S(x) → ¬R(x)))"
},
{
"input": "Translate into first-order logic: If participating in self-study leads to receiving qualifications, then students who do not participate in self-study cannot receive a qualification.",
"output": "∀x ((S(x) → P(x)) → (¬S(x) → ¬P(x)))"
},
{
"input": "Translate into first-order logic: If a student does not participate in self-study, they cannot participate in seminars.",
"output": "∀x (¬S(x) → ¬U(x))"
},
{
"input": "Translate into first-order logic: There exists at least one student who is participating in self-study.",
"output": "∃x S(x)"
},
{
"input": "Translate into first-order logic: All students engage in self-study.",
"output": "∀x S(x)"
},
{
"input": "Translate into first-order logic: If a student participates in research, then they publish papers.",
"output": "∀x (R(x) → U(x))"
},
{
"input": "Translate into first-order logic: If a student participates in research, then they engage in training.",
"output": "∀x (R(x) → T(x))"
},
{
"input": "Translate into first-order logic: All students engage in training.",
"output": "∀x T(x)"
},
{
"input": "Translate into first-order logic: If a student conducts research, then they receive a qualification.",
"output": "∀x (R(x) → P(x))"
},
{
"input": "Translate into first-order logic: There exists at least one student who has received a qualification.",
"output": "∃x P(x)"
},
{
"input": "Translate into first-order logic: There exists at least one student who is engaged in training.",
"output": "∃x T(x)"
},
{
"input": "Translate into first-order logic: All students receive a qualification.",
"output": "∀x P(x)"
},
{
"input": "Translate into first-order logic: There exists at least one student who is conducting research.",
"output": "∃x R(x)"
},
{
"input": "Translate into first-order logic: If a student does not engage in training, then they cannot participate in research.",
"output": "∀x (¬T(x) → ¬R(x))"
},
{
"input": "Translate into first-order logic: If a student does not engage in self-study, then they cannot receive a qualification.",
"output": "∀x (¬S(x) → ¬P(x))"
},
{
"input": "Translate into first-order logic: All students participate in self-study.",
"output": "∀x S(x)"
},
{
"input": "Translate into first-order logic: If training leads to receiving a qualification, then the inability to participate in self-study leads to the inability to receive a qualification.",
"output": "∀x ((T(x) → P(x)) → (¬S(x) → ¬P(x)))"
},
{
"input": "Translate into first-order logic: If the inability to engage in self-study leads to not receiving a qualification, then the inability to participate in training leads to the inability to conduct research.",
"output": "∀x ((¬S(x) → ¬P(x)) → (¬T(x) → ¬R(x)))"
},
{
"input": "Translate into first-order logic: If a student participates in self-study, then they are engaged in research.",
"output": "∀x (S(x) → R(x))"
},
{
"input": "Translate into first-order logic: If a student does not participate in self-study, then they cannot participate in training.",
"output": "∀x (¬S(x) → ¬T(x))"
},
{
"input": "Translate into first-order logic: If a student receives a qualification, then they engage in training.",
"output": "∀x (P(x) → T(x))"
},
{
"input": "Translate into first-order logic: If a student does not participate in self-study, then they cannot conduct research.",
"output": "∀x (¬S(x) → ¬R(x))"
},
{
"input": "Translate into first-order logic: If a student does not engage in independent learning, then they cannot conduct research.",
"output": "∀x (¬U(x) → ¬R(x))"
},
{
"input": "Translate into first-order logic: If a student participates in self-study, then they engage in independent learning.",
"output": "∀x (S(x) → U(x))"
},
{
"input": "Translate into first-order logic: All students engage in self-study.",
"output": "∀x S(x)"
},
{
"input": "Translate into first-order logic: If a student participates in research, then they receive a qualification.",
"output": "∀x (R(x) → P(x))"
},
{
"input": "Translate into first-order logic: If a student does not engage in independent learning, then they cannot participate in self-study.",
"output": "∀x (¬U(x) → ¬S(x))"
},
{
"input": "Translate into first-order logic: If a student participates in research, then they engage in self-study.",
"output": "∀x (R(x) → S(x))"
},
{
"input": "Translate into first-order logic: If a student receives a qualification, then they participate in self-study.",
"output": "∀x (P(x) → S(x))"
},
{
"input": "Translate into first-order logic: If a student does not engage in research, then they cannot receive a qualification.",
"output": "∀x (¬R(x) → ¬P(x))"
},
{
"input": "Translate into first-order logic: All students engage in research.",
"output": "∀x R(x)"
},
{
"input": "Translate into first-order logic: If a student does not participate in self-study, then they cannot engage in research.",
"output": "∀x (¬S(x) → ¬R(x))"
},
{
"input": "Translate into first-order logic: If a student does not participate in self-study, then they cannot receive a qualification.",
"output": "∀x (¬S(x) → ¬P(x))"
},
{
"input": "Translate into first-order logic: If a student does not participate in self-study, then they cannot participate in independent learning.",
"output": "∀x (¬S(x) → ¬U(x))"
},
{
"input": "Translate into first-order logic: If a student engages in research, then they receive a qualification.",
"output": "∀x (R(x) → P(x))"
},
{
"input": "Translate into first-order logic: If a student completes prerequisite courses, then they are eligible for advanced training.",
"output": "∀x (C(x) → T(x))"
},
{
"input": "Translate into first-order logic: There exists at least one student who has received a qualification.",
"output": "∃x Q(x)"
},
{
"input": "Translate into first-order logic: There exists at least one student who has completed prerequisite courses.",
"output": "∃x C(x)"
},
{
"input": "Translate into first-order logic: All students are required to undergo training.",
"output": "∀x T(x)"
},
{
"input": "Translate into first-order logic: All students participate in self-study.",
"output": "∀x S(x)"
},
{
"input": "Translate into first-order logic: There exists at least one student engaged in independent research.",
"output": "∃x R(x)"
},
{
"input": "Translate into first-order logic: If a student does not undergo training, then they cannot conduct research.",
"output": "∀x (¬T(x) → ¬R(x))"
},
{
"input": "Translate into first-order logic: If a student completes prerequisite courses, then they receive a qualification.",
"output": "∀x (C(x) → Q(x))"
},
{
"input": "Translate into first-order logic: If a student conducts research, then they engage in independent learning.",
"output": "∀x (R(x) → U(x))"
},
{
"input": "Translate into first-order logic: If a student does not undergo training, then they cannot engage in independent learning.",
"output": "∀x (¬T(x) → ¬U(x))"
},
{
"input": "Translate into first-order logic: All students must obtain qualifications.",
"output": "∀x Q(x)"
},
{
"input": "Translate into first-order logic: If a student undergoes training, then they participate in self-study.",
"output": "∀x (T(x) → S(x))"
},
{
"input": "Translate into first-order logic: If the inability to undergo training leads to the inability to conduct research, then at least one student must receive a qualification.",
"output": "(∀x (¬T(x) → ¬R(x))) → ∃x Q(x)"
},
{
"input": "Translate into first-order logic: If there exists at least one student engaged in independent research, then the inability to undergo training leads to the inability to conduct research.",
"output": "∃x R(x) → ∀x (¬T(x) → ¬R(x))"
},
{
"input": "Translate into first-order logic: If a student undergoes training, then they engage in independent learning.",
"output": "∀x (T(x) → U(x))"
},
{
"input": "Translate into first-order logic: If a student completes prerequisite courses, then they are able to conduct research.",
"output": "∀x (C(x) → R(x))"
},
{
"input": "Translate into first-order logic: There exists at least one student who participates in extracurricular activities.",
"output": "∃x E(x)"
},
{
"input": "Translate into first-order logic: All students participate in extracurricular activities.",
"output": "∀x E(x)"
},
{
"input": "Translate into first-order logic: There exists at least one student who has completed prerequisite courses.",
"output": "∃x C(x)"
},
{
"input": "Translate into first-order logic: If a student participates in extracurricular activities, then they engage in self-study.",
"output": "∀x (E(x) → S(x))"
},
{
"input": "Translate into first-order logic: All students engage in self-study.",
"output": "∀x S(x)"
},
{
"input": "Translate into first-order logic: If a student engages in self-study, then they develop critical thinking skills.",
"output": "∀x (S(x) → K(x))"
},
{
"input": "Translate into first-order logic: If a student does not undergo training, then they do not engage in self-study.",
"output": "∀x (¬T(x) → ¬S(x))"
},
{
"input": "Translate into first-order logic: If a student does not undergo training, then they cannot conduct research.",
"output": "∀x (¬T(x) → ¬R(x))"
},
{
"input": "Translate into first-order logic: There exists at least one student who conducts research.",
"output": "∃x R(x)"
},
{
"input": "Translate into first-order logic: If a student cannot conduct research, then they do not participate in extracurricular activities.",
"output": "∀x (¬R(x) → ¬E(x))"
},
{
"input": "Translate into first-order logic: If a student undergoes training, then they have completed prerequisite courses.",
"output": "∀x (T(x) → C(x))"
},
{
"input": "Translate into first-order logic: All students must complete prerequisite courses.",
"output": "∀x C(x)"
},
{
"input": "Translate into first-order logic: If there exists at least one student who participates in extracurricular activities, then the inability to undergo training leads to the inability to conduct research.",
"output": "∃x E(x) → ∀x (¬T(x) → ¬R(x))"
},
{
"input": "Translate into first-order logic: If participation in extracurricular activities leads to self-study, then all students must participate in extracurricular activities.",
"output": "(∀x (E(x) → S(x))) → ∀x E(x)"
},
{
"input": "Translate into first-order logic: All students engage in research.",
"output": "∀x R(x)"
},
{
"input": "Translate into first-order logic: All students undergo training.",
"output": "∀x T(x)"
},
{
"input": "Translate into first-order logic: All students engage in self-study.",
"output": "∀x S(x)"
},
{
"input": "Translate into first-order logic: All students undergo training.",
"output": "∀x T(x)"
},
{
"input": "Translate into first-order logic: There exists at least one student who engages in self-study.",
"output": "∃x S(x)"
},
{
"input": "Translate into first-order logic: All students participate in projects.",
"output": "∀x P(x)"
},
{
"input": "Translate into first-order logic: If a student does not undergo training, then they do not engage in extracurricular activities.",
"output": "∀x (¬T(x) → ¬E(x))"
},
{
"input": "Translate into first-order logic: If a student does not engage in self-study, then they do not undergo training.",
"output": "∀x (¬S(x) → ¬T(x))"
},
{
"input": "Translate into first-order logic: If a student participates in extracurricular activities, then they take part in projects.",
"output": "∀x (E(x) → P(x))"
},
{
"input": "Translate into first-order logic: There exists at least one student who undergoes training.",
"output": "∃x T(x)"
},
{
"input": "Translate into first-order logic: All students participate in extracurricular activities.",
"output": "∀x E(x)"
},
{
"input": "Translate into first-order logic: If a student participates in extracurricular activities, then they contribute to research.",
"output": "∀x (E(x) → R(x))"
},
{
"input": "Translate into first-order logic: If a student meets a certain qualification, then they engage in self-study.",
"output": "∀x (Q(x) → S(x))"
},
{
"input": "Translate into first-order logic: If a student contributes to research, then they engage in self-study.",
"output": "∀x (R(x) → S(x))"
},
{
"input": "Translate into first-order logic: If contributing to research leads to self-study, then participating in extracurricular activities leads to research involvement.",
"output": "∀x ((R(x) → S(x)) → (E(x) → R(x)))"
},
{
"input": "Translate into first-order logic: If all students participate in projects, then contributing to research leads to self-study.",
"output": "∀x P(x) → ∀x (R(x) → S(x))"
},
{
"input": "Translate into first-order logic: If a student engages in self-study, then they participate in extracurricular activities.",
"output": "∀x (S(x) → E(x))"
},
{
"input": "Translate into first-order logic: There exists at least one student who contributes to research.",
"output": "∃x R(x)"
},
{
"input": "Translate into first-order logic: If a student has training, then they have proficiency.",
"output": "∀x (T(x) → P(x))"
},
{
"input": "Translate into first-order logic: If a student lacks qualifications, then they lack proficiency.",
"output": "∀x (¬Q(x) → ¬P(x))"
},
{
"input": "Translate into first-order logic: All students have qualifications.",
"output": "∀x Q(x)"
},
{
"input": "Translate into first-order logic: If a student lacks understanding, then they lack skills.",
"output": "∀x (¬U(x) → ¬S(x))"
},
{
"input": "Translate into first-order logic: There exists at least one student with skills.",
"output": "∃x S(x)"
},
{
"input": "Translate into first-order logic: There exists at least one student with proficiency.",
"output": "∃x P(x)"
},
{
"input": "Translate into first-order logic: If a student lacks proficiency, then they lack qualifications.",
"output": "∀x (¬P(x) → ¬Q(x))"
},
{
"input": "Translate into first-order logic: If a student has skills, then they have understanding.",
"output": "∀x (S(x) → U(x))"
},
{
"input": "Translate into first-order logic: If a student lacks training, then they lack proficiency.",
"output": "∀x (¬T(x) → ¬P(x))"
},
{
"input": "Translate into first-order logic: All students have understanding.",
"output": "∀x U(x)"
},
{
"input": "Translate into first-order logic: If a student has understanding, then they have qualifications.",
"output": "∀x (U(x) → Q(x))"
},
{
"input": "Translate into first-order logic: If a student lacks proficiency, then they lack recognition.",
"output": "∀x (¬P(x) → ¬R(x))"
},
{
"input": "Translate into first-order logic: If lacking proficiency leads to lacking recognition, then lacking qualifications leads to lacking proficiency.",
"output": "∀x ((¬P(x) → ¬R(x)) → (¬Q(x) → ¬P(x)))"
},
{
"input": "Translate into first-order logic: If lacking training leads to lacking proficiency, then training leads to proficiency.",
"output": "∀x ((¬T(x) → ¬P(x)) → (T(x) → P(x)))"
},
{
"input": "Translate into first-order logic: If a student has proficiency, then they receive recognition.",
"output": "∀x (P(x) → R(x))"
},
{
"input": "Translate into first-order logic: If a student has understanding, then they have skills.",
"output": "∀x (U(x) → S(x))"
},
{
"input": "Translate into first-order logic: All students are enrolled in courses.",
"output": "∀x E(x)"
},
{
"input": "Translate into first-order logic: If a student lacks research, then they lack proficiency.",
"output": "∀x (¬R(x) → ¬P(x))"
},
{
"input": "Translate into first-order logic: If a student submits assignments, then they demonstrate knowledge.",
"output": "∀x (A(x) → K(x))"
},
{
"input": "Translate into first-order logic: If a student lacks participation, then they lack engagement.",
"output": "∀x (¬N(x) → ¬G(x))"
},
{
"input": "Translate into first-order logic: There exists at least one student who participates in discussions.",
"output": "∃x D(x)"
},
{
"input": "Translate into first-order logic: There exists at least one student who has proficiency.",
"output": "∃x P(x)"
},
{
"input": "Translate into first-order logic: If a student lacks proficiency, then they lack research.",
"output": "∀x (¬P(x) → ¬R(x))"
},
{
"input": "Translate into first-order logic: If a student engages, then they have understanding.",
"output": "∀x (G(x) → U(x))"
},
{
"input": "Translate into first-order logic: If a student lacks training, then they lack proficiency.",
"output": "∀x (¬T(x) → ¬P(x))"
},
{
"input": "Translate into first-order logic: All students have access to resources.",
"output": "∀x S(x)"
},
{
"input": "Translate into first-order logic: If a student has access to resources, then they complete assignments.",
"output": "∀x (S(x) → A(x))"
},
{
"input": "Translate into first-order logic: If a student lacks proficiency, then they lack certification.",
"output": "∀x (¬P(x) → ¬C(x))"
},
{
"input": "Translate into first-order logic: If lacking proficiency leads to lacking certification, then lacking research leads to lacking proficiency.",
"output": "∀x ((¬P(x) → ¬C(x)) → (¬R(x) → ¬P(x)))"
},
{
"input": "Translate into first-order logic: If lacking training leads to lacking proficiency, then training leads to proficiency.",
"output": "∀x ((¬T(x) → ¬P(x)) → (T(x) → P(x)))"
},
{
"input": "Translate into first-order logic: If a student has proficiency, then they obtain certification.",
"output": "∀x (P(x) → C(x))"
},
{
"input": "Translate into first-order logic: If a student has access to resources, then they can conduct research.",
"output": "∀x (S(x) → R(x))"
},
{
"input": "Translate into first-order logic: There exists at least one student with recognition.",
"output": "∃x R(x)"
},
{
"input": "Translate into first-order logic: If a student lacks skills, then they lack training.",
"output": "∀x (¬S(x) → ¬T(x))"
},
{
"input": "Translate into first-order logic: All students have recognition.",
"output": "∀x R(x)"
},
{
"input": "Translate into first-order logic: There exists at least one student with training.",
"output": "∃x T(x)"
},
{
"input": "Translate into first-order logic: If a student lacks proficiency, then they lack skills.",
"output": "∀x (¬P(x) → ¬S(x))"
},
{
"input": "Translate into first-order logic: There exists at least one student with skills.",
"output": "∃x S(x)"
},
{
"input": "Translate into first-order logic: If a student lacks recognition, then they lack qualifications.",
"output": "∀x (¬R(x) → ¬Q(x))"
},
{
"input": "Translate into first-order logic: If a student has recognition, then they have understanding.",
"output": "∀x (R(x) → U(x))"
},
{
"input": "Translate into first-order logic: All students have skills.",
"output": "∀x S(x)"
},
{
"input": "Translate into first-order logic: There exists at least one student with qualifications.",
"output": "∃x Q(x)"
},
{
"input": "Translate into first-order logic: All students have qualifications.",
"output": "∀x Q(x)"
},
{
"input": "Translate into first-order logic: If a student has recognition, then they have qualifications.",
"output": "∀x (R(x) → Q(x))"
},
{
"input": "Translate into first-order logic: If all students have recognition, then all students have skills.",
"output": "∀x R(x) → ∀x S(x)"
},
{
"input": "Translate into first-order logic: If recognition leads to understanding, then there exists at least one student with recognition.",
"output": "∀x (R(x) → U(x)) → ∃x R(x)"
},
{
"input": "Translate into first-order logic: If a student has proficiency, then they have recognition.",
"output": "∀x (P(x) → R(x))"
},
{
"input": "Translate into first-order logic: If a student has proficiency, then they have qualifications.",
"output": "∀x (P(x) → Q(x))"
},
{
"input": "Translate into first-order logic: All students have qualifications.",
"output": "∀x Q(x)"
},
{
"input": "Translate into first-order logic: All students have recognition.",
"output": "∀x R(x)"
},
{
"input": "Translate into first-order logic: If a student lacks understanding, then they lack recognition.",
"output": "∀x (¬U(x) → ¬R(x))"
},
{
"input": "Translate into first-order logic: There exists at least one student with proficiency.",
"output": "∃x P(x)"
},
{
"input": "Translate into first-order logic: All students have training.",
"output": "∀x T(x)"
},
{
"input": "Translate into first-order logic: If a student has qualifications, then they have recognition.",
"output": "∀x (Q(x) → R(x))"
},
{
"input": "Translate into first-order logic: If a student has proficiency, then they have qualifications.",
"output": "∀x (P(x) → Q(x))"
},
{
"input": "Translate into first-order logic: There exists at least one student with training.",
"output": "∃x T(x)"
},
{
"input": "Translate into first-order logic: If a student lacks qualifications, then they lack training.",
"output": "∀x (¬Q(x) → ¬T(x))"
},
{
"input": "Translate into first-order logic: If a student has proficiency, then they have training.",
"output": "∀x (P(x) → T(x))"
},
{
"input": "Translate into first-order logic: If a student has training, then they have qualifications.",
"output": "∀x (T(x) → Q(x))"
},
{
"input": "Translate into first-order logic: If a student lacks training, then they lack proficiency.",
"output": "∀x (¬T(x) → ¬P(x))"
},
{
"input": "Translate into first-order logic: If lacking training leads to lacking proficiency, then proficiency leads to training.",
"output": "∀x ((¬T(x) → ¬P(x)) → (P(x) → T(x)))"
},
{
"input": "Translate into first-order logic: If lacking understanding leads to lacking recognition, then proficiency leads to qualifications.",
"output": "∀x ((¬U(x) → ¬R(x)) → (P(x) → Q(x)))"
},
{
"input": "Translate into first-order logic: There exists at least one student with understanding.",
"output": "∃x U(x)"
},
{
"input": "Translate into first-order logic: If a student lacks understanding, then they lack training.",
"output": "∀x (¬U(x) → ¬T(x))"
},
{
"input": "Translate into first-order logic: All students have understanding.",
"output": "∀x U(x)"
},
{
"input": "Translate into first-order logic: There exists at least one student with training.",
"output": "∃x T(x)"
},
{
"input": "Translate into first-order logic: If a student has understanding, then they have reasoning skills.",
"output": "∀x (U(x) → R(x))"
},
{
"input": "Translate into first-order logic: All students have skills.",
"output": "∀x S(x)"
},
{
"input": "Translate into first-order logic: There exists at least one student with understanding.",
"output": "∃x U(x)"
},
{
"input": "Translate into first-order logic: If a student lacks skills, then they lack proficiency.",
"output": "∀x (¬S(x) → ¬P(x))"
},
{
"input": "Translate into first-order logic: There exists at least one student with skills.",
"output": "∃x S(x)"
},
{
"input": "Translate into first-order logic: If a student has reasoning skills, then they have understanding.",
"output": "∀x (R(x) → U(x))"
},
{
"input": "Translate into first-order logic: If a student lacks training, then they lack understanding.",
"output": "∀x (¬T(x) → ¬U(x))"
},
{
"input": "Translate into first-order logic: If a student lacks understanding, then they lack reasoning skills.",
"output": "∀x (¬U(x) → ¬R(x))"
},
{
"input": "Translate into first-order logic: If a student lacks qualifications, then they lack proficiency.",
"output": "∀x (¬Q(x) → ¬P(x))"
},
{
"input": "Translate into first-order logic: If a student lacks training, then they lack qualifications.",
"output": "∀x (¬T(x) → ¬Q(x))"
},
{
"input": "Translate into first-order logic: If there exists at least one student with understanding, then there exists at least one student with training.",
"output": "∃x U(x) → ∃x T(x)"
},
{
"input": "Translate into first-order logic: If there exists at least one student with skills, then lacking understanding leads to lacking reasoning skills.",
"output": "∃x S(x) → ∀x (¬U(x) → ¬R(x))"
},
{
"input": "Translate into first-order logic: If a student lacks reasoning skills, then they lack training.",
"output": "∀x (¬R(x) → ¬T(x))"
},
{
"input": "Translate into first-order logic: If a student has proficiency, then they have understanding.",
"output": "∀x (P(x) → U(x))"
},
{
"input": "Translate into first-order logic: All students adhere to HCMUT's code of conduct.",
"output": "∀x (Student(x) → AdheresToCodeOfConduct(x))"
},
{
"input": "Translate into first-order logic: There are vibrant student clubs at HCMUT.",
"output": "∃x VibrantStudentClub(x)"
},
{
"input": "Translate into first-order logic: If a student upholds HCMUT's values, then they adhere to HCMUT's code of conduct.",
"output": "∀x (UpholdsHCMUTValues(x) → AdheresToCodeOfConduct(x))"
},
{
"input": "Translate into first-order logic: If there are vibrant student clubs at HCMUT, then all students adhere to HCMUT's code of conduct.",
"output": "(∃x VibrantStudentClub(x) → ∀y (Student(y) → AdheresToCodeOfConduct(y)))"
},
{
"input": "Translate into first-order logic: If (If there are vibrant student clubs at HCMUT, then all students adhere to HCMUT's code of conduct) is true, then there are vibrant student clubs at HCMUT.",
"output": "((∃x VibrantStudentClub(x) → ∀y (Student(y) → AdheresToCodeOfConduct(y))) → ∃z VibrantStudentClub(z))"
},
{
"input": "Translate into first-order logic: If a student is an executive member of a student club, then they uphold HCMUT's values.",
"output": "∀x (ClubExecutiveMember(x) → UpholdsHCMUTValues(x))"
},
{
"input": "Translate into first-order logic: If a student is familiar with HCMUT's code of conduct, then they adhere to HCMUT's code of conduct.",
"output": "∀x (FamiliarWithCodeOfConduct(x) → AdheresToCodeOfConduct(x))"
},
{
"input": "Translate into first-order logic: If a student is enrolled in a university program, then the student has access to academic resources.",
"output": "(Enrolled(x) → HasAccessResources(x))"
},
{
"input": "Translate into first-order logic: There exists at least one student who is participating in an internship program.",
"output": "∃x (Internship(x))"
},
{
"input": "Translate into first-order logic: There exists at least one student who has completed a research project.",
"output": "∃x (ResearchCompleted(x))"
},
{
"input": "Translate into first-order logic: If a student is enrolled in a university program and has access to academic resources, then there exists at least one student who is participating in an internship program.",
"output": "((Enrolled(x) ∧ HasAccessResources(x)) → ∃y (Internship(y)))"
},
{
"input": "Translate into first-order logic: If a student is enrolled in a university program and has access to academic resources, then there exists at least one student who has completed a research project.",
"output": "((Enrolled(x) ∧ HasAccessResources(x)) → ∃y (ResearchCompleted(y)))"
},
{
"input": "Translate into first-order logic: There exists at least one student who is enrolled in a university program.",
"output": "∃x (Enrolled(x))"
},
{
"input": "Translate into first-order logic: If a student is conducting research, then the student has completed a research project.",
"output": "(Researching(x) → ResearchCompleted(x))"
},
{
"input": "Translate into first-order logic: If a student is enrolled in a course, then they have access to study materials.",
"output": "EnrolledInCourse(x) → HasAccessToMaterials(x)"
},
{
"input": "Translate into first-order logic: There exists at least one student who is enrolled in a course.",
"output": "∃x EnrolledInCourse(x)"
},
{
"input": "Translate into first-order logic: Every student has access to study materials.",
"output": "∀x HasAccessToMaterials(x)"
},
{
"input": "Translate into first-order logic: If every student has access to study materials, then there exists at least one student who is enrolled in a course.",
"output": "∀x HasAccessToMaterials(x) → ∃x EnrolledInCourse(x)"
},
{
"input": "Translate into first-order logic: If (a student being enrolled in a course implies they have access to study materials), then (if every student has access to study materials, there exists at least one student enrolled in a course).",
"output": "∀x (EnrolledInCourse(x) → HasAccessToMaterials(x)) → (∀x HasAccessToMaterials(x) → ∃x EnrolledInCourse(x))"
},
{
"input": "Translate into first-order logic: If a student doesn’t have a scholarship, then they don’t pay full tuition.",
"output": "¬HasScholarship(x) → ¬PaysFullTuition(x)"
},
{
"input": "Translate into first-order logic: If a student doesn’t have access to study materials, then they don’t have a scholarship.",
"output": "¬HasAccessToMaterials(x) → ¬HasScholarship(x)"
},
{
"input": "Translate into first-order logic: If a student is not studying, then they are not revising.",
"output": "∀x (¬IsStudying(x) → ¬IsRevising(x))"
},
{
"input": "Translate into first-order logic: If a student is not understanding the material, then they are not revising.",
"output": "∀x (¬IsUnderstandingMaterial(x) → ¬IsRevising(x))"
},
{
"input": "Translate into first-order logic: There exists at least one student who is taking an exam.",
"output": "∃x IsTakingExam(x)"
},
{
"input": "Translate into first-order logic: If (a student not understanding the material implies they are not revising), then (a student not studying implies they are not revising).",
"output": "(∀x (¬IsUnderstandingMaterial(x) → ¬IsRevising(x)) → ∀y (¬IsStudying(y) → ¬IsRevising(y)))"
},
{
"input": "Translate into first-order logic: If (a student not studying implies they are not revising), then there exists at least one student who is taking an exam.",
"output": "(∀x (¬IsStudying(x) → ¬IsRevising(x)) → ∃z IsTakingExam(z))"
},
{
"input": "Translate into first-order logic: If a student is revising, then they are taking an exam.",
"output": "∀x (IsRevising(x) → IsTakingExam(x))"
},
{
"input": "Translate into first-order logic: If a student is asking questions, then they are understanding the material.",
"output": "∀x (IsAskingQuestions(x) → IsUnderstandingMaterial(x))"
},
{
"input": "Translate into first-order logic: There exists at least one student who is studying.",
"output": "∃x IsStudying(x)"
},
{
"input": "Translate into first-order logic: There exists at least one student who is preparing for an exam.",
"output": "∃x IsPreparingForExam(x)"
},
{
"input": "Translate into first-order logic: If a student is not teaching, then they are not preparing for an exam.",
"output": "∀x (¬IsTeaching(x) → ¬IsPreparingForExam(x))"
},
{
"input": "Translate into first-order logic: If there exists at least one student who is preparing for an exam, then there exists at least one student who is studying.",
"output": "(∃x IsPreparingForExam(x) → ∃y IsStudying(y))"
},
{
"input": "Translate into first-order logic: If there exists at least one student who is studying, then there exists at least one student who is preparing for an exam.",
"output": "(∃x IsStudying(x) → ∃y IsPreparingForExam(y))"
},
{
"input": "Translate into first-order logic: Every student is asking questions.",
"output": "∀x IsAskingQuestions(x)"
},
{
"input": "Translate into first-order logic: There exists at least one student who is asking questions.",
"output": "∃x IsAskingQuestions(x)"
},
{
"input": "Translate into first-order logic: Every student is attending tutorials.",
"output": "∀x IsAttendingTutorials(x)"
},
{
"input": "Translate into first-order logic: There exists at least one student who is revising.",
"output": "∃x IsRevising(x)"
},
{
"input": "Translate into first-order logic: If a student is revising, then they are studying.",
"output": "∀x (IsRevising(x) → IsStudying(x))"
},
{
"input": "Translate into first-order logic: If every student is attending tutorials, then (if a student is revising, they are studying).",
"output": "(∀x IsAttendingTutorials(x) → ∀y (IsRevising(y) → IsStudying(y)))"
},
{
"input": "Translate into first-order logic: If there exists at least one student who is revising, then (if a student is revising, they are studying).",
"output": "(∃x IsRevising(x) → ∀y (IsRevising(y) → IsStudying(y)))"
},
{
"input": "Translate into first-order logic: If a student is studying, then they are revising.",
"output": "∀x (IsStudying(x) → IsRevising(x))"
},
{
"input": "Translate into first-order logic: There exists at least one student who is preparing for an exam.",
"output": "∃x IsPreparingForExam(x)"
},
{
"input": "Translate into first-order logic: If a student is not understanding the material, then they are not attending tutorials.",
"output": "∀x (¬IsUnderstandingMaterial(x) → ¬IsAttendingTutorials(x))"
},
{
"input": "Translate into first-order logic: If a student is preparing for an exam, then they are asking questions.",
"output": "∀x (IsPreparingForExam(x) → IsAskingQuestions(x))"
},
{
"input": "Translate into first-order logic: If a student is not studying, then they are not attending tutorials.",
"output": "∀x (¬IsStudying(x) → ¬IsAttendingTutorials(x))"
},
{
"input": "Translate into first-order logic: If (a student preparing for an exam implies they are asking questions), then (a student not understanding the material implies they are not attending tutorials).",
"output": "(∀x (IsPreparingForExam(x) → IsAskingQuestions(x)) → ∀y (¬IsUnderstandingMaterial(y) → ¬IsAttendingTutorials(y)))"
},
{
"input": "Translate into first-order logic: If (a student preparing for an exam implies they are asking questions), then (a student not studying implies they are not attending tutorials).",
"output": "(∀x (IsPreparingForExam(x) → IsAskingQuestions(x)) → ∀z (¬IsStudying(z) → ¬IsAttendingTutorials(z)))"
},
{
"input": "Translate into first-order logic: If a student is not revising, then they are not preparing for an exam.",
"output": "∀x (¬IsRevising(x) → ¬IsPreparingForExam(x))"
},
{
"input": "Translate into first-order logic: If a student is not attending tutorials, then they are not revising.",
"output": "∀x (¬IsAttendingTutorials(x) → ¬IsRevising(x))"
},
{
"input": "Translate into first-order logic: If a student is preparing for an exam, then they are understanding the material.",
"output": "∀x (IsPreparingForExam(x) → IsUnderstandingMaterial(x))"
},
{
"input": "Translate into first-order logic: If a student is studying, then they are asking questions.",
"output": "∀x (IsStudying(x) → IsAskingQuestions(x))"
},
{
"input": "Translate into first-order logic: Every student is attending tutorials.",
"output": "∀x IsAttendingTutorials(x)"
},
{
"input": "Translate into first-order logic: If (a student studying implies they are asking questions), then every student is attending tutorials.",
"output": "(∀x (IsStudying(x) → IsAskingQuestions(x)) → ∀y IsAttendingTutorials(y))"
},
{
"input": "Translate into first-order logic: If (a student preparing for an exam implies they are understanding the material), then every student is attending tutorials.",
"output": "(∀x (IsPreparingForExam(x) → IsUnderstandingMaterial(x)) → ∀y IsAttendingTutorials(y))"
},
{
"input": "Translate into first-order logic: Every student is preparing for an exam.",
"output": "∀x IsPreparingForExam(x)"
},
{
"input": "Translate into first-order logic: If a student is understanding the material, then they are revising.",
"output": "∀x (IsUnderstandingMaterial(x) → IsRevising(x))"
},
{
"input": "Translate into first-order logic: Every student is preparing for an exam.",
"output": "∀x IsPreparingForExam(x)"
},
{
"input": "Translate into first-order logic: If a student is not asking questions, then they are not attending tutorials.",
"output": "∀x (¬IsAskingQuestions(x) → ¬IsAttendingTutorials(x))"
},
{
"input": "Translate into first-order logic: There exists at least one student who is attending tutorials.",
"output": "∃x IsAttendingTutorials(x)"
},
{
"input": "Translate into first-order logic: If (a student not asking questions implies they are not attending tutorials), then there exists at least one student who is attending tutorials.",
"output": "(∀x (¬IsAskingQuestions(x) → ¬IsAttendingTutorials(x)) → ∃y IsAttendingTutorials(y))"
},
{
"input": "Translate into first-order logic: If there exists at least one student who is attending tutorials, then (if a student is not asking questions, they are not attending tutorials).",
"output": "(∃x IsAttendingTutorials(x) → ∀y (¬IsAskingQuestions(y) → ¬IsAttendingTutorials(y)))"
},
{
"input": "Translate into first-order logic: Every student is understanding the material.",
"output": "∀x IsUnderstandingMaterial(x)"
},
{
"input": "Translate into first-order logic: There exists at least one student who is preparing for an exam.",
"output": "∃x IsPreparingForExam(x)"
},
{
"input": "Translate into first-order logic: If a student is not revising, then they are not studying.",
"output": "∀x (¬IsRevising(x) → ¬IsStudying(x))"
},
{
"input": "Translate into first-order logic: If a student is not revising, then they are not asking questions.",
"output": "∀x (¬IsRevising(x) → ¬IsAskingQuestions(x))"
},
{
"input": "Translate into first-order logic: There exists at least one student who is asking questions.",
"output": "∃x IsAskingQuestions(x)"
},
{
"input": "Translate into first-order logic: If there exists at least one student who is asking questions, then (if a student is not revising, they are not asking questions).",
"output": "(∃x IsAskingQuestions(x) → ∀y (¬IsRevising(y) → ¬IsAskingQuestions(y)))"
},
{
"input": "Translate into first-order logic: If there exists at least one student who is asking questions, then (if a student is not revising, they are not studying).",
"output": "(∃x IsAskingQuestions(x) → ∀y (¬IsRevising(y) → ¬IsStudying(y)))"
},
{
"input": "Translate into first-order logic: If a student is not asking questions, then they are not preparing for an exam.",
"output": "∀x (¬IsAskingQuestions(x) → ¬IsPreparingForExam(x))"
},
{
"input": "Translate into first-order logic: If a student is asking questions, then they are revising.",
"output": "∀x (IsAskingQuestions(x) → IsRevising(x))"
},
{
"input": "Translate into first-order logic: If a student is not studying, then they are not asking questions.",
"output": "∀x (¬IsStudying(x) → ¬IsAskingQuestions(x))"
},
{
"input": "Translate into first-order logic: If a student is attending tutorials, then they are understanding the material.",
"output": "∀x (IsAttendingTutorials(x) → IsUnderstandingMaterial(x))"
},
{
"input": "Translate into first-order logic: There exists at least one student who is asking questions.",
"output": "∃x IsAskingQuestions(x)"
},
{
"input": "Translate into first-order logic: If (a student attending tutorials implies they are understanding the material), then there exists at least one student who is asking questions.",
"output": "(∀x (IsAttendingTutorials(x) → IsUnderstandingMaterial(x)) → ∃y IsAskingQuestions(y))"
},
{
"input": "Translate into first-order logic: If (a student attending tutorials implies they are understanding the material), then (if a student attending tutorials implies they are understanding the material, there exists at least one student who is asking questions).",
"output": "(∀x (IsAttendingTutorials(x) → IsUnderstandingMaterial(x)) → (∀z (IsAttendingTutorials(z) → IsUnderstandingMaterial(z)) → ∃w IsAskingQuestions(w)))"
},
{
"input": "Translate into first-order logic: There exists at least one student who is preparing for an exam.",
"output": "∃x IsPreparingForExam(x)"
},
{
"input": "Translate into first-order logic: Every student is studying.",
"output": "∀x IsStudying(x)"
},
{
"input": "Translate into first-order logic: Every student is studying.",
"output": "∀x IsStudying(x)"
},
{
"input": "Translate into first-order logic: If a student is attending tutorials, then they are understanding the material.",
"output": "∀x (IsAttendingTutorials(x) → IsUnderstandingMaterial(x))"
},
{
"input": "Translate into first-order logic: There exists at least one student who is understanding the material.",
"output": "∃x IsUnderstandingMaterial(x)"
},
{
"input": "Translate into first-order logic: If (a student attending tutorials implies they are understanding the material), then every student is studying.",
"output": "(∀x (IsAttendingTutorials(x) → IsUnderstandingMaterial(x)) → ∀y IsStudying(y))"
},
{
"input": "Translate into first-order logic: If there exists at least one student who is understanding the material, then (if a student is attending tutorials, they are understanding the material).",
"output": "(∃x IsUnderstandingMaterial(x) → ∀y (IsAttendingTutorials(y) → IsUnderstandingMaterial(y)))"
},
{
"input": "Translate into first-order logic: There exists at least one student who is preparing for an exam.",
"output": "∃x IsPreparingForExam(x)"
},
{
"input": "Translate into first-order logic: If a student is revising, then they are studying.",
"output": "∀x (IsRevising(x) → IsStudying(x))"
},
{
"input": "Translate into first-order logic: Every student is understanding the material.",
"output": "∀x IsUnderstandingMaterial(x)"
},
{
"input": "Translate into first-order logic: Every student is asking questions.",
"output": "∀x IsAskingQuestions(x)"
},
{
"input": "Translate into first-order logic: Every student is revising.",
"output": "∀x IsRevising(x)"
},
{
"input": "Translate into first-order logic: If a student is attending tutorials, then they are revising.",
"output": "∀x (IsAttendingTutorials(x) → IsRevising(x))"
},
{
"input": "Translate into first-order logic: Every student is revising.",
"output": "∀x IsRevising(x)"
},
{
"input": "Translate into first-order logic: If a student is not understanding the material, then they are not revising.",
"output": "∀x (¬IsUnderstandingMaterial(x) → ¬IsRevising(x))"
},
{
"input": "Translate into first-order logic: If (a student not understanding the material implies they are not revising), then (a student attending tutorials implies they are revising).",
"output": "(∀x (¬IsUnderstandingMaterial(x) → ¬IsRevising(x)) → ∀y (IsAttendingTutorials(y) → IsRevising(y)))"
},
{
"input": "Translate into first-order logic: If (the statement that 'if a student not understanding the material implies they are not revising, then a student attending tutorials implies they are revising') is true, then (if a student is not understanding the material, they are not revising).",
"output": "((∀x (¬IsUnderstandingMaterial(x) → ¬IsRevising(x)) → ∀y (IsAttendingTutorials(y) → IsRevising(y))) → ∀z (¬IsUnderstandingMaterial(z) → ¬IsRevising(z)))"
},
{
"input": "Translate into first-order logic: There exists at least one student who is revising.",
"output": "∃x IsRevising(x)"
},
{
"input": "Translate into first-order logic: If a student is not revising, then they are not attending tutorials.",
"output": "∀x (¬IsRevising(x) → ¬IsAttendingTutorials(x))"
},
{
"input": "Translate into first-order logic: If a university student is revising, then they are preparing for an exam.",
"output": "∀x (UniversityStudent(x) → (IsRevising(x) → IsPreparingForExam(x)))"
},
{
"input": "Translate into first-order logic: Every university student is asking questions.",
"output": "∀x (UniversityStudent(x) → IsAskingQuestions(x))"
},
{
"input": "Translate into first-order logic: If a university student is studying, then they are understanding the material.",
"output": "∀x (UniversityStudent(x) → (IsStudying(x) → IsUnderstandingMaterial(x)))"
},
{
"input": "Translate into first-order logic: If (a university student revising implies they are preparing for an exam), then (a university student studying implies they are understanding the material).",
"output": "(∀x (UniversityStudent(x) → (IsRevising(x) → IsPreparingForExam(x))) → ∀y (UniversityStudent(y) → (IsStudying(y) → IsUnderstandingMaterial(y))))"
},
{
"input": "Translate into first-order logic: If (the statement that 'if a university student revising implies they are preparing for an exam, then a university student studying implies they are understanding the material') is true, then (if a university student is studying, they are understanding the material).",
"output": "((∀x (UniversityStudent(x) → (IsRevising(x) → IsPreparingForExam(x))) → ∀y (UniversityStudent(y) → (IsStudying(y) → IsUnderstandingMaterial(y)))) → ∀z (UniversityStudent(z) → (IsStudying(z) → IsUnderstandingMaterial(z))))"
},
{
"input": "Translate into first-order logic: There exists at least one university student who is studying.",
"output": "∃x (UniversityStudent(x) ∧ IsStudying(x))"
},
{
"input": "Translate into first-order logic: If a university student is understanding the material, then they are asking questions.",
"output": "∀x (UniversityStudent(x) → (IsUnderstandingMaterial(x) → IsAskingQuestions(x)))"
},
{
"input": "Translate into first-order logic: Every student is studying.",
"output": "∀x IsStudying(x)"
},
{
"input": "Translate into first-order logic: There exists at least one student who is attending tutorials.",
"output": "∃x IsAttendingTutorials(x)"
},
{
"input": "Translate into first-order logic: There exists at least one student who is revising.",
"output": "∃x IsRevising(x)"
},
{
"input": "Translate into first-order logic: If there exists at least one student who is attending tutorials, then every student is studying.",
"output": "(∃x IsAttendingTutorials(x) → ∀y IsStudying(y))"
},
{
"input": "Translate into first-order logic: If there exists at least one student who is revising, then every student is studying.",
"output": "(∃x IsRevising(x) → ∀y IsStudying(y))"
},
{
"input": "Translate into first-order logic: Every student is attending tutorials.",
"output": "∀x IsAttendingTutorials(x)"
},
{
"input": "Translate into first-order logic: If a student is not revising, then they are not asking questions.",
"output": "∀x (¬IsRevising(x) → ¬IsAskingQuestions(x))"
},
{
"input": "Translate into first-order logic: If a high school student studies math diligently, then they understand trigonometry.",
"output": "(StudiesMathDiligently(x) → UnderstandsTrigonometry(x))"
},
{
"input": "Translate into first-order logic: There exists at least one high school student who understands trigonometry.",
"output": "∃x (UnderstandsTrigonometry(x))"
},
{
"input": "Translate into first-order logic: If a high school student is not proficient in algebra, then they will not ace calculus.",
"output": "(¬IsProficientInAlgebra(x) → ¬AcesCalculus(x))"
},
{
"input": "Translate into first-order logic: If (if a high school student is not proficient in algebra, then they will not ace calculus), then there exists at least one high school student who understands trigonometry.",
"output": "((¬IsProficientInAlgebra(x) → ¬AcesCalculus(x)) → ∃x (UnderstandsTrigonometry(x)))"
},
{
"input": "Translate into first-order logic: If (if (if a high school student is not proficient in algebra, then they will not ace calculus), then there exists at least one high school student who understands trigonometry), then there exists at least one high school student who understands trigonometry.",
"output": "(((¬IsProficientInAlgebra(x) → ¬AcesCalculus(x)) → ∃x (UnderstandsTrigonometry(x))) → ∃x (UnderstandsTrigonometry(x)))"
},
{
"input": "Translate into first-order logic: If a high school student does not practice math problems regularly, then they will not ace calculus.",
"output": "(¬PracticesMathRegularly(x) → ¬AcesCalculus(x))"
},
{
"input": "Translate into first-order logic: If a high school student does not practice math problems regularly, then they do not study math diligently.",
"output": "(¬PracticesMathRegularly(x) → ¬StudiesMathDiligently(x))"
},
{
"input": "Translate into first-order logic: Every high school student is studious.",
"output": "∀x (HighSchoolStudent(x) → IsStudious(x))"
},
{
"input": "Translate into first-order logic: Every high school student participates in extracurricular activities.",
"output": "∀x (HighSchoolStudent(x) → ParticipatesInExtracurriculars(x))"
},
{
"input": "Translate into first-order logic: Every high school student upholds school values.",
"output": "∀x (HighSchoolStudent(x) → UpholdsSchoolValues(x))"
},
{
"input": "Translate into first-order logic: If every high school student upholds school values, then every high school student is studious.",
"output": "(∀x (HighSchoolStudent(x) → UpholdsSchoolValues(x)) → ∀y (HighSchoolStudent(y) → IsStudious(y)))"
},
{
"input": "Translate into first-order logic: If every high school student is studious, then every high school student upholds school values.",
"output": "(∀x (HighSchoolStudent(x) → IsStudious(x)) → ∀y (HighSchoolStudent(y) → UpholdsSchoolValues(y)))"
},
{
"input": "Translate into first-order logic: If a high school student does not join school clubs, then they do not participate in extracurricular activities.",
"output": "∀x (HighSchoolStudent(x) → (¬JoinsSchoolClubs(x) → ¬ParticipatesInExtracurriculars(x)))"
},
{
"input": "Translate into first-order logic: If a high school student does not volunteer in community events, then they do not uphold school values.",
"output": "∀x (HighSchoolStudent(x) → (¬VolunteersInCommunityEvents(x) → ¬UpholdsSchoolValues(x)))"
},
{
"input": "Translate into first-order logic: Every high school student is diligent.",
"output": "∀x IsDiligent(x)"
},
{
"input": "Translate into first-order logic: If a high school student attends tutoring sessions, then they improve their grades.",
"output": "∀x (IsAttendingTutoring(x) → ImprovesGrades(x))"
},
{
"input": "Translate into first-order logic: There exists at least one high school student who attends tutoring sessions.",
"output": "∃x IsAttendingTutoring(x)"
},
{
"input": "Translate into first-order logic: If every high school student is diligent, then (if a high school student attends tutoring sessions, then they improve their grades).",
"output": "∀x IsDiligent(x) → ∀y (IsAttendingTutoring(y) → ImprovesGrades(y))"
},
{
"input": "Translate into first-order logic: If (if a high school student attends tutoring sessions, then they improve their grades), then every high school student is diligent.",
"output": "∀x (IsAttendingTutoring(x) → ImprovesGrades(x)) → ∀y IsDiligent(y)"
},
{
"input": "Translate into first-order logic: Every high school student is inquisitive.",
"output": "∀x IsInquisitive(x)"
},
{
"input": "Translate into first-order logic: If a high school student improves their grades, then they achieve academic success.",
"output": "∀x (ImprovesGrades(x) → AchievesAcademicSuccess(x))"
},
{
"input": "Translate into first-order logic: There exists at least one student who has completed the Educational Psychology course",
"output": "∃x (S(x) ∧ C(x))"
},
{
"input": "Translate into first-order logic: All students are enrolled in the Teacher Education program",
"output": "∀x (S(x) → E(x))"
},
{
"input": "Translate into first-order logic: All students possess basic teaching skills",
"output": "∀x (S(x) → T(x))"
},
{
"input": "Translate into first-order logic: If a student has not completed the Educational Psychology course, then that student does not meet the professional teaching standards",
"output": "∀x (S(x) → (¬C(x) → ¬P(x)))"
},
{
"input": "Translate into first-order logic: All students are enrolled in a thesis-based program",
"output": "∀x (S(x) → T(x))"
},
{
"input": "Translate into first-order logic: There exists at least one student who has participated in a research project",
"output": "∃x (S(x) ∧ R(x))"
},
{
"input": "Translate into first-order logic: If a student has not passed the Research Methodology course, then they are not eligible to apply for graduate scholarships",
"output": "∀x (S(x) → (¬M(x) → ¬G(x)))"
},
{
"input": "Translate into first-order logic: If a student has not submitted a research proposal, then that student has not participated in a research project",
"output": "∀x (S(x) → (¬P(x) → ¬R(x)))"
},
{
"input": "Translate into first-order logic: There exists at least one student who has passed the Research Methodology course",
"output": "∃x (S(x) ∧ M(x))"
},
{
"input": "Translate into first-order logic: All online students have logged into the online learning platform",
"output": "∀x (S(x) → L(x))"
},
{
"input": "Translate into first-order logic: There exists at least one online student who has completed a module quiz",
"output": "∃x (S(x) ∧ Q(x))"
},
{
"input": "Translate into first-order logic: If an online student has logged into the learning platform, then they have viewed at least one lecture video",
"output": "∀x (S(x) → (L(x) → V(x)))"
},
{
"input": "Translate into first-order logic: There exists at least one online student who has submitted a course feedback form",
"output": "∃x (S(x) ∧ F(x))"
},
{
"input": "Translate into first-order logic: All students follow the classroom rules",
"output": "∀x (S(x) → R(x))"
},
{
"input": "Translate into first-order logic: There exists at least one student who is a member of the student council",
"output": "∃x (S(x) ∧ C(x))"
},
{
"input": "Translate into first-order logic: All students receive positive participation marks",
"output": "∀x (S(x) → P(x))"
},
{
"input": "Translate into first-order logic: If a student has submitted all required assignments, then they are eligible to take the end-of-term quiz",
"output": "∀x (S(x) → (A(x) → E(x)))"
},
{
"input": "Translate into first-order logic: If a student has not attended the required number of classes, then they are not eligible to take the end-of-term quiz",
"output": "∀x (S(x) → (¬C(x) → ¬E(x)))"
},
{
"input": "Translate into first-order logic: If a student is eligible to take the end-of-term quiz, then they are qualified for the academic achievement award",
"output": "∀x (S(x) → (E(x) → Q(x)))"
},
{
"input": "Translate into first-order logic: All students have attended the required number of classes",
"output": "∀x (S(x) → C(x))"
},
{
"input": "Translate into first-order logic: If a student has volunteered in school activities, then they receive a community engagement certificate",
"output": "∀x (S(x) → (V(x) → M(x)))"
},
{
"input": "Translate into first-order logic: If a student has not reviewed the course materials, then they are not well-prepared for class discussions",
"output": "∀x (S(x) → (¬R(x) → ¬W(x)))"
},
{
"input": "Translate into first-order logic: All students participate actively in class",
"output": "∀x (S(x) → P(x))"
},
{
"input": "Translate into first-order logic: All students are well-prepared for class discussions",
"output": "∀x (S(x) → W(x))"
},
{
"input": "Translate into first-order logic: If a participant has completed the registration form, then they have received the necessary safety briefing",
"output": "∀x (P(x) → (R(x) → S(x)))"
},
{
"input": "Translate into first-order logic: All participants have completed the registration form",
"output": "∀x (P(x) → R(x))"
},
{
"input": "Translate into first-order logic: All participants are equipped with proper outdoor gear",
"output": "∀x (P(x) → G(x))"
},
{
"input": "Translate into first-order logic: If a participant has not signed the liability waiver, then they have not completed the registration form",
"output": "∀x (P(x) → (¬W(x) → ¬R(x)))"
},
{
"input": "Translate into first-order logic: If a student has not submitted the group contract, then they are not considered an active group member",
"output": "∀x (S(x) → (¬C(x) → ¬M(x)))"
},
{
"input": "Translate into first-order logic: If a student has been invited to the group, then they have agreed to join the group for the assignment",
"output": "∀x (S(x) → (I(x) → A(x)))"
},
{
"input": "Translate into first-order logic: All students have agreed to join a group for the assignment",
"output": "∀x (S(x) → A(x))"
},
{
"input": "Translate into first-order logic: If a student has not been invited to the group, then they are not considered an active group member",
"output": "∀x (S(x) → (¬I(x) → ¬M(x)))"
},
{
"input": "Translate into first-order logic: All students meet the seminar's eligibility criteria",
"output": "∀x (S(x) → E(x))"
},
{
"input": "Translate into first-order logic: If a student has not submitted a complete seminar application, then they will not be selected to attend the seminar",
"output": "∀x (S(x) → (¬A(x) → ¬T(x)))"
},
{
"input": "Translate into first-order logic: All students have shown interest in the seminar",
"output": "∀x (S(x) → I(x))"
},
{
"input": "Translate into first-order logic: If a student has not registered for the festival, then they do not have access to festival activities",
"output": "∀x (S(x) → (¬R(x) → ¬A(x)))"
},
{
"input": "Translate into first-order logic: If a student has not received a festival invitation, then they have not registered for the festival",
"output": "∀x (S(x) → (¬I(x) → ¬R(x)))"
},
{
"input": "Translate into first-order logic: If a student is attending the university festival, then they have access to festival activities",
"output": "∀x (S(x) → (F(x) → A(x)))"
},
{
"input": "Translate into first-order logic: All students are attending the university festival",
"output": "∀x (S(x) → F(x))"
},
{
"input": "Translate into first-order logic: If a student has submitted a scholarship application, then they are eligible for the scholarship",
"output": "∀x (S(x) → (A(x) → E(x)))"
},
{
"input": "Translate into first-order logic: If a student has not maintained a good academic standing, then they will not be shortlisted for an interview",
"output": "∀x (S(x) → (¬G(x) → ¬I(x)))"
},
{
"input": "Translate into first-order logic: There exists at least one student who has maintained a good academic standing",
"output": "∃x (S(x) ∧ G(x))"
},
{
"input": "Translate into first-order logic: If a student has not maintained a good academic standing, then they will not receive the scholarship",
"output": "∀x (S(x) → (¬G(x) → ¬R(x)))"
},
{
"input": "Translate into first-order logic: There exists at least one student who has submitted a scholarship application",
"output": "∃x (S(x) ∧ A(x))"
},
{
"input": "Translate into first-order logic: If a student has requested permission to be absent, then they are officially granted that permission",
"output": "∀x (S(x) → (R(x) → P(x)))"
},
{
"input": "Translate into first-order logic: If a student has not requested permission, then they are not granted permission to be absent",
"output": "∀x (S(x) → (¬R(x) → ¬P(x)))"
},
{
"input": "Translate into first-order logic: All students have requested permission to be absent from class",
"output": "∀x (S(x) → R(x))"
},
{
"input": "Translate into first-order logic: There exists at least one student who provided a valid reason for absence",
"output": "∃x (S(x) ∧ V(x))"
},
{
"input": "Translate into first-order logic: There exists at least one student who has shown interest in the start-up competition",
"output": "∃x (S(x) ∧ I(x))"
},
{
"input": "Translate into first-order logic: There exists at least one student who has submitted a competition application",
"output": "∃x (S(x) ∧ A(x))"
},
{
"input": "Translate into first-order logic: If a student has not formed a team, then they are not registered for the start-up competition",
"output": "∀x (S(x) → (¬T(x) → ¬R(x)))"
},
{
"input": "Translate into first-order logic: If a student has not submitted a competition application, then they are not eligible for the pitching round",
"output": "∀x (S(x) → (¬A(x) → ¬P(x)))"
},
{
"input": "Translate into first-order logic: There exists at least one student who has registered for the start-up competition",
"output": "∃x (S(x) ∧ R(x))"
},
{
"input": "Translate into first-order logic: If a person has not been trained to recognize scams, then they are vulnerable to scammers",
"output": "∀x (P(x) → (¬T(x) → V(x)))"
},
{
"input": "Translate into first-order logic: All individuals in the university environment are not vulnerable to scammers",
"output": "∀x (P(x) → ¬V(x))"
},
{
"input": "Translate into first-order logic: All individuals have been trained to recognize scams",
"output": "∀x (P(x) → T(x))"
},
{
"input": "Translate into first-order logic: If x does not use online documents from the library, then x does not gain more knowledge",
"output": "∀x (¬U(x) → ¬K(x))"
},
{
"input": "Translate into first-order logic: There exists a student who gains more knowledge from the online documents",
"output": "∃x (S(x) ∧ K(x))"
},
{
"input": "Translate into first-order logic: All students actively use the library's online resources",
"output": "∀x (S(x) → U(x))"
},
{
"input": "Translate into first-order logic: All students have met all academic requirements",
"output": "∀x (S(x) → M(x))"
},
{
"input": "Translate into first-order logic: If a student has submitted the exam eligibility form, then they have received clearance from the academic office",
"output": "∀x (S(x) → (E(x) → L(x)))"
},
{
"input": "Translate into first-order logic: All students are allowed to attend the final exam",
"output": "∀x (S(x) → A(x))"
},
{
"input": "Translate into first-order logic: There exists at least one student who has submitted the exam eligibility form",
"output": "∃x (S(x) ∧ E(x))"
},
{
"input": "Translate into first-order logic: If a student was caught using unauthorized materials, then they were reported for cheating",
"output": "∀x (S(x) → (C(x) → R(x)))"
},
{
"input": "Translate into first-order logic: If a student behaved suspiciously during the exam, then they were caught using unauthorized materials",
"output": "∀x (S(x) → (B(x) → C(x)))"
},
{
"input": "Translate into first-order logic: If a student was reported for cheating, then they behaved suspiciously during the exam",
"output": "∀x (S(x) → (R(x) → B(x)))"
},
{
"input": "Translate into first-order logic: There exists at least one student who attempted to communicate during the exam",
"output": "∃x (S(x) ∧ A(x))"
},
{
"input": "Translate into first-order logic: If a student behaved suspiciously during the exam, then they are summoned for a disciplinary hearing",
"output": "∀x (S(x) → (B(x) → D(x)))"
},
{
"input": "Translate into first-order logic: If a student has attended soft skills workshops, then they have improved their communication skills",
"output": "∀x (S(x) → (W(x) → C(x)))"
},
{
"input": "Translate into first-order logic: If a student did not participate in group projects, then they did not develop leadership abilities",
"output": "∀x (S(x) → (¬P(x) → ¬L(x)))"
},
{
"input": "Translate into first-order logic: All students have attended soft skills workshops",
"output": "∀x (S(x) → W(x))"
},
{
"input": "Translate into first-order logic: If a student has developed leadership abilities, then they have improved their communication skills",
"output": "∀x (S(x) → (L(x) → C(x)))"
},
{
"input": "Translate into first-order logic: If a student has not created a personal study-work schedule, then they do not manage academic deadlines effectively",
"output": "∀x (S(x) → (¬W(x) → ¬D(x)))"
},
{
"input": "Translate into first-order logic: If a student does not manage deadlines effectively, then they do not maintain consistent academic performance",
"output": "∀x (S(x) → (¬D(x) → ¬P(x)))"
},
{
"input": "Translate into first-order logic: If a student is employed part-time, then they report feeling balanced between work and study",
"output": "∀x (S(x) → (E(x) → B(x)))"
},
{
"input": "Translate into first-order logic: There exists at least one student who manages academic deadlines effectively",
"output": "∃x (S(x) ∧ D(x))"
},
{
"input": "Translate into first-order logic: If a student has not gained international experience through an exchange program, then they are not ready to actively join the international community",
"output": "∀x (S(x) → (¬E(x) → ¬R(x)))"
},
{
"input": "Translate into first-order logic: If a student has applied for an exchange program, then they have gained international experience",
"output": "∀x (S(x) → (A(x) → E(x)))"
},
{
"input": "Translate into first-order logic: If a student has received support from the university’s international office, then they have gained international experience",
"output": "∀x (S(x) → (U(x) → E(x)))"
},
{
"input": "Translate into first-order logic: If a student has not applied for an exchange program, then they are not selected for an international leadership role",
"output": "∀x (S(x) → (¬A(x) → ¬L(x)))"
},
{
"input": "Translate into first-order logic: There exists at least one student who has applied for an exchange program",
"output": "∃x (S(x) ∧ A(x))"
},
{
"input": "Translate into first-order logic: All students complete fundamental courses.",
"output": "∀x C(x)"
},
{
"input": "Translate into first-order logic: All students submit research papers.",
"output": "∀x R(x)"
},
{
"input": "Translate into first-order logic: At least one student participates in extracurricular activities.",
"output": "∃x E(x)"
},
{
"input": "Translate into first-order logic: If a student does not participate in extracurricular activities, they do not develop leadership skills.",
"output": "∀x (¬E(x) → ¬L(x))"
},
{
"input": "Translate into first-order logic: If a student does not complete fundamental courses, they are not eligible for graduation.",
"output": "∀x (¬C(x) → ¬G(x))"
},
{
"input": "Translate into first-order logic: If a student is enrolled in the honors program, they have access to advanced materials.",
"output": "∀x (H(x) → A(x))"
},
{
"input": "Translate into first-order logic: All students are enrolled in the honors program.",
"output": "∀x H(x)"
},
{
"input": "Translate into first-order logic: If a student does not participate in extracurricular activities, they cannot join the student council.",
"output": "∀x (¬E(x) → ¬S(x))"
},
{
"input": "Translate into first-order logic: If a student not completing fundamental courses implies they are not eligible for graduation, then being enrolled in the honors program implies having access to advanced materials.",
"output": "∀x (¬C(x) → ¬G(x)) → ∀x (H(x) → A(x))"
},
{
"input": "Translate into first-order logic: If a student not completing fundamental courses implies they are not eligible for graduation, then all students are enrolled in the honors program.",
"output": "∀x (¬C(x) → ¬G(x)) → ∀x H(x)"
},
{
"input": "Translate into first-order logic: If not participating in extracurricular activities implies not developing leadership skills, then (if not completing fundamental courses implies not being eligible for graduation, then all students are enrolled in the honors program).",
"output": "∀x (¬E(x) → ¬L(x)) → (∀x (¬C(x) → ¬G(x)) → ∀x H(x))"
},
{
"input": "Translate into first-order logic: The previous complex implication implies that being enrolled in the honors program implies having access to advanced materials.",
"output": "(∀x (¬E(x) → ¬L(x)) → (∀x (¬C(x) → ¬G(x)) → ∀x H(x))) → ∀x (H(x) → A(x))"
},
{
"input": "Translate into first-order logic: If not completing fundamental courses implies having access to advanced materials, then all students complete fundamental courses.",
"output": "∀x (¬C(x) → A(x)) → ∀x C(x)"
},
{
"input": "Translate into first-order logic: Being enrolled in the honors program implies completing fundamental courses.",
"output": "∀x (H(x) → C(x))"
},
{
"input": "Translate into first-order logic: All students participate in group projects.",
"output": "∀x P(x)"
},
{
"input": "Translate into first-order logic: If a student does not submit a research paper, they do not receive a passing grade.",
"output": "∀x (¬R(x) → ¬F(x))"
},
{
"input": "Translate into first-order logic: There exists at least one student in an advanced research program.",
"output": "∃x R(x)"
},
{
"input": "Translate into first-order logic: If a student does not attend advanced seminars, they do not earn research credits.",
"output": "∀x (¬S(x) → ¬C(x))"
},
{
"input": "Translate into first-order logic: If a student demonstrates research skills, they receive a research grant.",
"output": "∀x (K(x) → G(x))"
},
{
"input": "Translate into first-order logic: There exists at least one advanced seminar.",
"output": "∃x A(x)"
},
{
"input": "Translate into first-order logic: All students maintain academic excellence.",
"output": "∀x E(x)"
},
{
"input": "Translate into first-order logic: All students are part of the advanced research program.",
"output": "∀x R(x)"
},
{
"input": "Translate into first-order logic: There exists at least one research project.",
"output": "∃x P(x)"
},
{
"input": "Translate into first-order logic: If a student is not in the advanced research program, they cannot access specialized research facilities.",
"output": "∀x (¬R(x) → ¬F(x))"
},
{
"input": "Translate into first-order logic: If a student fails to secure a research grant, they cannot maintain academic excellence.",
"output": "∀x (¬G(x) → ¬E(x))"
},
{
"input": "Translate into first-order logic: If a student does not complete a research project, they lose access to advanced seminars.",
"output": "∀x (¬J(x) → ¬S(x))"
},
{
"input": "Translate into first-order logic: If a student does not maintain academic excellence, they are removed from the advanced research program.",
"output": "∀x (¬E(x) → ¬R(x))"
},
{
"input": "Translate into first-order logic: If a student receives a research grant, they gain access to specialized research facilities.",
"output": "∀x (G(x) → F(x))"
},
{
"input": "Translate into first-order logic: If an advanced seminar exists, then students who do not maintain academic excellence are removed from the advanced research program.",
"output": "∃x A(x) → ∀x (¬E(x) → ¬R(x))"
},
{
"input": "Translate into first-order logic: If (students who do not maintain academic excellence are removed from the advanced research program), then (students who fail to secure a research grant cannot maintain academic excellence).",
"output": "∀x (¬E(x) → ¬R(x)) → ∀x (¬G(x) → ¬E(x))"
},
{
"input": "Translate into first-order logic: If (students who do not complete a research project lose advanced seminar access), then (an advanced seminar exists implies that students who do not maintain academic excellence are removed from the advanced research program).",
"output": "∀x (¬J(x) → ¬S(x)) → (∃x A(x) → ∀x (¬E(x) → ¬R(x)))"
},
{
"input": "Translate into first-order logic: There exists at least one research grant recipient.",
"output": "∃x G(x)"
},
{
"input": "Translate into first-order logic: There exists at least one student with specialized research access.",
"output": "∃x F(x)"
},
{
"input": "Translate into first-order logic: If a student is in the advanced research program, they must conduct a research project.",
"output": "∀x (R(x) → J(x))"
},
{
"input": "Translate into first-order logic: If a student gains specialized research access, they can attend advanced seminars.",
"output": "∀x (F(x) → S(x))"
},
{
"input": "Translate into first-order logic: All students must complete advanced digital skills training.",
"output": "∀x D(x)"
},
{
"input": "Translate into first-order logic: If a student does not master coding skills, they cannot participate in tech innovation projects.",
"output": "∀x (¬C(x) → ¬T(x))"
},
{
"input": "Translate into first-order logic: If a student fails to complete data analysis workshops, they do not receive advanced certification.",
"output": "∀x (¬W(x) → ¬A(x))"
},
{
"input": "Translate into first-order logic: Every student in the technology track must demonstrate proficiency in artificial intelligence.",
"output": "∀x (H(x) → P(x))"
},
{
"input": "Translate into first-order logic: If a student demonstrates AI proficiency, they become eligible for research grants.",
"output": "∀x (P(x) → G(x))"
},
{
"input": "Translate into first-order logic: There is at least one student in the machine learning specialization.",
"output": "∃x M(x)"
},
{
"input": "Translate into first-order logic: If a student is in the machine learning specialization, they must complete advanced programming modules.",
"output": "∀x (M(x) → R(x))"
},
{
"input": "Translate into first-order logic: All students must develop a comprehensive technology portfolio.",
"output": "∀x F(x)"
},
{
"input": "Translate into first-order logic: If a student does not develop a technology portfolio, they cannot apply to top-tier tech companies.",
"output": "∀x (¬F(x) → ¬O(x))"
},
{
"input": "Translate into first-order logic: Students who do not receive advanced certification cannot join professional tech networks.",
"output": "∀x (¬A(x) → ¬N(x))"
},
{
"input": "Translate into first-order logic: If a student participates in hackathons, they gain practical coding experience.",
"output": "∀x (K(x) → E(x))"
},
{
"input": "Translate into first-order logic: All students in advanced technology tracks must complete innovative tech projects.",
"output": "∀x (V(x) → I(x))"
},
{
"input": "Translate into first-order logic: If a student does not complete an innovative tech project, they are ineligible for industry internships.",
"output": "∀x (¬I(x) → ¬S(x))"
},
{
"input": "Translate into first-order logic: There exists at least one student in an advanced technology track.",
"output": "∃x V(x)"
},
{
"input": "Translate into first-order logic: If a student is in an advanced technology track, they must maintain cutting-edge technological skills.",
"output": "∀x (V(x) → U(x))"
},
{
"input": "Translate into first-order logic: If a student does not complete core courses, they cannot graduate.",
"output": "∀x (¬C(x) → ¬G(x))"
},
{
"input": "Translate into first-order logic: At least one student is enrolled in advanced research seminars.",
"output": "∃x S(x)"
},
{
"input": "Translate into first-order logic: If a student does not attend advanced research seminars, they cannot earn research credits.",
"output": "∀x (¬A(x) → ¬R(x))"
},
{
"input": "Translate into first-order logic: If a student does not have research credits, they cannot join advanced research programs.",
"output": "∀x (¬R(x) → ¬P(x))"
},
{
"input": "Translate into first-order logic: All students maintain academic excellence.",
"output": "∀x E(x)"
},
{
"input": "Translate into first-order logic: If a student does not maintain academic excellence, they are removed from research programs.",
"output": "∀x (¬E(x) → ¬Q(x))"
},
{
"input": "Translate into first-order logic: If a student completes advanced research seminars, they develop specialized research skills.",
"output": "∀x (M(x) → K(x))"
},
{
"input": "Translate into first-order logic: If a student develops specialized research skills, they become eligible for research grants.",
"output": "∀x (K(x) → N(x))"
},
{
"input": "Translate into first-order logic: If a student receives a research grant, they gain access to advanced research facilities.",
"output": "∀x (F(x) → D(x))"
},
{
"input": "Translate into first-order logic: There exists at least one opportunity for advanced research.",
"output": "∃x O(x)"
},
{
"input": "Translate into first-order logic: All students are required to participate in research projects.",
"output": "∀x J(x)"
},
{
"input": "Translate into first-order logic: If a student does not participate in research projects, they lose academic standing.",
"output": "∀x (¬J(x) → L(x))"
},
{
"input": "Translate into first-order logic: Students with advanced research access can attend specialized workshops.",
"output": "∀x (D(x) → W(x))"
},
{
"input": "Translate into first-order logic: If a student loses academic standing, they cannot receive research grants.",
"output": "∀x (L(x) → ¬F(x))"
},
{
"input": "Translate into first-order logic: Completing research projects implies developing specialized research skills.",
"output": "∀x (B(x) → K(x))"
},
{
"input": "Translate into first-order logic: If a student obtains academic credits, they meet course requirements.",
"output": "∀x (A(x) → M(x))"
},
{
"input": "Translate into first-order logic: If a student conducts research, they obtain academic credits.",
"output": "∀x (R(x) → A(x))"
},
{
"input": "Translate into first-order logic: If a student participates in seminars, they obtain academic credits.",
"output": "∀x (S(x) → A(x))"
},
{
"input": "Translate into first-order logic: All students are enrolled in advanced programs.",
"output": "∀x P(x)"
},
{
"input": "Translate into first-order logic: If a student obtains academic credits, they are in an advanced program.",
"output": "∀x (A(x) → P(x))"
},
{
"input": "Translate into first-order logic: At least one student participates in seminars.",
"output": "∃x S(x)"
},
{
"input": "Translate into first-order logic: At least one student obtains academic credits.",
"output": "∃x A(x)"
},
{
"input": "Translate into first-order logic: If a student participates in seminars, they are in an advanced program.",
"output": "∀x (S(x) → P(x))"
},
{
"input": "Translate into first-order logic: All students obtain academic credits.",
"output": "∀x A(x)"
},
{
"input": "Translate into first-order logic: All students conduct research.",
"output": "∀x R(x)"
},
{
"input": "Translate into first-order logic: At least one student conducts research.",
"output": "∃x R(x)"
},
{
"input": "Translate into first-order logic: If a student takes advanced tests, they meet course requirements.",
"output": "∀x (T(x) → M(x))"
},
{
"input": "Translate into first-order logic: If at least one student conducts research, then conducting research implies obtaining academic credits.",
"output": "∃x R(x) → ∀x (R(x) → A(x))"
},
{
"input": "Translate into first-order logic: If obtaining academic credits implies meeting course requirements, then obtaining academic credits implies being in an advanced program.",
"output": "∀x (A(x) → M(x)) → ∀x (A(x) → P(x))"
},
{
"input": "Translate into first-order logic: If participating in seminars implies obtaining academic credits, then obtaining academic credits implies being in an advanced program.",
"output": "∀x (S(x) → A(x)) → ∀x (A(x) → P(x))"
},
{
"input": "Translate into first-order logic: If a student does not meet course requirements, they do not take advanced tests.",
"output": "∀x (¬M(x) → ¬T(x))"
},
{
"input": "Translate into first-order logic: At least one student takes advanced tests.",
"output": "∃x T(x)"
},
{
"input": "Translate into first-order logic: If a student participates in seminars, they meet course requirements.",
"output": "∀x (S(x) → M(x))"
},
{
"input": "Translate into first-order logic: If a student is in an advanced program, they take advanced tests.",
"output": "∀x (P(x) → T(x))"
},
{
"input": "Translate into first-order logic: All students attend training.",
"output": "∀x (Student(x) → AttendsTraining(x))"
},
{
"input": "Translate into first-order logic: All students study regularly.",
"output": "∀x (Student(x) → StudiesRegularly(x))"
},
{
"input": "Translate into first-order logic: All students qualify for a scholarship.",
"output": "∀x (QualifiesForScholarship(x))"
},
{
"input": "Translate into first-order logic: There is at least one student who attends tutoring sessions.",
"output": "∃x (AttendsTutoring(x))"
},
{
"input": "Translate into first-order logic: If a student does not receive a recommendation letter, then they do not understand the material.",
"output": "(¬ReceivesRecommendation(x) → ¬UnderstandsMaterial(x))"
},
{
"input": "Translate into first-order logic: All students receive a recommendation letter.",
"output": "∀x (ReceivesRecommendation(x))"
},
{
"input": "Translate into first-order logic: All students pass the exam.",
"output": "∀x (PassesExam(x))"
},
{
"input": "Translate into first-order logic: If a student studies regularly, then they pass the exam.",
"output": "(StudiesRegularly(x) → PassesExam(x))"
},
{
"input": "Translate into first-order logic: If a student understands the material, then they receive a recommendation letter.",
"output": "(UnderstandsMaterial(x) → ReceivesRecommendation(x))"
},
{
"input": "Translate into first-order logic: If a student does not receive a recommendation letter, then they do not study regularly.",
"output": "(¬ReceivesRecommendation(x) → ¬StudiesRegularly(x))"
},
{
"input": "Translate into first-order logic: There is at least one student who qualifies for a scholarship.",
"output": "∃x (QualifiesForScholarship(x))"
},
{
"input": "Translate into first-order logic: There is at least one student who studies regularly.",
"output": "∃x (StudiesRegularly(x))"
},
{
"input": "Translate into first-order logic: If a student does not receive a recommendation letter, then they do not pass the exam.",
"output": "(¬ReceivesRecommendation(x) → ¬PassesExam(x))"
},
{
"input": "Translate into first-order logic: If a student does not pass the exam, then they do not receive a recommendation letter.",
"output": "(¬PassesExam(x) → ¬ReceivesRecommendation(x))"
},
{
"input": "Translate into first-order logic: If not receiving a recommendation letter implies not passing the exam, then there is at least one student who qualifies for a scholarship.",
"output": "((¬ReceivesRecommendation(x) → ¬PassesExam(x)) → ∃x (QualifiesForScholarship(x)))"
},
{
"input": "Translate into first-order logic: If there is at least one student who attends tutoring sessions, then if a student does not pass the exam, they do not receive a recommendation letter.",
"output": "(∃x (AttendsTutoring(x)) → (¬PassesExam(x) → ¬ReceivesRecommendation(x)))"
},
{
"input": "Translate into first-order logic: If the implication (if not receiving a recommendation letter then not passing the exam) guarantees the existence of a student who qualifies for a scholarship, then there is at least one student who studies regularly.",
"output": "(((¬ReceivesRecommendation(x) → ¬PassesExam(x)) → ∃x (QualifiesForScholarship(x))) → ∃x (StudiesRegularly(x)))"
},
{
"input": "Translate into first-order logic: If a student passes the exam, then they attend tutoring sessions.",
"output": "(PassesExam(x) → AttendsTutoring(x))"
},
{
"input": "Translate into first-order logic: If a student does not understand the material, then they are not considered to qualify for a scholarship.",
"output": "(¬UnderstandsMaterial(x) → ¬QualifiesForScholarship(x))"
},
{
"input": "Translate into first-order logic: There is at least one student who passes the exam.",
"output": "∃x (PassesExam(x))"
},
{
"input": "Translate into first-order logic: If a student does not pass the exam, then they do not understand the material.",
"output": "(¬PassesExam(x) → ¬UnderstandsMaterial(x))"
},
{
"input": "Translate into first-order logic: If a student qualifies for a scholarship, then they pass the exam.",
"output": "(QualifiesScholarship(x) → PassesExam(x))"
},
{
"input": "Translate into first-order logic: There is at least one student who receives a recommendation letter.",
"output": "∃x (ReceivesRecommendation(x))"
},
{
"input": "Translate into first-order logic: All students attend tutoring sessions.",
"output": "∀x (AttendsTutoring(x))"
},
{
"input": "Translate into first-order logic: If a student does not receive a recommendation letter, then they do not study regularly.",
"output": "(¬ReceivesRecommendation(x) → ¬StudiesRegularly(x))"
},
{
"input": "Translate into first-order logic: If a student attends tutoring sessions, then they receive a recommendation letter.",
"output": "(AttendsTutoring(x) → ReceivesRecommendation(x))"
},
{
"input": "Translate into first-order logic: If a student does not receive a recommendation letter, then they do not pass the exam.",
"output": "(¬ReceivesRecommendation(x) → ¬PassesExam(x))"
},
{
"input": "Translate into first-order logic: If a student does not receive a recommendation letter, then they do not qualify for a scholarship.",
"output": "(¬ReceivesRecommendation(x) → ¬QualifiesScholarship(x))"
},
{
"input": "Translate into first-order logic: If a student does not receive a recommendation letter, then they do not attend tutoring sessions.",
"output": "(¬ReceivesRecommendation(x) → ¬AttendsTutoring(x))"
},
{
"input": "Translate into first-order logic: If a student does not pass the exam, then they do not receive a recommendation letter.",
"output": "(¬PassesExam(x) → ¬ReceivesRecommendation(x))"
},
{
"input": "Translate into first-order logic: All students receive a recommendation letter.",
"output": "∀x (ReceivesRecommendation(x))"
},
{
"input": "Translate into first-order logic: There is at least one student who qualifies for a scholarship.",
"output": "∃x (QualifiesScholarship(x))"
},
{
"input": "Translate into first-order logic: There is at least one student who studies regularly.",
"output": "∃x (StudiesRegularly(x))"
},
{
"input": "Translate into first-order logic: If not passing the exam implies not receiving a recommendation letter, then not receiving a recommendation letter implies not qualifying for a scholarship.",
"output": "((¬PassesExam(x) → ¬ReceivesRecommendation(x)) → (¬ReceivesRecommendation(x) → ¬QualifiesScholarship(x)))"
},
{
"input": "Translate into first-order logic: If not receiving a recommendation letter implies not attending tutoring sessions, then if a student qualifies for a scholarship, they pass the exam.",
"output": "((¬ReceivesRecommendation(x) → ¬AttendsTutoring(x)) → (QualifiesScholarship(x) → PassesExam(x)))"
},
{
"input": "Translate into first-order logic: There is at least one student who passes the exam.",
"output": "∃x (PassesExam(x))"
},
{
"input": "Translate into first-order logic: If a student does not attend tutoring sessions, then they do not study regularly.",
"output": "(¬AttendsTutoring(x) → ¬StudiesRegularly(x))"
},
{
"input": "Translate into first-order logic: There is at least one student who attends tutoring sessions.",
"output": "∃x (AttendsTutoring(x))"
},
{
"input": "Translate into first-order logic: If a student passes the exam, then they receive a recommendation letter.",
"output": "(PassesExam(x) → ReceivesRecommendation(x))"
},
{
"input": "Translate into first-order logic: If a student does not pass the exam, then they do not receive an award.",
"output": "(¬PassesExam(x) → ¬ReceivesAward(x))"
},
{
"input": "Translate into first-order logic: If a student is diligent, then they study regularly.",
"output": "(Diligent(x) → StudiesRegularly(x))"
},
{
"input": "Translate into first-order logic: If a student studies regularly, then they receive an award.",
"output": "(StudiesRegularly(x) → ReceivesAward(x))"
},
{
"input": "Translate into first-order logic: There is at least one student who passes the exam.",
"output": "∃x (PassesExam(x))"
},
{
"input": "Translate into first-order logic: If a student participates in extracurricular activities, then they receive an award.",
"output": "(ParticipatesExtracurricular(x) → ReceivesAward(x))"
},
{
"input": "Translate into first-order logic: All students receive an award.",
"output": "∀x (ReceivesAward(x))"
},
{
"input": "Translate into first-order logic: There is at least one diligent student.",
"output": "∃x (Diligent(x))"
},
{
"input": "Translate into first-order logic: If a student does not attend tutoring sessions, then they do not study regularly.",
"output": "(¬AttendsTutoring(x) → ¬StudiesRegularly(x))"
},
{
"input": "Translate into first-order logic: All students pass the exam.",
"output": "∀x (PassesExam(x))"
},
{
"input": "Translate into first-order logic: There is at least one student who studies regularly.",
"output": "∃x (StudiesRegularly(x))"
},
{
"input": "Translate into first-order logic: All students are diligent.",
"output": "∀x (Diligent(x))"
},
{
"input": "Translate into first-order logic: There is at least one student who attends tutoring sessions.",
"output": "∃x (AttendsTutoring(x))"
},
{
"input": "Translate into first-order logic: If being diligent implies studying regularly, then all students pass the exam.",
"output": "((Diligent(x) → StudiesRegularly(x)) → ∀x (PassesExam(x)))"
},
{
"input": "Translate into first-order logic: If the fact that being diligent implies studying regularly leads to all students passing the exam, then there is at least one diligent student.",
"output": "(((Diligent(x) → StudiesRegularly(x)) → ∀x (PassesExam(x))) → ∃x (Diligent(x)))"
},
{
"input": "Translate into first-order logic: If there is at least one student who attends tutoring sessions, then if being diligent implies studying regularly leads to all students passing the exam, then there is at least one diligent student.",
"output": "(∃x (AttendsTutoring(x)) → (((Diligent(x) → StudiesRegularly(x)) → ∀x (PassesExam(x))) → ∃x (Diligent(x))))"
},
{
"input": "Translate into first-order logic: If a student studies regularly, then they participate in extracurricular activities.",
"output": "(StudiesRegularly(x) → ParticipatesExtracurricular(x))"
},
{
"input": "Translate into first-order logic: If a student does not attend tutoring sessions, then they do not receive an award.",
"output": "(¬AttendsTutoring(x) → ¬ReceivesAward(x))"
},
{
"input": "Translate into first-order logic: If a student passes the exam, then they participate in extracurricular activities.",
"output": "(PassesExam(x) → ParticipatesExtracurricular(x))"
},
{
"input": "Translate into first-order logic: If a student passes the exam, then they attend tutoring sessions.",
"output": "(PassesExam(x) → AttendsTutoring(x))"
},
{
"input": "Translate into first-order logic: If a student does not qualify for a scholarship, then they do not receive an award.",
"output": "(¬QualifiesScholarship(x) → ¬ReceivesAward(x))"
},
{
"input": "Translate into first-order logic: There is at least one student who qualifies for a scholarship.",
"output": "∃x (QualifiesScholarship(x))"
},
{
"input": "Translate into first-order logic: If a student does not study regularly, then they do not receive an award.",
"output": "(¬StudiesRegularly(x) → ¬ReceivesAward(x))"
},
{
"input": "Translate into first-order logic: If a student studies regularly, then they pass the exam.",
"output": "(StudiesRegularly(x) → PassesExam(x))"
},
{
"input": "Translate into first-order logic: All students qualify for a scholarship.",
"output": "∀x (QualifiesScholarship(x))"
},
{
"input": "Translate into first-order logic: All students receive a recommendation letter.",
"output": "∀x (ReceivesRecommendation(x))"
},
{
"input": "Translate into first-order logic: There is at least one student who attends tutoring sessions.",
"output": "∃x (AttendsTutoring(x))"
},
{
"input": "Translate into first-order logic: All students receive an award.",
"output": "∀x (ReceivesAward(x))"
},
{
"input": "Translate into first-order logic: If a student does not qualify for a scholarship, then they do not receive a recommendation letter.",
"output": "(¬QualifiesScholarship(x) → ¬ReceivesRecommendation(x))"
},
{
"input": "Translate into first-order logic: If a student qualifies for a scholarship, then they receive a recommendation letter.",
"output": "(QualifiesScholarship(x) → ReceivesRecommendation(x))"
},
{
"input": "Translate into first-order logic: There is at least one student who studies regularly.",
"output": "∃x (StudiesRegularly(x))"
},
{
"input": "Translate into first-order logic: All students study regularly.",
"output": "∀x (StudiesRegularly(x))"
},
{
"input": "Translate into first-order logic: If it holds that if a student does not study regularly then they do not receive an award, then all students qualify for a scholarship.",
"output": "((¬StudiesRegularly(x) → ¬ReceivesAward(x)) → ∀x (QualifiesScholarship(x)))"
},
{
"input": "Translate into first-order logic: If a student qualifying for a scholarship implies they receive a recommendation letter, then there is at least one student who attends tutoring sessions.",
"output": "((QualifiesScholarship(x) → ReceivesRecommendation(x)) → ∃x (AttendsTutoring(x)))"
},
{
"input": "Translate into first-order logic: There is at least one student who receives an award.",
"output": "∃x (ReceivesAward(x))"
},
{
"input": "Translate into first-order logic: If a student receives an award, then they receive a recommendation letter.",
"output": "(ReceivesAward(x) → ReceivesRecommendation(x))"
},
{
"input": "Translate into first-order logic: If a student does not pass the exam, then they do not attend tutoring sessions.",
"output": "(¬PassesExam(x) → ¬AttendsTutoring(x))"
},
{
"input": "Translate into first-order logic: If a student does not attend tutoring sessions, then they do not study regularly.",
"output": "(¬AttendsTutoring(x) → ¬StudiesRegularly(x))"
},
{
"input": "Translate into first-order logic: All students understand the material.",
"output": "∀x (UnderstandsMaterial(x))"
},
{
"input": "Translate into first-order logic: There is at least one student who passes the exam.",
"output": "∃x (PassesExam(x))"
},
{
"input": "Translate into first-order logic: All students study regularly.",
"output": "∀x (StudiesRegularly(x))"
},
{
"input": "Translate into first-order logic: There is at least one student who is diligent.",
"output": "∃x (IsDiligent(x))"
},
{
"input": "Translate into first-order logic: If a student does not study regularly, then they do not understand the material.",
"output": "(¬StudiesRegularly(x) → ¬UnderstandsMaterial(x))"
},
{
"input": "Translate into first-order logic: There is at least one student who studies regularly.",
"output": "∃x (StudiesRegularly(x))"
},
{
"input": "Translate into first-order logic: If a student does not pass the exam, then they are not diligent.",
"output": "(¬PassesExam(x) → ¬IsDiligent(x))"
},
{
"input": "Translate into first-order logic: All students attend lectures.",
"output": "∀x (AttendsLectures(x))"
},
{
"input": "Translate into first-order logic: All students are diligent.",
"output": "∀x (IsDiligent(x))"
},
{
"input": "Translate into first-order logic: If a student understands the material, then they study regularly.",
"output": "(UnderstandsMaterial(x) → StudiesRegularly(x))"
},
{
"input": "Translate into first-order logic: If a student completes assignments, then they study regularly.",
"output": "(CompletesAssignments(x) → StudiesRegularly(x))"
},
{
"input": "Translate into first-order logic: There is at least one student who completes assignments.",
"output": "∃x (CompletesAssignments(x))"
},
{
"input": "Translate into first-order logic: If completing assignments implies studying regularly, then all students understand the material.",
"output": "((CompletesAssignments(x) → StudiesRegularly(x)) → (∀x (UnderstandsMaterial(x))))"
},
{
"input": "Translate into first-order logic: If understanding the material implies studying regularly, then there is at least one student who completes assignments.",
"output": "((UnderstandsMaterial(x) → StudiesRegularly(x)) → ∃x (CompletesAssignments(x)))"
},
{
"input": "Translate into first-order logic: There is at least one student who understands the material.",
"output": "∃x (UnderstandsMaterial(x))"
},
{
"input": "Translate into first-order logic: If a student does not complete assignments, then they do not study regularly.",
"output": "(¬CompletesAssignments(x) → ¬StudiesRegularly(x))"
},
{
"input": "Translate into first-order logic: All students pass the exam.",
"output": "∀x (PassesExam(x))"
},
{
"input": "Translate into first-order logic: If a student does not attend lectures, then they do not complete assignments.",
"output": "(¬AttendsLectures(x) → ¬CompletesAssignments(x))"
},
{
"input": "Translate into first-order logic: If a student understands the material, then they attend tutoring sessions.",
"output": "(UnderstandsMaterial(x) → AttendsTutoring(x))"
},
{
"input": "Translate into first-order logic: If a student understands the material, then they receive a recommendation letter.",
"output": "(UnderstandsMaterial(x) → ReceivesRecommendation(x))"
},
{
"input": "Translate into first-order logic: There is at least one student who attends tutoring sessions.",
"output": "∃x (AttendsTutoring(x))"
},
{
"input": "Translate into first-order logic: If a student does not receive a recommendation letter, then they do not understand the material.",
"output": "(¬ReceivesRecommendation(x) → ¬UnderstandsMaterial(x))"
},
{
"input": "Translate into first-order logic: If a student receives a recommendation letter, then they study regularly.",
"output": "(ReceivesRecommendation(x) → StudiesRegularly(x))"
},
{
"input": "Translate into first-order logic: If a student does not qualify for a scholarship, then they do not study regularly.",
"output": "(¬QualifiesScholarship(x) → ¬StudiesRegularly(x))"
},
{
"input": "Translate into first-order logic: All students pass the exam.",
"output": "∀x (PassesExam(x))"
},
{
"input": "Translate into first-order logic: If a student does not pass the exam, then they do not qualify for a scholarship.",
"output": "(¬PassesExam(x) → ¬QualifiesScholarship(x))"
},
{
"input": "Translate into first-order logic: There is at least one student who receives a recommendation letter.",
"output": "∃x (ReceivesRecommendation(x))"
},
{
"input": "Translate into first-order logic: If a student does not study regularly, then they do not qualify for a scholarship.",
"output": "(¬StudiesRegularly(x) → ¬QualifiesScholarship(x))"
},
{
"input": "Translate into first-order logic: If a student Trần tutoring sessions, then they qualify for a scholarship.",
"output": "(AttendsTutoring(x) → QualifiesScholarship(x))"
},
{
"input": "Translate into first-order logic: If a student studies regularly, then they qualify for a scholarship.",
"output": "(StudiesRegularly(x) → QualifiesScholarship(x))"
},
{
"input": "Translate into first-order logic: If there is at least one student who attends tutoring sessions, then there is at least one student who receives a recommendation letter.",
"output": "(∃x (AttendsTutoring(x)) → ∃x (ReceivesRecommendation(x)))"
},
{
"input": "Translate into first-order logic: If studying regularly implies qualifying for a scholarship, then there is at least one student who attends tutoring sessions.",
"output": "((StudiesRegularly(x) → QualifiesScholarship(x)) → ∃x (AttendsTutoring(x)))"
},
{
"input": "Translate into first-order logic: All students attend tutoring sessions.",
"output": "∀x (AttendsTutoring(x))"
},
{
"input": "Translate into first-order logic: If a student understands the material, then they qualify for a scholarship.",
"output": "(UnderstandsMaterial(x) → QualifiesScholarship(x))"
},
{
"input": "Translate into first-order logic: If a student passes the exam, then they understands the material.",
"output": "(PassesExam(x) → UnderstandsMaterial(x))"
},
{
"input": "Translate into first-order logic: All students study regularly.",
"output": "∀x (StudiesRegularly(x))"
},
{
"input": "Translate into first-order logic: There is at least one student who passes the exam.",
"output": "∃x PassesExam(x)"
},
{
"input": "Translate into first-order logic: If a student does not qualify for a scholarship, then they do not study regularly.",
"output": "∀x (¬QualifiesForScholarship(x) → ¬StudiesRegularly(x))"
},
{
"input": "Translate into first-order logic: If a student understands the material, then they qualify for a scholarship.",
"output": "∀x (UnderstandsMaterial(x) → QualifiesForScholarship(x))"
},
{
"input": "Translate into first-order logic: If a student does not understand the material, then they do not receive a recommendation letter.",
"output": "∀x (¬UnderstandsMaterial(x) → ¬ReceivesRecommendation(x))"
},
{
"input": "Translate into first-order logic: If a student qualifies for a scholarship, then they attend tutoring sessions.",
"output": "∀x (QualifiesForScholarship(x) → AttendsTutoring(x))"
},
{
"input": "Translate into first-order logic: If a student studies regularly, then they attend tutoring sessions.",
"output": "∀x (StudiesRegularly(x) → AttendsTutoring(x))"
},
{
"input": "Translate into first-order logic: If a student understands the material, then they study regularly.",
"output": "∀x (UnderstandsMaterial(x) → StudiesRegularly(x))"
},
{
"input": "Translate into first-order logic: If a student passes the exam, then they study regularly.",
"output": "∀x (PassesExam(x) → StudiesRegularly(x))"
},
{
"input": "Translate into first-order logic: There is at least one student who qualifies for a scholarship.",
"output": "∃x QualifiesForScholarship(x)"
},
{
"input": "Translate into first-order logic: If a student does not receive a recommendation letter, then they do not qualify for a scholarship.",
"output": "∀x (¬ReceivesRecommendation(x) → ¬QualifiesForScholarship(x))"
},
{
"input": "Translate into first-order logic: If a student does not understand the material, then they do not receive a recommendation letter.",
"output": "(¬UnderstandsMaterial(x) → ¬ReceivesRecommendation(x))"
},
{
"input": "Translate into first-order logic: If a student attends tutoring sessions, then they receive a recommendation letter.",
"output": "(AttendsTutoring(x) → ReceivesRecommendation(x))"
},
{
"input": "Translate into first-order logic: There is at least one student who understands the material.",
"output": "∃x (UnderstandsMaterial(x))"
},
{
"input": "Translate into first-order logic: All students pass the exam.",
"output": "∀x (PassesExam(x))"
},
{
"input": "Translate into first-order logic: If a student does not attend tutoring sessions, then they do not qualify for a scholarship.",
"output": "(¬AttendsTutoring(x) → ¬QualifiesForScholarship(x))"
},
{
"input": "Translate into first-order logic: If a student studies regularly, then they attend tutoring sessions.",
"output": "(StudiesRegularly(x) → AttendsTutoring(x))"
},
{
"input": "Translate into first-order logic: If a student qualifies for a scholarship, then they attend tutoring sessions.",
"output": "(QualifiesForScholarship(x) → AttendsTutoring(x))"
},
{
"input": "Translate into first-order logic: If a student passes the exam, then they understand the material.",
"output": "(PassesExam(x) → UnderstandsMaterial(x))"
},
{
"input": "Translate into first-order logic: If a student does not pass the exam, then they do not attend tutoring sessions.",
"output": "(¬PassesExam(x) → ¬AttendsTutoring(x))"
},
{
"input": "Translate into first-order logic: If a student understands the material, then they attend tutoring sessions.",
"output": "(UnderstandsMaterial(x) → AttendsTutoring(x))"
},
{
"input": "Translate into first-order logic: If a student does not pass the exam, then they do not study regularly.",
"output": "(¬PassesExam(x) → ¬StudiesRegularly(x))"
},
{
"input": "Translate into first-order logic: If a student does not study regularly, then they do not qualify for a scholarship.",
"output": "(¬StudiesRegularly(x) → ¬QualifiesForScholarship(x))"
},
{
"input": "Translate into first-order logic: If it holds that if a student does not understand the material then they do not receive a recommendation letter, then there is at least one student who understands the material.",
"output": "((¬UnderstandsMaterial(x) → ¬ReceivesRecommendation(x)) → ∃x (UnderstandsMaterial(x)))"
},
{
"input": "Translate into first-order logic: If it holds that if a student understands the material then they attend tutoring sessions, then if a student does not pass the exam, they do not attend tutoring sessions.",
"output": "((UnderstandsMaterial(x) → AttendsTutoring(x)) → (¬PassesExam(x) → ¬AttendsTutoring(x)))"
},
{
"input": "Translate into first-order logic: If a student receives a recommendation letter, then they attend tutoring sessions.",
"output": "(ReceivesRecommendation(x) → AttendsTutoring(x))"
},
{
"input": "Translate into first-order logic: If a student receives a recommendation letter, then they study regularly.",
"output": "(ReceivesRecommendation(x) → StudiesRegularly(x))"
},
{
"input": "Translate into first-order logic: All students receive a recommendation letter.",
"output": "∀x (ReceivesRecommendation(x))"
},
{
"input": "Translate into first-order logic: If a student studies regularly, then they receive a recommendation letter.",
"output": "(StudiesRegularly(x) → ReceivesRecommendation(x))"
},
{
"input": "Translate into first-order logic: There exists at least one student who is prepared.",
"output": "∃x (Prepared(x))"
},
{
"input": "Translate into first-order logic: There exists at least one student who asks questions.",
"output": "∃x (AsksQuestions(x))"
},
{
"input": "Translate into first-order logic: If a student is prepared, then they receive a recommendation letter.",
"output": "(Prepared(x) → ReceivesRecommendation(x))"
},
{
"input": "Translate into first-order logic: All students take the test.",
"output": "∀x (TakesTest(x))"
},
{
"input": "Translate into first-order logic: All students study regularly.",
"output": "∀x (StudiesRegularly(x))"
},
{
"input": "Translate into first-order logic: If a student does not receive a recommendation letter, then they do not ask questions.",
"output": "(¬ReceivesRecommendation(x) → ¬AsksQuestions(x))"
},
{
"input": "Translate into first-order logic: If a student is not prepared, then they do not receive a recommendation letter.",
"output": "(¬Prepared(x) → ¬ReceivesRecommendation(x))"
},
{
"input": "Translate into first-order logic: All students ask questions.",
"output": "∀x (AsksQuestions(x))"
},
{
"input": "Translate into first-order logic: If a student asks questions, then they are prepared.",
"output": "(AsksQuestions(x) → Prepared(x))"
},
{
"input": "Translate into first-order logic: If a student studies regularly, then they attend university.",
"output": "(StudiesRegularly(x) → AttendsUniversity(x))"
},
{
"input": "Translate into first-order logic: If a student does not take the test, then they do not ask questions.",
"output": "(¬TakesTest(x) → ¬AsksQuestions(x))"
},
{
"input": "Translate into first-order logic: If a student does not take the test, then they do not attend university.",
"output": "(¬TakesTest(x) → ¬AttendsUniversity(x))"
},
{
"input": "Translate into first-order logic: If at least one student asks questions, then all students who study regularly also attend university.",
"output": "(∃x (AsksQuestions(x)) → (StudiesRegularly(x) → AttendsUniversity(x)))"
},
{
"input": "Translate into first-order logic: If all students take the test, then at least one student is prepared.",
"output": "(∀x (TakesTest(x))) → (∃x (Prepared(x)))"
},
{
"input": "Translate into first-order logic: If the previous statement is true, then at least one student is prepared.",
"output": "(((∃x (AsksQuestions(x)) → (StudiesRegularly(x) → AttendsUniversity(x))) → ∃x (Prepared(x))) → ∃x (Prepared(x)))"
},
{
"input": "Translate into first-order logic: All students are prepared.",
"output": "∀x (Prepared(x))"
},
{
"input": "Translate into first-order logic: If a student is not prepared, then they do not study regularly.",
"output": "(¬Prepared(x) → ¬StudiesRegularly(x))"
},
{
"input": "Translate into first-order logic: There exists at least one student who attends university.",
"output": "∃x (AttendsUniversity(x))"
},
{
"input": "Translate into first-order logic: If a student asks questions, then they study regularly.",
"output": "(AsksQuestions(x) → StudiesRegularly(x))"
},
{
"input": "Translate into first-order logic: If a student attends tutoring sessions, then they qualify for a scholarship.",
"output": "∀x (Student(x) ∧ AttendsTutoring(x) → QualifiesForScholarship(x))"
},
{
"input": "Translate into first-order logic: If a student receives a recommendation letter, then they qualify for a scholarship.",
"output": "∀x (Student(x) ∧ ReceivesRecommendation(x) → QualifiesForScholarship(x))"
},
{
"input": "Translate into first-order logic: If a student understands the material, then they attend tutoring sessions.",
"output": "∀x (Student(x) ∧ UnderstandsMaterial(x) → AttendsTutoring(x))"
},
{
"input": "Translate into first-order logic: If a student passes the exam, then they understand the material.",
"output": "∀x (Student(x) ∧ PassesExam(x) → UnderstandsMaterial(x))"
},
{
"input": "Translate into first-order logic: If a student does not qualify for a scholarship, then they do not receive a recommendation letter.",
"output": "∀x (Student(x) ∧ ¬QualifiesForScholarship(x) → ¬ReceivesRecommendation(x))"
},
{
"input": "Translate into first-order logic: If a student studies regularly, then they pass the exam.",
"output": "(StudiesRegularly(x) → PassesExam(x))"
},
{
"input": "Translate into first-order logic: All students receive an award.",
"output": "∀x (ReceivesAward(x))"
},
{
"input": "Translate into first-order logic: If a student does not receive a recommendation letter, then they do not qualify for a scholarship.",
"output": "(¬ReceivesRecommendation(x) → ¬QualifiesForScholarship(x))"
},
{
"input": "Translate into first-order logic: There is at least one student who receives an award.",
"output": "∃x (ReceivesAward(x))"
},
{
"input": "Translate into first-order logic: There is at least one student who studies regularly.",
"output": "∃x (StudiesRegularly(x))"
},
{
"input": "Translate into first-order logic: All students pass the exam.",
"output": "∀x (PassesExam(x))"
},
{
"input": "Translate into first-order logic: All students study regularly.",
"output": "∀x (StudiesRegularly(x))"
},
{
"input": "Translate into first-order logic: If a student studies regularly, then they qualify for a scholarship.",
"output": "(StudiesRegularly(x) → QualifiesForScholarship(x))"
},
{
"input": "Translate into first-order logic: If a student studies regularly, then they receive a recommendation letter.",
"output": "(StudiesRegularly(x) → ReceivesRecommendation(x))"
},
{
"input": "Translate into first-order logic: There is at least one student who attends tutoring sessions.",
"output": "∃x (AttendsTutoring(x))"
},
{
"input": "Translate into first-order logic: If a student does not attend tutoring sessions, then they do not pass the exam.",
"output": "(¬AttendsTutoring(x) → ¬PassesExam(x))"
},
{
"input": "Translate into first-order logic: If a student qualifies for a scholarship, then they pass the exam.",
"output": "(QualifiesForScholarship(x) → PassesExam(x))"
},
{
"input": "Translate into first-order logic: If all students pass the exam, then all students study regularly.",
"output": "∀x (PassesExam(x)) → ∀x (StudiesRegularly(x))"
},
{
"input": "Translate into first-order logic: If qualifying for a scholarship implies passing the exam, then there is at least one student who studies regularly.",
"output": "((QualifiesForScholarship(x) → PassesExam(x)) → ∃x (StudiesRegularly(x)))"
},
{
"input": "Translate into first-order logic: If qualifying for a scholarship implies passing the exam, then if a student studies regularly, they pass the exam.",
"output": "((QualifiesForScholarship(x) → PassesExam(x)) → (StudiesRegularly(x) → PassesExam(x)))"
},
{
"input": "Translate into first-order logic: If a student does not qualify for a scholarship, then they do not study regularly.",
"output": "(¬QualifiesForScholarship(x) → ¬StudiesRegularly(x))"
},
{
"input": "Translate into first-order logic: If a student attends tutoring sessions, then they qualify for a scholarship.",
"output": "(AttendsTutoring(x) → QualifiesForScholarship(x))"
},
{
"input": "Translate into first-order logic: If a student qualifies for a scholarship, then they receive a recommendation letter.",
"output": "(QualifiesForScholarship(x) → ReceivesRecommendation(x))"
},
{
"input": "Translate into first-order logic: If a student does not receive a recommendation letter, then they do not pass the exam.",
"output": "(¬ReceivesRecommendation(x) → ¬PassesExam(x))"
},
{
"input": "Translate into first-order logic: If a student studies regularly, then they pass the exam.",
"output": "∀x (Student(x) ∧ StudiesRegularly(x) → PassesExam(x))"
},
{
"input": "Translate into first-order logic: If a student receives an award, then they study regularly.",
"output": "∀x (Student(x) ∧ ReceivesAward(x) → StudiesRegularly(x))"
},
{
"input": "Translate into first-order logic: If a student does not study regularly, then they do not qualify for a scholarship.",
"output": "∀x (Student(x) ∧ ¬StudiesRegularly(x) → ¬QualifiesForScholarship(x))"
},
{
"input": "Translate into first-order logic: If a student does not attend tutoring sessions, then they do not qualify for a scholarship.",
"output": "∀x (Student(x) ∧ ¬AttendsTutoring(x) → ¬QualifiesForScholarship(x))"
},
{
"input": "Translate into first-order logic: There is at least one student who qualifies for a scholarship.",
"output": "∃x (Student(x) ∧ QualifiesForScholarship(x))"
},
{
"input": "Translate into first-order logic: If a student invests time in project-based learning, that student gains a broader understanding of the subject.",
"output": "∀x (Student(x) ∧ InvestsTimeProjectLearning(x) → BroaderUnderstanding(x))"
},
{
"input": "Translate into first-order logic: There is at least one person who mentors first-year students.",
"output": "∃x (Person(x) ∧ MentorsFirstYears(x))"
},
{
"input": "Translate into first-order logic: If a student has a broader understanding of the subject, that student also mentors first-year students.",
"output": "∀x (Student(x) ∧ BroaderUnderstanding(x) → MentorsFirstYears(x))"
},
{
"input": "Translate into first-order logic: All students complete the end-of-term research paper.",
"output": "∀x (Student(x) → CompletesResearchPaper(x))"
},
{
"input": "Translate into first-order logic: If a student does not complete the end-of-term research paper, that student does not mentor first-year students.",
"output": "∀x ((Student(x) ∧ ¬CompletesResearchPaper(x)) → ¬MentorsFirstYears(x))"
},
{
"input": "Translate into first-order logic: All students have valid library access.",
"output": "∀x (Student(x) → ValidLibraryAccess(x))"
},
{
"input": "Translate into first-order logic: If investing time in project-based learning leads to a broader understanding, then everyone must complete the end-of-term research paper.",
"output": "((∀x ((Student(x) ∧ InvestsTimeProjectLearning(x)) → BroaderUnderstanding(x))) → (∀x (Student(x) → CompletesResearchPaper(x))))"
},
{
"input": "Translate into first-order logic: If a broader understanding leads to mentoring first-year students, then investing time in project-based learning leads to that broader understanding.",
"output": "((∀x ((Student(x) ∧ BroaderUnderstanding(x)) → MentorsFirstYears(x))) → (∀x ((Student(x) ∧ InvestsTimeProjectLearning(x)) → BroaderUnderstanding(x))))"
},
{
"input": "Translate into first-order logic: If a student never visits the campus writing center, that student does not maintain valid library access.",
"output": "∀x ((Student(x) ∧ ¬VisitsWritingCenter(x)) → ¬ValidLibraryAccess(x))"
},
{
"input": "Translate into first-order logic: There is at least one person who uses the library’s advanced research tools.",
"output": "∃x (Person(x) ∧ UsesAdvancedResearchTools(x))"
},
{
"input": "Translate into first-order logic: If a person mentors first-year students, that person also has a broader understanding of the subject.",
"output": "∀x ((Person(x) ∧ MentorsFirstYears(x)) → BroaderUnderstanding(x))"
},
{
"input": "Translate into first-order logic: If a student enrolls in advanced courses, the student excels in those courses.",
"output": "∀x (Student(x) ∧ EnrollsAdvanced(x) → Excels(x))"
},
{
"input": "Translate into first-order logic: If a learner completes all assigned coursework, the learner masters foundational knowledge.",
"output": "∀x (Learner(x) ∧ CompletesCoursework(x) → MastersFoundations(x))"
},
{
"input": "Translate into first-order logic: All learners complete their assigned coursework.",
"output": "∀x (Learner(x) → CompletesCoursework(x))"
},
{
"input": "Translate into first-order logic: If a student enrolls in advanced courses, the student masters foundational knowledge.",
"output": "∀x (Student(x) ∧ EnrollsAdvanced(x) → MastersFoundations(x))"
},
{
"input": "Translate into first-order logic: If a researcher writes a publication, then the researcher provides novel insights to the field.",
"output": "∀x (Researcher(x) ∧ WritesPublication(x) → ProvidesNovelInsights(x))"
},
{
"input": "Translate into first-order logic: There exists a learner who completes all assigned coursework.",
"output": "∃x (Learner(x) ∧ CompletesCoursework(x))"
},
{
"input": "Translate into first-order logic: If it is established that students enrolled in advanced courses excel, then it remains true that they excel.",
"output": "((∀x (Student(x) ∧ EnrollsAdvanced(x) → Excels(x))) → (∀x (Student(x) ∧ EnrollsAdvanced(x) → Excels(x))))"
},
{
"input": "Translate into first-order logic: If a researcher writes a publication and thereby provides novel insights, then whenever students enroll in advanced courses and excel, they continue to excel.",
"output": "∀x (Researcher(x) ∧ WritesPublication(x) ∧ ProvidesNovelInsights(x) → ∀y (Student(y) ∧ EnrollsAdvanced(y) ∧ Excels(y) → ContinuesToExcel(y)))"
},
{
"input": "Translate into first-order logic: If a learner does not complete all assigned coursework, then the learner does not master foundational knowledge.",
"output": "∀x ((Learner(x) ∧ ¬CompletesCoursework(x)) → ¬MastersFoundations(x))"
},
{
"input": "Translate into first-order logic: All researchers provide novel insights to the field.",
"output": "∀x (Researcher(x) → ProvidesNovelInsights(x))"
},
{
"input": "Translate into first-order logic: All researchers write publications.",
"output": "∀x (Researcher(x) → WritesPublication(x))"
},
{
"input": "Translate into first-order logic: If a student studies regularly, then the student understands course material.",
"output": "∀x (Student(x) ∧ StudiesRegularly(x) → UnderstandsMaterial(x))"
},
{
"input": "Translate into first-order logic: There exists at least one student who passes the course.",
"output": "∃x (Student(x) ∧ PassesCourse(x))"
},
{
"input": "Translate into first-order logic: There exists at least one student who takes detailed notes.",
"output": "∃x (Student(x) ∧ TakesDetailedNotes(x))"
},
{
"input": "Translate into first-order logic: If a student does not take detailed notes, then the student does not qualify for advanced courses.",
"output": "∀x (Student(x) ∧ ¬TakesDetailedNotes(x) → ¬QualifiesForAdvanced(x))"
},
{
"input": "Translate into first-order logic: If a student does not understand course material, then the student does not take detailed notes.",
"output": "∀x (Student(x) ∧ ¬UnderstandsMaterial(x) → ¬TakesDetailedNotes(x))"
},
{
"input": "Translate into first-order logic: If it's true that not understanding course material implies not taking detailed notes, then there exists a student who passes the course.",
"output": "((∀x (Student(x) ∧ ¬UnderstandsMaterial(x) → ¬TakesDetailedNotes(x))) → (∃x (Student(x) ∧ PassesCourse(x))))"
},
{
"input": "Translate into first-order logic: If it's true that studying regularly implies understanding course material, then there exists a student who passes the course.",
"output": "((∀x (Student(x) ∧ StudiesRegularly(x) → UnderstandsMaterial(x))) → (∃x (Student(x) ∧ PassesCourse(x))))"
},
{
"input": "Translate into first-order logic: If a student does not qualify for advanced courses, then the student does not understand course material.",
"output": "∀x (Student(x) ∧ ¬QualifiesForAdvanced(x) → ¬UnderstandsMaterial(x))"
},
{
"input": "Translate into first-order logic: If a student understands course material, then the student passes the course.",
"output": "∀x (Student(x) ∧ UnderstandsMaterial(x) → PassesCourse(x))"
},
{
"input": "Translate into first-order logic: There exists at least one student who takes advanced courses.",
"output": "∃x (Student(x) ∧ TakesAdvancedCourses(x))"
},
{
"input": "Translate into first-order logic: There exists at least one student who is qualified for graduation.",
"output": "∃x (Student(x) ∧ QualifiedForGraduation(x))"
},
{
"input": "Translate into first-order logic: If a student regularly attends classes, then the student understands the course material.",
"output": "∀x (Student(x) ∧ RegularlyAttends(x) → UnderstandsMaterial(x))"
},
{
"input": "Translate into first-order logic: All students are qualified for graduation.",
"output": "∀x (Student(x) → QualifiedForGraduation(x))"
},
{
"input": "Translate into first-order logic: If a student takes advanced courses, then the student regularly attends classes.",
"output": "∀x (Student(x) ∧ TakesAdvancedCourses(x) → RegularlyAttends(x))"
},
{
"input": "Translate into first-order logic: If all students are qualified for graduation, then there exists at least one student who takes advanced courses.",
"output": "(∀x (Student(x) → QualifiedForGraduation(x)) → ∃x (Student(x) ∧ TakesAdvancedCourses(x)))"
},
{
"input": "Translate into first-order logic: If it's true that regular attendance implies understanding course material, then there exists at least one student who is qualified for graduation.",
"output": "((∀x (Student(x) ∧ RegularlyAttends(x) → UnderstandsMaterial(x))) → (∃x (Student(x) ∧ QualifiedForGraduation(x))))"
},
{
"input": "Translate into first-order logic: All students study consistently.",
"output": "∀x (Student(x) → StudiesConsistently(x))"
},
{
"input": "Translate into first-order logic: There exists at least one student who participates in discussions.",
"output": "∃x (Student(x) ∧ ParticipatesInDiscussions(x))"
},
{
"input": "Translate into first-order logic: There exists at least one student who takes advanced coursework.",
"output": "∃x (Student(x) ∧ TakesAdvancedCoursework(x))"
},
{
"input": "Translate into first-order logic: All students participate in study groups.",
"output": "∀x (Student(x) → ParticipatesInStudyGroups(x))"
},
{
"input": "Translate into first-order logic: If a student does not use the university library, then the student does not succeed in difficult courses.",
"output": "∀x (Student(x) ∧ ¬UsesLibrary(x) → ¬SucceedsInDifficultCourses(x))"
},
{
"input": "Translate into first-order logic: All students use the university library.",
"output": "∀x (Student(x) → UsesLibrary(x))"
},
{
"input": "Translate into first-order logic: If a student does not use the university library, then the student does not receive academic recognition.",
"output": "∀x (Student(x) ∧ ¬UsesLibrary(x) → ¬ReceivesAcademicRecognition(x))"
},
{
"input": "Translate into first-order logic: If all students use the university library, then there exists at least one student who takes advanced coursework.",
"output": "(∀x (Student(x) → UsesLibrary(x)) → ∃x (Student(x) ∧ TakesAdvancedCoursework(x)))"
},
{
"input": "Translate into first-order logic: If all students participate in study groups, then students who don't use the university library don't succeed in difficult courses.",
"output": "(∀x (Student(x) → ParticipatesInStudyGroups(x)) → ∀x (Student(x) ∧ ¬UsesLibrary(x) → ¬SucceedsInDifficultCourses(x)))"
},
{
"input": "Translate into first-order logic: If a student takes advanced coursework, then the student participates in study groups.",
"output": "∀x (Student(x) ∧ TakesAdvancedCoursework(x) → ParticipatesInStudyGroups(x))"
},
{
"input": "Translate into first-order logic: If a student does not take advanced coursework, then the student does not receive academic recognition.",
"output": "∀x (Student(x) ∧ ¬TakesAdvancedCoursework(x) → ¬ReceivesAcademicRecognition(x))"
},
{
"input": "Translate into first-order logic: There is at least one student enrolled in a specialized computer science course.",
"output": "∃x (SpecializedCourse(x))"
},
{
"input": "Translate into first-order logic: There exists a learner who regularly joins advanced seminars.",
"output": "∃x (AdvancedSeminar(x))"
},
{
"input": "Translate into first-order logic: If a learner carries out an independent research project, then that learner receives a key academic distinction.",
"output": "∀x (IndependentProject(x) → AcademicDistinction(x))"
},
{
"input": "Translate into first-order logic: Any learner who is not in a specialized computer science course will not conduct an independent research project.",
"output": "∀x (¬SpecializedCourse(x) → ¬IndependentProject(x))"
},
{
"input": "Translate into first-order logic: There is at least one learner who successfully undertakes an independent research project.",
"output": "∃x (IndependentProject(x))"
},
{
"input": "Translate into first-order logic: If learners outside specialized computer science courses never conduct an independent research project, then there is someone who has indeed completed such a project.",
"output": "((∀x (¬SpecializedCourse(x) → ¬IndependentProject(x))) → ∃x (IndependentProject(x)))"
},
{
"input": "Translate into first-order logic: If at least one learner regularly joins advanced seminars, then assuming learners who are not in specialized courses do not engage in research projects, there is still someone who completes one.",
"output": "(∃x (AdvancedSeminar(x)) → ((∀y (¬SpecializedCourse(y) → ¬IndependentProject(y))) → ∃z (IndependentProject(z))))"
},
{
"input": "Translate into first-order logic: If there is a learner in a specialized computer science course, then conducting an independent research project leads to earning an academic distinction.",
"output": "(∃x (SpecializedCourse(x)) → (∀y (IndependentProject(y) → AcademicDistinction(y))))"
},
{
"input": "Translate into first-order logic: Any learner not involved in research collaborations will not engage in an independent research project.",
"output": "∀x (¬ResearchCollaboration(x) → ¬IndependentProject(x))"
},
{
"input": "Translate into first-order logic: Whoever participates in research collaborations also joins advanced seminars.",
"output": "∀x (ResearchCollaboration(x) → AdvancedSeminar(x))"
},
{
"input": "Translate into first-order logic: Every person in this program is a university student.",
"output": "∀x (UniversityStudent(x))"
},
{
"input": "Translate into first-order logic: If someone is a university student, then they regularly attend lectures.",
"output": "∀x (UniversityStudent(x) → AttendsLectures(x))"
},
{
"input": "Translate into first-order logic: If a person does not regularly attend lectures, then they do not receive top grades.",
"output": "∀x (¬AttendsLectures(x) → ¬TopGrades(x))"
},
{
"input": "Translate into first-order logic: If a student submits all assignments on time, then they pass the course with distinction.",
"output": "∀x (SubmitsOnTime(x) → PassesWithDistinction(x))"
},
{
"input": "Translate into first-order logic: Everyone in the program regularly attends lectures.",
"output": "∀x (AttendsLectures(x))"
},
{
"input": "Translate into first-order logic: If everyone in the program is a university student, then it is true that those who don't regularly attend lectures don't receive top grades.",
"output": "(∀x (UniversityStudent(x)) → ∀x (¬AttendsLectures(x) → ¬TopGrades(x)))"
},
{
"input": "Translate into first-order logic: If submitting all assignments on time leads to passing with distinction, then not attending lectures regularly results in not receiving top grades.",
"output": "((∀x (SubmitsOnTime(x) → PassesWithDistinction(x))) → (∀x (¬AttendsLectures(x) → ¬TopGrades(x))))"
},
{
"input": "Translate into first-order logic: If not attending lectures regularly results in not receiving top grades, then submitting all assignments on time leads to passing with distinction.",
"output": "((∀x (¬AttendsLectures(x) → ¬TopGrades(x))) → (∀x (SubmitsOnTime(x) → PassesWithDistinction(x))))"
},
{
"input": "Translate into first-order logic: There exists at least one person who regularly attends lectures.",
"output": "∃x (AttendsLectures(x))"
},
{
"input": "Translate into first-order logic: There exists at least one university student in the program.",
"output": "∃x (UniversityStudent(x))"
},
{
"input": "Translate into first-order logic: There exists at least one teaching assistant in the computer science department.",
"output": "∃x (TeachingAssistant(x))"
},
{
"input": "Translate into first-order logic: There exists at least one student who participates in research projects.",
"output": "∃x (ResearchParticipant(x))"
},
{
"input": "Translate into first-order logic: If a student qualifies for graduate programs, then that student participates in research projects.",
"output": "∀x (QualifiesForGrad(x) → ResearchParticipant(x))"
},
{
"input": "Translate into first-order logic: If a student does not submit all assignments, then that student does not receive academic honors.",
"output": "∀x (¬SubmitsAssignments(x) → ¬ReceivesHonors(x))"
},
{
"input": "Translate into first-order logic: There exists at least one student who utilizes university resources.",
"output": "∃x (UtilizesResources(x))"
},
{
"input": "Translate into first-order logic: If there exists a student who participates in research projects, then it is true that students who don't submit all assignments won't receive academic honors.",
"output": "(∃x (ResearchParticipant(x)) → ∀y (¬SubmitsAssignments(y) → ¬ReceivesHonors(y)))"
},
{
"input": "Translate into first-order logic: If the existence of research project participants implies that non-submitters don't receive honors, then there exists a teaching assistant.",
"output": "((∃x (ResearchParticipant(x)) → ∀y (¬SubmitsAssignments(y) → ¬ReceivesHonors(y))) → ∃z (TeachingAssistant(z)))"
},
{
"input": "Translate into first-order logic: If there exists a research participant, then if the existence of research participants implies non-submitters don't receive honors, there must be a teaching assistant.",
"output": "(∃x (ResearchParticipant(x)) → ((∃y (ResearchParticipant(y)) → ∀z (¬SubmitsAssignments(z) → ¬ReceivesHonors(z))) → ∃w (TeachingAssistant(w))))"
},
{
"input": "Translate into first-order logic: If a student doesn't qualify for graduate programs, then that student doesn't submit all assignments.",
"output": "∀x (¬QualifiesForGrad(x) → ¬SubmitsAssignments(x))"
},
{
"input": "Translate into first-order logic: There exists at least one student who receives academic honors.",
"output": "∃x (ReceivesHonors(x))"
},
{
"input": "Translate into first-order logic: All participants in the summer coding bootcamp complete daily programming exercises.",
"output": "∀x (BootcampParticipant(x) → CompletesExercises(x))"
},
{
"input": "Translate into first-order logic: If someone completes daily programming exercises, then they develop practical coding skills.",
"output": "∀x (CompletesExercises(x) → DevelopsCodingSkills(x))"
},
{
"input": "Translate into first-order logic: If a student contributes to open-source projects, then they enhance their professional portfolio.",
"output": "∀x (ContributesToOpenSource(x) → EnhancesPortfolio(x))"
},
{
"input": "Translate into first-order logic: If a student doesn't receive mentorship, then they cannot contribute to open-source projects.",
"output": "∀x (¬ReceivesMentorship(x) → ¬ContributesToOpenSource(x))"
},
{
"input": "Translate into first-order logic: If a student attends code review sessions, then they receive mentorship.",
"output": "∀x (AttendsCodeReviews(x) → ReceivesMentorship(x))"
},
{
"input": "Translate into first-order logic: If all bootcamp participants complete daily exercises, then completing exercises develops practical coding skills.",
"output": "(∀x (BootcampParticipant(x) → CompletesExercises(x)) → ∀x (CompletesExercises(x) → DevelopsCodingSkills(x)))"
},
{
"input": "Translate into first-order logic: If not receiving mentorship prevents open-source contributions, then attending code reviews ensures receiving mentorship.",
"output": "(∀x (¬ReceivesMentorship(x) → ¬ContributesToOpenSource(x)) → ∀x (AttendsCodeReviews(x) → ReceivesMentorship(x)))"
},
{
"input": "Translate into first-order logic: If contributing to open-source enhances portfolios, then when all bootcamp participants complete daily exercises, this develops practical coding skills.",
"output": "(∀x (ContributesToOpenSource(x) → EnhancesPortfolio(x)) → (∀x (BootcampParticipant(x) → CompletesExercises(x)) → ∀x (CompletesExercises(x) → DevelopsCodingSkills(x))))"
},
{
"input": "Translate into first-order logic: All students contribute to open-source projects.",
"output": "∀x (ContributesToOpenSource(x))"
},
{
"input": "Translate into first-order logic: All students enhance their professional portfolios.",
"output": "∀x (EnhancesPortfolio(x))"
},
{
"input": "Translate into first-order logic: There exists at least one educational technology laboratory on campus.",
"output": "∃x (EducationalTechLab(x))"
},
{
"input": "Translate into first-order logic: All students take part in collaborative learning activities.",
"output": "∀x (Student(x) → ParticipatesToCollaborativeLearning(x))"
},
{
"input": "Translate into first-order logic: If a student qualifies for academic scholarships, then that student submits all required assignments.",
"output": "∀x (QualifiesForScholarship(x) → SubmitsAssignments(x))"
},
{
"input": "Translate into first-order logic: If a student does not qualify for academic scholarships, then that student does not take part in collaborative learning activities.",
"output": "∀x (¬QualifiesForScholarship(x) → ¬ParticipatesToCollaborativeLearning(x))"
},
{
"input": "Translate into first-order logic: All students submit all required assignments.",
"output": "∀x (Student(x) → SubmitsAssignments(x))"
},
{
"input": "Translate into first-order logic: If there exists an educational technology laboratory on campus, then all students take part in collaborative learning activities.",
"output": "(∃x (EducationalTechLab(x)) → ∀y (Student(y) → ParticipatesToCollaborativeLearning(y)))"
},
{
"input": "Translate into first-order logic: If all students take part in collaborative learning activities, then there exists an educational technology laboratory on campus.",
"output": "(∀x (Student(x) → ParticipatesToCollaborativeLearning(x)) → ∃y (EducationalTechLab(y)))"
},
{
"input": "Translate into first-order logic: If all students submit required assignments, then if there exists an educational technology laboratory, all students take part in collaborative learning activities.",
"output": "(∀x (Student(x) → SubmitsAssignments(x)) → (∃y (EducationalTechLab(y)) → ∀z (Student(z) → ParticipatesToCollaborativeLearning(z))))"
},
{
"input": "Translate into first-order logic: All students participate in peer review sessions.",
"output": "∀x (Student(x) → ParticipatesInPeerReview(x))"
},
{
"input": "Translate into first-order logic: All students qualify for academic scholarships.",
"output": "∀x (Student(x) → QualifiesForScholarship(x))"
},
{
"input": "Translate into first-order logic: All students in the digital literacy program take standardized assessments.",
"output": "∀x (TakesAssessments(x))"
},
{
"input": "Translate into first-order logic: All students participate in group projects.",
"output": "∀x (ParticipatesInProjects(x))"
},
{
"input": "Translate into first-order logic: There exists at least one student who qualifies for the honors program.",
"output": "∃x (QualifiesForHonors(x))"
},
{
"input": "Translate into first-order logic: If a student qualifies for the honors program, then that student participates in group projects.",
"output": "∀x (QualifiesForHonors(x) → ParticipatesInProjects(x))"
},
{
"input": "Translate into first-order logic: If a student participates in group projects, then that student receives constructive feedback.",
"output": "∀x (ParticipatesInProjects(x) → ReceivesFeedback(x))"
},
{
"input": "Translate into first-order logic: If participating in group projects means receiving constructive feedback, then all students participate in group projects.",
"output": "(∀x (ParticipatesInProjects(x) → ReceivesFeedback(x)) → ∀x (ParticipatesInProjects(x)))"
},
{
"input": "Translate into first-order logic: If all students participate in group projects, then participating in group projects means receiving constructive feedback.",
"output": "(∀x (ParticipatesInProjects(x)) → ∀x (ParticipatesInProjects(x) → ReceivesFeedback(x)))"
},
{
"input": "Translate into first-order logic: If qualifying for honors means participating in group projects, then if participating in projects means receiving feedback, all students participate in projects.",
"output": "(∀x (QualifiesForHonors(x) → ParticipatesInProjects(x)) → (∀x (ParticipatesInProjects(x) → ReceivesFeedback(x)) → ∀x (ParticipatesInProjects(x))))"
},
{
"input": "Translate into first-order logic: If a student does not utilize learning technologies, then that student does not succeed in advanced courses.",
"output": "∀x (¬UtilizesTechnology(x) → ¬SucceedsInAdvanced(x))"
},
{
"input": "Translate into first-order logic: If a student qualifies for the honors program, then that student takes standardized assessments.",
"output": "∀x (QualifiesForHonors(x) → TakesAssessments(x))"
},
{
"input": "Translate into first-order logic: There exists at least one research program at the university.",
"output": "∃x (ResearchProgram(x))"
},
{
"input": "Translate into first-order logic: There exists at least one pioneering course in the curriculum.",
"output": "∃x (PioneeringCourse(x))"
},
{
"input": "Translate into first-order logic: All educational programs use digital resources.",
"output": "∀x (EducationalProgram(x) → UsesDigitalResources(x))"
},
{
"input": "Translate into first-order logic: All students qualify for graduation.",
"output": "∀x (Student(x) → QualifiesForGraduation(x))"
},
{
"input": "Translate into first-order logic: There exists at least one student who takes final examinations.",
"output": "∃x (Student(x) ∧ TakesFinalExams(x))"
},
{
"input": "Translate into first-order logic: If there is a research program at the university, then there is at least one student who takes final examinations.",
"output": "(∃x (ResearchProgram(x)) → ∃y (Student(y) ∧ TakesFinalExams(y)))"
},
{
"input": "Translate into first-order logic: If there is a pioneering course in the curriculum, then there exists a research program at the university.",
"output": "(∃x (PioneeringCourse(x)) → ∃y (ResearchProgram(y)))"
},
{
"input": "Translate into first-order logic: If all students qualify for graduation, then all educational programs use digital resources.",
"output": "(∀x (Student(x) → QualifiesForGraduation(x)) → ∀y (EducationalProgram(y) → UsesDigitalResources(y)))"
},
{
"input": "Translate into first-order logic: All students take final examinations.",
"output": "∀x (Student(x) → TakesFinalExams(x))"
},
{
"input": "Translate into first-order logic: If a student qualifies for graduation, then that student takes final examinations.",
"output": "∀x (QualifiesForGraduation(x) → TakesFinalExams(x))"
},
{
"input": "Translate into first-order logic: All computer science students are skilled in software development.",
"output": "∀x (ComputerScienceStudent(x) → SkilledInSoftwareDev(x))"
},
{
"input": "Translate into first-order logic: If someone regularly practices coding, then they are skilled in software development.",
"output": "∀x (PracticesCoding(x) → SkilledInSoftwareDev(x))"
},
{
"input": "Translate into first-order logic: If a programmer qualifies for advanced certification, then they take specialized training courses.",
"output": "∀x (QualifiesForCertification(x) → TakesTrainingCourses(x))"
},
{
"input": "Translate into first-order logic: All computer science students regularly practice coding.",
"output": "∀x (ComputerScienceStudent(x) → PracticesCoding(x))"
},
{
"input": "Translate into first-order logic: If someone is skilled in software development, then they can produce professional applications.",
"output": "∀x (SkilledInSoftwareDev(x) → ProducesProfessionalApps(x))"
},
{
"input": "Translate into first-order logic: If all computer science students regularly practice coding, then regular coding practice leads to software development skill.",
"output": "(∀x (ComputerScienceStudent(x) → PracticesCoding(x)) → ∀x (PracticesCoding(x) → SkilledInSoftwareDev(x)))"
},
{
"input": "Translate into first-order logic: If all students are skilled in software development, then having software development skills means being able to produce professional applications.",
"output": "(∀x (ComputerScienceStudent(x) → SkilledInSoftwareDev(x)) → ∀x (SkilledInSoftwareDev(x) → ProducesProfessionalApps(x)))"
},
{
"input": "Translate into first-order logic: If having software development skills meaning capable of producing professional applications implies that regular coding practice leads to software skill, then the reverse implication also holds.",
"output": "((∀x (ComputerScienceStudent(x) → SkilledInSoftwareDev(x)) → ∀x (SkilledInSoftwareDev(x) → ProducesProfessionalApps(x))) → (∀x (ComputerScienceStudent(x) → PracticesCoding(x)) → ∀x (PracticesCoding(x) → SkilledInSoftwareDev(x))))"
},
{
"input": "Translate into first-order logic: If someone doesn't take specialized training courses, then they don't understand underlying algorithms.",
"output": "∀x (¬TakesTrainingCourses(x) → ¬UnderstandsAlgorithms(x))"
},
{
"input": "Translate into first-order logic: All computer science students can produce professional applications.",
"output": "∀x (ComputerScienceStudent(x) → ProducesProfessionalApps(x))"
},
{
"input": "Translate into first-order logic: There exists at least one student who graduates on time.",
"output": "∃x (GraduatesOnTime(x))"
},
{
"input": "Translate into first-order logic: All university students take required core curriculum courses.",
"output": "∀x (TakesRequiredCourses(x))"
},
{
"input": "Translate into first-order logic: If a student doesn't understand foundational concepts, then that student won't graduate on time.",
"output": "∀x (¬UnderstandsFoundations(x) → ¬GraduatesOnTime(x))"
},
{
"input": "Translate into first-order logic: There exists at least one student who studies regularly.",
"output": "∃x (StudiesRegularly(x))"
},
{
"input": "Translate into first-order logic: If a student doesn't study regularly, then that student won't graduate on time.",
"output": "∀x (¬StudiesRegularly(x) → ¬GraduatesOnTime(x))"
},
{
"input": "Translate into first-order logic: If it's true that not understanding foundational concepts prevents graduating on time, then all university students take required core curriculum courses.",
"output": "(∀x (¬UnderstandsFoundations(x) → ¬GraduatesOnTime(x)) → ∀x (TakesRequiredCourses(x)))"
},
{
"input": "Translate into first-order logic: If not understanding foundational concepts prevents on-time graduation, then there exists a student who studies regularly.",
"output": "(∀x (¬UnderstandsFoundations(x) → ¬GraduatesOnTime(x)) → ∃x (StudiesRegularly(x)))"
},
{
"input": "Translate into first-order logic: If all university students take required core curriculum courses, then there exists at least one student who graduates on time.",
"output": "(∀x (TakesRequiredCourses(x)) → ∃x (GraduatesOnTime(x)))"
},
{
"input": "Translate into first-order logic: There exists at least one student who understands foundational concepts.",
"output": "∃x (UnderstandsFoundations(x))"
},
{
"input": "Translate into first-order logic: If a student doesn't take required core curriculum courses, then that student doesn't understand foundational concepts.",
"output": "∀x (¬TakesRequiredCourses(x) → ¬UnderstandsFoundations(x))"
},
{
"input": "Translate into first-order logic: If a language learner completes immersion programs, then that learner achieves conversational fluency.",
"output": "∀x (CompletesImmersionProgram(x) → AchievesConversationalFluency(x))"
},
{
"input": "Translate into first-order logic: If a student doesn't engage with native speakers, then that student cannot complete immersion programs effectively.",
"output": "∀x (¬EngagesWithNativeSpeakers(x) → ¬CompletesImmersionProgram(x))"
},
{
"input": "Translate into first-order logic: There exists at least one language learner who regularly engages with native speakers.",
"output": "∃x (EngagesWithNativeSpeakers(x))"
},
{
"input": "Translate into first-order logic: If a language student doesn't engage with native speakers, then that student doesn't achieve conversational fluency.",
"output": "∀x (¬EngagesWithNativeSpeakers(x) → ¬AchievesConversationalFluency(x))"
},
{
"input": "Translate into first-order logic: There exists at least one student receiving cultural competency recognition.",
"output": "∃x (ReceivesCulturalCompetencyRecognition(x))"
},
{
"input": "Translate into first-order logic: If there exists a language learner who engages with native speakers, then students who don't engage with natives cannot complete immersion programs.",
"output": "(∃x (EngagesWithNativeSpeakers(x)) → ∀y (¬EngagesWithNativeSpeakers(y) → ¬CompletesImmersionProgram(y)))"
},
{
"input": "Translate into first-order logic: If not engaging with native speakers means not achieving fluency, then at least one student receives cultural competency recognition.",
"output": "(∀x (¬EngagesWithNativeSpeakers(x) → ¬AchievesConversationalFluency(x)) → ∃y (ReceivesCulturalCompetencyRecognition(y)))"
},
{
"input": "Translate into first-order logic: If not engaging with native speakers prevents completing immersion programs, then completing immersion programs leads to achieving conversational fluency.",
"output": "(∀x (¬EngagesWithNativeSpeakers(x) → ¬CompletesImmersionProgram(x)) → ∀y (CompletesImmersionProgram(y) → AchievesConversationalFluency(y)))"
},
{
"input": "Translate into first-order logic: All language students create digital pronunciation portfolios.",
"output": "∀x (LanguageStudent(x) → CreatesPronunciationPortfolio(x))"
},
{
"input": "Translate into first-order logic: There exists at least one student who has completed an immersion program.",
"output": "∃x (CompletesImmersionProgram(x))"
},
{
"input": "Translate into first-order logic: All students take part in team projects.",
"output": "∀x (TakesPartInTeamProjects(x))"
},
{
"input": "Translate into first-order logic: All students participate in peer reviews.",
"output": "∀x (ParticipatesInPeerReviews(x))"
},
{
"input": "Translate into first-order logic: All students utilize online learning resources.",
"output": "∀x (UtilizesOnlineResources(x))"
},
{
"input": "Translate into first-order logic: There exists at least one student who takes part in team projects.",
"output": "∃x (TakesPartInTeamProjects(x))"
},
{
"input": "Translate into first-order logic: There exists at least one student who utilizes online learning resources.",
"output": "∃x (UtilizesOnlineResources(x))"
},
{
"input": "Translate into first-order logic: If there exists a student who utilizes online learning resources, then all students take part in team projects.",
"output": "(∃x (UtilizesOnlineResources(x)) → ∀x (TakesPartInTeamProjects(x)))"
},
{
"input": "Translate into first-order logic: If it's true that the existence of a student utilizing online resources implies all students take part in team projects, then there exists a student who takes part in team projects.",
"output": "((∃x (UtilizesOnlineResources(x)) → ∀x (TakesPartInTeamProjects(x))) → ∃x (TakesPartInTeamProjects(x)))"
},
{
"input": "Translate into first-order logic: If it's true that the existence of a student utilizing online resources implies all students take part in team projects, then all students utilize online learning resources.",
"output": "((∃x (UtilizesOnlineResources(x)) → ∀x (TakesPartInTeamProjects(x))) → ∀x (UtilizesOnlineResources(x)))"
},
{
"input": "Translate into first-order logic: There exists at least one student who receives academic recognition.",
"output": "∃x (ReceivesAcademicRecognition(x))"
},
{
"input": "Translate into first-order logic: There exists at least one student who qualifies for advanced seminars.",
"output": "∃x (QualifiesForAdvancedSeminars(x))"
},
{
"input": "Translate into first-order logic: There exists at least one research-based educational program.",
"output": "∃x (ResearchBasedProgram(x))"
},
{
"input": "Translate into first-order logic: There exists at least one student who qualifies for honors distinction.",
"output": "∃x (QualifiesForHonors(x))"
},
{
"input": "Translate into first-order logic: If an educational program isn't research-based, then it doesn't incorporate thesis requirements.",
"output": "∀x (¬ResearchBasedProgram(x) → ¬IncorporatesThesis(x))"
},
{
"input": "Translate into first-order logic: All students participate in peer learning communities.",
"output": "∀x (ParticipatesInPeerLearning(x))"
},
{
"input": "Translate into first-order logic: If a program incorporates thesis requirements, then it is research-based.",
"output": "∀x (IncorporatesThesis(x) → ResearchBasedProgram(x))"
},
{
"input": "Translate into first-order logic: If all students participate in peer learning communities, then there exists a research-based educational program.",
"output": "(∀x (ParticipatesInPeerLearning(x)) → ∃x (ResearchBasedProgram(x)))"
},
{
"input": "Translate into first-order logic: If it's true that non-research programs lack thesis requirements, then it's also true that universal peer learning participation implies the existence of research-based programs.",
"output": "(∀x (¬ResearchBasedProgram(x) → ¬IncorporatesThesis(x)) → (∀x (ParticipatesInPeerLearning(x)) → ∃x (ResearchBasedProgram(x))))"
},
{
"input": "Translate into first-order logic: If programs incorporating thesis requirements are research-based, then there exists a student who qualifies for honors distinction.",
"output": "(∀x (IncorporatesThesis(x) → ResearchBasedProgram(x)) → ∃x (QualifiesForHonors(x)))"
},
{
"input": "Translate into first-order logic: If a student doesn't submit a substantial portfolio, then that student doesn't complete thesis requirements.",
"output": "∀x (¬SubmitsPortfolio(x) → ¬IncorporatesThesis(x))"
},
{
"input": "Translate into first-order logic: If a student doesn't submit a substantial portfolio, then that student doesn't qualify for honors distinction.",
"output": "∀x (¬SubmitsPortfolio(x) → ¬QualifiesForHonors(x))"
},
{
"input": "Translate into first-order logic: If a language student completes immersion training, then that student develops cultural competency.",
"output": "∀x (CompletesImmersion(x) → DevelopsCompetency(x))"
},
{
"input": "Translate into first-order logic: If a student doesn't practice with native speakers, then that student doesn't complete immersion training.",
"output": "∀x (¬PracticesWithNatives(x) → ¬CompletesImmersion(x))"
},
{
"input": "Translate into first-order logic: If a student earns language certification, then that student qualifies for international exchange programs.",
"output": "∀x (EarnsCertification(x) → QualifiesForExchange(x))"
},
{
"input": "Translate into first-order logic: There exists at least one student who earns language certification.",
"output": "∃x (EarnsCertification(x))"
},
{
"input": "Translate into first-order logic: If completing immersion training implies developing cultural competency, then earning certification implies qualifying for exchange programs.",
"output": "(∀x (CompletesImmersion(x) → DevelopsCompetency(x)) → ∀x (EarnsCertification(x) → QualifiesForExchange(x)))"
},
{
"input": "Translate into first-order logic: If immersion implies competency, then this relationship implies certification leads to exchange qualification.",
"output": "(∀x (CompletesImmersion(x) → DevelopsCompetency(x)) → (∀x (CompletesImmersion(x) → DevelopsCompetency(x)) → ∀x (EarnsCertification(x) → QualifiesForExchange(x))))"
},
{
"input": "Translate into first-order logic: If the relationship between immersion, competency, certification, and exchanges is valid, then certification implies exchange qualification.",
"output": "((∀x (CompletesImmersion(x) → DevelopsCompetency(x)) → ∀x (EarnsCertification(x) → QualifiesForExchange(x))) → ∀x (EarnsCertification(x) → QualifiesForExchange(x)))"
},
{
"input": "Translate into first-order logic: If not practicing with natives implies not completing immersion, then certification implies exchange qualification.",
"output": "(∀x (¬PracticesWithNatives(x) → ¬CompletesImmersion(x)) → ∀x (EarnsCertification(x) → QualifiesForExchange(x)))"
},
{
"input": "Translate into first-order logic: If a student earns language certification, then that student maintains a digital portfolio.",
"output": "∀x (EarnsCertification(x) → MaintainsPortfolio(x))"
},
{
"input": "Translate into first-order logic: There exists at least one student who has passed the final exam",
"output": "∃x (Student(x) ∧ PassedExam(x))"
},
{
"input": "Translate into first-order logic: Every student who attends lectures regularly performs well in exams",
"output": "∀x (Student(x) → (AttendsLectures(x) → PerformsWell(x)))"
},
{
"input": "Translate into first-order logic: Every student who fails the final exam must retake the course",
"output": "∀x (Student(x) → (FailedExam(x) → RetakeCourse(x)))"
},
{
"input": "Translate into first-order logic: If a student completes all required courses, then they graduate",
"output": "∀x (Student(x) → (CompletedCourses(x) → Graduate(x)))"
},
{
"input": "Translate into first-order logic: If all students who attend lectures perform well, then students who participate in discussions also perform well",
"output": "((∀x (Student(x) → (AttendsLectures(x) → PerformsWell(x)))) → ∀x (Student(x) → (ParticipatesDiscussions(x) → PerformsWell(x))))"
},
{
"input": "Translate into first-order logic: If a student does not pass the exam, then they do not get a diploma",
"output": "∀x (Student(x) → (¬PassedExam(x) → ¬Diploma(x)))"
},
{
"input": "Translate into first-order logic: Every student must maintain a minimum GPA to stay enrolled",
"output": "∀x (Student(x) → MaintainMinGPA(x))"
},
{
"input": "Translate into first-order logic: There exists at least one student who graduates",
"output": "∃x (Student(x) ∧ Graduate(x))"
},
{
"input": "Translate into first-order logic: There exists at least one professor who teaches an advanced mathematics course",
"output": "∃x (Professor(x) ∧ TeachesAdvancedMath(x))"
},
{
"input": "Translate into first-order logic: Every professor who teaches advanced mathematics must have a PhD",
"output": "∀x (Professor(x) → (TeachesAdvancedMath(x) → HasPhD(x)))"
},
{
"input": "Translate into first-order logic: Every student enrolled in an advanced mathematics course must have completed calculus",
"output": "∀x (Student(x) → (EnrolledAdvancedMath(x) → CompletedCalculus(x)))"
},
{
"input": "Translate into first-order logic: If a student does not attend tutorials, then they struggle with assignments",
"output": "∀x (Student(x) → (¬AttendsTutorials(x) → StrugglesAssignments(x)))"
},
{
"input": "Translate into first-order logic: If a student submits assignments on time, then they perform better in exams",
"output": "∀x (Student(x) → (SubmitsOnTime(x) → PerformsBetter(x)))"
},
{
"input": "Translate into first-order logic: If a student completes an advanced course, then they can apply for research programs",
"output": "∀x (Student(x) → (CompletedAdvancedCourse(x) → CanApplyResearch(x)))"
},
{
"input": "Translate into first-order logic: If every professor teaching advanced mathematics has a PhD, then those professors are experts in the field",
"output": "(∀x (Professor(x) → (TeachesAdvancedMath(x) → HasPhD(x)))) → ∀x (Professor(x) → Expert(x)))"
},
{
"input": "Translate into first-order logic: Every professor must conduct research in their field",
"output": "∀x (Professor(x) → ConductsResearch(x))"
},
{
"input": "Translate into first-order logic: There exists at least one student who is enrolled in a course",
"output": "∃x (Student(x) ∧ Enrolled(x))"
},
{
"input": "Translate into first-order logic: Every student must complete prerequisite courses before enrolling in an advanced course",
"output": "∀x (Student(x) → (EnrolledInAdvancedCourse(x) → PrerequisiteCompleted(x)))"
},
{
"input": "Translate into first-order logic: Every enrolled student has access to the university library",
"output": "∀x (Student(x) → (Enrolled(x) → HasLibraryAccess(x)))"
},
{
"input": "Translate into first-order logic: If a student is not officially registered, then they cannot enroll in courses",
"output": "∀x (Student(x) → (¬Registered(x) → ¬Enrolled(x)))"
},
{
"input": "Translate into first-order logic: If a student has completed all graduation requirements, then they are eligible for a diploma",
"output": "∀x (Student(x) → (GraduationRequirementsMet(x) → EligibleForDiploma(x)))"
},
{
"input": "Translate into first-order logic: If it is true that every student has access to the library, then any student who is officially enrolled can borrow books",
"output": "(∀x (Student(x) → HasLibraryAccess(x))) → ∀x (Student(x) → (Enrolled(x) → CanBorrowBooks(x)))"
},
{
"input": "Translate into first-order logic: If a student is not enrolled in any course, then they cannot access the library",
"output": "∀x (Student(x) → (¬Enrolled(x) → ¬HasLibraryAccess(x)))"
},
{
"input": "Translate into first-order logic: Every student must pay tuition fees to enroll in courses",
"output": "∀x (Student(x) → (Enrolled(x) → PaysTuition(x)))"
},
{
"input": "Translate into first-order logic: Every student who studies hard passes the exam",
"output": "∀x (Student(x) → (H(x) → P(x)))"
},
{
"input": "Translate into first-order logic: Some students do not study hard",
"output": "∃x (Student(x) ∧ ¬H(x))"
},
{
"input": "Translate into first-order logic: If a student is well-prepared, then they study hard",
"output": "∀x (Student(x) → (W(x) → H(x)))"
},
{
"input": "Translate into first-order logic: Every student in the university must pass at least one exam",
"output": "∀x (Student(x) → P(x))"
},
{
"input": "Translate into first-order logic: If a student attends all classes, then they are well-prepared",
"output": "∀x (Student(x) → (A(x) → W(x)))"
},
{
"input": "Translate into first-order logic: If a student fails an exam, then they did not attend all classes",
"output": "∀x (Student(x) → (F(x) → ¬A(x)))"
},
{
"input": "Translate into first-order logic: Some students who attend all classes do not study hard",
"output": "∃x (Student(x) ∧ A(x) ∧ ¬H(x))"
},
{
"input": "Translate into first-order logic: Every student who is well-prepared has a high chance of passing the exam",
"output": "∀x (Student(x) → (W(x) → HighChance(P(x))))"
},
{
"input": "Translate into first-order logic: If students are highly competitive, they tend to push themselves harder to achieve better results.",
"output": "∀x (Student(x) ∧ Competitive(x) → IncreasedEffort(x) ∧ BetterResults(x))"
},
{
"input": "Translate into first-order logic: If students suffer from excessive competition, they will experience higher stress and burnout.",
"output": "∀x (Student(x) ∧ ExcessiveCompetition(x) → Stress(x) ∧ Burnout(x))"
},
{
"input": "Translate into first-order logic: If students compete in a healthy environment, they often experience improved motivation and performance.",
"output": "∀x (Student(x) ∧ HealthyCompetition(x) ∧ SupportiveEnvironment(x) → ImprovedMotivation(x) ∧ EnhancedPerformance(x))"
},
{
"input": "Translate into first-order logic: If students face intense academic competition, they will experience feelings of inadequacy and anxiety.",
"output": "∀x (Student(x) ∧ IntenseCompetition(x) → Inadequacy(x) ∧ Anxiety(x))"
},
{
"input": "Translate into first-order logic: If students focus on personal growth, they will achieve more sustainable academic success.",
"output": "∀x (Student(x) ∧ PersonalGrowthFocus(x) → SustainableSuccess(x))"
},
{
"input": "Translate into first-order logic: If students experience cooperative learning environments, they can improve learning and enhance performance.",
"output": "∀x (Student(x) ∧ CooperativeLearning(x) → BetterLearning(x) ∧ HigherPerformance(x))"
},
{
"input": "Translate into first-order logic: If students engage in excessive competition, they will prioritize grades over deep understanding.",
"output": "∀x (Student(x) ∧ ExcessiveCompetition(x) → GradeFocus(x) ∧ ¬DeepUnderstanding(x))"
},
{
"input": "Translate into first-order logic: If students receive proper mentorship, they can balance competition with well-being.",
"output": "∀x (Student(x) ∧ GoodMentorship(x) → BalancedApproach(x) ∧ WellBeing(x))"
},
{
"input": "Translate into first-order logic: If students develop self-reflection habits, they can mitigate negative competition effects.",
"output": "∀x (Student(x) ∧ SelfReflection(x) → MitigateNegativeEffects(x))"
},
{
"input": "Translate into first-order logic: If institutions implement balanced evaluation systems, students experience reduced toxic competition.",
"output": "∀x (Institution(x) ∧ BalancedEvaluation(x) → ReduceToxicCompetition(x))"
},
{
"input": "Translate into first-order logic: There exists at least one educational policy that improves student engagement.",
"output": "∃x (Policy(x) ∧ ImprovesEngagement(x))"
},
{
"input": "Translate into first-order logic: Every education reform is aimed at increasing student success.",
"output": "∀x (Reform(x) → AimsStudentSuccess(x))"
},
{
"input": "Translate into first-order logic: If a teaching method is research-backed, then it is effective.",
"output": "∀x (TeachingMethod(x) ∧ ResearchBacked(x) → Effective(x))"
},
{
"input": "Translate into first-order logic: If an educational policy is ineffective, then it does not improve student engagement.",
"output": "∀x (Policy(x) ∧ Ineffective(x) → ¬ImprovesEngagement(x))"
},
{
"input": "Translate into first-order logic: If a curriculum is well-structured, then it leads to better learning outcomes.",
"output": "∀x (Curriculum(x) ∧ WellStructured(x) → BetterOutcomes(x))"
},
{
"input": "Translate into first-order logic: If every teacher is well-trained, then student performance increases.",
"output": "∀x (Teacher(x) → WellTrained(x))"
},
{
"input": "Translate into first-order logic: If a school has modern facilities, then it provides a better learning environment.",
"output": "∀x (School(x) ∧ ModernFacilities(x) → BetterEnvironment(x))"
},
{
"input": "Translate into first-order logic: If a school provides personalized learning, then it enhances student motivation.",
"output": "∀x (School(x) ∧ PersonalizedLearning(x) → EnhancesMotivation(x))"
},
{
"input": "Translate into first-order logic: Every well-funded school has access to better resources.",
"output": "∀x (School(x) ∧ WellFunded(x) → BetterResources(x))"
},
{
"input": "Translate into first-order logic: There exists at least one school that implements innovative teaching strategies.",
"output": "∃x (School(x) ∧ InnovativeStrategies(x))"
},
{
"input": "Translate into first-order logic: There exists at least one educational policy that improves student engagement.",
"output": "∃x (Policy(x) ∧ ImprovesEngagement(x))"
},
{
"input": "Translate into first-order logic: Every education reform is aimed at increasing student success.",
"output": "∀x (Reform(x) → AimsStudentSuccess(x))"
},
{
"input": "Translate into first-order logic: If a teaching method is research-backed, then it is effective.",
"output": "∀x (TeachingMethod(x) ∧ ResearchBacked(x) → Effective(x))"
},
{
"input": "Translate into first-order logic: If an educational policy is ineffective, then it does not improve student engagement.",
"output": "∀x (Policy(x) ∧ Ineffective(x) → ¬ImprovesEngagement(x))"
},
{
"input": "Translate into first-order logic: If a curriculum is well-structured, then it leads to better learning outcomes.",
"output": "∀x (Curriculum(x) ∧ WellStructured(x) → BetterOutcomes(x))"
},
{
"input": "Translate into first-order logic: If every teacher is well-trained, then student performance increases.",
"output": "∀x (Teacher(x) → WellTrained(x))"
},
{
"input": "Translate into first-order logic: If a school has modern facilities, then it provides a better learning environment.",
"output": "∀x (School(x) ∧ ModernFacilities(x) → BetterEnvironment(x))"
},
{
"input": "Translate into first-order logic: If a school provides personalized learning, then it enhances student motivation.",
"output": "∀x (School(x) ∧ PersonalizedLearning(x) → EnhancesMotivation(x))"
},
{
"input": "Translate into first-order logic: Every well-funded school has access to better resources.",
"output": "∀x (School(x) ∧ WellFunded(x) → BetterResources(x))"
},
{
"input": "Translate into first-order logic: There exists at least one school that implements innovative teaching strategies.",
"output": "∃x (School(x) ∧ InnovativeStrategies(x))"
},
{
"input": "Translate into first-order logic: There exists a student who excels in mathematics.",
"output": "∃x (Student(x) ∧ ExcelsMath(x))"
},
{
"input": "Translate into first-order logic: All students who study regularly perform well in exams.",
"output": "∀x (Student(x) ∧ StudiesRegularly(x) → PerformsWellExams(x))"
},
{
"input": "Translate into first-order logic: If a student understands the concepts, they can solve complex problems.",
"output": "∀x (Student(x) ∧ UnderstandsConcepts(x) → SolvesComplexProblems(x))"
},
{
"input": "Translate into first-order logic: If a student does not practice, then they struggle with problem-solving.",
"output": "∀x (Student(x) ∧ ¬Practices(x) → StrugglesProblemSolving(x))"
},
{
"input": "Translate into first-order logic: If a student attends lectures, then they gain a better understanding of the subject.",
"output": "∀x (Student(x) ∧ AttendsLectures(x) → BetterUnderstanding(x))"
},
{
"input": "Translate into first-order logic: If every student gets proper guidance, then their performance improves.",
"output": "∀x (Student(x) → ProperGuidance(x))"
},
{
"input": "Translate into first-order logic: If a student participates in group discussions, then their analytical skills enhance.",
"output": "∀x (Student(x) ∧ GroupDiscussions(x) → AnalyticalSkillsEnhanced(x))"
},
{
"input": "Translate into first-order logic: If a school has experienced teachers, then students learn effectively.",
"output": "∀x (School(x) ∧ ExperiencedTeachers(x) → LearnEffectively(x))"
},
{
"input": "Translate into first-order logic: Every student who takes mock tests scores higher in final exams.",
"output": "∀x (Student(x) ∧ TakesMockTests(x) → ScoresHigherExams(x))"
},
{
"input": "Translate into first-order logic: There exists at least one student who actively engages in class discussions.",
"output": "∃x (Student(x) ∧ EngagesClassDiscussions(x))"
},
{
"input": "Translate into first-order logic: There exists at least one university that implements a hybrid learning model.",
"output": "∃x (University(x) ∧ HybridLearning(x))"
},
{
"input": "Translate into first-order logic: Every accredited university follows a standard curriculum.",
"output": "∀x (University(x) ∧ Accredited(x) → StandardCurriculum(x))"
},
{
"input": "Translate into first-order logic: If a university offers online courses, then it increases accessibility.",
"output": "∀x (University(x) ∧ OnlineCourses(x) → IncreasesAccessibility(x))"
},
{
"input": "Translate into first-order logic: If a university does not provide scholarships, then some students cannot afford tuition.",
"output": "∀x (University(x) ∧ ¬Scholarships(x) → ¬AffordableTuition(x))"
},
{
"input": "Translate into first-order logic: If a university has strong research programs, then it attracts top faculty.",
"output": "∀x (University(x) ∧ StrongResearch(x) → TopFaculty(x))"
},
{
"input": "Translate into first-order logic: If every student has access to digital learning tools, then their learning experience improves.",
"output": "∀x (Student(x) → DigitalTools(x))"
},
{
"input": "Translate into first-order logic: If a university collaborates with industries, then students gain practical experience.",
"output": "∀x (University(x) ∧ IndustryCollaboration(x) → PracticalExperience(x))"
},
{
"input": "Translate into first-order logic: If a university provides mentorship programs, then student career readiness improves.",
"output": "∀x (University(x) ∧ MentorshipPrograms(x) → CareerReadiness(x))"
},
{
"input": "Translate into first-order logic: Every well-ranked university has high student satisfaction.",
"output": "∀x (University(x) ∧ WellRanked(x) → HighSatisfaction(x))"
},
{
"input": "Translate into first-order logic: There exists at least one university that supports interdisciplinary studies.",
"output": "∃x (University(x) ∧ InterdisciplinaryStudies(x))"
},
{
"input": "Translate into first-order logic: If students engage in active learning, they retain information more effectively.",
"output": "∀x (Student(x) ∧ ActiveLearning(x) → BetterRetention(x))"
},
{
"input": "Translate into first-order logic: If students have access to diverse learning materials, they develop a broader understanding of subjects.",
"output": "∀x (Student(x) ∧ AccessToDiverseMaterials(x) → BroaderUnderstanding(x))"
},
{
"input": "Translate into first-order logic: If students participate in group projects, they enhance teamwork and communication skills.",
"output": "∀x (Student(x) ∧ GroupProjects(x) → TeamworkSkills(x) ∧ CommunicationSkills(x))"
},
{
"input": "Translate into first-order logic: If students receive constructive feedback, they can improve their academic performance.",
"output": "∀x (Student(x) ∧ ConstructiveFeedback(x) → ImprovedPerformance(x))"
},
{
"input": "Translate into first-order logic: If students rely solely on rote memorization, they may struggle with critical thinking.",
"output": "∀x (Student(x) ∧ RoteMemorization(x) → ¬CriticalThinking(x))"
},
{
"input": "Translate into first-order logic: If students are exposed to real-world applications of knowledge, they gain a deeper appreciation for learning.",
"output": "∀x (Student(x) ∧ RealWorldApplications(x) → DeeperAppreciation(x))"
},
{
"input": "Translate into first-order logic: If students lack proper time management skills, they may experience academic burnout.",
"output": "∀x (Student(x) ∧ ¬TimeManagementSkills(x) → AcademicBurnout(x))"
},
{
"input": "Translate into first-order logic: If teachers provide personalized support, students feel more motivated to learn.",
"output": "∀x (Student(x) ∧ PersonalizedSupport(x) → HigherMotivation(x))"
},
{
"input": "Translate into first-order logic: If students practice self-discipline, they develop better study habits and consistency.",
"output": "∀x (Student(x) ∧ SelfDiscipline(x) → BetterStudyHabits(x) ∧ Consistency(x))"
},
{
"input": "Translate into first-order logic: If schools encourage a growth mindset, students are more resilient to academic challenges.",
"output": "∀x (School(x) ∧ GrowthMindsetEncouraged(x) → MoreResilientStudents(x))"
},
{
"input": "Translate into first-order logic: If students participate in extracurricular activities, they develop better social skills.",
"output": "∀x (Student(x) ∧ ExtracurricularActivities(x) → BetterSocialSkills(x))"
},
{
"input": "Translate into first-order logic: If students engage in project-based learning, they enhance problem-solving abilities.",
"output": "∀x (Student(x) ∧ ProjectBasedLearning(x) → EnhancedProblemSolving(x))"
},
{
"input": "Translate into first-order logic: If students receive timely academic support, they are less likely to fall behind in their studies.",
"output": "∀x (Student(x) ∧ TimelyAcademicSupport(x) → LessLikelihoodFallingBehind(x))"
},
{
"input": "Translate into first-order logic: If students are exposed to interdisciplinary learning, they gain a more holistic understanding of concepts.",
"output": "∀x (Student(x) ∧ InterdisciplinaryLearning(x) → HolisticUnderstanding(x))"
},
{
"input": "Translate into first-order logic: If students rely solely on test scores, they may neglect creativity and innovation.",
"output": "∀x (Student(x) ∧ SolelyTestScores(x) → ¬Creativity(x) ∧ ¬Innovation(x))"
},
{
"input": "Translate into first-order logic: If students collaborate with peers from diverse backgrounds, they improve cultural awareness and adaptability.",
"output": "∀x (Student(x) ∧ PeerDiversity(x) → ImprovedCulturalAwareness(x) ∧ BetterAdaptability(x))"
},
{
"input": "Translate into first-order logic: If students experience high academic pressure, they are more prone to anxiety and decreased motivation.",
"output": "∀x (Student(x) ∧ HighAcademicPressure(x) → IncreasedAnxiety(x) ∧ DecreasedMotivation(x))"
},
{
"input": "Translate into first-order logic: If teachers use interactive teaching methods, students are more engaged in learning.",
"output": "∀x (Student(x) ∧ InteractiveTeaching(x) → HigherEngagement(x))"
},
{
"input": "Translate into first-order logic: If students develop metacognitive skills, they become more effective independent learners.",
"output": "∀x (Student(x) ∧ MetacognitiveSkills(x) → MoreEffectiveIndependentLearning(x))"
},
{
"input": "Translate into first-order logic: If educational institutions promote lifelong learning habits, students continue to grow beyond formal education.",
"output": "∀x (Institution(x) ∧ PromoteLifelongLearning(x) → ContinuedGrowthBeyondEducation(x))"
},
{
"input": "Translate into first-order logic: If students engage in self-directed learning, they develop stronger critical thinking skills.",
"output": "∀x (Student(x) ∧ SelfDirectedLearning(x) → StrongerCriticalThinking(x))"
},
{
"input": "Translate into first-order logic: If students receive frequent formative assessments, they can track their academic progress effectively.",
"output": "∀x (Student(x) ∧ FrequentFormativeAssessments(x) → EffectiveProgressTracking(x))"
},
{
"input": "Translate into first-order logic: If students participate in classroom debates, they improve their reasoning and argumentation skills.",
"output": "∀x (Student(x) ∧ ClassroomDebates(x) → ImprovedReasoning(x) ∧ BetterArgumentation(x))"
},
{
"input": "Translate into first-order logic: If students engage in hands-on experiments, they gain a deeper understanding of scientific concepts.",
"output": "∀x (Student(x) ∧ HandsOnExperiments(x) → DeeperUnderstanding(x))"
},
{
"input": "Translate into first-order logic: If students face rigid curriculum structures, they may struggle to explore their personal interests.",
"output": "∀x (Student(x) ∧ RigidCurriculum(x) → StruggleToExploreInterests(x))"
},
{
"input": "Translate into first-order logic: If students work on open-ended projects, they enhance their creativity and innovation skills.",
"output": "∀x (Student(x) ∧ OpenEndedProjects(x) → EnhancedCreativity(x) ∧ StrongerInnovation(x))"
},
{
"input": "Translate into first-order logic: If students lack access to quality educational resources, their academic performance may suffer.",
"output": "∀x (Student(x) ∧ ¬QualityResources(x) → LowerAcademicPerformance(x))"
},
{
"input": "Translate into first-order logic: If teachers provide differentiated instruction, students with diverse learning needs perform better.",
"output": "∀x (Student(x) ∧ DifferentiatedInstruction(x) → BetterPerformanceDiverseNeeds(x))"
},
{
"input": "Translate into first-order logic: If students are encouraged to ask questions, they develop a stronger sense of curiosity and inquiry.",
"output": "∀x (Student(x) ∧ EncouragedToAskQuestions(x) → StrongerCuriosity(x) ∧ InquirySkills(x))"
},
{
"input": "Translate into first-order logic: If schools integrate technology in learning, students gain better digital literacy skills.",
"output": "∀x (Institution(x) ∧ TechnologyIntegratedLearning(x) → ImprovedDigitalLiteracy(x))"
},
{
"input": "Translate into first-order logic: If students engage in collaborative learning, they develop better teamwork skills.",
"output": "∀x (Student(x) ∧ CollaborativeLearning(x) → BetterTeamworkSkills(x))"
},
{
"input": "Translate into first-order logic: If students receive constructive feedback, they can improve their academic performance.",
"output": "∀x (Student(x) ∧ ConstructiveFeedback(x) → ImprovedAcademicPerformance(x))"
},
{
"input": "Translate into first-order logic: If students participate in extracurricular leadership roles, they enhance their decision-making abilities.",
"output": "∀x (Student(x) ∧ ExtracurricularLeadership(x) → EnhancedDecisionMaking(x))"
},
{
"input": "Translate into first-order logic: If students have access to personalized learning plans, they achieve better learning outcomes.",
"output": "∀x (Student(x) ∧ PersonalizedLearningPlans(x) → BetterLearningOutcomes(x))"
},
{
"input": "Translate into first-order logic: If students experience flexible learning environments, they adapt more effectively to different challenges.",
"output": "∀x (Student(x) ∧ FlexibleLearning(x) → EffectiveAdaptation(x))"
},
{
"input": "Translate into first-order logic: If students rely solely on rote memorization, they may struggle with critical thinking.",
"output": "∀x (Student(x) ∧ SolelyRoteMemorization(x) → StrugglesWithCriticalThinking(x))"
},
{
"input": "Translate into first-order logic: If students engage in interdisciplinary projects, they build connections between different fields of knowledge.",
"output": "∀x (Student(x) ∧ InterdisciplinaryProjects(x) → KnowledgeConnections(x))"
},
{
"input": "Translate into first-order logic: If students are taught time management strategies, they can handle academic workloads more efficiently.",
"output": "∀x (Student(x) ∧ TimeManagementStrategies(x) → EfficientWorkloadHandling(x))"
},
{
"input": "Translate into first-order logic: If students receive mentorship from experienced educators, they develop stronger career readiness skills.",
"output": "∀x (Student(x) ∧ ExperiencedMentorship(x) → StrongerCareerReadiness(x))"
},
{
"input": "Translate into first-order logic: If schools promote inclusive education, students from diverse backgrounds have equal learning opportunities.",
"output": "∀x (Institution(x) ∧ PromotesInclusiveEducation(x) → EqualLearningOpportunities(x))"
},
{
"input": "Translate into first-order logic: If students engage in problem-based learning, they develop stronger analytical skills.",
"output": "∀x (Student(x) ∧ ProblemBasedLearning(x) → StrongerAnalyticalSkills(x))"
},
{
"input": "Translate into first-order logic: If students have access to diverse learning materials, they gain a broader perspective on subjects.",
"output": "∀x (Student(x) ∧ DiverseLearningMaterials(x) → BroaderSubjectPerspective(x))"
},
{
"input": "Translate into first-order logic: If students participate in peer tutoring, both tutors and learners reinforce their knowledge.",
"output": "∀x (Student(x) ∧ PeerTutoring(x) → ReinforcedKnowledge(x))"
},
{
"input": "Translate into first-order logic: If students experience project-based assessments, they apply theoretical knowledge to practical situations.",
"output": "∀x (Student(x) ∧ ProjectBasedAssessments(x) → PracticalApplication(x))"
},
{
"input": "Translate into first-order logic: If students lack motivation, their academic performance may decline.",
"output": "∀x (Student(x) ∧ LackMotivation(x) → DeclinedAcademicPerformance(x))"
},
{
"input": "Translate into first-order logic: If students engage in digital learning platforms, they enhance their technological proficiency.",
"output": "∀x (Student(x) ∧ DigitalLearningPlatforms(x) → EnhancedTechProficiency(x))"
},
{
"input": "Translate into first-order logic: If students practice metacognitive strategies, they become more effective self-learners.",
"output": "∀x (Student(x) ∧ MetacognitiveStrategies(x) → EffectiveSelfLearner(x))"
},
{
"input": "Translate into first-order logic: If students receive clear learning objectives, they can set better academic goals.",
"output": "∀x (Student(x) ∧ ClearLearningObjectives(x) → BetterAcademicGoals(x))"
},
{
"input": "Translate into first-order logic: If students engage in physical activities during school hours, they improve their cognitive function.",
"output": "∀x (Student(x) ∧ SchoolPhysicalActivity(x) → ImprovedCognitiveFunction(x))"
},
{
"input": "Translate into first-order logic: If schools implement competency-based education, students progress based on mastery rather than time spent.",
"output": "∀x (Institution(x) ∧ CompetencyBasedEducation(x) → MasteryBasedProgression(x))"
},
{
"input": "Translate into first-order logic: Every student attends tutoring.",
"output": "∀x (Student(x) → AttendsTutoring(x))"
},
{
"input": "Translate into first-order logic: If a student completes assignments on time, then they understand the course material.",
"output": "∀x (Student(x) ∧ CompletesAssignmentsOnTime(x) → UnderstandsMaterial(x))"
},
{
"input": "Translate into first-order logic: If a student understands the material, then they are prepared for the final exam.",
"output": "∀x (Student(x) ∧ UnderstandsMaterial(x) → PreparedForExam(x))"
},
{
"input": "Translate into first-order logic: If a student completes assignments on time, then they submit assignments on time.",
"output": "∀x (Student(x) ∧ CompletesAssignmentsOnTime(x) → SubmitsAssignmentsOnTime(x))"
},
{
"input": "Translate into first-order logic: If a student completes assignments on time, then they are prepared for the final exam.",
"output": "∀x (Student(x) ∧ CompletesAssignmentsOnTime(x) → PreparedForExam(x))"
},
{
"input": "Translate into first-order logic: If a student installs the software from the university’s repository, then the software is functional.",
"output": "(InstallsSoftware(x) → FunctionalSoftware(x))"
},
{
"input": "Translate into first-order logic: There exists at least one student who has installed the software from the university’s repository.",
"output": "∃x (InstallsSoftware(x))"
},
{
"input": "Translate into first-order logic: There exists at least one student who is using the software.",
"output": "∃x (UsesSoftware(x))"
},
{
"input": "Translate into first-order logic: If a student does not update the software, then the software is not secure.",
"output": "(¬UpdatesSoftware(x) → ¬SecureSoftware(x))"
},
{
"input": "Translate into first-order logic: If a student does not install the software from the university’s repository, then the software is not functional.",
"output": "(¬InstallsSoftware(x) → ¬FunctionalSoftware(x))"
},
{
"input": "Translate into first-order logic: If a student installs the software, it implies that if they do not update it, the software will be insecure.",
"output": "(InstallsSoftware(x) → (¬UpdatesSoftware(x) → ¬SecureSoftware(x)))"
},
{
"input": "Translate into first-order logic: If a student installs the software, then they have access to the latest features from the university's system.",
"output": "(InstallsSoftware(x) → HasAccessToLatestFeatures(x))"
},
{
"input": "Translate into first-order logic: There exists at least one student who has updated the software.",
"output": "∃x (UpdatesSoftware(x))"
},
{
"input": "Translate into first-order logic: If a student does not update the software, then they do not have access to the latest features.",
"output": "(¬UpdatesSoftware(x) → ¬HasAccessToLatestFeatures(x))"
},
{
"input": "Translate into first-order logic: Every student attends tutoring.",
"output": "∀x (Student(x) → AttendsTutoring(x))"
},
{
"input": "Translate into first-order logic: If a student completes assignments on time, then they understand the course material.",
"output": "∀x (Student(x) ∧ CompletesAssignmentsOnTime(x) → UnderstandsMaterial(x))"
},
{
"input": "Translate into first-order logic: If a student understands the material, then they are prepared for the final exam.",
"output": "∀x (Student(x) ∧ UnderstandsMaterial(x) → PreparedForExam(x))"
},
{
"input": "Translate into first-order logic: If a student completes assignments on time, then they submit assignments on time.",
"output": "∀x (Student(x) ∧ CompletesAssignmentsOnTime(x) → SubmitsAssignmentsOnTime(x))"
},
{
"input": "Translate into first-order logic: If a student completes assignments on time, then they are prepared for the final exam.",
"output": "∀x (Student(x) ∧ CompletesAssignmentsOnTime(x) → PreparedForExam(x))"
},
{
"input": "Translate into first-order logic: There exists at least one student who is enrolled in the course.",
"output": "∃x (Enrolled(x))"
},
{
"input": "Translate into first-order logic: If a student studies consistently, then the student understands the subject.",
"output": "∀x ((StudiesConsistently(x) → UnderstandsSubject(x)))"
},
{
"input": "Translate into first-order logic: If a student does not study consistently, then the student does not perform well in exams.",
"output": "∀x ((¬StudiesConsistently(x) → ¬PerformsWell(x)))"
},
{
"input": "Translate into first-order logic: All students are enrolled in the course.",
"output": "∀x (Enrolled(x))"
},
{
"input": "Translate into first-order logic: If a student does not attend lectures, then the student does not complete assignments.",
"output": "∀x ((¬AttendsLectures(x) → ¬CompletesAssignments(x)))"
},
{
"input": "Translate into first-order logic: If studying consistently leads to understanding the subject, then all students are enrolled in the course.",
"output": "∀x (StudiesConsistently(x) → UnderstandsSubject(x)) → ∀x (Enrolled(x))"
},
{
"input": "Translate into first-order logic: All students complete their assignments.",
"output": "∀x (CompletesAssignments(x))"
},
{
"input": "Translate into first-order logic: If a student does not perform well in exams, then the student did not study consistently.",
"output": "∀x ((¬PerformsWell(x) → ¬StudiesConsistently(x)))"
},
{
"input": "Translate into first-order logic: If a student is not enrolled in the course, then the student does not complete assignments.",
"output": "∀x ((¬Enrolled(x) → ¬CompletesAssignments(x)))"
},
{
"input": "Translate into first-order logic: Every student attends tutoring.",
"output": "∀x (Student(x) → AttendsTutoring(x))"
},
{
"input": "Translate into first-order logic: If a student completes assignments on time, then they understand the course material.",
"output": "∀x (Student(x) ∧ CompletesAssignmentsOnTime(x) → UnderstandsMaterial(x))"
},
{
"input": "Translate into first-order logic: If a student understands the material, then they are prepared for the final exam.",
"output": "∀x (Student(x) ∧ UnderstandsMaterial(x) → PreparedForExam(x))"
},
{
"input": "Translate into first-order logic: If a student completes assignments on time, then they submit assignments on time.",
"output": "∀x (Student(x) ∧ CompletesAssignmentsOnTime(x) → SubmitsAssignmentsOnTime(x))"
},
{
"input": "Translate into first-order logic: If a student completes assignments on time, then they are prepared for the final exam.",
"output": "∀x (Student(x) ∧ CompletesAssignmentsOnTime(x) → PreparedForExam(x))"
},
{
"input": "Translate into first-order logic: All books in the library are cataloged.",
"output": "∀x (Cataloged(x))"
},
{
"input": "Translate into first-order logic: There exists at least one book that is cataloged.",
"output": "∃x (Cataloged(x))"
},
{
"input": "Translate into first-order logic: If a book is reserved, then it is not available for borrowing.",
"output": "∀x ((Reserved(x) → ¬Borrowable(x)))"
},
{
"input": "Translate into first-order logic: If a book is not returned, then it is not available.",
"output": "∀x ((¬Returned(x) → ¬Available(x)))"
},
{
"input": "Translate into first-order logic: All users of the library follow the library rules.",
"output": "∀x (FollowsRules(x))"
},
{
"input": "Translate into first-order logic: There exists at least one book that is available.",
"output": "∃x (Available(x))"
},
{
"input": "Translate into first-order logic: All books in the reference section cannot be borrowed.",
"output": "∀x ((ReferenceSection(x) → ¬Borrowable(x)))"
},
{
"input": "Translate into first-order logic: If all reference books cannot be borrowed, then there exists at least one available book.",
"output": "∀x (ReferenceSection(x) → ¬Borrowable(x)) → ∃x (Available(x))"
},
{
"input": "Translate into first-order logic: If a book is not reserved, then it is cataloged.",
"output": "∀x (¬Reserved(x) → Cataloged(x))"
},
{
"input": "Translate into first-order logic: If a book is available, then it is cataloged.",
"output": "∀x (Available(x) → Cataloged(x))"
},
{
"input": "Translate into first-order logic: If a book is not cataloged, then it is not in the reference section.",
"output": "∀x (¬Cataloged(x) → ¬ReferenceSection(x))"
},
{
"input": "Translate into first-order logic: All members provide support to their teammates.",
"output": "∀x (TeamMember(x) → SupportsTeammates(x))"
},
{
"input": "Translate into first-order logic: If a member supports their teammates, they take initiative.",
"output": "∀x (TeamMember(x) ∧ SupportsTeammates(x) → TakesInitiative(x))"
},
{
"input": "Translate into first-order logic: If a team member takes initiative, they collaborate.",
"output": "∀x (TeamMember(x) ∧ TakesInitiative(x) → Collaborates(x))"
},
{
"input": "Translate into first-order logic: If a team member does not communicate, they do not receive feedback.",
"output": "∀x (TeamMember(x) ∧ ¬Communicates(x) → ¬ReceivesFeedback(x))"
},
{
"input": "Translate into first-order logic: If a student does not practice Calculus exercises, they will not understand the concepts.",
"output": "∀x ((¬PracticeExercises(x) → ¬UnderstandConcepts(x)))"
},
{
"input": "Translate into first-order logic: If a student does not attend Calculus lectures, they will not understand the definitions.",
"output": "∀x ((¬AttendLectures(x) → ¬UnderstandDefinitions(x)))"
},
{
"input": "Translate into first-order logic: There exists at least one student who has mastered Calculus.",
"output": "∃x (MasterCalculus(x))"
},
{
"input": "Translate into first-order logic: All students have mastered Calculus.",
"output": "∀x (MasterCalculus(x))"
},
{
"input": "Translate into first-order logic: If a student does not attend lectures, they will not practice exercises.",
"output": "∀x ((¬AttendLectures(x) → ¬PracticeExercises(x)))"
},
{
"input": "Translate into first-order logic: If a student does not master Calculus, they will not practice exercises.",
"output": "∀x ((¬MasterCalculus(x) → ¬PracticeExercises(x)))"
},
{
"input": "Translate into first-order logic: If a student practices exercises, they will perform well in exams.",
"output": "∀x ((PracticeExercises(x) → PerformWell(x)))"
},
{
"input": "Translate into first-order logic: All students are required to submit assignments.",
"output": "∀x (SubmitAssignments(x))"
},
{
"input": "Translate into first-order logic: If a student does not take notes, they will not practice exercises.",
"output": "∀x ((¬TakeNotes(x) → ¬PracticeExercises(x)))"
},
{
"input": "Translate into first-order logic: If not attending lectures leads to not understanding definitions, then all students have mastered Calculus.",
"output": "∀x (¬AttendLectures(x) → ¬UnderstandDefinitions(x)) → ∀x (MasterCalculus(x))"
},
{
"input": "Translate into first-order logic: If a student does not attend lectures, they will not master Calculus.",
"output": "∀x ((¬AttendLectures(x) → ¬MasterCalculus(x)))"
},
{
"input": "Translate into first-order logic: If a student takes notes, they will perform well in exams.",
"output": "∀x ((TakeNotes(x) → PerformWell(x)))"
},
{
"input": "Translate into first-order logic: If a student does not practice exercises, they will not take notes.",
"output": "∀x ((¬PracticeExercises(x) → ¬TakeNotes(x)))"
},
{
"input": "Translate into first-order logic: All students practice exercises.",
"output": "∀x (PracticeExercises(x))"
},
{
"input": "Translate into first-order logic: All students perform well in exams.",
"output": "∀x (PerformWell(x))"
},
{
"input": "Translate into first-order logic: If a student does not perform well in exams, they will not master Calculus.",
"output": "∀x ((¬PerformWell(x) → ¬MasterCalculus(x)))"
},
{
"input": "Translate into first-order logic: If a student attends tutoring, then that student improves exam scores.",
"output": "∀x (Student(x) ∧ AttendsTutoring(x) → ImprovesExamScores(x))"
},
{
"input": "Translate into first-order logic: If a student improves exam scores, then that student has an opportunity to succeed.",
"output": "∀x (Student(x) ∧ ImprovesExamScores(x) → HasOpportunityToSucceed(x))"
},
{
"input": "Translate into first-order logic: If a student participates in group discussions, then that student attends tutoring.",
"output": "∀x (Student(x) ∧ ParticipatesGroupDiscussion(x) → AttendsTutoring(x))"
},
{
"input": "Translate into first-order logic: There exists at least one student who participates in group discussions.",
"output": "∃x (Student(x) ∧ ParticipatesGroupDiscussion(x))"
},
{
"input": "Translate into first-order logic: If a student does not submit assignments on time, then that student does not attend tutoring.",
"output": "∀x (Student(x) ∧ ¬SubmitsOnTime(x) → ¬AttendsTutoring(x))"
},
{
"input": "Translate into first-order logic: There exists at least one student who submits assignments.",
"output": "∃x (SubmitsAssignments(x))"
},
{
"input": "Translate into first-order logic: If a student completes the project, then they pass the test.",
"output": "∀x ((CompletesProject(x) → PassesTest(x)))"
},
{
"input": "Translate into first-order logic: If a student completes the project, then they attend lectures.",
"output": "∀x ((CompletesProject(x) → AttendsLectures(x)))"
},
{
"input": "Translate into first-order logic: Every student passes the test.",
"output": "∀x (PassesTest(x))"
},
{
"input": "Translate into first-order logic: Every student submits assignments.",
"output": "∀x (SubmitsAssignments(x))"
},
{
"input": "Translate into first-order logic: If at least one student submits assignments, then every student passes the test.",
"output": "∃x (SubmitsAssignments(x)) → ∀x (PassesTest(x))"
},
{
"input": "Translate into first-order logic: There exists at least one student who participates in discussions.",
"output": "∃x (ParticipatesInDiscussions(x))"
},
{
"input": "Translate into first-order logic: There exists at least one student who passes the test.",
"output": "∃x (PassesTest(x))"
},
{
"input": "Translate into first-order logic: If a student participates in discussions, then they attend lectures.",
"output": "∀x ((ParticipatesInDiscussions(x) → AttendsLectures(x)))"
},
{
"input": "Translate into first-order logic: If a student attends tutoring, then that student improves exam scores.",
"output": "∀x (Student(x) ∧ AttendsTutoring(x) → ImprovesExamScores(x))"
},
{
"input": "Translate into first-order logic: If a student improves exam scores, then that student has an opportunity to succeed.",
"output": "∀x (Student(x) ∧ ImprovesExamScores(x) → HasOpportunityToSucceed(x))"
},
{
"input": "Translate into first-order logic: If a student participates in group discussions, then that student attends tutoring.",
"output": "∀x (Student(x) ∧ ParticipatesGroupDiscussion(x) → AttendsTutoring(x))"
},
{
"input": "Translate into first-order logic: There exists at least one student who participates in group discussions.",
"output": "∃x (Student(x) ∧ ParticipatesGroupDiscussion(x))"
},
{
"input": "Translate into first-order logic: If a student does not submit assignments on time, then that student does not attend tutoring.",
"output": "∀x (Student(x) ∧ ¬SubmitsOnTime(x) → ¬AttendsTutoring(x))"
},
{
"input": "Translate into first-order logic: There exists at least one student who asks questions during class.",
"output": "∃x (AsksQuestionsDuringClass(x))"
},
{
"input": "Translate into first-order logic: If a student does not engage in class discussions, then they do not understand the material.",
"output": "∀x ((¬EngagesInDiscussions(x) → ¬UnderstandsMaterial(x)))"
},
{
"input": "Translate into first-order logic: Not every student participates in a study group.",
"output": "¬(∀x (ParticipatesInStudyGroup(x)))"
},
{
"input": "Translate into first-order logic: If a student does not submit assignments on time, then they do not receive full credit.",
"output": "∀x ((¬SubmitsAssignmentsOnTime(x) → ¬ReceivesFullCredit(x)))"
},
{
"input": "Translate into first-order logic: If a student attends office hours, then they understand the material better.",
"output": "∀x ((AttendsOfficeHours(x) → UnderstandsMaterialBetter(x)))"
},
{
"input": "Translate into first-order logic: If a student completes all coursework, then they have a good chance to pass the exam.",
"output": "∀x ((CompletesAllCoursework(x) ↔ HasGoodChanceToPassExam(x)))"
},
{
"input": "Translate into first-order logic: If a student attends office hours, then they are likely to pass the exam.",
"output": "∀x ((AttendsOfficeHours(x) → LikelyToPassExam(x)))"
},
{
"input": "Translate into first-order logic: There exists at least one student who attends office hours.",
"output": "∃x (AttendsOfficeHours(x))"
},
{
"input": "Translate into first-order logic: If a student completes the project, then they are prepared for the final exam.",
"output": "∀x ((CompletesProject(x) → PreparedForFinalExam(x)))"
},
{
"input": "Translate into first-order logic: If a student does not use online documents from the library, then that student does not gain more knowledge.",
"output": "∀x (Student(x) ∧ ¬UsesOnlineDocuments(x) → ¬GainsKnowledge(x))"
},
{
"input": "Translate into first-order logic: There exists a student who gains more knowledge.",
"output": "∃x (Student(x) ∧ GainsKnowledge(x))"
},
{
"input": "Translate into first-order logic: If a Python script does not have error handling, then it does not handle exceptions.",
"output": "∀x ((PythonScript(x) → (¬HasErrorHandling(x) → ¬HandlesExceptions(x))))"
},
{
"input": "Translate into first-order logic: If a Python script does not have error handling, then it does not produce reliable outputs.",
"output": "∀x ((PythonScript(x) → (¬HasErrorHandling(x) → ¬ReliableOutputs(x))))"
},
{
"input": "Translate into first-order logic: If a Python program follows best practices, then it is optimized.",
"output": "∀x ((BestPractices(x) → Optimized(x)))"
},
{
"input": "Translate into first-order logic: There exists at least one Python script with error handling.",
"output": "∃x ((PythonScript(x) ∧ HasErrorHandling(x)))"
},
{
"input": "Translate into first-order logic: All well-structured Python programs are optimized.",
"output": "∀x ((WellStructured(x) → Optimized(x)))"
},
{
"input": "Translate into first-order logic: All Python projects adhere to best practices.",
"output": "∀x ((PythonProject(x) → BestPractices(x)))"
},
{
"input": "Translate into first-order logic: There exists at least one optimized Python program.",
"output": "∃x (OptimizedPythonProgram(x))"
},
{
"input": "Translate into first-order logic: If a Python script does not have error handling, then it does not follow best practices.",
"output": "∀x ((PythonScript(x) → (¬HasErrorHandling(x) → ¬BestPractices(x))))"
},
{
"input": "Translate into first-order logic: If a Python program is optimized, then it has error handling.",
"output": "∀x ((OptimizedPythonProgram(x) → HasErrorHandling(x)))"
},
{
"input": "Translate into first-order logic: If a Python script has error handling, then it handles exceptions.",
"output": "∀x ((PythonScript(x) → (HasErrorHandling(x) → HandlesExceptions(x))))"
},
{
"input": "Translate into first-order logic: If a Python script has error handling, then it follows best practices.",
"output": "∀x ((PythonScript(x) → (HasErrorHandling(x) → BestPractices(x))))"
},
{
"input": "Translate into first-order logic: All Python scripts have error handling.",
"output": "∀x ((PythonScript(x) → HasErrorHandling(x)))"
},
{
"input": "Translate into first-order logic: There exists at least one Python project that follows best practices.",
"output": "∃x ((PythonProject(x) ∧ BestPractices(x)))"
},
{
"input": "Translate into first-order logic: All Python programs produce reliable outputs.",
"output": "∀x (ReliableOutputs(x))"
},
{
"input": "Translate into first-order logic: If a Python project follows best practices, then it produces reliable outputs.",
"output": "∀x ((PythonProject(x) → (BestPractices(x) → ReliableOutputs(x))))"
},
{
"input": "Translate into first-order logic: If all well-structured Python programs are optimized, then a script without error handling does not handle exceptions.",
"output": "∀x (WellStructured(x) → Optimized(x)) → ∀x (PythonScript(x) → (¬HasErrorHandling(x) → ¬HandlesExceptions(x)))"
},
{
"input": "Translate into first-order logic: If a Python program is not optimized, then it does not follow best practices.",
"output": "∀x ((¬Optimized(x) → ¬BestPractices(x)))"
},
{
"input": "Translate into first-order logic: If a Python script does not have error handling, then it does not follow PEP 8.",
"output": "∀x ((PythonScript(x) → (¬HasErrorHandling(x) → ¬FollowsPEP8(x))))"
},
{
"input": "Translate into first-order logic: If a Python program produces reliable outputs, then it is optimized.",
"output": "∀x ((ReliableOutputs(x) → Optimized(x)))"
},
{
"input": "Translate into first-order logic: If a dataset has missing values, then it affects model convergence.",
"output": "∀x (Dataset(x) ∧ MissingValues(x) → AffectsConvergence(x))"
},
{
"input": "Translate into first-order logic: If a dataset requires preprocessing, then missing values affect model convergence.",
"output": "∀x (Dataset(x) ∧ PreprocessingRequired(x) → (MissingValues(x) → AffectsConvergence(x)))"
},
{
"input": "Translate into first-order logic: There exists at least one dataset with missing values.",
"output": "∃x (Dataset(x) ∧ MissingValues(x))"
},
{
"input": "Translate into first-order logic: If a function is differentiable, then it is continuous.",
"output": "∀x ((Differentiable(x) → Continuous(x)))"
},
{
"input": "Translate into first-order logic: There exists at least one function that is integrable.",
"output": "∃x (Integrable(x))"
},
{
"input": "Translate into first-order logic: There exists at least one function that is differentiable.",
"output": "∃x (Differentiable(x))"
},
{
"input": "Translate into first-order logic: If a function is twice differentiable, then it is differentiable.",
"output": "∀x ((TwiceDifferentiable(x) → Differentiable(x)))"
},
{
"input": "Translate into first-order logic: All continuous functions satisfy the Intermediate Value Theorem.",
"output": "∀x ((Continuous(x) → IVT(x)))"
},
{
"input": "Translate into first-order logic: If a function is differentiable, then it is integrable.",
"output": "∀x ((Differentiable(x) → Integrable(x)))"
},
{
"input": "Translate into first-order logic: If a function is not continuous, then it is not differentiable.",
"output": "∀x ((¬Continuous(x) → ¬Differentiable(x)))"
},
{
"input": "Translate into first-order logic: All differentiable functions satisfy the Mean Value Theorem.",
"output": "∀x ((Differentiable(x) → MVT(x)))"
},
{
"input": "Translate into first-order logic: All polynomials are differentiable.",
"output": "∀x ((Polynomial(x) → Differentiable(x)))"
},
{
"input": "Translate into first-order logic: There exists at least one polynomial function.",
"output": "∃x (Polynomial(x))"
},
{
"input": "Translate into first-order logic: There exists at least one continuous function.",
"output": "∃x (Continuous(x))"
},
{
"input": "Translate into first-order logic: If a function is not differentiable, then it is not a polynomial.",
"output": "∀x ((¬Differentiable(x) → ¬Polynomial(x)))"
},
{
"input": "Translate into first-order logic: All integrable functions satisfy the Fundamental Theorem of Calculus.",
"output": "∀x ((Integrable(x) → FTC(x)))"
},
{
"input": "Translate into first-order logic: If all differentiable functions satisfy the Mean Value Theorem, then there exists at least one continuous function.",
"output": "(∀x (Differentiable(x) → MVT(x))) → ∃x (Continuous(x))"
},
{
"input": "Translate into first-order logic: If a student does not complete a specific task, then that student is not a university student.",
"output": "∀x (Student(x) ∧ ¬CompletesTask(x) → ¬UniversityStudent(x))"
},
{
"input": "Translate into first-order logic: There exists a student attending a specific course.",
"output": "∃x (Student(x) ∧ AttendsCourse(x))"
},
{
"input": "Translate into first-order logic: All students are attending the course",
"output": "∀x (AttendsCourse(x))"
},
{
"input": "Translate into first-order logic: If x attends lectures regularly, then x passes the course",
"output": "∀x ((AttendsLecturesRegularly(x) → PassesCourse(x)))"
},
{
"input": "Translate into first-order logic: There exists a student working on a project",
"output": "∃x (WorkingOnProject(x))"
},
{
"input": "Translate into first-order logic: If there exists a student working on a project, then all students are attending the course",
"output": "∃x (WorkingOnProject(x)) → ∀x (AttendsCourse(x))"
},
{
"input": "Translate into first-order logic: There exists a student attending lectures regularly",
"output": "∃x (AttendsLecturesRegularly(x))"
},
{
"input": "Translate into first-order logic: There exists a student completing assignments",
"output": "∃x (CompletingAssignments(x))"
},
{
"input": "Translate into first-order logic: All students can register BKA program if they did not register it last semester.",
"output": "∀x (Student(x) ∧ ¬tBKALastSemester(x) → BKA(x))"
},
{
"input": "Translate into first-order logic: OISP students are not allowed to delay the tutor fee.",
"output": "∀x (OISP(x) → ¬DelayTutorFee(x))"
},
{
"input": "Translate into first-order logic: Students must either pay the tutor fee, delay it, or register for the BKA program.",
"output": "∀x (Student(x) → (PayTutorFee(x) ∨ DelayTutorFee(x) ∨ BKA(x)))"
},
{
"input": "Translate into first-order logic: Frieren is an OISP student and she can't pay the tutor fee.",
"output": "OISP(Frieren) ∧ ¬PayTutorFee(Frieren)"
},
{
"input": "Translate into first-order logic: Frieren did not register the BKA program last semester.",
"output": "¬tBKALastSemester(Frieren)"
},
{
"input": "Translate into first-order logic: Students who absent the final exam will fail the course.",
"output": "∀x (Student(x) ∧ Absent(x) → Fail(x))"
},
{
"input": "Translate into first-order logic: Students must bring an ID or verification paper so that they will not be marked as absent.",
"output": "∀x (Student(x) → (BringID(x) ∨ BringPaper(x) → ¬Absent(x)))"
},
{
"input": "Translate into first-order logic: Students who bring an ID will not bring a verification paper.",
"output": "∀x (BringID(x) → ¬BringPaper(x))"
},
{
"input": "Translate into first-order logic: Sarifi didn't bring the ID but she did not fail.",
"output": "¬BringID(Sarifi) ∧ ¬Fail(Sarifi)"
},
{
"input": "Translate into first-order logic: Study hard earn students knowledge.",
"output": "∀x (StudyHard(x) → HasKnowledge(x))"
},
{
"input": "Translate into first-order logic: Having knowledge makes you do the exam well.",
"output": "∀x (HasKnowledge(x) → DoesExamWell(x))"
},
{
"input": "Translate into first-order logic: If you do the exam well and do not help others, you will pass the course.",
"output": "∀x (DoesExamWell(x) ∧ ¬HelpsOthers(x) → PassesCourse(x))"
},
{
"input": "Translate into first-order logic: If you do not have knowledge but got help from others, you will pass the course.",
"output": "∀x (¬HasKnowledge(x) ∧ ReceivedHelp(x) → PassesCourse(x))"
},
{
"input": "Translate into first-order logic: Only if you have the knowledge can you help others.",
"output": "∀x (HelpsOthers(x) → HasKnowledge(x))"
},
{
"input": "Translate into first-order logic: Mia did the exam well.",
"output": "DoesExamWell(Mia)"
},
{
"input": "Translate into first-order logic: Mia passed the course.",
"output": "PassesCourse(Mia)"
},
{
"input": "Translate into first-order logic: Students who study hard gain knowledge.",
"output": "∀x (StudyHard(x) → HasKnowledge(x))"
},
{
"input": "Translate into first-order logic: Having knowledge enables you to do well on the exam.",
"output": "∀x (HasKnowledge(x) → DoesExamWell(x))"
},
{
"input": "Translate into first-order logic: If you do well on the exam and do not help others, you will pass the course.",
"output": "∀x (DoesExamWell(x) ∧ ¬HelpsOthers(x) → PassesCourse(x))"
},
{
"input": "Translate into first-order logic: If you do not have knowledge but receive help from others, you will pass the course.",
"output": "∀x (¬HasKnowledge(x) ∧ ReceivedHelp(x) → PassesCourse(x))"
},
{
"input": "Translate into first-order logic: You can only help others if you have knowledge.",
"output": "∀x (HelpsOthers(x) → HasKnowledge(x))"
},
{
"input": "Translate into first-order logic: Mia did the exam well.",
"output": "DoesExamWell(Mia)"
},
{
"input": "Translate into first-order logic: Mia passed the course.",
"output": "PassesCourse(Mia)"
},
{
"input": "Translate into first-order logic: Students who participate in many activities will gain enough labor days.",
"output": "∀x (Participate_Many_Activities(x) → Gain_Labor_Days(x))"
},
{
"input": "Translate into first-order logic: Students must be a last-year student and gained enough labor days to do the graduation project.",
"output": "∀x (Last_Year_Student(x) ∧ Gain_Labor_Days(x) → Can_Do_Graduation_Project(x))"
},
{
"input": "Translate into first-order logic: Only if a student has completed a graduation project can they graduate.",
"output": "∀x (Graduate(x) → Complete_Graduation_Project(x))"
},
{
"input": "Translate into first-order logic: A student who graduated is no longer a last-year student.",
"output": "∀x (Graduate(x) → ¬Last_Year_Student(x))"
},
{
"input": "Translate into first-order logic: Iruma is not a last-year student.",
"output": "¬Last_Year_Student(Iruma)"
},
{
"input": "Translate into first-order logic: Students absent on the presentation day will get an F for the assignment.",
"output": "∀x (Absent_Presentation(x) → F_Assignment(x))"
},
{
"input": "Translate into first-order logic: Students who read scripts OR present too long will also get an F for the assignment.",
"output": "∀x (Read_Scripts(x) ∨ Present_Too_Long(x) → F_Assignment(x))"
},
{
"input": "Translate into first-order logic: Those who do not get an F for the assignment will pass the course.",
"output": "∀x (¬F_Assignment(x) → Pass_Course(x))"
},
{
"input": "Translate into first-order logic: Students who get an F for the assignment must redo the assignment.",
"output": "∀x (F_Assignment(x) → Redo_Assignment(x))"
},
{
"input": "Translate into first-order logic: Students absent when redoing the assignment will fail the course.",
"output": "∀x (Redo_Assignment(x) ∧ Absent(x) → Fail_Course(x))"
},
{
"input": "Translate into first-order logic: Students who read scripts AND present too long when redoing the assignment will fail the course.",
"output": "∀x (Redo_Assignment(x) ∧ Read_Scripts(x) ∧ Present_Too_Long(x) → Fail_Course(x))"
},
{
"input": "Translate into first-order logic: Students who redo the assignment but don’t fail will pass the course.",
"output": "∀x (Redo_Assignment(x) ∧ ¬Fail_Course(x) → Pass_Course(x))"
},
{
"input": "Translate into first-order logic: Yashiro always presents too long, but she always attended the presentation day.",
"output": "Present_Too_Long(Yashiro) ∧ ¬Absent_Presentation(Yashiro)"
},
{
"input": "Translate into first-order logic: Students who miss any quiz will fail the class.",
"output": "∀x (Miss_Quiz(x) → Fail_Class(x))"
},
{
"input": "Translate into first-order logic: Students who score less than 50% on the final exam will fail the class.",
"output": "∀x (Score_Final(x) < 50 → Fail_Class(x))"
},
{
"input": "Translate into first-order logic: Students who complete all homework and attend every class will pass the final exam.",
"output": "∀x (Complete_Homework(x) ∧ Attend_All_Classes(x) → Pass_Final(x))"
},
{
"input": "Translate into first-order logic: Ponko completed all homework but missed one class.",
"output": "Complete_Homework(Ponko) ∧ ¬Attend_All_Classes(Ponko)"
},
{
"input": "Translate into first-order logic: Students who fail the class must retake it next semester.",
"output": "∀x (Fail_Class(x) → Retake_Next_Semester(x))"
},
{
"input": "Translate into first-order logic: Students who come to the library to borrow books will gain books.",
"output": "∀x (Borrow_Books(x) → Got_Book(x))"
},
{
"input": "Translate into first-order logic: Students who got a book and are hardworking will read them.",
"output": "∀x (Got_Book(x) ∧ Hardworking(x) → Read_Book(x))"
},
{
"input": "Translate into first-order logic: Students who read books will gain knowledge.",
"output": "∀x (Read_Book(x) → Gain_Knowledge(x))"
},
{
"input": "Translate into first-order logic: Students who have knowledge will pass the course.",
"output": "∀x (Gain_Knowledge(x) → Pass_Course(x))"
},
{
"input": "Translate into first-order logic: Dio comes to the library to borrow a book, and he passes the course.",
"output": "Borrow_Books(Dio) ∧ Pass_Course(Dio)"
},
{
"input": "Translate into first-order logic: Students who pass the final exam with a grade above 80 will qualify for a scholarship.",
"output": "∀x (ScoreFinalExam(x) > 80 → QualifyScholarship(x))"
},
{
"input": "Translate into first-order logic: A student who does not attend classes regularly cannot score above 80 on the final exam.",
"output": "∀x (¬AttendRegularly(x) → ScoreFinalExam(x) ≤ 80)"
},
{
"input": "Translate into first-order logic: Any student who is part of the basketball team must attend classes regularly to remain on the team.",
"output": "∀x (BasketballTeam(x) → MustAttendRegularly(x))"
},
{
"input": "Translate into first-order logic: Students who remain on the basketball team all semester receive an athletic certificate.",
"output": "∀x (RemainOnTeamAllSemester(x) → AthleticCertificate(x))"
},
{
"input": "Translate into first-order logic: Rillance is part of the basketball team.",
"output": "BasketballTeam(Rillance)"
},
{
"input": "Translate into first-order logic: Rillance received an athletic certificate.",
"output": "AthleticCertificate(Rillance)"
},
{
"input": "Translate into first-order logic: Rillance scored 85 on the final exam.",
"output": "ScoreFinalExam(Rillance, scorefinalexam) ∧ scorefinalexam = 85"
},
{
"input": "Translate into first-order logic: All students are people.",
"output": "∀x (Student(x) → Person(x))"
},
{
"input": "Translate into first-order logic: All teachers are people.",
"output": "∀x (Teacher(x) → Person(x))"
},
{
"input": "Translate into first-order logic: All schools have students.",
"output": "∀x (School(x) → ∃y (Student(y) ∧ EnrolledIn(y, x)))"
},
{
"input": "Translate into first-order logic: Every student is enrolled in at least one school.",
"output": "∀x (Student(x) → ∃y (School(y) ∧ EnrolledIn(x, y)))"
},
{
"input": "Translate into first-order logic: If a person is a teacher, they work at a school.",
"output": "∀x (Teacher(x) → ∃y (School(y) ∧ WorksAt(x, y)))"
},
{
"input": "Translate into first-order logic: If a person works at a school, they contribute to education.",
"output": "∀x (WorksAt(x, y) → ContributesToEducation(x))"
},
{
"input": "Translate into first-order logic: Every student who attends a school has access to education.",
"output": "∀x (∀y (EnrolledIn(x, y) ∧ School(y) → HasAccessToEducation(x)))"
},
{
"input": "Translate into first-order logic: If a person has access to education, they can gain knowledge.",
"output": "∀x (HasAccessToEducation(x) → GainsKnowledge(x))"
},
{
"input": "Translate into first-order logic: If a person gains knowledge, they can apply it in life.",
"output": "∀x (GainsKnowledge(x) → CanApplyKnowledge(x))"
},
{
"input": "Translate into first-order logic: If a person applies knowledge in life, they increase their opportunities.",
"output": "∀x (CanApplyKnowledge(x) → IncreasesOpportunities(x))"
},
{
"input": "Translate into first-order logic: If a student increases their opportunities, they can achieve success.",
"output": "∀x (IncreasesOpportunities(x) → CanAchieveSuccess(x))"
},
{
"input": "Translate into first-order logic: A teacher guides students in gaining knowledge.",
"output": "∀x (∀y (Teacher(x) ∧ Student(y) ∧ Guides(x, y) → HelpsGainKnowledge(y)))"
},
{
"input": "Translate into first-order logic: If a teacher guides a student, the student benefits from education.",
"output": "∀x (HelpsGainKnowledge(x) → BenefitsFromEducation(x))"
},
{
"input": "Translate into first-order logic: If a student benefits from education, they develop skills.",
"output": "∀x (BenefitsFromEducation(x) → DevelopsSkills(x))"
},
{
"input": "Translate into first-order logic: If a person develops skills, they contribute to society.",
"output": "∀x (DevelopsSkills(x) → ContributesToSociety(x))"
},
{
"input": "Translate into first-order logic: Students who got F in Assignment will fail the course",
"output": "∀x (F_Assignment(x) → Fail_Course(x))"
},
{
"input": "Translate into first-order logic: Do the Assignment incorrectly will get an F for the coding section",
"output": "∀x (Incorrect_Assignment(x) → F_Coding(x))"
},
{
"input": "Translate into first-order logic: If you do not do the Assignment by yourself, you won't gain experience",
"output": "∀x (¬Do_By_Self(x) → ¬Experience(x))"
},
{
"input": "Translate into first-order logic: If you don't have experience, you can't do the harmony",
"output": "∀x (¬Experience(x) → ¬Can_Harmony(x))"
},
{
"input": "Translate into first-order logic: If you can't do the harmony, you get F for Harmony section",
"output": "∀x (¬Can_Harmony(x) → F_Harmony(x))"
},
{
"input": "Translate into first-order logic: If Code section or Harmony section got an F, the whole assignment will get an F",
"output": "∀x (F_Coding(x) ∨ F_Harmony(x) → F_Assignment(x))"
},
{
"input": "Translate into first-order logic: Ruri passed the course",
"output": "¬Fail_Course(Ruri)"
},
{
"input": "Translate into first-order logic: If someone teaches a student, they must be a teacher.",
"output": "∀x (∀y (Teaches(x, y) ∧ Student(y) → Teacher(x)))"
},
{
"input": "Translate into first-order logic: If someone is motivated by someone else, that person has motivation.",
"output": "∀x (∀y (MotivatedBy(x, y) → HasMotivation(x)))"
},
{
"input": "Translate into first-order logic: If someone improves, they are motivated by someone.",
"output": "∀x (Improves(x) → ∃y (MotivatedBy(x, y)))"
},
{
"input": "Translate into first-order logic: If a teacher shares knowledge with a student, the student gains experience.",
"output": "∀x (∀y (Teacher(x) ∧ Student(y) ∧ SharesKnowledge(x, y) → GainsExperience(y)))"
},
{
"input": "Translate into first-order logic: If a student learns, they improve.",
"output": "∀x (Learns(x) → Improves(x))"
},
{
"input": "Translate into first-order logic: If a student gains experience, they learn.",
"output": "∀x (GainsExperience(x) → Learns(x))"
},
{
"input": "Translate into first-order logic: Every student is taught by at least one teacher.",
"output": "∀x (Student(x) → ∃y (Teacher(y) ∧ Teaches(y, x)))"
},
{
"input": "Translate into first-order logic: Ludwig teaches Mia.",
"output": "Teaches(Ludwig, Mia)"
},
{
"input": "Translate into first-order logic: Ludwig is a teacher.",
"output": "Teacher(Ludwig)"
},
{
"input": "Translate into first-order logic: Anyone who has knowledge can teach.",
"output": "∀x (HasKnowledge(x) → CanTeach(x))"
},
{
"input": "Translate into first-order logic: Anyone who can teach shares knowledge.",
"output": "∀x (CanTeach(x) → ∃y (SharesKnowledge(x, y)))"
},
{
"input": "Translate into first-order logic: All teachers have knowledge.",
"output": "∀x (Teacher(x) → HasKnowledge(x))"
},
{
"input": "Translate into first-order logic: All teachers are people.",
"output": "∀x (Teacher(x) → Person(x))"
},
{
"input": "Translate into first-order logic: All students are people.",
"output": "∀x (Student(x) → Person(x))"
},
{
"input": "Translate into first-order logic: Mia is a student.",
"output": "Student(Mia)"
},
{
"input": "Translate into first-order logic: All students are people.",
"output": "∀x (Student(x) → Person(x))"
},
{
"input": "Translate into first-order logic: All teachers are people.",
"output": "∀x (Teacher(x) → Person(x))"
},
{
"input": "Translate into first-order logic: Every student attends at least one school.",
"output": "∀x (Student(x) → ∃y (School(y) ∧ Attends(x, y)))"
},
{
"input": "Translate into first-order logic: Every school provides education.",
"output": "∀x (School(x) → ProvidesEducation(x))"
},
{
"input": "Translate into first-order logic: If a person receives education, they gain knowledge.",
"output": "∀x (ReceivesEducation(x) → GainsKnowledge(x))"
},
{
"input": "Translate into first-order logic: If a person gains knowledge, they can develop critical thinking skills.",
"output": "∀x (GainsKnowledge(x) → DevelopsCriticalThinking(x))"
},
{
"input": "Translate into first-order logic: If a person develops critical thinking skills, they make better decisions.",
"output": "∀x (DevelopsCriticalThinking(x) → MakesBetterDecisions(x))"
},
{
"input": "Translate into first-order logic: Teachers are responsible for delivering education.",
"output": "∀x (Teacher(x) → DeliversEducation(x))"
},
{
"input": "Translate into first-order logic: If a teacher delivers education, their students gain knowledge.",
"output": "∀x (∀y (DeliversEducation(y) ∧ Student(x) → GainsKnowledge(x)))"
},
{
"input": "Translate into first-order logic: If students gain knowledge, they can use it to solve problems.",
"output": "∀x (GainsKnowledge(x) → CanSolveProblems(x))"
},
{
"input": "Translate into first-order logic: If students can solve problems, they can improve their communities.",
"output": "∀x (CanSolveProblems(x) → ImprovesCommunity(x))"
},
{
"input": "Translate into first-order logic: If someone improves their community, they contribute to society.",
"output": "∀x (ImprovesCommunity(x) → ContributesToSociety(x))"
},
{
"input": "Translate into first-order logic: If a person contributes to society, they can inspire others.",
"output": "∀x (ContributesToSociety(x) → InspiresOthers(x))"
},
{
"input": "Translate into first-order logic: If someone inspires others, they have a meaningful impact.",
"output": "∀x (InspiresOthers(x) → HasMeaningfulImpact(x))"
},
{
"input": "Translate into first-order logic: A meaningful impact leads to long-term change.",
"output": "∀x (HasMeaningfulImpact(x) → CreatesLongTermChange(x))"
},
{
"input": "Translate into first-order logic: Some students prefer online learning.",
"output": "∃x (Student(x) ∧ PrefersOnlineLearning(x))"
},
{
"input": "Translate into first-order logic: Libraries have a large collection of books.",
"output": "∃x (Library(x) ∧ HasManyBooks(x))"
},
{
"input": "Translate into first-order logic: People enjoy watching movies in their free time.",
"output": "∃x (Person(x) ∧ EnjoysMovies(x))"
},
{
"input": "Translate into first-order logic: All students are people.",
"output": "∀x (Student(x) → Person(x))"
},
{
"input": "Translate into first-order logic: All teachers are people.",
"output": "∀x (Teacher(x) → Person(x))"
},
{
"input": "Translate into first-order logic: Every student attends at least one school.",
"output": "∀x (Student(x) → ∃y (School(y) ∧ Attends(x, y)))"
},
{
"input": "Translate into first-order logic: Every school provides education.",
"output": "∀x (School(x) → ProvidesEducation(x))"
},
{
"input": "Translate into first-order logic: If a person receives education, they gain knowledge.",
"output": "∀x (ReceivesEducation(x) → GainsKnowledge(x))"
},
{
"input": "Translate into first-order logic: If a person gains knowledge, they can develop critical thinking skills.",
"output": "∀x (GainsKnowledge(x) → DevelopsCriticalThinking(x))"
},
{
"input": "Translate into first-order logic: If a person develops critical thinking skills, they make better decisions.",
"output": "∀x (DevelopsCriticalThinking(x) → MakesBetterDecisions(x))"
},
{
"input": "Translate into first-order logic: Teachers are responsible for delivering education.",
"output": "∀x (Teacher(x) → DeliversEducation(x))"
},
{
"input": "Translate into first-order logic: If a teacher delivers education, their students gain knowledge.",
"output": "∀x (∀y (DeliversEducation(y) ∧ Student(x) → GainsKnowledge(x)))"
},
{
"input": "Translate into first-order logic: If students gain knowledge, they can use it to solve problems.",
"output": "∀x (GainsKnowledge(x) → CanSolveProblems(x))"
},
{
"input": "Translate into first-order logic: If students can solve problems, they can improve their communities.",
"output": "∀x (CanSolveProblems(x) → ImprovesCommunity(x))"
},
{
"input": "Translate into first-order logic: If someone improves their community, they contribute to society.",
"output": "∀x (ImprovesCommunity(x) → ContributesToSociety(x))"
},
{
"input": "Translate into first-order logic: If a person contributes to society, they can inspire others.",
"output": "∀x (ContributesToSociety(x) → InspiresOthers(x))"
},
{
"input": "Translate into first-order logic: If someone inspires others, they have a meaningful impact.",
"output": "∀x (InspiresOthers(x) → HasMeaningfulImpact(x))"
},
{
"input": "Translate into first-order logic: A meaningful impact leads to long-term change.",
"output": "∀x (HasMeaningfulImpact(x) → CreatesLongTermChange(x))"
},
{
"input": "Translate into first-order logic: Some students are interested in sports.",
"output": "∃x (Student(x) ∧ InterestedInSports(x))"
},
{
"input": "Translate into first-order logic: Many people like to travel during holidays.",
"output": "∃x (Person(x) ∧ LikesToTravel(x))"
},
{
"input": "Translate into first-order logic: Some animals can recognize their own reflection in a mirror.",
"output": "∃x (Animal(x) ∧ RecognizesMirrorReflection(x))"
},
{
"input": "Translate into first-order logic: Machine learning is a subset of artificial intelligence where computers learn from data.",
"output": "∀x (MachineLearning(x) → SubsetOfArtificialIntelligence(x))"
},
{
"input": "Translate into first-order logic: In supervised learning, models are trained on labeled data to predict outputs from inputs.",
"output": "∀x (SupervisedLearning(x) → TrainedOnLabeledData(x))"
},
{
"input": "Translate into first-order logic: In unsupervised learning, models are trained on unlabeled data to find patterns or groupings.",
"output": "∀x (UnsupervisedLearning(x) → TrainedOnUnlabeledData(x))"
},
{
"input": "Translate into first-order logic: In reinforcement learning, an agent learns by interacting with an environment and receiving feedback.",
"output": "∀x (ReinforcementLearning(x) → LearnsFromEnvironmentFeedback(x))"
},
{
"input": "Translate into first-order logic: Machine learning models can be classified into regression, classification, clustering, and reinforcement models.",
"output": "∀x (MLModel(x) → (Regression(x) ∨ Classification(x) ∨ Clustering(x) ∨ Reinforcement(x)))"
},
{
"input": "Translate into first-order logic: A regression model predicts a continuous output based on input features.",
"output": "∀x (RegressionModel(x) → PredictsContinuousOutput(x))"
},
{
"input": "Translate into first-order logic: A classification model predicts discrete labels or categories based on input features.",
"output": "∀x (ClassificationModel(x) → PredictsDiscreteLabels(x))"
},
{
"input": "Translate into first-order logic: Clustering models group similar data points together based on input features.",
"output": "∀x (ClusteringModel(x) → GroupsSimilarDataPoints(x))"
},
{
"input": "Translate into first-order logic: Overfitting occurs when a model learns the training data too well, capturing noise and patterns that do not generalize to new data.",
"output": "∀x (Overfitting(x) → LearnsTrainingDataTooWell(x))"
},
{
"input": "Translate into first-order logic: Underfitting occurs when a model is too simple and cannot capture the underlying patterns in the data.",
"output": "∀x (Underfitting(x) → CannotCapturePatterns(x))"
},
{
"input": "Translate into first-order logic: Cross-validation is used to assess the performance of a machine learning model by partitioning the data into subsets for training and testing.",
"output": "∀x (CrossValidation(x) → AssessesPerformance(x))"
},
{
"input": "Translate into first-order logic: Gradient descent is a popular optimization algorithm used in machine learning to minimize a loss function.",
"output": "∀x (GradientDescent(x) → MinimizesLossFunction(x))"
},
{
"input": "Translate into first-order logic: SQL is a standard programming language used for managing relational databases.",
"output": "∀x (SQL(x) → UsedForManagingRelationalDatabases(x))"
},
{
"input": "Translate into first-order logic: A relational database consists of tables, each containing rows and columns.",
"output": "∀x (RelationalDatabase(x) → ConsistsOfTables(x))"
},
{
"input": "Translate into first-order logic: SQL queries are used to interact with databases and perform operations such as retrieving, inserting, updating, and deleting data.",
"output": "∀x (SQLQuery(x) → (RetrieveData(x) ∨ InsertData(x) ∨ UpdateData(x) ∨ DeleteData(x)))"
},
{
"input": "Translate into first-order logic: The SELECT statement is used to query and retrieve data from one or more tables.",
"output": "∀x (SelectStatement(x) → QueryData(x))"
},
{
"input": "Translate into first-order logic: The WHERE clause is used in SQL to filter records based on specific conditions.",
"output": "∀x (WhereClause(x) → FiltersRecords(x))"
},
{
"input": "Translate into first-order logic: The INSERT INTO statement is used to add new rows of data to a table.",
"output": "∀x (InsertInto(x) → AddRowsToTable(x))"
},
{
"input": "Translate into first-order logic: The UPDATE statement is used to modify existing records in a table.",
"output": "∀x (UpdateStatement(x) → ModifyRecords(x))"
},
{
"input": "Translate into first-order logic: The DELETE statement is used to remove records from a table.",
"output": "∀x (DeleteStatement(x) → RemoveRecords(x))"
},
{
"input": "Translate into first-order logic: The JOIN operation is used to combine data from two or more tables based on a related column.",
"output": "∀x (∀y (Join(x, y) → CombineData(x, y)))"
},
{
"input": "Translate into first-order logic: The PRIMARY KEY constraint uniquely identifies each record in a table.",
"output": "∀x (PrimaryKey(x) → UniquelyIdentifiesRecord(x))"
},
{
"input": "Translate into first-order logic: The FOREIGN KEY constraint ensures the integrity of the relationship between tables.",
"output": "∀x (ForeignKey(x) → EnsuresDataIntegrity(x))"
},
{
"input": "Translate into first-order logic: The GROUP BY clause is used to group rows that have the same values into summary rows, such as totals.",
"output": "∀x (GroupBy(x) → GroupRows(x))"
},
{
"input": "Translate into first-order logic: The ORDER BY clause is used to sort the result set in ascending or descending order.",
"output": "∀x (OrderBy(x) → SortResultSet(x))"
},
{
"input": "Translate into first-order logic: An index in SQL is used to improve the speed of data retrieval operations.",
"output": "∀x (Index(x) → ImprovesDataRetrievalSpeed(x))"
},
{
"input": "Translate into first-order logic: For all students, they possess the fundamental knowledge of the subject.",
"output": "∀x (PossessesFundamentalKnowledge(x))"
},
{
"input": "Translate into first-order logic: If a student understands the core concepts, they are able to apply those concepts in practice.",
"output": "∀x ((UnderstandsCoreConcepts(x) → AppliesConcepts(x)))"
},
{
"input": "Translate into first-order logic: If a student can apply concepts, they are likely to succeed in assessments.",
"output": "∀x ((AppliesConcepts(x) → SucceedsInAssessments(x)))"
},
{
"input": "Translate into first-order logic: If a student does not succeed in assessments, it indicates that they lack understanding of the core concepts.",
"output": "∀x ((¬SucceedsInAssessments(x) → ¬UnderstandsCoreConcepts(x)))"
},
{
"input": "Translate into first-order logic: If a student attends all classes, they are likely to gain a better understanding of the subject.",
"output": "∀x ((AttendsAllClasses(x) → UnderstandsCoreConcepts(x)))"
},
{
"input": "Translate into first-order logic: If a student fails to apply the core concepts, they may struggle with the subject matter.",
"output": "∀x ((¬AppliesConcepts(x) → StrugglesWithSubject(x)))"
},
{
"input": "Translate into first-order logic: If a student misses classes, they might not understand key concepts, leading to failure in assessments.",
"output": "∀x ((¬AttendsAllClasses(x) → (¬UnderstandsCoreConcepts(x) ∧ ¬SucceedsInAssessments(x))))"
},
{
"input": "Translate into first-order logic: If a student does not complete their coursework, it suggests they are not engaging with the learning process.",
"output": "∀x ((¬CompletesCoursework(x) → ¬EngagesInLearningProcess(x)))"
},
{
"input": "Translate into first-order logic: Attending all classes ensures that students receive the full scope of education in the subject.",
"output": "∀x ((AttendsAllClasses(x) → EngagesInLearningProcess(x)))"
},
{
"input": "Translate into first-order logic: There exists at least one student who understands the core concepts of the subject.",
"output": "∃x (UnderstandsCoreConcepts(x))"
},
{
"input": "Translate into first-order logic: If a student does not understand the subject, they are unlikely to complete the coursework successfully.",
"output": "∀x ((¬UnderstandsCoreConcepts(x) → ¬CompletesCoursework(x)))"
},
{
"input": "Translate into first-order logic: All students possess the necessary understanding to succeed in assessments.",
"output": "∀x (SucceedsInAssessments(x))"
},
{
"input": "Translate into first-order logic: If a student engages in self-directed study, they will be more likely to succeed in assessments.",
"output": "∀x ((EngagesInSelfDirectedStudy(x) → SucceedsInAssessments(x)))"
},
{
"input": "Translate into first-order logic: If a student engages in extracurricular activities, it will support their understanding of the subject.",
"output": "∀x ((EngagesInExtracurricularActivities(x) → UnderstandsCoreConcepts(x)))"
},
{
"input": "Translate into first-order logic: If a student is able to engage in the learning process, they will succeed academically.",
"output": "∀x ((EngagesInLearningProcess(x) → SucceedsInAssessments(x)))"
},
{
"input": "Translate into first-order logic: There exists at least one student who excels in assessments.",
"output": "∃x (Student(x) ∧ ExcelsInAssessments(x))"
},
{
"input": "Translate into first-order logic: If a student cannot apply knowledge, they will struggle with learning new concepts.",
"output": "∀x (Student(x) ∧ ¬AppliesKnowledge(x) → ¬UnderstandsNewConcepts(x))"
},
{
"input": "Translate into first-order logic: If a student is not meeting the academic standards, they will not progress in their studies.",
"output": "∀x (Student(x) ∧ ¬MeetsStandards(x) → ¬ProgressesStudies(x))"
},
{
"input": "Translate into first-order logic: All students are expected to adhere to the academic code of conduct outlined by the school law.",
"output": "∀x (Student(x) → AdheresConduct(x))"
},
{
"input": "Translate into first-order logic: There exists at least one student who has demonstrated mastery of the subject.",
"output": "∃x P(x)"
},
{
"input": "Translate into first-order logic: If a student does not meet the requirements for passing, they cannot move forward in the curriculum.",
"output": "∀x (¬Q(x) → ¬R(x))"
},
{
"input": "Translate into first-order logic: All students are engaged in active learning sessions within the classroom.",
"output": "∀x T(x)"
},
{
"input": "Translate into first-order logic: At least one student is participating in the current course or class.",
"output": "∃x T(x)"
},
{
"input": "Translate into first-order logic: All students have the same baseline knowledge required to succeed in the subject.",
"output": "∀x Q(x)"
},
{
"input": "Translate into first-order logic: At least one student has a solid understanding of the core concepts.",
"output": "∃x Q(x)"
},
{
"input": "Translate into first-order logic: If a student fails to meet the required standards, they will not be able to apply the knowledge in real-world scenarios.",
"output": "∀x (¬R(x) → ¬U(x))"
},
{
"input": "Translate into first-order logic: All students are proficient in the core skills necessary for academic success.",
"output": "∀x P(x)"
},
{
"input": "Translate into first-order logic: All students are expected to follow the school’s code of conduct.",
"output": "∀x S(x)"
},
{
"input": "Translate into first-order logic: If a student has the ability to apply their knowledge in real-world contexts, they will succeed in advanced coursework.",
"output": "∀x (U(x) → R(x))"
},
{
"input": "Translate into first-order logic: At least one student is actively participating in the course activities.",
"output": "∃x T(x)"
},
{
"input": "Translate into first-order logic: If a student does not meet the academic standards, they will not be able to advance in their education.",
"output": "∀x (¬Q(x) → ¬R(x))"
},
{
"input": "Translate into first-order logic: If a student has the skills necessary to apply what they've learned, they will succeed in future coursework.",
"output": "∀x (U(x) → R(x))"
},
{
"input": "Translate into first-order logic: If a student fails to meet expectations, they cannot pursue additional academic opportunities or specialized subjects.",
"output": "∀x (¬U(x) → ¬P(x))"
},
{
"input": "Translate into first-order logic: For students who meet all educational requirements, further educational opportunities will be available.",
"output": "∀x R(x)"
},
{
"input": "Translate into first-order logic: If a student successfully completes a prerequisite course, they are eligible to enroll in the next level course.",
"output": "∀x (U(x) → S(x))"
},
{
"input": "Translate into first-order logic: If a student demonstrates competence in one subject, they are qualified to advance to a more challenging subject.",
"output": "∀x (U(x) → S(x))"
},
{
"input": "Translate into first-order logic: All students enrolled in the course are actively engaging in the learning material.",
"output": "∀x T(x)"
},
{
"input": "Translate into first-order logic: At least one student has enrolled in the prerequisite course.",
"output": "∃x U(x)"
},
{
"input": "Translate into first-order logic: If a student passes the final exam, they are considered to have mastered the course content.",
"output": "∀x (P(x) → R(x))"
},
{
"input": "Translate into first-order logic: If a student does not demonstrate mastery, they are not considered to have passed the course.",
"output": "∀x (¬R(x) → ¬P(x))"
},
{
"input": "Translate into first-order logic: If a student does not meet the course prerequisites, they cannot take the final exam.",
"output": "∀x (¬T(x) → ¬P(x))"
},
{
"input": "Translate into first-order logic: All students are expected to complete the assigned coursework on time.",
"output": "∀x Q(x)"
},
{
"input": "Translate into first-order logic: All students are required to complete assignments in accordance with the syllabus.",
"output": "∀x Q(x)"
},
{
"input": "Translate into first-order logic: If a student demonstrates mastery of the course material, they will be recommended for advanced coursework.",
"output": "∀x (R(x) → S(x))"
},
{
"input": "Translate into first-order logic: If a student passes a course, they are eligible to move on to the next subject.",
"output": "∀x (P(x) → S(x))"
},
{
"input": "Translate into first-order logic: If a student fails to meet the prerequisites, they cannot take more advanced courses.",
"output": "∀x (¬T(x) → ¬S(x))"
},
{
"input": "Translate into first-order logic: If a student fails to meet the course requirements, they will not be eligible for further academic opportunities.",
"output": "∀x (¬Q(x) → ¬S(x))"
},
{
"input": "Translate into first-order logic: If a student has demonstrated understanding of the core principles, they are encouraged to pursue further academic challenges.",
"output": "∀x (R(x) → S(x))"
},
{
"input": "Translate into first-order logic: For students who have mastered the necessary content, additional learning opportunities will be provided.",
"output": "∀x (R(x) → S(x))"
},
{
"input": "Translate into first-order logic: If a student fails the final project, they will not pass the course.",
"output": "∀x (Student(x) ∧ FailsFinalProject(x) → ¬PassCourse(x))"
},
{
"input": "Translate into first-order logic: If a student does not attend at least 80% of the lectures, they will not be eligible for the final project.",
"output": "∀x (Student(x) ∧ ¬AttendsLectures80Percent(x) → ¬EligibleForFinalProject(x))"
},
{
"input": "Translate into first-order logic: If a student fails the midterm exam, they will not be eligible for extra credit.",
"output": "∀x (Student(x) ∧ FailsMidterm(x) → ¬EligibleForExtraCredit(x))"
},
{
"input": "Translate into first-order logic: If a student completes all the required assignments on time and attends at least 80% of the lectures, they will be eligible for the final project.",
"output": "∀x (Student(x) ∧ SubmitsAllAssignmentsOnTime(x) ∧ AttendsLectures80Percent(x) → EligibleForFinalProject(x))"
},
{
"input": "Translate into first-order logic: If a student fails the final project, they will not pass the course and will lose eligibility for scholarships.",
"output": "∀x (Student(x) ∧ FailsFinalProject(x) → (¬PassCourse(x) ∧ ¬EligibleForScholarship(x)))"
},
{
"input": "Translate into first-order logic: If a student fails the midterm exam, they will not be eligible for extra credit.",
"output": "∀x (Student(x) ∧ FailsMidterm(x) → ¬EligibleForExtraCredit(x))"
},
{
"input": "Translate into first-order logic: If a student successfully completes a prerequisite course, they are eligible to enroll in the next level course.",
"output": "∀x (U(x) → S(x))"
},
{
"input": "Translate into first-order logic: If a student demonstrates competence in one subject, they are qualified to advance to a more challenging subject.",
"output": "∀x (U(x) → S(x))"
},
{
"input": "Translate into first-order logic: All students enrolled in the course are actively engaging in the learning material.",
"output": "∀x T(x)"
},
{
"input": "Translate into first-order logic: At least one student has enrolled in the prerequisite course.",
"output": "∃x U(x)"
},
{
"input": "Translate into first-order logic: If a student passes the final exam, they are considered to have mastered the course content.",
"output": "∀x (P(x) → R(x))"
},
{
"input": "Translate into first-order logic: If a student does not demonstrate mastery, they are not considered to have passed the course.",
"output": "∀x (¬R(x) → ¬P(x))"
},
{
"input": "Translate into first-order logic: If a student does not meet the course prerequisites, they cannot take the final exam.",
"output": "∀x (¬T(x) → ¬P(x))"
},
{
"input": "Translate into first-order logic: All students are expected to complete the assigned coursework on time.",
"output": "∀x Q(x)"
},
{
"input": "Translate into first-order logic: All students are required to complete assignments in accordance with the syllabus.",
"output": "∀x Q(x)"
},
{
"input": "Translate into first-order logic: If a student demonstrates mastery of the course material, they will be recommended for advanced coursework.",
"output": "∀x (R(x) → S(x))"
},
{
"input": "Translate into first-order logic: If a student passes a course, they are eligible to move on to the next subject.",
"output": "∀x (P(x) → S(x))"
},
{
"input": "Translate into first-order logic: If a student fails to meet the prerequisites, they cannot take more advanced courses.",
"output": "∀x (¬T(x) → ¬S(x))"
},
{
"input": "Translate into first-order logic: If a student fails to meet the course requirements, they will not be eligible for further academic opportunities.",
"output": "∀x (¬Q(x) → ¬S(x))"
},
{
"input": "Translate into first-order logic: If a student has demonstrated understanding of the core principles, they are encouraged to pursue further academic challenges.",
"output": "∀x (R(x) → S(x))"
},
{
"input": "Translate into first-order logic: For students who have mastered the necessary content, additional learning opportunities will be provided.",
"output": "∀x (R(x) → S(x))"
},
{
"input": "Translate into first-order logic: If an event is advertised to the university community, it informs participants.",
"output": "∀x (Event(x) ∧ AdvertisesEvent(x) → InformsParticipants(x))"
},
{
"input": "Translate into first-order logic: If an event has scheduling conflicts, it cannot maximize attendance.",
"output": "∀x (Event(x) ∧ ¬NoConflicts(x) → ¬MaximizesAttendance(x))"
},
{
"input": "Translate into first-order logic: If an event informs participants and has no scheduling conflicts, it attracts participants.",
"output": "∀x (Event(x) ∧ InformsParticipants(x) ∧ NoConflicts(x) → AttractsParticipants(x))"
},
{
"input": "Translate into first-order logic: Every student in the course is participating in the training session.",
"output": "∀x T(x)"
},
{
"input": "Translate into first-order logic: If a student attends the seminar, they will be eligible for the certification.",
"output": "∀x (R(x) → Q(x))"
},
{
"input": "Translate into first-order logic: If a student attends the seminar, they will be able to complete the course successfully.",
"output": "∀x (R(x) → S(x))"
},
{
"input": "Translate into first-order logic: Every student is registered for the course.",
"output": "∀x T(x)"
},
{
"input": "Translate into first-order logic: If a student attends the seminar, they will have the necessary knowledge to pass the course.",
"output": "∀x (R(x) → U(x))"
},
{
"input": "Translate into first-order logic: If a student does not attend the seminar, they will not be able to complete the course.",
"output": "∀x (¬R(x) → ¬S(x))"
},
{
"input": "Translate into first-order logic: If a student does not submit the required assignments, they will not pass the course.",
"output": "∀x (¬P(x) → ¬U(x))"
},
{
"input": "Translate into first-order logic: There exists a student who has submitted their assignments.",
"output": "∃x P(x)"
},
{
"input": "Translate into first-order logic: If a student does not complete the assignments on time, they will not pass the course.",
"output": "∀x (¬P(x) → ¬U(x))"
},
{
"input": "Translate into first-order logic: There exists a student who attended the seminar.",
"output": "∃x R(x)"
},
{
"input": "Translate into first-order logic: There exists a student who passed the course.",
"output": "∃x U(x)"
},
{
"input": "Translate into first-order logic: If a student does not attend the seminar, they will not be eligible for the certification.",
"output": "∀x (¬R(x) → ¬Q(x))"
},
{
"input": "Translate into first-order logic: If a student has attended the seminar, they will be able to pass the course with certification.",
"output": "∀x (R(x) → (U(x) ∧ Q(x)))"
},
{
"input": "Translate into first-order logic: If a student uses efficient sorting algorithms, they achieve better performance.",
"output": "∀x (Student(x) ∧ UsesEfficientSorting(x) → BetterPerformance(x))"
},
{
"input": "Translate into first-order logic: If a student understands recursion, they can break problems into smaller parts.",
"output": "∀x (Student(x) ∧ UnderstandsRecursion(x) → BreaksProblemIntoSmallerParts(x))"
},
{
"input": "Translate into first-order logic: Every AI model requires training data to function properly.",
"output": "∀x R(x)"
},
{
"input": "Translate into first-order logic: If an AI model is not trained, it cannot perform predictions.",
"output": "∀x (¬T(x) → ¬P(x))"
},
{
"input": "Translate into first-order logic: Training an AI model requires a large dataset to improve its performance.",
"output": "∀x (T(x) → D(x))"
},
{
"input": "Translate into first-order logic: If an AI model uses deep learning, it will need substantial computational resources.",
"output": "∀x (L(x) → C(x))"
},
{
"input": "Translate into first-order logic: If an AI model does not have sufficient training data, it cannot achieve high accuracy.",
"output": "∀x (¬S(x) → ¬A(x))"
},
{
"input": "Translate into first-order logic: For all AI models, training is essential to enable predictions.",
"output": "∀x (T(x) → P(x))"
},
{
"input": "Translate into first-order logic: If an AI model is trained on high-quality data, it will perform well in predictions.",
"output": "∀x (Q(x) → H(x))"
},
{
"input": "Translate into first-order logic: If an AI model lacks training data, it is not possible to use it for predictions.",
"output": "∀x (¬S(x) → ¬P(x))"
},
{
"input": "Translate into first-order logic: If an AI model is trained, it will have the capacity to make predictions.",
"output": "∀x (T(x) → P(x))"
},
{
"input": "Translate into first-order logic: If an AI model does not use deep learning, it will likely underperform on tasks requiring complex reasoning.",
"output": "∀x (¬L(x) → U(x))"
},
{
"input": "Translate into first-order logic: At least one AI model can perform well when trained with a proper dataset.",
"output": "∃x W(x)"
},
{
"input": "Translate into first-order logic: For all AI models, training improves their ability to solve complex problems.",
"output": "∀x (T(x) → V(x))"
},
{
"input": "Translate into first-order logic: If an AI model is not trained, it cannot generalize to unseen data.",
"output": "∀x (¬T(x) → ¬G(x))"
},
{
"input": "Translate into first-order logic: For all AI systems, the training process involves iterating on the model using feedback from predictions.",
"output": "∀x (T(x) → I(x))"
},
{
"input": "Translate into first-order logic: If an AI model is not provided with sufficient training, it will not learn efficiently.",
"output": "∀x (¬S(x) → ¬E(x))"
},
{
"input": "Translate into first-order logic: If a timetable is optimized, it allocates resources like classrooms and instructors efficiently.",
"output": "∀x (Timetable(x) ∧ OptimizedTimetable(x) → AllocatesResourcesEfficiently(x))"
},
{
"input": "Translate into first-order logic: If a student has a balanced schedule, they have enough breaks and are not overloaded.",
"output": "∀x (Student(x) ∧ BalancedSchedule(x) → (HasAdequateBreaks(x) ∧ ¬OverloadedSchedule(x)))"
},
{
"input": "Translate into first-order logic: To build a website, a strong understanding of web development technologies like HTML, CSS, and JavaScript is essential.",
"output": "∀x (B(x) → U(x))"
},
{
"input": "Translate into first-order logic: Every website requires HTML to structure content, CSS to style it, and JavaScript to add interactivity.",
"output": "∀x (H(x) → S(x))"
},
{
"input": "Translate into first-order logic: The performance of a website depends on how well the HTML is structured and how optimized the CSS and JavaScript are.",
"output": "∀x (C(x) → T(x))"
},
{
"input": "Translate into first-order logic: Responsive design is crucial for ensuring that a website works well on all devices, from desktops to smartphones.",
"output": "∀x (J(x) → I(x))"
},
{
"input": "Translate into first-order logic: If a student knows how to use frameworks like Bootstrap or Tailwind CSS, they can speed up the development process for styling.",
"output": "∀x (O(x) → P(x))"
},
{
"input": "Translate into first-order logic: JavaScript is necessary for adding dynamic functionality to a website, such as user interactions, animations, and form validation.",
"output": "∀x (R(x) → W(x))"
},
{
"input": "Translate into first-order logic: Version control with Git is important for tracking changes in the code and collaborating with others on the project.",
"output": "∀x (F(x) → D(x))"
},
{
"input": "Translate into first-order logic: Web development requires knowledge of both front-end and back-end technologies to create full-stack applications.",
"output": "∀x (K(x) → Y(x))"
},
{
"input": "Translate into first-order logic: Web accessibility should be considered to ensure that the website is usable by people with disabilities.",
"output": "∀x (G(x) → V(x))"
},
{
"input": "Translate into first-order logic: A good understanding of SEO (Search Engine Optimization) helps improve the visibility of a website on search engines.",
"output": "∀x (E(x) → A(x))"
},
{
"input": "Translate into first-order logic: Testing a website for compatibility across multiple browsers ensures that users have a consistent experience.",
"output": "∀x (X(x) → M(x))"
},
{
"input": "Translate into first-order logic: If a website does not load quickly, it can negatively impact user experience and lead to a higher bounce rate.",
"output": "∀x (Z(x) → Q(x))"
},
{
"input": "Translate into first-order logic: Understanding databases and how to connect them to a website is crucial for building websites that store and retrieve data.",
"output": "∀x (N(x) → L(x))"
},
{
"input": "Translate into first-order logic: Security measures like HTTPS, input validation, and preventing XSS attacks are essential for protecting user data on the website.",
"output": "∀x (¬L2(x) → ¬P(x))"
},
{
"input": "Translate into first-order logic: Once a website is built, hosting and deploying it to the web is the final step to make it publicly accessible.",
"output": "∀x (D2(x) → C2(x))"
},
{
"input": "Translate into first-order logic: To study effectively, a student must manage their time, set goals, and eliminate distractions.",
"output": "∀x ((M(x) ∧ G(x) ∧ D(x)) → E(x))"
},
{
"input": "Translate into first-order logic: Breaking down large topics into smaller chunks and using active recall can improve information retention.",
"output": "∀x ((B(x) ∧ A(x)) → R(x))"
},
{
"input": "Translate into first-order logic: Spaced repetition, along with regular testing, boosts long-term memory retention.",
"output": "∀x ((S(x) ∨ T(x)) → L(x))"
},
{
"input": "Translate into first-order logic: Studying in a focused and distraction-free environment increases productivity.",
"output": "∀x ((F(x) ∧ D(x)) → P(x))"
},
{
"input": "Translate into first-order logic: Studying in groups or studying solo can both be effective, depending on the individual’s learning style.",
"output": "∀x ((I(x) ∨ O(x)) → K(x))"
},
{
"input": "Translate into first-order logic: Regular breaks and maintaining a balanced lifestyle promote better cognitive function.",
"output": "∀x ((R2(x) ∧ B2(x)) → C(x))"
},
{
"input": "Translate into first-order logic: Consistent review of learned material, coupled with practical application, strengthens both memory and understanding.",
"output": "∀x ((V(x) ∧ P2(x)) → U(x))"
},
{
"input": "Translate into first-order logic: If a student x is enrolled in Research Methods (R), then they have passed the Philosophy prerequisite (P).",
"output": "∀x (R(x) → P(x))"
},
{
"input": "Translate into first-order logic: There is at least one student x who has qualified for the Quantum Physics competition (Q).",
"output": "∃x Q(x)"
},
{
"input": "Translate into first-order logic: If a student x is enrolled in Research Methods (R), they are eligible for the University Honors program (U).",
"output": "∀x (R(x) → U(x))"
},
{
"input": "Translate into first-order logic: A student x who hasn't passed the Philosophy prerequisite (P) cannot qualify for the Quantum Physics competition (Q).",
"output": "∀x (¬P(x) → ¬Q(x))"
},
{
"input": "Translate into first-order logic: All students x have passed the Philosophy prerequisite (P).",
"output": "∀x P(x)"
},
{
"input": "Translate into first-order logic: Students x in the University Honors program (U) receive a full Scholarship (S).",
"output": "∀x (U(x) → S(x))"
},
{
"input": "Translate into first-order logic: If a student x hasn't completed the Thesis Writing course (T), they cannot enroll in Research Methods (R).",
"output": "∀x (¬T(x) → ¬R(x))"
},
{
"input": "Translate into first-order logic: At least one student x has been admitted to the University Honors program (U).",
"output": "∃x U(x)"
},
{
"input": "Translate into first-order logic: All students x receive a full Scholarship (S).",
"output": "∀x S(x)"
},
{
"input": "Translate into first-order logic: There exists at least one student x who has passed the Philosophy prerequisite (P).",
"output": "∃x P(x)"
},
{
"input": "Translate into first-order logic: Students x who pass the Philosophy prerequisite (P) are automatically enrolled in Research Methods (R).",
"output": "∀x (P(x) → R(x))"
},
{
"input": "Translate into first-order logic: There is at least one student x enrolled in Research Methods (R).",
"output": "∃x R(x)"
},
{
"input": "Translate into first-order logic: Every student x is part of the University Honors program (U).",
"output": "∀x U(x)"
},
{
"input": "Translate into first-order logic: Enrollment in Research Methods (R) guarantees a full Scholarship (S) for student x.",
"output": "∀x (R(x) → S(x))"
},
{
"input": "Translate into first-order logic: All students x have qualified for the Quantum Physics competition (Q).",
"output": "∀x Q(x)"
},
{
"input": "Translate into first-order logic: If all students have passed Philosophy (P), then any student x who passes P is automatically enrolled in Research Methods (R).",
"output": "(∀x P(x) → ∀x (P(x) → R(x)))"
},
{
"input": "Translate into first-order logic: If all students have passed Philosophy (P), then every student x is admitted to the University Honors program (U).",
"output": "(∀x P(x) → ∀x U(x))"
},
{
"input": "Translate into first-order logic: Students x who haven't completed Thesis Writing (T) are disqualified from the Quantum Physics competition (Q).",
"output": "∀x (¬T(x) → ¬Q(x))"
},
{
"input": "Translate into first-order logic: Qualifying for the Quantum Physics competition (Q) requires passing the Philosophy prerequisite (P).",
"output": "∀x (Q(x) → P(x))"
},
{
"input": "Translate into first-order logic: Every student x is enrolled in Research Methods (R).",
"output": "∀x R(x)"
},
{
"input": "Translate into first-order logic: Students x who qualify for the Quantum Physics competition (Q) must enroll in Research Methods (R).",
"output": "∀x (Q(x) → R(x))"
},
{
"input": "Translate into first-order logic: A student x without a Scholarship (S) cannot qualify for the Quantum Physics competition (Q).",
"output": "∀x (¬S(x) → ¬Q(x))"
},
{
"input": "Translate into first-order logic: Receiving a Scholarship (S) obligates student x to enroll in Research Methods (R).",
"output": "∀x (S(x) → R(x))"
},
{
"input": "Translate into first-order logic: Scholarship recipients (S) automatically qualify for the Quantum Physics competition (Q).",
"output": "∀x (S(x) → Q(x))"
},
{
"input": "Translate into first-order logic: All students x receive a full Scholarship (S).",
"output": "∀x S(x)"
},
{
"input": "Translate into first-order logic: There is at least one student x enrolled in Research Methods (R).",
"output": "∃x R(x)"
},
{
"input": "Translate into first-order logic: Students x who haven't completed Thesis Writing (T) have not passed Philosophy (P).",
"output": "∀x (¬T(x) → ¬P(x))"
},
{
"input": "Translate into first-order logic: Enrollment in Thesis Writing (T) guarantees a Scholarship (S) for student x.",
"output": "∀x (T(x) → S(x))"
},
{
"input": "Translate into first-order logic: A student x without a Scholarship (S) cannot qualify for the Quantum Physics competition (Q).",
"output": "∀x (¬S(x) → ¬Q(x))"
},
{
"input": "Translate into first-order logic: Membership in the University Honors program (U) provides a Scholarship (S).",
"output": "∀x (U(x) → S(x))"
},
{
"input": "Translate into first-order logic: Every student x is enrolled in Research Methods (R).",
"output": "∀x R(x)"
},
{
"input": "Translate into first-order logic: Skipping Thesis Writing (T) disqualifies student x from the Quantum Physics competition (Q).",
"output": "∀x (¬T(x) → ¬Q(x))"
},
{
"input": "Translate into first-order logic: All students x have passed the Philosophy prerequisite (P).",
"output": "∀x P(x)"
},
{
"input": "Translate into first-order logic: At least one student x is part of the University Honors program (U).",
"output": "∃x U(x)"
},
{
"input": "Translate into first-order logic: If Thesis enrollment (T → S) holds, then all students receive Scholarships (S).",
"output": "(∀x (T(x) → S(x)) → ∀x S(x))"
},
{
"input": "Translate into first-order logic: Universal enrollment in Research Methods (R) ensures all students pass Philosophy (P).",
"output": "(∀x R(x) → ∀x P(x))"
},
{
"input": "Translate into first-order logic: The policy 'No Thesis (¬T) → No Philosophy (¬P)' implies 'Thesis (T) → Scholarship (S).'",
"output": "(∀x (¬T(x) → ¬P(x)) → ∀x (T(x) → S(x)))"
},
{
"input": "Translate into first-order logic: Failure to qualify for Quantum Physics (Q) revokes Honors program (U) eligibility.",
"output": "∀x (¬Q(x) → ¬U(x))"
},
{
"input": "Translate into first-order logic: There exists at least one student x who has completed Thesis Writing (T).",
"output": "∃x T(x)"
},
{
"input": "Translate into first-order logic: Completing the Thesis requirement ensures eligibility for a Research grant.",
"output": "∀x (T(x) → R(x))"
},
{
"input": "Translate into first-order logic: At least one student has been awarded a Scholarship.",
"output": "∃x S(x)"
},
{
"input": "Translate into first-order logic: Scholarship recipients must maintain a minimum GPA.",
"output": "∀x (S(x) → P(x))"
},
{
"input": "Translate into first-order logic: Students who fail to maintain the required GPA lose access to University housing.",
"output": "∀x (¬P(x) → ¬U(x))"
},
{
"input": "Translate into first-order logic: All students are required to complete a Thesis.",
"output": "∀x T(x)"
},
{
"input": "Translate into first-order logic: Access to University housing is reserved for Scholarship recipients.",
"output": "∀x (U(x) → S(x))"
},
{
"input": "Translate into first-order logic: Students without housing cannot participate in the Quantum Computing lab.",
"output": "∀x (¬U(x) → ¬Q(x))"
},
{
"input": "Translate into first-order logic: Non-participation in the Quantum lab leads to Scholarship revocation.",
"output": "∀x (¬Q(x) → ¬S(x))"
},
{
"input": "Translate into first-order logic: A low GPA disqualifies students from the Quantum lab.",
"output": "∀x (¬P(x) → ¬Q(x))"
},
{
"input": "Translate into first-order logic: There is at least one student with a Research grant.",
"output": "∃x R(x)"
},
{
"input": "Translate into first-order logic: Research grant recipients are guaranteed University housing.",
"output": "∀x (R(x) → U(x))"
},
{
"input": "Translate into first-order logic: At least one student has fulfilled the Thesis requirement.",
"output": "∃x T(x)"
},
{
"input": "Translate into first-order logic: The policy linking GPA to housing implies Thesis completion guarantees a Research grant.",
"output": "(∀x (¬P(x) → ¬U(x)) → ∀x (T(x) → R(x)))"
},
{
"input": "Translate into first-order logic: The existence of Scholarships enforces GPA requirements for lab participation.",
"output": "(∃x S(x) → ∀x (¬P(x) → ¬Q(x)))"
},
{
"input": "Translate into first-order logic: Mandatory Thesis completion ensures at least one Research grant is awarded.",
"output": "(∀x T(x) → ∃x R(x))"
},
{
"input": "Translate into first-order logic: Every student receives a Research grant.",
"output": "∀x R(x)"
},
{
"input": "Translate into first-order logic: Students without housing cannot complete their Thesis.",
"output": "∀x (¬U(x) → ¬T(x))"
},
{
"input": "Translate into first-order logic: All students are Scholarship recipients.",
"output": "∀x S(x)"
},
{
"input": "Translate into first-order logic: At least one student has access to University housing.",
"output": "∃x U(x)"
},
{
"input": "Translate into first-order logic: Some students maintain the required GPA.",
"output": "∃x P(x)"
},
{
"input": "Translate into first-order logic: Housing access requires maintaining the GPA.",
"output": "∀x (U(x) → P(x))"
},
{
"input": "Translate into first-order logic: Failure to complete the Thesis results in loss of housing.",
"output": "∀x (¬T(x) → ¬U(x))"
},
{
"input": "Translate into first-order logic: At least one student has passed the Philosophy requirement.",
"output": "∃x P(x)"
},
{
"input": "Translate into first-order logic: All students have passed the Philosophy requirement.",
"output": "∀x P(x)"
},
{
"input": "Translate into first-order logic: Passing Philosophy grants eligibility for the Quantum Physics lab.",
"output": "∀x (P(x) → Q(x))"
},
{
"input": "Translate into first-order logic: There is at least one recipient of the Research grant.",
"output": "∃x R(x)"
},
{
"input": "Translate into first-order logic: Some students qualify for the Quantum Physics lab.",
"output": "∃x Q(x)"
},
{
"input": "Translate into first-order logic: A few students have access to University housing.",
"output": "∃x U(x)"
},
{
"input": "Translate into first-order logic: Failure to complete the Thesis disqualifies students from Scholarships.",
"output": "∀x (¬T(x) → ¬S(x))"
},
{
"input": "Translate into first-order logic: At least one student has received a Scholarship.",
"output": "∃x S(x)"
},
{
"input": "Translate into first-order logic: Every student is guaranteed University housing.",
"output": "∀x U(x)"
},
{
"input": "Translate into first-order logic: Thesis completion is required for Quantum lab access.",
"output": "∀x (T(x) → Q(x))"
},
{
"input": "Translate into first-order logic: Scholarship recipients receive priority housing.",
"output": "∀x (S(x) → U(x))"
},
{
"input": "Translate into first-order logic: All students have completed their Thesis.",
"output": "∀x T(x)"
},
{
"input": "Translate into first-order logic: Full Thesis compliance ensures Research grant availability.",
"output": "(∀x T(x) → ∃x R(x))"
},
{
"input": "Translate into first-order logic: Research grant recipients qualify for University housing.",
"output": "(∃x R(x) → ∃x U(x))"
},
{
"input": "Translate into first-order logic: The policy linking Research grants to housing implies universal housing access.",
"output": "((∃x R(x) → ∃x U(x)) → ∀x U(x))"
},
{
"input": "Translate into first-order logic: Thesis completion guarantees Scholarship eligibility.",
"output": "∀x (T(x) → S(x))"
},
{
"input": "Translate into first-order logic: Housing access requires Thesis completion.",
"output": "∀x (U(x) → T(x))"
},
{
"input": "Translate into first-order logic: Students without Scholarships cannot finish their Thesis.",
"output": "∀x (¬S(x) → ¬T(x))"
},
{
"input": "Translate into first-order logic: Thesis completion proves Philosophy proficiency.",
"output": "∀x (T(x) → P(x))"
},
{
"input": "Translate into first-order logic: Research grant disqualification blocks Thesis submission.",
"output": "∀x (¬R(x) → ¬T(x))"
},
{
"input": "Translate into first-order logic: No Thesis completion means no Quantum lab access.",
"output": "∀x (¬T(x) → ¬Q(x))"
},
{
"input": "Translate into first-order logic: Quantum lab qualification requires passing Philosophy.",
"output": "∀x (Q(x) → P(x))"
},
{
"input": "Translate into first-order logic: Enrollment in Quantum Physics (Q) grants access to University housing (U).",
"output": "∀x (Q(x) → U(x))"
},
{
"input": "Translate into first-order logic: Passing Philosophy (P) allows enrollment in Quantum Physics (Q).",
"output": "∀x (P(x) → Q(x))"
},
{
"input": "Translate into first-order logic: All students have passed the Philosophy prerequisite (P).",
"output": "∀x P(x)"
},
{
"input": "Translate into first-order logic: At least one student has passed Philosophy (P).",
"output": "∃x P(x)"
},
{
"input": "Translate into first-order logic: Every student receives a Research grant (R).",
"output": "∀x R(x)"
},
{
"input": "Translate into first-order logic: Some students have been awarded Research grants (R).",
"output": "∃x R(x)"
},
{
"input": "Translate into first-order logic: Students not enrolled in Quantum Physics (¬Q) have failed Philosophy (¬P).",
"output": "∀x (¬Q(x) → ¬P(x))"
},
{
"input": "Translate into first-order logic: All students are guaranteed University housing (U).",
"output": "∀x U(x)"
},
{
"input": "Translate into first-order logic: University housing (U) ensures Scholarship eligibility (S).",
"output": "∀x (U(x) → S(x))"
},
{
"input": "Translate into first-order logic: There exists at least one student who completed Thesis Writing (T).",
"output": "∃x T(x)"
},
{
"input": "Translate into first-order logic: Students without Scholarships (¬S) cannot receive Research grants (¬R).",
"output": "∀x (¬S(x) → ¬R(x))"
},
{
"input": "Translate into first-order logic: Access to University housing (U) requires passing Philosophy (P).",
"output": "∀x (U(x) → P(x))"
},
{
"input": "Translate into first-order logic: Universal Research grant distribution (∀R) ensures Philosophy passers can enroll in Quantum (P→Q).",
"output": "(∀x R(x) → ∀x (P(x) → Q(x)))"
},
{
"input": "Translate into first-order logic: The policy 'Housing → Scholarships' implies universal housing access (∀U).",
"output": "(∀x (U(x) → S(x)) → ∀x U(x))"
},
{
"input": "Translate into first-order logic: The housing-Scholarship policy guarantees all students have housing (∀U).",
"output": "((∀x (U(x) → S(x)) → ∀x U(x)) → ∀x U(x))"
},
{
"input": "Translate into first-order logic: If Philosophy enables Quantum enrollment (P→Q), some students receive Research grants (∃R).",
"output": "(∀x (P(x) → Q(x)) → ∃x R(x))"
},
{
"input": "Translate into first-order logic: All students have completed Thesis Writing (T).",
"output": "∀x T(x)"
},
{
"input": "Translate into first-order logic: Lack of housing (¬U) revokes Scholarships (¬S).",
"output": "∀x (¬U(x) → ¬S(x))"
},
{
"input": "Translate into first-order logic: Research grant disqualification (¬R) blocks Thesis completion (¬T).",
"output": "∀x (¬R(x) → ¬T(x))"
},
{
"input": "Translate into first-order logic: Scholarship loss (¬S) denies Quantum Physics enrollment (¬Q).",
"output": "∀x (¬S(x) → ¬Q(x))"
},
{
"input": "Translate into first-order logic: All students are enrolled in Quantum Physics (Q).",
"output": "∀x Q(x)"
},
{
"input": "Translate into first-order logic: At least one student has received a Scholarship.",
"output": "∃x S(x)"
},
{
"input": "Translate into first-order logic: All students are required to submit a Research project.",
"output": "∀x R(x)"
},
{
"input": "Translate into first-order logic: Research project completion grants access to University housing.",
"output": "∀x (R(x) → U(x))"
},
{
"input": "Translate into first-order logic: Students who skip the Thesis requirement cannot submit a Research project.",
"output": "∀x (¬T(x) → ¬R(x))"
},
{
"input": "Translate into first-order logic: Failure to pass Philosophy disqualifies students from Scholarships.",
"output": "∀x (¬P(x) → ¬S(x))"
},
{
"input": "Translate into first-order logic: Research project submission requires Thesis completion.",
"output": "∀x (R(x) → T(x))"
},
{
"input": "Translate into first-order logic: Some students have passed the Philosophy prerequisite.",
"output": "∃x P(x)"
},
{
"input": "Translate into first-order logic: Research project participants must pass Philosophy.",
"output": "∀x (R(x) → P(x))"
},
{
"input": "Translate into first-order logic: There exists at least one student who completed their Thesis.",
"output": "∃x T(x)"
},
{
"input": "Translate into first-order logic: Non-submission of Research projects blocks Thesis completion.",
"output": "∀x (¬R(x) → ¬T(x))"
},
{
"input": "Translate into first-order logic: At least one student has submitted a Research project.",
"output": "∃x R(x)"
},
{
"input": "Translate into first-order logic: Scholarship disqualification revokes Philosophy eligibility.",
"output": "∀x (¬S(x) → ¬P(x))"
},
{
"input": "Translate into first-order logic: The policy 'Research → Housing' enforces Scholarship-Philosophy linkage.",
"output": "(∀x (R(x) → U(x)) → ∀x (¬S(x) → ¬P(x)))"
},
{
"input": "Translate into first-order logic: The Research-Housing policy ensures Scholarship availability.",
"output": "(∀x (R(x) → U(x)) → ∃x S(x))"
},
{
"input": "Translate into first-order logic: Research-Housing compliance requires Scholarship-Philosophy alignment.",
"output": "(∀x (R(x) → U(x)) → ∀x (¬P(x) → ¬S(x)))"
},
{
"input": "Translate into first-order logic: The rule 'No Research → No Thesis' guarantees Thesis completion.",
"output": "(∀x (¬R(x) → ¬T(x)) → ∃x T(x))"
},
{
"input": "Translate into first-order logic: Some students have secured University housing.",
"output": "∃x U(x)"
},
{
"input": "Translate into first-order logic: Quantum Physics enrollment provides housing access.",
"output": "∀x (Q(x) → U(x))"
},
{
"input": "Translate into first-order logic: At least one student is enrolled in Quantum Physics.",
"output": "∃x Q(x)"
},
{
"input": "Translate into first-order logic: Research project disqualification revokes Scholarships.",
"output": "∀x (¬R(x) → ¬S(x))"
},
{
"input": "Translate into first-order logic: All students are enrolled in Quantum Physics.",
"output": "∀x Q(x)"
},
{
"input": "Translate into first-order logic: Students who do not submit a Research project (¬R) cannot complete their Thesis (¬T).",
"output": "∀x (¬R(x) → ¬T(x))"
},
{
"input": "Translate into first-order logic: Failure to pass Philosophy (¬P) disqualifies students from Scholarships (¬S).",
"output": "∀x (¬P(x) → ¬S(x))"
},
{
"input": "Translate into first-order logic: At least one student has submitted a Research project.",
"output": "∃x R(x)"
},
{
"input": "Translate into first-order logic: Failing Philosophy (¬P) blocks Research project submission (¬R).",
"output": "∀x (¬P(x) → ¬R(x))"
},
{
"input": "Translate into first-order logic: Incomplete Thesis (¬T) revokes University housing access (¬U).",
"output": "∀x (¬T(x) → ¬U(x))"
},
{
"input": "Translate into first-order logic: Passing Philosophy (P) guarantees University housing (U).",
"output": "∀x (P(x) → U(x))"
},
{
"input": "Translate into first-order logic: All students are guaranteed University housing.",
"output": "∀x U(x)"
},
{
"input": "Translate into first-order logic: Every student must submit a Research project.",
"output": "∀x R(x)"
},
{
"input": "Translate into first-order logic: The policy 'No Research → No Thesis' enforces universal Research compliance.",
"output": "(∀x (¬R(x) → ¬T(x)) → ∀x R(x))"
},
{
"input": "Translate into first-order logic: The rule 'No Thesis → No Housing' ensures all students submit Research.",
"output": "(∀x (¬T(x) → ¬U(x)) → ∀x R(x))"
},
{
"input": "Translate into first-order logic: The Scholarship-Philosophy linkage implies Thesis-Housing dependency.",
"output": "(∀x (¬P(x) → ¬S(x)) → ∀x (¬T(x) → ¬U(x)))"
},
{
"input": "Translate into first-order logic: The Research-Thesis policy enforces Philosophy-Research compliance.",
"output": "(∀x (¬R(x) → ¬T(x)) → ∀x (¬P(x) → ¬R(x)))"
},
{
"input": "Translate into first-order logic: Scholarship recipients qualify for Quantum Physics enrollment.",
"output": "∀x (S(x) → Q(x))"
},
{
"input": "Translate into first-order logic: Students who do not apply for Scholarships (¬S) cannot enroll in Thesis Writing (¬T).",
"output": "∀x (¬S(x) → ¬T(x))"
},
{
"input": "Translate into first-order logic: Passing Philosophy (P) grants eligibility for Research Methods (R).",
"output": "∀x (P(x) → R(x))"
},
{
"input": "Translate into first-order logic: All students are guaranteed University housing (U).",
"output": "∀x U(x)"
},
{
"input": "Translate into first-order logic: Enrollment in Research Methods (R) requires Thesis Writing (T).",
"output": "∀x (R(x) → T(x))"
},
{
"input": "Translate into first-order logic: Passing Philosophy (P) necessitates enrolling in Thesis Writing (T).",
"output": "∀x (P(x) → T(x))"
},
{
"input": "Translate into first-order logic: Every student is enrolled in Quantum Physics (Q).",
"output": "∀x Q(x)"
},
{
"input": "Translate into first-order logic: Some students are participating in Research Methods (R).",
"output": "∃x R(x)"
},
{
"input": "Translate into first-order logic: All students have submitted Scholarship applications (S).",
"output": "∀x S(x)"
},
{
"input": "Translate into first-order logic: Universal Quantum Physics enrollment (∀Q) enforces Philosophy-Thesis linkage (P→T).",
"output": "(∀x Q(x) → ∀x (P(x) → T(x)))"
},
{
"input": "Translate into first-order logic: Mandatory Quantum Physics (∀Q) implies Scholarship applications are required for Thesis (¬S→¬T).",
"output": "(∀x Q(x) → ∀x (¬S(x) → ¬T(x)))"
},
{
"input": "Translate into first-order logic: The policy 'Philosophy → Thesis' ensures universal housing access (∀U).",
"output": "(∀x (P(x) → T(x)) → ∀x U(x))"
},
{
"input": "Translate into first-order logic: Universal housing (∀U) guarantees Scholarship-Thesis compliance under Quantum enrollment (∀Q → ¬S→¬T).",
"output": "(∀x U(x) → (∀x Q(x) → ∀x (¬S(x) → ¬T(x))))"
},
{
"input": "Translate into first-order logic: Lack of housing (¬U) revokes Research Methods eligibility (¬R).",
"output": "∀x (¬U(x) → ¬R(x))"
},
{
"input": "Translate into first-order logic: Students who don't conduct research (¬R) can't enroll in Quantum Physics (¬Q).",
"output": "∀x (¬R(x) → ¬Q(x))"
},
{
"input": "Translate into first-order logic: Dormitory access (U) requires submitting a thesis (T).",
"output": "∀x (U(x) → T(x))"
},
{
"input": "Translate into first-order logic: Some students have submitted theses.",
"output": "∃x T(x)"
},
{
"input": "Translate into first-order logic: Thesis submission (T) guarantees dormitory access (U).",
"output": "∀x (T(x) → U(x))"
},
{
"input": "Translate into first-order logic: No dormitory access (¬U) blocks Philosophy enrollment (¬P).",
"output": "∀x (¬U(x) → ¬P(x))"
},
{
"input": "Translate into first-order logic: All students take Quantum Physics.",
"output": "∀x Q(x)"
},
{
"input": "Translate into first-order logic: Some students conduct research.",
"output": "∃x R(x)"
},
{
"input": "Translate into first-order logic: The rule 'Thesis→Dormitory' enforces 'No Research→No Quantum'.",
"output": "(∀x (T(x) → U(x)) → ∀x (¬R(x) → ¬Q(x)))"
},
{
"input": "Translate into first-order logic: Existence of thesis submitters triggers the research-quantum policy link.",
"output": "(∃x T(x) → (∀x (T(x) → U(x)) → ∀x (¬R(x) → ¬Q(x))))"
},
{
"input": "Translate into first-order logic: Researchers get dormitory access.",
"output": "∀x (R(x) → U(x))"
},
{
"input": "Translate into first-order logic: Quantum enrollment grants scholarship eligibility (S).",
"output": "∀x (Q(x) → S(x))"
},
{
"input": "Translate into first-order logic: Scholarships require Philosophy proficiency.",
"output": "∀x (S(x) → P(x))"
},
{
"input": "Translate into first-order logic: All students receive scholarships.",
"output": "∀x S(x)"
},
{
"input": "Translate into first-order logic: Submitting course registration (S) grants enrollment confirmation (U).",
"output": "∀x (S(x) → U(x))"
},
{
"input": "Translate into first-order logic: Meeting prerequisites (Q) allows enrollment in advanced courses (T).",
"output": "∀x (Q(x) → T(x))"
},
{
"input": "Translate into first-order logic: Some students have successfully submitted registrations.",
"output": "∃x S(x)"
},
{
"input": "Translate into first-order logic: All students have cleared tuition payments (P).",
"output": "∀x P(x)"
},
{
"input": "Translate into first-order logic: All students satisfy prerequisite requirements.",
"output": "∀x Q(x)"
},
{
"input": "Translate into first-order logic: Every registration has advisor approval (R).",
"output": "∀x R(x)"
},
{
"input": "Translate into first-order logic: Lack of advisor approval blocks enrollment confirmation.",
"output": "∀x (¬R(x) → ¬U(x))"
},
{
"input": "Translate into first-order logic: Unconfirmed enrollments invalidate registration submissions.",
"output": "∀x (¬U(x) → ¬S(x))"
},
{
"input": "Translate into first-order logic: Full tuition compliance by all students waives prerequisite checks.",
"output": "(∀x P(x) → ∀x Q(x))"
},
{
"input": "Translate into first-order logic: Universal advisor approval triggers automatic purge of unconfirmed registrations.",
"output": "(∀x R(x) → ∀x (¬U(x) → ¬S(x)))"
},
{
"input": "Translate into first-order logic: All students submitted course registrations.",
"output": "∀x S(x)"
},
{
"input": "Translate into first-order logic: Outstanding tuition fees void advisor approvals.",
"output": "∀x (¬P(x) → ¬R(x))"
},
{
"input": "Translate into first-order logic: Enrollment confirmation requires cleared payments.",
"output": "∀x (U(x) → P(x))"
},
{
"input": "Translate into first-order logic: Advanced course enrollment mandates advisor consent.",
"output": "∀x (T(x) → R(x))"
},
{
"input": "Translate into first-order logic: Some students qualify for advanced courses.",
"output": "∃x Q(x)"
},
{
"input": "Translate into first-order logic: In Calculus 2 for engineering students, if an object x does not have property P then it also does not have property R.",
"output": "∀x (¬P(x) → ¬R(x))"
},
{
"input": "Translate into first-order logic: In Calculus 2 for engineering students, for all objects x, x has property Q.",
"output": "∀x Q(x)"
},
{
"input": "Translate into first-order logic: In Calculus 2 for engineering students, there exists at least one object x that has property R.",
"output": "∃x R(x)"
},
{
"input": "Translate into first-order logic: In Calculus 2 for engineering students, if an object x does not have property U then it does not have property P.",
"output": "∀x (¬U(x) → ¬P(x))"
},
{
"input": "Translate into first-order logic: In Calculus 2 for engineering students, if an object x has property Q then it also has property T.",
"output": "∀x (Q(x) → T(x))"
},
{
"input": "Translate into first-order logic: In Calculus 2 for engineering students, if an object x does not have property T then it does not have property S.",
"output": "∀x (¬T(x) → ¬S(x))"
},
{
"input": "Translate into first-order logic: In Calculus 2 for engineering students, if an object x has property U then it has property P.",
"output": "∀x (U(x) → P(x))"
},
{
"input": "Translate into first-order logic: In Calculus 2 for engineering students, if an object x has property P then it also has property T.",
"output": "∀x (P(x) → T(x))"
},
{
"input": "Translate into first-order logic: In Calculus 2 for engineering students, if x having property U implies x has property P then x having property Q implies x has property T.",
"output": "(∀x (U(x) → P(x)) → ∀x (Q(x) → T(x)))"
},
{
"input": "Translate into first-order logic: In Calculus 2 for engineering students, if not having property P implies not having property R then x having property U implies x has property P.",
"output": "(∀x (¬P(x) → ¬R(x)) → ∀x (U(x) → P(x)))"
},
{
"input": "Translate into first-order logic: In Calculus 2 for engineering students, if an object x has property T then it has property U.",
"output": "∀x (T(x) → U(x))"
},
{
"input": "Translate into first-order logic: In Calculus 2 for engineering students, for all objects x, x has property P.",
"output": "∀x P(x)"
},
{
"input": "Translate into first-order logic: In Calculus 2 for engineering students, for all objects x, x has property R.",
"output": "∀x R(x)"
},
{
"input": "Translate into first-order logic: In Calculus 2 for engineering students, if an object x has property S then it has property P.",
"output": "∀x (S(x) → P(x))"
},
{
"input": "Translate into first-order logic: In Calculus 2 for engineering students, there exists at least one object x that has property P.",
"output": "∃x P(x)"
},
{
"input": "Translate into first-order logic: Submitting a research proposal (S) requires advisor review (R).",
"output": "∀x (S(x) → R(x))"
},
{
"input": "Translate into first-order logic: Passing Philosophy (P) grants dormitory access (U).",
"output": "∀x (P(x) → U(x))"
},
{
"input": "Translate into first-order logic: Some students have submitted research proposals.",
"output": "∃x S(x)"
},
{
"input": "Translate into first-order logic: Thesis completion (T) requires a submitted proposal.",
"output": "∀x (T(x) → S(x))"
},
{
"input": "Translate into first-order logic: Advisor-reviewed proposals grant dormitory access.",
"output": "∀x (R(x) → U(x))"
},
{
"input": "Translate into first-order logic: Some students qualify for advanced seminars (Q).",
"output": "∃x Q(x)"
},
{
"input": "Translate into first-order logic: Research proposals must lead to thesis work.",
"output": "∀x (S(x) → T(x))"
},
{
"input": "Translate into first-order logic: Failing Philosophy revokes dormitory access.",
"output": "∀x (¬P(x) → ¬U(x))"
},
{
"input": "Translate into first-order logic: The Philosophy-dormitory rule enforces proposal-review linkage.",
"output": "(∀x (¬P(x) → ¬U(x)) → ∀x (S(x) → R(x)))"
},
{
"input": "Translate into first-order logic: The Philosophy-dormitory policy ensures advanced seminar participation.",
"output": "(∀x (¬P(x) → ¬U(x)) → ∃x Q(x))"
},
{
"input": "Translate into first-order logic: Submitting proposals guarantees dormitory access.",
"output": "∀x (S(x) → U(x))"
},
{
"input": "Translate into first-order logic: All students complete theses.",
"output": "∀x T(x)"
},
{
"input": "Translate into first-order logic: Some students have dormitory access.",
"output": "∃x U(x)"
},
{
"input": "Translate into first-order logic: No proposal submission blocks dormitory access.",
"output": "∀x (¬S(x) → ¬U(x))"
},
{
"input": "Translate into first-order logic: Philosophy failure invalidates advisor reviews.",
"output": "∀x (¬P(x) → ¬R(x))"
},
{
"input": "Translate into first-order logic: At the University of Technology, every object x has property Q.",
"output": "∀x Q(x)"
},
{
"input": "Translate into first-order logic: At the University of Technology, every object x has property S.",
"output": "∀x S(x)"
},
{
"input": "Translate into first-order logic: At the University of Technology, if an object x does not have property Q, then it does not have property P.",
"output": "∀x (¬Q(x) → ¬P(x))"
},
{
"input": "Translate into first-order logic: At the University of Technology, every object x has property U.",
"output": "∀x U(x)"
},
{
"input": "Translate into first-order logic: At the University of Technology, every object x has property T.",
"output": "∀x T(x)"
},
{
"input": "Translate into first-order logic: At the University of Technology, if an object x has property T, then it also has property Q.",
"output": "∀x (T(x) → Q(x))"
},
{
"input": "Translate into first-order logic: At the University of Technology, there exists at least one object x that has property U.",
"output": "∃x U(x)"
},
{
"input": "Translate into first-order logic: At the University of Technology, if an object x has property P, then it has property U.",
"output": "∀x (P(x) → U(x))"
},
{
"input": "Translate into first-order logic: At the University of Technology, if there exists an object x with property U, then every object x has property S.",
"output": "(∃x U(x) → ∀x S(x))"
},
{
"input": "Translate into first-order logic: At the University of Technology, if it is true that whenever an object x has property T then it has property Q, then every object x has property T.",
"output": "(∀x (T(x) → Q(x)) → ∀x T(x))"
},
{
"input": "Translate into first-order logic: At the University of Technology, every object x has property R.",
"output": "∀x R(x)"
},
{
"input": "Translate into first-order logic: At the University of Technology, if an object x has property S, then it also has property Q.",
"output": "∀x (S(x) → Q(x))"
},
{
"input": "Translate into first-order logic: At the University of Technology, if an object x does not have property S, then it does not have property U.",
"output": "∀x (¬S(x) → ¬U(x))"
},
{
"input": "Translate into first-order logic: At the University of Technology, if an object x has property R, then it also has property U.",
"output": "∀x (R(x) → U(x))"
},
{
"input": "Translate into first-order logic: At the University of Technology, if an object x has property U, then it has property S.",
"output": "∀x (U(x) → S(x))"
},
{
"input": "Translate into first-order logic: All students have dormitory access (U).",
"output": "∀x U(x)"
},
{
"input": "Translate into first-order logic: Dormitory access requires passing Philosophy (P).",
"output": "∀x (U(x) → P(x))"
},
{
"input": "Translate into first-order logic: Some students completed Research projects (R).",
"output": "∃x R(x)"
},
{
"input": "Translate into first-order logic: No scholarship (¬S) blocks dormitory access.",
"output": "∀x (¬S(x) → ¬U(x))"
},
{
"input": "Translate into first-order logic: Thesis completion (T) grants scholarship eligibility.",
"output": "∀x (T(x) → S(x))"
},
{
"input": "Translate into first-order logic: All students receive scholarships.",
"output": "∀x S(x)"
},
{
"input": "Translate into first-order logic: Some students qualify for Quantum Physics (Q).",
"output": "∃x Q(x)"
},
{
"input": "Translate into first-order logic: All students passed Philosophy.",
"output": "∀x P(x)"
},
{
"input": "Translate into first-order logic: Some students have scholarships.",
"output": "∃x S(x)"
},
{
"input": "Translate into first-order logic: Research completion ensures Philosophy proficiency.",
"output": "∀x (R(x) → P(x))"
},
{
"input": "Translate into first-order logic: Existence of researchers enforces Research→Philosophy rule.",
"output": "(∃x R(x) → ∀x (R(x) → P(x)))"
},
{
"input": "Translate into first-order logic: Dormitory-Philosophy link ensures universal scholarships.",
"output": "(∀x (U(x) → P(x)) → ∀x S(x))"
},
{
"input": "Translate into first-order logic: Quantum students enforce Research→Philosophy compliance.",
"output": "(∃x Q(x) → ∀x (R(x) → P(x)))"
},
{
"input": "Translate into first-order logic: All students completed Research projects.",
"output": "∀x R(x)"
},
{
"input": "Translate into first-order logic: Scholarship loss blocks Quantum Physics.",
"output": "∀x (¬S(x) → ¬Q(x))"
},
{
"input": "Translate into first-order logic: No dorm access blocks Quantum Physics.",
"output": "∀x (¬U(x) → ¬Q(x))"
},
{
"input": "Translate into first-order logic: At the University of Technology, there exists at least one object x that has property U.",
"output": "∃x U(x)"
},
{
"input": "Translate into first-order logic: At the University of Technology, if an object x does not have property S, then it does not have property P.",
"output": "∀x (¬S(x) → ¬P(x))"
},
{
"input": "Translate into first-order logic: At the University of Technology, every object x has property P.",
"output": "∀x P(x)"
},
{
"input": "Translate into first-order logic: At the University of Technology, if an object x has property U, then it has property S.",
"output": "∀x (U(x) → S(x))"
},
{
"input": "Translate into first-order logic: At the University of Technology, there exists at least one object x that has property S.",
"output": "∃x S(x)"
},
{
"input": "Translate into first-order logic: At the University of Technology, there exists at least one object x that has property P.",
"output": "∃x P(x)"
},
{
"input": "Translate into first-order logic: At the University of Technology, if an object x has property R, then it has property U.",
"output": "∀x (R(x) → U(x))"
},
{
"input": "Translate into first-order logic: At the University of Technology, there exists at least one object x that has property T.",
"output": "∃x T(x)"
},
{
"input": "Translate into first-order logic: At the University of Technology, if it is true that if an object x does not have property S then it does not have property P, then there exists at least one object x that has property P.",
"output": "(∀x (¬S(x) → ¬P(x)) → ∃x P(x))"
},
{
"input": "Translate into first-order logic: At the University of Technology, if there exists at least one object x that has property U, then if an object x does not have property S it does not have property P.",
"output": "(∃x U(x) → ∀x (¬S(x) → ¬P(x)))"
},
{
"input": "Translate into first-order logic: At the University of Technology, if an object x has property U, then it has property Q.",
"output": "∀x (U(x) → Q(x))"
},
{
"input": "Translate into first-order logic: At the University of Technology, if an object x does not have property P, then it does not have property S.",
"output": "∀x (¬P(x) → ¬S(x))"
},
{
"input": "Translate into first-order logic: At the University of Technology, if an object x does not have property U, then it does not have property P.",
"output": "∀x (¬U(x) → ¬P(x))"
},
{
"input": "Translate into first-order logic: At the University of Technology, if an object x does not have property R, then it does not have property P.",
"output": "∀x (¬R(x) → ¬P(x))"
},
{
"input": "Translate into first-order logic: At the University of Technology, there exists at least one object x that has property Q.",
"output": "∃x Q(x)"
},
{
"input": "Translate into first-order logic: There exists at least one object x that has property R.",
"output": "∃x R(x)"
},
{
"input": "Translate into first-order logic: If an object x does not have property U, then it does not have property Q.",
"output": "∀x (¬U(x) → ¬Q(x))"
},
{
"input": "Translate into first-order logic: Every object x has property P.",
"output": "∀x P(x)"
},
{
"input": "Translate into first-order logic: If an object x does not have property Q, then it does not have property S.",
"output": "∀x (¬Q(x) → ¬S(x))"
},
{
"input": "Translate into first-order logic: If an object x does not have property R, then it does not have property S.",
"output": "∀x (¬R(x) → ¬S(x))"
},
{
"input": "Translate into first-order logic: If an object x has property T, then it has property P.",
"output": "∀x (T(x) → P(x))"
},
{
"input": "Translate into first-order logic: If an object x does not have property T, then it does not have property R.",
"output": "∀x (¬T(x) → ¬R(x))"
},
{
"input": "Translate into first-order logic: There exists at least one object x that has property U.",
"output": "∃x U(x)"
},
{
"input": "Translate into first-order logic: If it is true that if an object x does not have property T then it does not have property R, then if an object x has property T, it has property P.",
"output": "(∀x (¬T(x) → ¬R(x)) → ∀x (T(x) → P(x)))"
},
{
"input": "Translate into first-order logic: If there exists at least one object x with property R, then there exists at least one object x with property U.",
"output": "(∃x R(x) → ∃x U(x))"
},
{
"input": "Translate into first-order logic: If there exists at least one object x with property R, then every object x has property P.",
"output": "(∃x R(x) → ∀x P(x))"
},
{
"input": "Translate into first-order logic: Every object x has property R.",
"output": "∀x R(x)"
},
{
"input": "Translate into first-order logic: If an object x does not have property U, then it does not have property T.",
"output": "∀x (¬U(x) → ¬T(x))"
},
{
"input": "Translate into first-order logic: There exists at least one object x that has property Q.",
"output": "∃x Q(x)"
},
{
"input": "Translate into first-order logic: Submitting a thesis proposal (S) requires advisor approval (T).",
"output": "∀x (S(x) → T(x))"
},
{
"input": "Translate into first-order logic: Failing Philosophy (¬P) blocks Quantum Physics enrollment (¬Q).",
"output": "∀x (¬P(x) → ¬Q(x))"
},
{
"input": "Translate into first-order logic: Thesis proposals grant dormitory access (U).",
"output": "∀x (S(x) → U(x))"
},
{
"input": "Translate into first-order logic: Research project approval (R) grants dormitory access.",
"output": "∀x (R(x) → U(x))"
},
{
"input": "Translate into first-order logic: Dormitory access allows Quantum Physics enrollment.",
"output": "∀x (U(x) → Q(x))"
},
{
"input": "Translate into first-order logic: No advisor approval blocks Philosophy progression.",
"output": "∀x (¬T(x) → ¬P(x))"
},
{
"input": "Translate into first-order logic: Some students are enrolled in Quantum Physics.",
"output": "∃x Q(x)"
},
{
"input": "Translate into first-order logic: All students have submitted thesis proposals.",
"output": "∀x S(x)"
},
{
"input": "Translate into first-order logic: Thesis-advisor rule enforces research-dormitory link.",
"output": "(∀x (S(x) → T(x)) → ∀x (R(x) → U(x)))"
},
{
"input": "Translate into first-order logic: Thesis-advisor compliance ensures universal submissions.",
"output": "(∀x (S(x) → T(x)) → ∀x S(x))"
},
{
"input": "Translate into first-order logic: Philosophy-Quantum rules enforce research-dormitory policies.",
"output": "(∀x (¬P(x) → ¬Q(x)) → ∀x (R(x) → U(x)))"
},
{
"input": "Translate into first-order logic: All students have dormitory access.",
"output": "∀x U(x)"
},
{
"input": "Translate into first-order logic: Quantum enrollment requires dormitory access.",
"output": "∀x (Q(x) → U(x))"
},
{
"input": "Translate into first-order logic: Advisor approval ensures dormitory access.",
"output": "∀x (T(x) → U(x))"
},
{
"input": "Translate into first-order logic: Qualifying for Quantum Physics (Q) requires Research project completion (R).",
"output": "∀x (Q(x) → R(x))"
},
{
"input": "Translate into first-order logic: Failing the entrance exam (¬T) blocks dormitory access (¬U).",
"output": "∀x (¬T(x) → ¬U(x))"
},
{
"input": "Translate into first-order logic: Special program enrollment (S) mandates passing Philosophy (P).",
"output": "∀x (S(x) → P(x))"
},
{
"input": "Translate into first-order logic: All students passed the entrance exam.",
"output": "∀x T(x)"
},
{
"input": "Translate into first-order logic: All students have passed Philosophy.",
"output": "∀x P(x)"
},
{
"input": "Translate into first-order logic: No entrance exam pass → No Research completion.",
"output": "∀x (¬T(x) → ¬R(x))"
},
{
"input": "Translate into first-order logic: Some students completed Research projects.",
"output": "∃x R(x)"
},
{
"input": "Translate into first-order logic: Special program students get dormitory access.",
"output": "∀x (S(x) → U(x))"
},
{
"input": "Translate into first-order logic: Universal Philosophy success ensures special program benefits.",
"output": "(∀x P(x) → ∀x S(x))"
},
{
"input": "Translate into first-order logic: Research completers enforce Quantum Physics requirements.",
"output": "(∃x R(x) → ∀x (Q(x) → R(x)))"
},
{
"input": "Translate into first-order logic: The exam-Research rule activates Quantum Physics policies.",
"output": "(∀x (¬T(x) → ¬R(x)) → ∀x (Q(x) → R(x)))"
},
{
"input": "Translate into first-order logic: Quantum disqualification revokes dormitory rights.",
"output": "∀x (¬Q(x) → ¬U(x))"
},
{
"input": "Translate into first-order logic: Some students qualify for Quantum Physics.",
"output": "∃x Q(x)"
},
{
"input": "Translate into first-order logic: Quantum qualification grants dormitory access.",
"output": "∀x (Q(x) → U(x))"
},
{
"input": "Translate into first-order logic: At the university, if an object x has property U, then it has property P.",
"output": "∀x (U(x) → P(x))"
},
{
"input": "Translate into first-order logic: At the university, there exists at least one object x that has property Q.",
"output": "∃x Q(x)"
},
{
"input": "Translate into first-order logic: At the university, every object x has property S.",
"output": "∀x S(x)"
},
{
"input": "Translate into first-order logic: At the university, if an object x does not have property Q, then it does not have property U.",
"output": "∀x (¬Q(x) → ¬U(x))"
},
{
"input": "Translate into first-order logic: At the university, every object x has property R.",
"output": "∀x R(x)"
},
{
"input": "Translate into first-order logic: At the university, every object x has property P.",
"output": "∀x P(x)"
},
{
"input": "Translate into first-order logic: At the university, if an object x has property U, then it has property T.",
"output": "∀x (U(x) → T(x))"
},
{
"input": "Translate into first-order logic: At the university, every object x has property Q.",
"output": "∀x Q(x)"
},
{
"input": "Translate into first-order logic: At the university, if it is true that if an object x has property U then it has property T, then every object x has property P.",
"output": "(∀x (U(x) → T(x)) → ∀x P(x))"
},
{
"input": "Translate into first-order logic: At the university, if every object x has property R, then there exists at least one object x that has property Q.",
"output": "(∀x R(x) → ∃x Q(x))"
},
{
"input": "Translate into first-order logic: At the university, if it is true that if an object x having property U implies it has property T then every object x has property P, then every object x has property P.",
"output": "((∀x (U(x) → T(x)) → ∀x P(x)) → ∀x P(x))"
},
{
"input": "Translate into first-order logic: At the university, if an object x does not have property U, then it does not have property R.",
"output": "∀x (¬U(x) → ¬R(x))"
},
{
"input": "Translate into first-order logic: At the university, if an object x does not have property S, then it does not have property P.",
"output": "∀x (¬S(x) → ¬P(x))"
},
{
"input": "Translate into first-order logic: At the university, if an object x does not have property Q, then it does not have property S.",
"output": "∀x (¬Q(x) → ¬S(x))"
},
{
"input": "Translate into first-order logic: If a student attends classes regularly, then they will understand the material better.",
"output": "∀x (AttendsRegularly(x) → UnderstandsMaterial(x))"
},
{
"input": "Translate into first-order logic: If a student participates in extracurricular activities, then they will develop social skills.",
"output": "∀x (Extracurricular(x) → SocialSkills(x))"
},
{
"input": "Translate into first-order logic: If a student understands the material, then they will perform well in exams.",
"output": "∀x (UnderstandsMaterial(x) → PerformsWell(x))"
},
{
"input": "Translate into first-order logic: If a student participates in extracurricular activities, then they will perform well in exams.",
"output": "∀x (Extracurricular(x) → PerformsWell(x))"
},
{
"input": "Translate into first-order logic: There exists at least one student who has qualified for the Quantum Physics competition.",
"output": "∃x (QualifiesQuantum(x))"
},
{
"input": "Translate into first-order logic: All students are enrolled in Research Methods.",
"output": "∀x (ResearchMethods(x))"
},
{
"input": "Translate into first-order logic: If a student receives a Scholarship, then they are enrolled in Research Methods.",
"output": "∀x (Scholarship(x) → ResearchMethods(x))"
},
{
"input": "Translate into first-order logic: If a student is enrolled in Research Methods, then they have qualified for the Quantum Physics competition.",
"output": "∀x (ResearchMethods(x) → QualifiesQuantum(x))"
},
{
"input": "Translate into first-order logic: If there exists at least one student who has completed the Thesis Writing course, then all students are enrolled in Research Methods.",
"output": "∃x (ThesisWriting(x))"
},
{
"input": "Translate into first-order logic: All students have completed the Thesis Writing course.",
"output": "∀x (ThesisWriting(x))"
},
{
"input": "Translate into first-order logic: If a student does not receive a Scholarship, then they have not qualified for the Quantum Physics competition.",
"output": "∀x (¬Scholarship(x) → ¬QualifiesQuantum(x))"
},
{
"input": "Translate into first-order logic: All students are part of the University Honors program.",
"output": "∀x (UniversityHonors(x))"
},
{
"input": "Translate into first-order logic: If a student completes the Thesis Writing course, then they have passed the Philosophy prerequisite.",
"output": "∀x (ThesisWriting(x) → PhilosophyPrerequisite(x))"
},
{
"input": "Translate into first-order logic: All students are enrolled in Research Methods.",
"output": "∀x (ResearchMethods(x))"
},
{
"input": "Translate into first-order logic: If a student is enrolled in Research Methods, then they have qualified for the Quantum Physics competition.",
"output": "∀x (ResearchMethods(x) → QualifiesQuantum(x))"
},
{
"input": "Translate into first-order logic: If a student completes the Thesis Writing course, then all students are enrolled in Research Methods.",
"output": "∀x (ThesisWriting(x) → ∀y (ResearchMethods(y)))"
},
{
"input": "Translate into first-order logic: If a student is not part of the University Honors program, then they have not qualified for the Quantum Physics competition.",
"output": "∀x (¬UniversityHonors(x) → ¬QualifiesQuantum(x))"
},
{
"input": "Translate into first-order logic: There exists at least one student who has completed the Thesis Writing course.",
"output": "∃x (ThesisWriting(x))"
},
{
"input": "Translate into first-order logic: Every student must complete a community service project to graduate.",
"output": "∀x (CommunityService(x))"
},
{
"input": "Translate into first-order logic: Students who participate in study groups tend to have higher grades.",
"output": "∀x (StudyGroups(x) → HigherGrades(x))"
},
{
"input": "Translate into first-order logic: All students have access to online learning resources.",
"output": "∀x (OnlineResources(x))"
},
{
"input": "Translate into first-order logic: There is at least one student who has received a merit-based scholarship.",
"output": "∃x (MeritScholarship(x))"
},
{
"input": "Translate into first-order logic: If all students complete a community service project, then at least one student has attended an international exchange program.",
"output": "∀x (CommunityService(x))"
},
{
"input": "Translate into first-order logic: If all students have access to online learning resources, then they are all enrolled in at least one online course.",
"output": "∀x (OnlineResources(x))"
},
{
"input": "Translate into first-order logic: Every student is required to take a foreign language course.",
"output": "∀x (ForeignLanguage(x))"
},
{
"input": "Translate into first-order logic: All students have participated in at least one extracurricular activity.",
"output": "∀x (Extracurricular(x))"
},
{
"input": "Translate into first-order logic: If a student studies a subject for 10 hours or more, they will gain the required knowledge.",
"output": "∀x (∀y (Studies(x, y, ≥10) → Knowledge(x, y)))"
},
{
"input": "Translate into first-order logic: If a student gains the required knowledge, they will either pass the exam or complete a project.",
"output": "∀x (∀y (Knowledge(x, y) → (ExamPass(x, y) ∨ Project(x, y))))"
},
{
"input": "Translate into first-order logic: If a student does not complete the project, they must take the exam.",
"output": "∀x (∀y (¬Project(x, y) → ExamTake(x, y)))"
},
{
"input": "Translate into first-order logic: If a subject requires an exam, the professor either prepares the exam, or the system generates one.",
"output": "∀y (RequiresExam(y) → (ProfessorPrepares(y) ∨ SystemGenerates(y)))"
},
{
"input": "Translate into first-order logic: If a student studies less than 10 hours, they must take the exam.",
"output": "∀x (∀y (Studies(x, y, <10) → ExamTake(x, y)))"
},
{
"input": "Translate into first-order logic: If a student passes 3 or more subjects, they are eligible for a scholarship.",
"output": "∀x (PassesSubjects(x, ≥3) → Scholarship(x))"
},
{
"input": "Translate into first-order logic: If a student studies at least 15 hours for a subject, they are exempted from the exam.",
"output": "∀x (∀y (Studies(x, y, ≥15) → ¬ExamTake(x, y)))"
},
{
"input": "Translate into first-order logic: If a student gains required knowledge in three subjects but fails to complete a project in any, they must take the exam for those subjects.",
"output": "∀x ((KnowledgeThreeSubjects(x) ∧ ¬ProjectAny(x)) → ExamTakeThree(x))"
},
{
"input": "Translate into first-order logic: If a student studies less than 10 hours but completes the project, they still must take an assessment if the professor requires it.",
"output": "∀x (∀y ((Studies(x, y, <10) ∧ Project(x, y) ∧ ProfessorRequires(y)) → Assessment(x, y)))"
},
{
"input": "Translate into first-order logic: Every course contains knowledge.",
"output": "∀x (Course(x) → ContainsKnowledge(x))"
},
{
"input": "Translate into first-order logic: If a student enrolls in a course and passes it, they will gain knowledge.",
"output": "∀s (∀c ((Enrolled(s, c) ∧ Passes(s, c)) → GainsKnowledge(s, c)))"
},
{
"input": "Translate into first-order logic: If a student gains knowledge from a course, they will have understanding.",
"output": "∀s (∀c (GainsKnowledge(s, c) → Understanding(s, c)))"
},
{
"input": "Translate into first-order logic: If a course has an equivalent alternative, passing the alternative fulfills the prerequisite requirement.",
"output": "∀c (∀d (Equivalent(c, d) → (Passes(s, d) → FulfillsPrerequisite(s, c))))"
},
{
"input": "Translate into first-order logic: If a student meets all prerequisite requirements and is enrolled in a course, they are allowed to take the course.",
"output": "∀s (∀c ((MeetsPrerequisites(s, c) ∧ Enrolled(s, c)) → AllowedToTake(s, c)))"
},
{
"input": "Translate into first-order logic: Tuan is enrolled in the 'Machine Learning 101' course in semester 243.",
"output": "Enrolled(Tuan, ML101, 243)"
},
{
"input": "Translate into first-order logic: To take the 'Machine Learning 101' course, students must pass the 'Linear Algebra' course.",
"output": "∀s (AllowedToTake(s, ML101) → Passes(s, LinearAlgebra))"
},
{
"input": "Translate into first-order logic: The 'Intro to Linear Algebra' course is considered equivalent to the 'Linear Algebra' course.",
"output": "Equivalent(LinearAlgebra, IntroLinearAlgebra)"
},
{
"input": "Translate into first-order logic: Tuan passed the 'Intro to Linear Algebra' course in semester 241.",
"output": "Passes(Tuan, IntroLinearAlgebra, 241)"
},
{
"input": "Translate into first-order logic: Every student must complete at least 150 credits to graduate.",
"output": "∀x (Graduate(x) → Credits(x, ≥150))"
},
{
"input": "Translate into first-order logic: If a student fails a core course, they must retake and pass it to graduate.",
"output": "∀x (∀c (CoreCourse(c) ∧ Fails(x, c) → (Retake(x, c) ∧ Passes(x, c) → Graduate(x))))"
},
{
"input": "Translate into first-order logic: To register for the Capstone Project, a student must complete Advanced Algorithms and Research Methods.",
"output": "∀x (Enroll(x, Capstone) → (Completed(x, AdvAlgorithms) ∧ Completed(x, ResearchMethods)))"
},
{
"input": "Translate into first-order logic: Advanced Algorithms requires Data Structures and Discrete Mathematics as prerequisites.",
"output": "∀x (Completed(x, AdvAlgorithms) → (Passes(x, DataStructures) ∧ Passes(x, DiscreteMath)))"
},
{
"input": "Translate into first-order logic: If a student earns at least 12 credits per semester and their GPA is 3.0 or higher, they can apply for early graduation.",
"output": "∀x ((CreditsPerSemester(x, ≥12) ∧ GPA(x, ≥3.0)) → ApplyEarlyGraduation(x))"
},
{
"input": "Translate into first-order logic: If a student has not completed all prerequisite courses, they cannot register for any dependent courses.",
"output": "∀x (∀c (¬MeetsPrerequisites(x, c) → ¬Enroll(x, c)))"
},
{
"input": "Translate into first-order logic: A student must retake a failed course in the next available semester unless they have special approval to delay.",
"output": "∀x (∀c (Fails(x, c) → (RetakeNext(x, c) ∨ Approval(x, c))))"
},
{
"input": "Translate into first-order logic: If a student delays retaking a failed core course without approval, they are ineligible for graduation.",
"output": "∀x (∀c (CoreCourse(c) ∧ DelaysRetake(x, c) ∧ ¬Approval(x, c) → ¬Graduate(x)))"
},
{
"input": "Translate into first-order logic: Nam has completed 138 credits and passed Data Structures but not Discrete Mathematics.",
"output": "Credits(Nam, 138) ∧ Passes(Nam, DataStructures) ∧ ¬Passes(Nam, DiscreteMath)"
},
{
"input": "Translate into first-order logic: Nam earns 15 credits per semester and has a GPA of 3.2.",
"output": "CreditsPerSemester(Nam, 15) ∧ GPA(Nam, 3.2)"
},
{
"input": "Translate into first-order logic: Nam failed Operating Systems, a core course, and has not retaken it yet.",
"output": "CoreCourse(OperatingSystems) ∧ Fails(Nam, OperatingSystems) ∧ ¬Retake(Nam, OperatingSystems)"
},
{
"input": "Translate into first-order logic: Every subject contains knowledge.",
"output": "∀x (Subject(x) → ContainsKnowledge(x))"
},
{
"input": "Translate into first-order logic: If a student has knowledge of a subject, they can explain it to their friends.",
"output": "∀s (∀x (Knowledge(s, x) → Explain(s, x, Friends)))"
},
{
"input": "Translate into first-order logic: If a student explains a subject to their friends and the friends understand it, the student has mastered the subject.",
"output": "∀s (∀x ((Explain(s, x, Friends) ∧ Understand(Friends, x)) → Mastered(s, x)))"
},
{
"input": "Translate into first-order logic: If a student masters a subject, they can earn an A or A+.",
"output": "∀s (∀x (Mastered(s, x) → (GradeA(s, x) ∨ GradeAPlus(s, x))))"
},
{
"input": "Translate into first-order logic: If a student earns at least five A or A+ grades, they can receive a scholarship.",
"output": "∀s ((Count(GradeA(s, x) ∨ GradeAPlus(s, x), ≥5) → Scholarship(s)))"
},
{
"input": "Translate into first-order logic: Tuấn has earned three A grades.",
"output": "Count(GradeA(Tuan, x), 3)"
},
{
"input": "Translate into first-order logic: Tuấn has not earned any additional A+ grades.",
"output": "Count(GradeAPlus(Tuan, x), 0)"
},
{
"input": "Translate into first-order logic: If a student earns an A in a subject, they must have mastered the subject.",
"output": "∀s (∀x (GradeA(s, x) → Mastered(s, x)))"
},
{
"input": "Translate into first-order logic: If Tuấn's friends do not understand a subject, Tuấn has not mastered it.",
"output": "∀x (¬Understand(Friends, x) → ¬Mastered(Tuan, x))"
},
{
"input": "Translate into first-order logic: If a student cannot explain a subject, they do not have knowledge of it.",
"output": "∀s (∀x (¬Explain(s, x, Friends) → ¬Knowledge(s, x)))"
},
{
"input": "Translate into first-order logic: If a student earns an A in a subject, they must have mastered the subject.",
"output": "∀x (GradeA(x, S) → Mastered(x, S))"
},
{
"input": "Translate into first-order logic: Every student has mastered the subject.",
"output": "∀x (Mastered(x, S))"
},
{
"input": "Translate into first-order logic: There exists at least one student who has earned an A+.",
"output": "∃x (GradeAPlus(x, S))"
},
{
"input": "Translate into first-order logic: Every student can explain the subject to their friends.",
"output": "∀x (Explain(x, S, Friends))"
},
{
"input": "Translate into first-order logic: Every student has knowledge of the subject.",
"output": "∀x (Knowledge(x, S))"
},
{
"input": "Translate into first-order logic: If a student earns an A in a subject, then there exists at least one student who has earned an A+.",
"output": "∀x (GradeA(x, S) → ∃y (GradeAPlus(y, S)))"
},
{
"input": "Translate into first-order logic: If a student wants to understand the lesson, they must pay attention to the teacher's lecture.",
"output": "∀x (WantUnderstand(x) → PayAttention(x))"
},
{
"input": "Translate into first-order logic: If a student does not follow the school's rules, they are not considered exemplary.",
"output": "∀x (¬FollowRules(x) → ¬Exemplary(x))"
},
{
"input": "Translate into first-order logic: Every student must do extra exercises at home.",
"output": "∀x (ExtraExercises(x))"
},
{
"input": "Translate into first-order logic: There exists at least one student who wants to understand the lesson.",
"output": "∃x (WantUnderstand(x))"
},
{
"input": "Translate into first-order logic: If a student wants to understand the lesson, then there exists at least one student who does extra exercises at home.",
"output": "∀x (WantUnderstand(x) → ∃y (ExtraExercises(y)))"
},
{
"input": "Translate into first-order logic: If a student follows the school's rules, they are considered exemplary.",
"output": "∀x (FollowRules(x) → Exemplary(x))"
},
{
"input": "Translate into first-order logic: If a student wants to understand the lesson, they are considered exemplary.",
"output": "∀x (WantUnderstand(x) → Exemplary(x))"
},
{
"input": "Translate into first-order logic: If a student does not pass the Algorithms course, then they also do not meet the requirements for the Software Engineering course.",
"output": "∀x (¬PassAlgorithms(x) → ¬MeetsSE(x))"
},
{
"input": "Translate into first-order logic: All students are enrolled in the Data Structures course.",
"output": "∀x (EnrolledDataStructures(x))"
},
{
"input": "Translate into first-order logic: All students have completed the Programming Fundamentals module.",
"output": "∀x (CompletedProgFundamentals(x))"
},
{
"input": "Translate into first-order logic: All students meet the requirements for the Software Engineering course.",
"output": "∀x (MeetsSE(x))"
},
{
"input": "Translate into first-order logic: If a student does not complete the Capstone Project, then they do not meet the requirements for Software Engineering.",
"output": "∀x (¬CompleteCapstone(x) → ¬MeetsSE(x))"
},
{
"input": "Translate into first-order logic: If a student does not complete the Capstone Project, then they do not fulfill the graduation requirement.",
"output": "∀x (¬CompleteCapstone(x) → ¬Graduate(x))"
},
{
"input": "Translate into first-order logic: If an AI system is transparent, then it can be audited.",
"output": "∀x (Transparent(x) → Auditable(x))"
},
{
"input": "Translate into first-order logic: If an AI system is not fair, then it is not trustworthy.",
"output": "∀x (¬Fair(x) → ¬Trustworthy(x))"
},
{
"input": "Translate into first-order logic: All AI systems in this study are fair.",
"output": "∀x (Fair(x))"
},
{
"input": "Translate into first-order logic: All AI systems in this study are transparent.",
"output": "∀x (Transparent(x))"
},
{
"input": "Translate into first-order logic: If an AI system is fair, then it is trustworthy.",
"output": "∀x (Fair(x) → Trustworthy(x))"
},
{
"input": "Translate into first-order logic: If fairness leads to trustworthiness, then all AI systems must be transparent.",
"output": "∀x (Fair(x) → Trustworthy(x)) → ∀x (Transparent(x))"
},
{
"input": "Translate into first-order logic: If fairness leads to trustworthiness, then transparency implies auditability.",
"output": "∀x (Fair(x) → Trustworthy(x)) → ∀x (Transparent(x) → Auditable(x))"
},
{
"input": "Translate into first-order logic: All AI systems comply with ethical regulations.",
"output": "∀x (Ethical(x))"
},
{
"input": "Translate into first-order logic: If a student attends the Programming Fundamentals course, then they will be ready for the Advanced Programming course.",
"output": "∀x (AttendProgFund(x) → ReadyAdvProg(x))"
},
{
"input": "Translate into first-order logic: All students are required to attend the Advanced Programming course.",
"output": "∀x (AttendAdvProg(x))"
},
{
"input": "Translate into first-order logic: All students have completed the Programming Fundamentals course.",
"output": "∀x (PassProgFund(x))"
},
{
"input": "Translate into first-order logic: If attending the Programming Fundamentals course leads to being ready for the Advanced Programming course, then all students must attend the Programming Fundamentals course.",
"output": "∀x (AttendProgFund(x) → ReadyAdvProg(x)) → ∀x (AttendProgFund(x))"
},
{
"input": "Translate into first-order logic: All students have passed the Mathematics for Computer Science course.",
"output": "∀x (PassMathCS(x))"
},
{
"input": "Translate into first-order logic: All students must comply with the institutional standards.",
"output": "∀x (MeetsStandard(x))"
},
{
"input": "Translate into first-order logic: If a student attends a specific course, they will be required to complete an assignment.",
"output": "∀x (AttendCourse(x) → Assignment(x))"
},
{
"input": "Translate into first-order logic: If a student completes the assignment, they will receive a passing grade.",
"output": "∀x (Assignment(x) → PassGrade(x))"
},
{
"input": "Translate into first-order logic: If a student has participated in the assessment process, they will have successfully completed the assignment.",
"output": "∀x (AssessmentProcess(x) → Assignment(x))"
},
{
"input": "Translate into first-order logic: All students have completed the assessment process.",
"output": "∀x (AssessmentProcess(x))"
},
{
"input": "Translate into first-order logic: If students receive low grades, it may indicate insufficient effort, decreasing motivation, frustration, and anxiety, or they might seek additional support.",
"output": "∀x (L(x) → ((E(x) ∧ M(x) ∧ F(x) ∧ A(x)) ∨ S(x)))"
},
{
"input": "Translate into first-order logic: If students reflect on their low grades, they will take proactive steps to improve.",
"output": "∀x (R(x) → P(x))"
},
{
"input": "Translate into first-order logic: If students take proactive steps to improve, they will increase their study hours and focus more on their weaknesses.",
"output": "∀x (P(x) → (H(x) ∧ W(x)))"
},
{
"input": "Translate into first-order logic: If students don't take proactive steps to improve, they won't increase their study hours and focus more on their weaknesses.",
"output": "∀x (¬P(x) → (¬H(x) ∧ ¬W(x)))"
},
{
"input": "Translate into first-order logic: If a student spends time learning, then they will grow.",
"output": "∀x (S(x) ∧ L(x) → G(x))"
},
{
"input": "Translate into first-order logic: If a person is not teaching, then they cannot learn.",
"output": "∀x (¬T(x) → ¬L(x))"
},
{
"input": "Translate into first-order logic: Everyone is a student.",
"output": "∀x S(x)"
},
{
"input": "Translate into first-order logic: There exists a teacher.",
"output": "∃x T(x)"
},
{
"input": "Translate into first-order logic: If a person is not a student, then they cannot teach.",
"output": "∀x (¬S(x) → ¬T(x))"
},
{
"input": "Translate into first-order logic: If not teaching leads to not learning, then there exists someone who is learning.",
"output": "∀x (¬T(x) → ¬L(x)) → ∃x L(x)"
},
{
"input": "Translate into first-order logic: If everyone is a student, then having knowledge leads to receiving education.",
"output": "∀x S(x) → ∀x (K(x) → E(x))"
},
{
"input": "Translate into first-order logic: There exists someone who has graduated.",
"output": "∃x D(x)"
},
{
"input": "Translate into first-order logic: If a person has graduated, then they have knowledge.",
"output": "∀x (D(x) → K(x))"
},
{
"input": "Translate into first-order logic: Learning leads to the development of critical thinking and problem-solving skills.",
"output": "∀x (L(x) → (C(x) ∧ P(x)))"
},
{
"input": "Translate into first-order logic: If a person is a student, then they must attend classes regularly.",
"output": "∀x (S(x) → A(x))"
},
{
"input": "Translate into first-order logic: If a person is not a student, then they cannot attend classes.",
"output": "∀x (¬S(x) → ¬A(x))"
},
{
"input": "Translate into first-order logic: John is a student.",
"output": "S(John)"
},
{
"input": "Translate into first-order logic: John attends classes regularly.",
"output": "A(John)"
},
{
"input": "Translate into first-order logic: Sarah is not a student.",
"output": "¬S(Sarah)"
},
{
"input": "Translate into first-order logic: If a student attends classes regularly, they will gain knowledge.",
"output": "∀x (S(x) ∧ A(x) → K(x))"
},
{
"input": "Translate into first-order logic: Knowledge gained in class can lead to a better future.",
"output": "∀x (K(x) → F(x))"
},
{
"input": "Translate into first-order logic: There is a limit to the number of students who can attend each class.",
"output": "∀c ∃n (MaxStudents(c, n))"
},
{
"input": "Translate into first-order logic: Students who miss more than 3 classes per semester will be penalized.",
"output": "∀x (S(x,missedclass) ∧ M(x,missedclass) ∧ missedclass > 3 → P(x))"
},
{
"input": "Translate into first-order logic: John has missed no classes this semester.",
"output": "M(John, missedclass) ∧ (missedclass = 0)"
},
{
"input": "Translate into first-order logic: If you are a student of the school and have a valid library card, you can borrow books.",
"output": "∀x ((S(x) ∧ V(x)) → B(x))"
},
{
"input": "Translate into first-order logic: If you return books overdue, you will be fined.",
"output": "∀x (O(x) → F(x))"
},
{
"input": "Translate into first-order logic: If you are fined, you cannot borrow books.",
"output": "∀x (F(x) → ¬B(x))"
},
{
"input": "Translate into first-order logic: An is a student of the school.",
"output": "S(An)"
},
{
"input": "Translate into first-order logic: An has a valid library card.",
"output": "V(An)"
},
{
"input": "Translate into first-order logic: An returned books overdue.",
"output": "O(An)"
},
{
"input": "Translate into first-order logic: All students attend lectures.",
"output": "∀x (Student(x) → AttendsLectures(x))"
},
{
"input": "Translate into first-order logic: If a student attends lectures, they participate in group discussions.",
"output": "∀x (Student(x) ∧ AttendsLectures(x) → ParticipatesInGroupDiscussions(x))"
},
{
"input": "Translate into first-order logic: All students attend lectures.",
"output": "∀x (Student(x) → AttendsLectures(x))"
},
{
"input": "Translate into first-order logic: If a student attends lectures, they participate in group discussions.",
"output": "∀x (Student(x) ∧ AttendsLectures(x) → ParticipatesInGroupDiscussions(x))"
},
{
"input": "Translate into first-order logic: If a student wants to understand the lesson, they pay attention to the lecture.",
"output": "∀x (Student(x) ∧ WantsToUnderstand(x) → PaysAttention(x))"
},
{
"input": "Translate into first-order logic: If a student wants to understand the lesson, they do extra exercises at home.",
"output": "∀x (Student(x) ∧ WantsToUnderstand(x) → DoesExtraExercises(x))"
},
{
"input": "Translate into first-order logic: If some student does extra exercises at home, then some student pays attention to the lecture.",
"output": "∃x (Student(x) ∧ DoesExtraExercises(x)) → ∃x (Student(x) ∧ PaysAttention(x))"
},
{
"input": "Translate into first-order logic: If a student participates in a class, they will register for it.",
"output": "∀x (P(x) → R(x))"
},
{
"input": "Translate into first-order logic: Every student is enrolled in at least one course.",
"output": "∀x E(x)"
},
{
"input": "Translate into first-order logic: If a student is not enrolled in a course, they are not participating in it.",
"output": "∀x (¬E(x) → ¬P(x))"
},
{
"input": "Translate into first-order logic: There exists at least one student who participates in a course.",
"output": "∃x P(x)"
},
{
"input": "Translate into first-order logic: If a student is enrolled in a course, they must complete the assignments.",
"output": "∀x (E(x) → A(x))"
},
{
"input": "Translate into first-order logic: If every student participates in a course, then if a student is enrolled, they must complete the assignments.",
"output": "∀x P(x) → ∀x (E(x) → A(x))"
},
{
"input": "Translate into first-order logic: If it is true that every student participates in a course and if a student is enrolled, they must complete the assignments, then every student participates in a course.",
"output": "(∀x P(x) ∧ ∀x (E(x) → A(x))) → ∀x P(x)"
},
{
"input": "Translate into first-order logic: If a student is enrolled in a course, they must attend the class.",
"output": "∀x (E(x) → T(x))"
},
{
"input": "Translate into first-order logic: Every student is required to attend the class in the course they are enrolled in.",
"output": "∀x (E(x) → T(x))"
},
{
"input": "Translate into first-order logic: If a teacher uses various instructional methods, they address diverse student learning needs.",
"output": "∀x (Teacher(x) ∧ UsesInstructionalMethods(x) → AddressesDiverseLearningNeeds(x))"
},
{
"input": "Translate into first-order logic: If a teacher manages their classroom well, they promote a respectful learning environment.",
"output": "∀x (Teacher(x) ∧ ManagesClassroom(x) → PromotesLearningEnvironment(x))"
},
{
"input": "Translate into first-order logic: If a teacher uses instructional methods and manages their classroom, they understand pedagogical principles.",
"output": "∀x (Teacher(x) ∧ UsesInstructionalMethods(x) ∧ ManagesClassroom(x) → UnderstandsPedagogicalPrinciples(x))"
},
{
"input": "Translate into first-order logic: There exists at least one student who participated in the online training session.",
"output": "∃x A(x)"
},
{
"input": "Translate into first-order logic: There exists at least one student who signed the academic integrity agreement.",
"output": "∃x S(x)"
},
{
"input": "Translate into first-order logic: If a student did not submit the final report, then they did not receive course recognition.",
"output": "∀x (¬F(x) → ¬R(x))"
},
{
"input": "Translate into first-order logic: If a student attended the training session, then they submitted the final report.",
"output": "∀x (A(x) → F(x))"
},
{
"input": "Translate into first-order logic: If a student did not attend the training session, then they did not submit the final report.",
"output": "∀x (¬A(x) → ¬F(x))"
},
{
"input": "Translate into first-order logic: If students who did not attend the training session also failed to submit the final report, then they did not receive course recognition.",
"output": "∀x ((¬A(x) ∧ ¬F(x)) → ¬R(x))"
},
{
"input": "Translate into first-order logic: If not attending the training session leads to not submitting the final report, then some students must have signed the academic integrity agreement.",
"output": "∀x (¬A(x) → ¬F(x)) → ∃x S(x)"
},
{
"input": "Translate into first-order logic: If a student did not attend the training session, then they did not submit the final project either.",
"output": "∀x (¬A(x) → ¬P(x))"
},
{
"input": "Translate into first-order logic: If a student did not sign the academic integrity agreement, then they did not receive course recognition.",
"output": "∀x (¬S(x) → ¬R(x))"
},
{
"input": "Translate into first-order logic: If a student hasn’t submitted their final project, they don’t meet the Research Skills requirement.",
"output": "∀x (Student(x) ∧ ¬SubmittedFinalProject(x) → ¬MeetsResearchSkills(x))"
},
{
"input": "Translate into first-order logic: If a student meets the Research Skills requirement, they’ve presented in a research seminar.",
"output": "∀x (Student(x) ∧ MeetsResearchSkills(x) → PresentedInSeminar(x))"
},
{
"input": "Translate into first-order logic: There exists at least one student who has passed the prerequisite course in programming.",
"output": "∃x P(x)"
},
{
"input": "Translate into first-order logic: If a student does not meet the minimum grade requirement, they are not allowed to proceed to advanced courses.",
"output": "∀x (¬G(x) → ¬A(x))"
},
{
"input": "Translate into first-order logic: All students are required to complete the foundational courses before proceeding to specialized courses.",
"output": "∀x (S(x) → F(x))"
},
{
"input": "Translate into first-order logic: If a student has not passed the core course, they cannot proceed with the elective courses.",
"output": "∀x (¬C(x) → ¬E(x))"
},
{
"input": "Translate into first-order logic: If a student has not completed the prerequisite course, they are not allowed to enroll in any advanced courses.",
"output": "∀x (¬Q(x) → ¬A(x))"
},
{
"input": "Translate into first-order logic: If a student has passed the prerequisite course, they are allowed to proceed to specialized courses.",
"output": "∀x (P(x) → S(x))"
},
{
"input": "Translate into first-order logic: If a student has completed the foundational courses, then they must have met the prerequisites for elective courses.",
"output": "∀x (F(x) → E(x))"
},
{
"input": "Translate into first-order logic: If a student has failed to meet the required standards, they cannot participate in the final project preparation.",
"output": "∀x (¬R(x) → ¬J(x))"
},
{
"input": "Translate into first-order logic: There exists at least one student who is eligible to participate in the final project preparation.",
"output": "∃x J(x)"
},
{
"input": "Translate into first-order logic: If a student has passed the prerequisite course, then they are eligible to enroll in the next course.",
"output": "∀x (PassedPrerequisite(x) → EligibleToEnroll(x))"
},
{
"input": "Translate into first-order logic: There exists at least one student who is eligible to enroll in the next course.",
"output": "∃x EligibleToEnroll(x)"
},
{
"input": "Translate into first-order logic: All students must complete the required introductory courses.",
"output": "∀x CompletedIntroCourses(x)"
},
{
"input": "Translate into first-order logic: A student is eligible to enroll in the next course only if they have passed the prerequisite course.",
"output": "∀x (EligibleToEnroll(x) → PassedPrerequisite(x))"
},
{
"input": "Translate into first-order logic: For courses with lab components, a student is allowed to take the exam if their lab score is at least 4.0 out of 10 and all their component scores are greater than 0.",
"output": "∀s (∀c (AllowedToTakeExam(s, c) ↔ (ComponentScore(s, c, Lab, labscore) ∧ labscore ≥ 4.0 ∧ ∀i (ComponentScore(s, c, i, componentscore) ∧ componentscore > 0))))"
},
{
"input": "Translate into first-order logic: Kelvin’s lab score for CH3002 is at least 4.0 out of 10, and all his component scores for CH3002 are positive.",
"output": "ComponentScore(Kelvin, CH3002, Lab, componentscore) ∧ componentscore ≥ 4.0"
},
{
"input": "Translate into first-order logic: Students enrolled in multiple courses must submit a project unless the course is taught by Professor X.",
"output": "∀i (ComponentScore(Kelvin, CH3002, i, componentscore) ∧ componentscore > 0)"
},
{
"input": "Translate into first-order logic: CH3002 has three components: Lab, Quiz, and Homework, but Quiz scores are optional for students over 20 years old.",
"output": "∀s (∀c (Enrolled(s, c) ∧ ¬TaughtBy(c, ProfessorX) → MustSubmitProject(s, c)))"
},
{
"input": "Translate into first-order logic: Kelvin is 19 years old and has a Homework score of 7.0 in CH3001, which is unrelated to CH3002.",
"output": "Components(CH3002, {Lab, Quiz, Homework})"
},
{
"input": "Translate into first-order logic: Professor Y teaches CH3002, and all courses taught by Professor Y have an extra credit option.",
"output": "∀s (∀c (Age(s, age) ∧ age > 20 → ¬Required(ComponentScore(s, c, Quiz))))"
},
{
"input": "Translate into first-order logic: Extra credit can increase a student’s total score by up to 2 points, but it doesn’t affect component scores.",
"output": "Age(Kelvin, age) ∧ age = 19"
},
{
"input": "Translate into first-order logic: Another student, Liam, has a Lab score of 3.5 in CH3002 and is not allowed to take the exam.",
"output": "ComponentScore(Kelvin, CH3001, Homework, componentscore) ∧ componentscore = 7.0"
},
{
"input": "Translate into first-order logic: Courses with more than 50 students require a midterm, but CH3002 has only 45 students.",
"output": "¬Equal(CH3001, CH3002)"
},
{
"input": "Translate into first-order logic: Kelvin submitted his CH3002 lab report on time, which is required for lab scores to be valid.",
"output": "TaughtBy(CH3002, ProfessorY)"
},
{
"input": "Translate into first-order logic: Late submissions reduce a lab score by 1.0, unless the student has a medical excuse.",
"output": "∀c (TaughtBy(c, ProfessorY) → HasExtraCredit(c))"
},
{
"input": "Translate into first-order logic: Liam has a medical excuse for CH3001 but not for CH3002.",
"output": "∀s (∀c (HasExtraCredit(c) → TotalScoreIncrease(s, c, totalscoreincrease) ∧ totalscoreincrease ≤ 2.0 ∧ ¬AffectsComponentScores(s, c)))"
},
{
"input": "Translate into first-order logic: CH3002’s final exam is scheduled for December 15th, and all eligible students must attend.",
"output": "ComponentScore(Liam, CH3002, Lab, componentscore) ∧ componentscore = 3.5"
},
{
"input": "Translate into first-order logic: Students are allowed to enter the laboratory to conduct experiments only if they have both health insurance and accident insurance.",
"output": "∀s (AllowedToEnterLab(s) ↔ (HasHealthInsurance(s) ∧ HasAccidentInsurance(s)))"
},
{
"input": "Translate into first-order logic: Lan has both health insurance and accident insurance.",
"output": "HasHealthInsurance(Lan)"
},
{
"input": "Translate into first-order logic: The laboratory is open from 9 AM to 5 PM on weekdays, unless there’s a special event.",
"output": "HasAccidentInsurance(Lan)"
},
{
"input": "Translate into first-order logic: Students must wear safety goggles in the lab, but this rule is waived for virtual labs.",
"output": "∀s ((LabOpen(Weekdays, 9AM_5PM) ∧ ¬SpecialEvent) → CanAccessLab(s))"
},
{
"input": "Translate into first-order logic: Lan is enrolled in Chemistry 101, which requires lab access on Tuesdays.",
"output": "∀s (InLab(s) ∧ ¬VirtualLab → MustWearGoggles(s))"
},
{
"input": "Translate into first-order logic: Another student, Kai, has health insurance but no accident insurance.",
"output": "Enrolled(Lan, Chemistry101)"
},
{
"input": "Translate into first-order logic: Lab equipment must be reserved 24 hours in advance for groups larger than three.",
"output": "RequiresLabAccess(Chemistry101, Tuesdays)"
},
{
"input": "Translate into first-order logic: Lan is working alone and doesn’t need to reserve equipment.",
"output": "HasHealthInsurance(Kai)"
},
{
"input": "Translate into first-order logic: All students must complete a safety training course, though Lan completed hers last semester.",
"output": "¬HasAccidentInsurance(Kai)"
},
{
"input": "Translate into first-order logic: The lab supervisor, Dr. Zee, allows extra hours for students with a GPA above 3.5.",
"output": "∀s (GroupSize(s, groupsize) ∧ groupsize > 3 → MustReserveEquipment(s, 24Hours))"
},
{
"input": "Translate into first-order logic: Lan’s GPA is 3.8, but she only works during regular hours.",
"output": "GroupSize(Lan, groupsize) ∧ groupsize = 1"
},
{
"input": "Translate into first-order logic: Kai was denied lab access last week due to incomplete paperwork.",
"output": "CompletedSafetyTraining(Lan)"
},
{
"input": "Translate into first-order logic: Chemistry 101 experiments require a minimum temperature of 20°C in the lab.",
"output": "∀s ((GPA(s, gpa) ∧ gpa > 3.5 ∧ Approved(DrZee, s)) → ExtraLabHours(s))"
},
{
"input": "Translate into first-order logic: Full-time students must take at least 14 credits per semester, but in special cases (e.g., weak academic performance or health issues), they can take a minimum of 11 credits for up to 2 semesters.",
"output": "∀s (FullTimeStudent(s) → (Credits(s, credits) ∧ credits ≥ 14 ∨ (SpecialCase(s) ∧ Credits(s, credits) ∧ credits ≥ 11)))"
},
{
"input": "Translate into first-order logic: Part-time (work-study) students must take at least 11 credits per semester, but in special cases (e.g., weak academic performance, health issues, or work reasons), they can take a minimum of 9 credits for up to 3 semesters.",
"output": "∀s (PartTimeStudent(s) → (Credits(s) ≥ 11 ∨ (SpecialCase(s) ∧ Credits(s) ≥ 9)))"
},
{
"input": "Translate into first-order logic: Linh is a full-time student with health issues, taking 12 credits this semester.",
"output": "FullTimeStudent(Linh) ∧ SpecialCase(Linh) ∧ Credits(Linh) = 12"
},
{
"input": "Translate into first-order logic: This is Linh’s first semester using the special case exception.",
"output": "SemesterCountSpecialCase(Linh) = 1"
},
{
"input": "Translate into first-order logic: Part-time students must submit a work schedule to the registrar each semester.",
"output": "∀s (PartTimeStudent(s) → MustSubmitWorkSchedule(s))"
},
{
"input": "Translate into first-order logic: Full-time students taking fewer than 14 credits must meet with an advisor annually.",
"output": "∀s (FullTimeStudent(s) ∧ Credits(s) < 14 → MustMeetAdvisor(s))"
},
{
"input": "Translate into first-order logic: Linh is enrolled in a 4-credit lab course and two 4-credit lecture courses.",
"output": "Enrolled(Linh, LabCourse) ∧ Credits(LabCourse) = 4"
},
{
"input": "Translate into first-order logic: Another student, Minh, is a part-time student taking 10 credits due to work reasons.",
"output": "Enrolled(Linh, LectureCourse1) ∧ Credits(LectureCourse1) = 4"
},
{
"input": "Translate into first-order logic: Courses worth more than 3 credits require attendance at 80% of classes.",
"output": "Enrolled(Linh, LectureCourse2) ∧ Credits(LectureCourse2) = 4"
},
{
"input": "Translate into first-order logic: The university offers a tuition discount for students taking exactly 12 credits.",
"output": "PartTimeStudent(Minh) ∧ SpecialCase(Minh) ∧ Credits(Minh) = 10"
},
{
"input": "Translate into first-order logic: Linh has not exceeded the 2-semester limit for special cases.",
"output": "∀c (Credits(c, credits) ∧ credits > 3 → AttendanceRequired(c, 80%))"
},
{
"input": "Translate into first-order logic: Minh’s employer requires him to work 20 hours per week.",
"output": "∀s (Credits(s, credits) ∧ credits = 12 → EligibleForDiscount(s))"
},
{
"input": "Translate into first-order logic: Full-time students must declare a major by their third semester, and Linh is in her second.",
"output": "SemesterCountSpecialCase(Linh, semestercount) ∧ semestercount ≤ 2"
},
{
"input": "Translate into first-order logic: The training program has a total of 120 credits.",
"output": "TotalCredits(TrainingProgram, totalcredits) ∧ totalcredits = 120"
},
{
"input": "Translate into first-order logic: Ha has accumulated 80 credits in the training program.",
"output": "AccumulatedCredits(Ha, accumulatedcredits) ∧ accumulatedcredits = 80"
},
{
"input": "Translate into first-order logic: Students must submit an internship application by June 1st to be considered.",
"output": "∀s (EligibleForInternship(s) → SubmittedApplication(s, Before(June1)))"
},
{
"input": "Translate into first-order logic: Ha submitted her application on May 15th.",
"output": "SubmittedApplication(Ha, May15)"
},
{
"input": "Translate into first-order logic: The training program includes 30 credits of elective courses, but only 20 credits are counted toward the internship requirement.",
"output": "ElectiveCredits(TrainingProgram, effectivecredits) ∧ effectivecredits = 30"
},
{
"input": "Translate into first-order logic: Another student, Vinh, has accumulated 75 credits and is also in the training program.",
"output": "CountedElectiveCredits(TrainingProgram, Internship, countedelectivecredits) ∧ countedelectivecredits = 20"
},
{
"input": "Translate into first-order logic: Students with a GPA below 2.5 are required to take a remedial course before interning.",
"output": "AccumulatedCredits(Vinh, accumulatedcredits) ∧ accumulatedcredits = 75"
},
{
"input": "Translate into first-order logic: Ha’s GPA is 3.2, and she has no remedial requirements.",
"output": "Program(Vinh) = TrainingProgram"
},
{
"input": "Translate into first-order logic: Internships are offered in two cycles: summer and fall, with summer priority for seniors.",
"output": "∀s (GPA(s, gpa) ∧ gpa < 2.5 → RequiresRemedialCourse(s))"
},
{
"input": "Translate into first-order logic: Ha is a junior and applying for a fall internship.",
"output": "GPA(Ha, gpa) ∧ gpa = 3.2"
},
{
"input": "Translate into first-order logic: The program advisor must approve all internship applications, and Hà’s was approved.",
"output": "¬RequiresRemedialCourse(Hà)"
},
{
"input": "Translate into first-order logic: Vinh missed the application deadline and accumulated only 10 elective credits.",
"output": "InternshipCycles = {Summer, Fall}"
},
{
"input": "Translate into first-order logic: Students are ranked based on their average semester scores as follows: Excellent (3.6 to 4.0), Good (3.2 to 3.6), Fair (2.5 to 3.2), Average (2.0 to 2.5), Weak (1.0 to 2.0), Poor (below 1.0).",
"output": "∀s ((AverageScore(s, averagescore) ∧ averagescore ≥ 3.6 ∧ AverageScore(s, averagescore) ∧ averagescore ≤ 4.0) → Ranking(s, Excellent))"
},
{
"input": "Translate into first-order logic: Phong has an average semester score of 2.3.",
"output": "∀s ((AverageScore(s, averagescore) ∧ averagescore ≥ 3.2 ∧ AverageScore(s, averagescore) ∧ averagescore < 3.6) → Ranking(s, Good))"
},
{
"input": "Translate into first-order logic: Students with an Excellent ranking receive a scholarship of $500 per semester.",
"output": "∀s ((AverageScore(s, averagescore) ∧ averagescore ≥ 2.5 ∧ AverageScore(s, averagescore) ∧ averagescore < 3.2) → Ranking(s, Fair))"
},
{
"input": "Translate into first-order logic: Phong is in his third semester and has taken 15 credits this term.",
"output": "∀s ((AverageScore(s, averagescore) ∧ averagescore ≥ 2.0 ∧ AverageScore(s,averagescore) ∧ averagescore < 2.5) → Ranking(s, Average))"
},
{
"input": "Translate into first-order logic: Another student, Hoa, has an average score of 3.7 and is ranked Excellent.",
"output": "∀s ((AverageScore(s, averagescore) ∧ averagescore ≥ 1.0 ∧ AverageScore(s, averagescore) ∧ averagescore < 2.0) → Ranking(s, Weak))"
},
{
"input": "Translate into first-order logic: Scores are calculated based on a weighted average of exams (60%) and projects (40%).",
"output": "∀s (AverageScore(s, averagescore) ∧ averagescore < 1.0 → Ranking(s, Poor))"
},
{
"input": "Translate into first-order logic: Phong scored 2.5 on exams and 2.0 on projects this semester.",
"output": "AverageScore(Phong, averagescore) ∧ averagescore = 2.3"
},
{
"input": "Translate into first-order logic: Students ranked below Fair must attend a study skills workshop.",
"output": "∀s (Ranking(s, Excellent) → Scholarship(s, 500))"
},
{
"input": "Translate into first-order logic: The maximum score per course is 4.0, and Phong is enrolled in four courses.",
"output": "Semester(Phong, semester) ∧ semester = 3 ∧ Credits(Phong, credits)  ∧ credits = 15"
},
{
"input": "Translate into first-order logic: Hoa has a part-time job and still maintains her ranking.",
"output": "AverageScore(Hoa, averagescore) ∧ averagescore = 3.7 ∧ Ranking(Hoa, Excellent)"
},
{
"input": "Translate into first-order logic: Phong submitted his final project on time, avoiding a 0.5-point penalty.",
"output": "ExamScore(Phong, examscore) ∧ examscore = 2.5 ∧ ProjectScore(Phong, projectscore) ∧ projectscore = 2.0"
},
{
"input": "Translate into first-order logic: Students are ranked into academic years based on their accumulated credits (N) compared to the average credits per year (M). For the second year, M ≤ N < 2M and they must meet the foreign language standard for year two.",
"output": "∀s (SecondYear(s) ↔ ((M ≤ AccumulatedCredits(s) < 2M) ∧ MeetsLanguageStandard(s, YearTwo)))"
},
{
"input": "Translate into first-order logic: The average credits per year (M) for regular students is 33.",
"output": "M = 33"
},
{
"input": "Translate into first-order logic: Tâm has accumulated 40 credits and has met the foreign language standard for year two.",
"output": "AccumulatedCredits(Tâm, accumulatedcredits) ∧ accumulatedcredits = 40 ∧ MeetsLanguageStandard(Tâm, YearTwo)"
},
{
"input": "Translate into first-order logic: Students in accelerated programs have an average credits per year (M) of 40.",
"output": "M_accelerated = 40"
},
{
"input": "Translate into first-order logic: Tâm is enrolled in the regular program, not the accelerated one.",
"output": "Program(Tâm, Regular) ∧ ¬Program(Tâm, Accelerated)"
},
{
"input": "Translate into first-order logic: Another student, Nam, has 70 credits but hasn’t met the language standard for year two.",
"output": "AccumulatedCredits(Nam, accumulatedcredits) ∧ accumulatedcredits = 70 ∧ ¬MeetsLanguageStandard(Nam, YearTwo)"
},
{
"input": "Translate into first-order logic: The foreign language standard for year two requires a TOEFL score of at least 500.",
"output": "∀s (MeetsLanguageStandard(s, YearTwo) ↔ TOEFLScore(s) ≥ 500)"
},
{
"input": "Translate into first-order logic: Tâm’s TOEFL score is 550, and she submitted it before the October 1st deadline.",
"output": "TOEFLScore(Tâm, toeflscore) ∧ toeflscore = 550 ∧ SubmittedBefore(Tâm, October1)"
},
{
"input": "Translate into first-order logic: Students must complete at least 10 credits of core courses each year, and Tâm has 15 this year.",
"output": "∀s (CoreCredits(s, CurrentYear, corecredits) ∧ corecredits ≥ 10)"
},
{
"input": "Translate into first-order logic: Nam is in his third semester and has a GPA of 3.0.",
"output": "CoreCredits(Tâm, CurrentYear, corecredits) ∧ corecredits = 15"
},
{
"input": "Translate into first-order logic: Second-year students are eligible for a mentorship program if they apply by November 15th.",
"output": "Semester(Nam, semester) ∧ semester = 3 ∧ GPA(Nam, gpa) ∧ gpa = 3.0"
},
{
"input": "Translate into first-order logic: Tâm applied for the mentorship program on November 10th.",
"output": "∀s (SecondYear(s) ∧ AppliedBefore(s, November15) → EligibleMentorship(s))"
},
{
"input": "Translate into first-order logic: The regular program includes a total of 132 credits across four years.",
"output": "AppliedBefore(Tâm, November10)"
},
{
"input": "Translate into first-order logic: Students are ranked into academic years based on their accumulated credits (N) compared to the average credits per year (M). For the third year, 2M ≤ N < 3M and they must meet the foreign language standard for year three.",
"output": "∀s (ThirdYear(s) ↔ ((2M ≤ AccumulatedCredits(s) < 3M) ∧ MeetsLanguageStandard(s, YearThree)))"
},
{
"input": "Translate into first-order logic: The average credits per year (M) for regular students is 33.",
"output": "M = 33"
},
{
"input": "Translate into first-order logic: Phong has accumulated 70 credits and has met the foreign language standard for year three.",
"output": "AccumulatedCredits(Phong, accumulatedcredits) ∧ accumulatedcredits = 70 ∧ MeetsLanguageStandard(Phong, YearThree)"
},
{
"input": "Translate into first-order logic: The foreign language standard for year three requires an IELTS score of at least 6.0.",
"output": "∀s (MeetsLanguageStandard(s, YearThree) ↔ IELTS(s, ielts) ∧ ielts ≥ 6.0)"
},
{
"input": "Translate into first-order logic: Phong’s IELTS score is 6.5, certified last month.",
"output": "IELTS(Phong, ielts) ∧ ielts = 6.5 ∧ Certified(Phong, LastMonth)"
},
{
"input": "Translate into first-order logic: Students in the honors program have an average credits per year (M) of 36.",
"output": "M_honors = 36"
},
{
"input": "Translate into first-order logic: Phong is in the regular program, not the honors program.",
"output": "Program(Phong) = Regular ∧ ¬Program(Phong) = Honors"
},
{
"input": "Translate into first-order logic: Another student, Lan, has 60 credits and meets the language standard for year two but not year three.",
"output": "AccumulatedCredits(Lan) = 60 ∧ MeetsLanguageStandard(Lan, YearTwo) ∧ ¬MeetsLanguageStandard(Lan, YearThree)"
},
{
"input": "Translate into first-order logic: Third-year students must complete a 5-credit capstone project, which Phong has enrolled in.",
"output": "∀s (ThirdYear(s) → Enrolled(s, CapstoneProject) ∧ Credits(CapstoneProject) = 5)"
},
{
"input": "Translate into first-order logic: The regular program requires a total of 132 credits for graduation.",
"output": "Enrolled(Phong, CapstoneProject)"
},
{
"input": "Translate into first-order logic: Phong has a GPA of 3.4 and no academic probation history.",
"output": "TotalCredits(RegularProgram, regularprogram) ∧ regularprogram = 132"
},
{
"input": "Translate into first-order logic: Lan missed the language certification deadline of September 30th.",
"output": "GPA(Phong, gpa) ∧ gpa = 3.4 ∧ ¬OnProbation(Phong)"
},
{
"input": "Translate into first-order logic: Third-year students can apply for study abroad if they meet the foreign language standard for year three.",
"output": "¬CertifiedBefore(Lan, September30)"
},
{
"input": "Translate into first-order logic: If students join in group work, they develop interpersonal skills.",
"output": "∀x (Student(x) ∧ ParticipatesInGroupWork(x) → DevelopsInterpersonalSkills(x))"
},
{
"input": "Translate into first-order logic: If students work in groups, then they can share their perspectives and create creative solutions.",
"output": "∀x (Student(x) ∧ WorksInGroups(x) → SharesPerspectives(x) ∧ CreativeSolutions(x))"
},
{
"input": "Translate into first-order logic: If students work in groups, then they can increase motivation and performance.",
"output": "∀x (Student(x) ∧ GroupWork(x) → IncreasedMotivation(x) ∧ ImprovedPerformance(x))"
},
{
"input": "Translate into first-order logic: If students join group work with unequal contribution, then they can frustrate among members.",
"output": "∀x (Student(x) ∧ GroupWork(x) ∧ UnequalContribution(x) → FrustrationAmongMembers(x))"
},
{
"input": "Translate into first-order logic: If students join in a group work with dominant personality, then they will reduce collaboration effectiveness.",
"output": "∀x (Student(x) ∧ GroupWork(x) ∧ DominantPersonality(x) → ReducedCollaborationEffectiveness(x))"
},
{
"input": "Translate into first-order logic: If students join in a group with promoting critical thinking, then they can improve their problem solving.",
"output": "∀x (Student(x) ∧ GroupWork(x) ∧ PromotesCriticalThinking(x) → ImprovedProblemSolving(x))"
},
{
"input": "Translate into first-order logic: If students struggle with poor group dynamics, then they will be stressed and have lower satisfaction.",
"output": "∀x (Student(x) ∧ GroupWork(x) ∧ PoorGroupDynamics(x) → Stress(x) ∧ LowerSatisfaction(x))"
},
{
"input": "Translate into first-order logic: If students join a good communicative group, then they have successful collaboration.",
"output": "∀x (Student(x) ∧ GroupWork(x) ∧ GoodCommunication(x) → SuccessfulCollaboration(x))"
},
{
"input": "Translate into first-order logic: If a person is a student, then that person is qualified.",
"output": "∀x (S(x) → Q(x))"
},
{
"input": "Translate into first-order logic: If a person is a teacher, then that person is respected.",
"output": "∀x (T(x) → R(x))"
},
{
"input": "Translate into first-order logic: There exists at least one person who is prepared.",
"output": "∃x P(x)"
},
{
"input": "Translate into first-order logic: If a person is respected, then that person is useful.",
"output": "∀x (R(x) → U(x))"
},
{
"input": "Translate into first-order logic: There exists at least one person who is respected.",
"output": "∃x R(x)"
},
{
"input": "Translate into first-order logic: If all students being qualified implies that someone is respected, then that implication holds.",
"output": "(∀x (S(x) → Q(x)) → ∃x R(x))"
},
{
"input": "Translate into first-order logic: If all teachers being respected implies that someone is prepared, then that implication holds.",
"output": "(∀x (T(x) → R(x)) → ∃x P(x))"
},
{
"input": "Translate into first-order logic: If a person is not useful, then that person is not a student.",
"output": "∀x (¬U(x) → ¬S(x))"
},
{
"input": "Translate into first-order logic: If a person is respected, then that person is also prepared.",
"output": "∀x (R(x) → P(x))"
},
{
"input": "Translate into first-order logic: Every student is participating in the training session.",
"output": "∀x T(x)"
},
{
"input": "Translate into first-order logic: If a student attends the seminar, they will be eligible for the certification.",
"output": "∀x (S(x) → Q(x))"
},
{
"input": "Translate into first-order logic: If a student is registered for the course, they attend the seminar.",
"output": "∀x (R(x) → S(x))"
},
{
"input": "Translate into first-order logic: Every student is registered for the course.",
"output": "∀x R(x)"
},
{
"input": "Translate into first-order logic: If a student attends the seminar, they are participating in the training session.",
"output": "∀x (S(x) → T(x))"
},
{
"input": "Translate into first-order logic: If a student does not submit assignments, they did not attend the seminar.",
"output": "∀x (¬P(x) → ¬S(x))"
},
{
"input": "Translate into first-order logic: Every student completes the course successfully.",
"output": "∀x U(x)"
},
{
"input": "Translate into first-order logic: If there exists a student participating in the training session, then all students are participating in the training session.",
"output": "(∃x T(x) → ∀x T(x))"
},
{
"input": "Translate into first-order logic: If a student attends the Software Engineering workshop, then they will be ready for the Capstone Project.",
"output": "∀x (S(x) → R(x))"
},
{
"input": "Translate into first-order logic: There exists at least one student who has passed the course on Computational Thinking.",
"output": "∃x Q(x)"
},
{
"input": "Translate into first-order logic: If a student has completed the User Interface course, then they have also submitted the final project.",
"output": "∀x (U(x) → P(x))"
},
{
"input": "Translate into first-order logic: If a student has submitted the final project, then they have passed the Technical Writing course.",
"output": "∀x (P(x) → T(x))"
},
{
"input": "Translate into first-order logic: If a student is not ready for the Capstone Project, then they have not submitted the final project.",
"output": "∀x (¬R(x) → ¬P(x))"
},
{
"input": "Translate into first-order logic: If submitting the final project leads to passing Technical Writing, then attending the Software Engineering workshop leads to being ready for the Capstone Project.",
"output": "(∀x (P(x) → T(x)) → ∀x (S(x) → R(x)))"
},
{
"input": "Translate into first-order logic: If the above implication holds, then submitting the final project leads to passing Technical Writing.",
"output": "(∀x (P(x) → T(x)) → ∀x (S(x) → R(x)) → ∀x (P(x) → T(x)))"
},
{
"input": "Translate into first-order logic: All students have attended the Software Engineering workshop.",
"output": "∀x S(x)"
},
{
"input": "Translate into first-order logic: There exists at least one student who has submitted the final project.",
"output": "∃x P(x)"
},
{
"input": "Translate into first-order logic: If a student has completed the Data Science course, then they are eligible to apply for the Machine Learning course.",
"output": "∀x (D(x) → M(x))"
},
{
"input": "Translate into first-order logic: There exists at least one student who has completed the Data Structures course.",
"output": "∃x C(x)"
},
{
"input": "Translate into first-order logic: If a student has completed the Algorithms course, then they have also completed the Data Science course.",
"output": "∀x (A(x) → D(x))"
},
{
"input": "Translate into first-order logic: If a student has completed the Data Science course, then they have passed the exam on Data Analytics.",
"output": "∀x (D(x) → E(x))"
},
{
"input": "Translate into first-order logic: If a student is not eligible to apply for the Machine Learning course, then they have not completed the Data Science course.",
"output": "∀x (¬M(x) → ¬D(x))"
},
{
"input": "Translate into first-order logic: If completing the Data Science course leads to passing the Data Analytics exam, then completing the Data Science course makes the student eligible to apply for the Machine Learning course.",
"output": "(∀x (D(x) → E(x)) → ∀x (D(x) → M(x)))"
},
{
"input": "Translate into first-order logic: If the above implication holds, then completing the Data Science course leads to passing the Data Analytics exam.",
"output": "(∀x (D(x) → E(x)) → ∀x (D(x) → M(x)) → ∀x (D(x) → E(x)))"
},
{
"input": "Translate into first-order logic: All students have completed the Data Structures course.",
"output": "∀x C(x)"
},
{
"input": "Translate into first-order logic: There exists at least one student who has completed the Data Science course.",
"output": "∃x D(x)"
},
{
"input": "Translate into first-order logic: If a course includes AI ethics, then students understand responsible AI.",
"output": "∀x (E(x) → U(x))"
},
{
"input": "Translate into first-order logic: All students in the AI program study AI ethics.",
"output": "∀x (E(x))"
},
{
"input": "Translate into first-order logic: If students understand responsible AI, then they can build trustworthy systems.",
"output": "∀x (U(x) → T(x))"
},
{
"input": "Translate into first-order logic: All students in the AI program follow the institution’s ethical AI guidelines.",
"output": "∀x (G(x))"
},
{
"input": "Translate into first-order logic: If a student has completed the required prerequisite course, they are eligible to enroll in advanced courses.",
"output": "∀x (R(x) → U(x))"
},
{
"input": "Translate into first-order logic: There exists at least one student who has met the eligibility requirements for advanced courses.",
"output": "∃x U(x)"
},
{
"input": "Translate into first-order logic: If a student has not met the eligibility requirements, they are not allowed to enroll in the elective courses.",
"output": "∀x (¬U(x) → ¬Q(x))"
},
{
"input": "Translate into first-order logic: All students must meet the eligibility requirements to enroll in the advanced courses.",
"output": "∀x U(x)"
},
{
"input": "Translate into first-order logic: If a student has not completed the prerequisite courses, they cannot proceed to the next level of courses.",
"output": "∀x (¬R(x) → ¬S(x))"
},
{
"input": "Translate into first-order logic: If a student does not meet the eligibility criteria for advanced courses, they are not allowed to enroll in the elective courses.",
"output": "(∀x (¬U(x) → ¬Q(x)) → ∃x U(x))"
},
{
"input": "Translate into first-order logic: If completing the prerequisite course implies eligibility for the advanced courses, then at least one student has the required eligibility.",
"output": "(∀x (R(x) → U(x)) → ∃x U(x))"
},
{
"input": "Translate into first-order logic: If a student has completed the foundation course, they are eligible to proceed with the specialization courses.",
"output": "∀x (T(x) → S(x))"
},
{
"input": "Translate into first-order logic: If a student has failed to meet the standards for a course, they are not allowed to participate in the final project preparation.",
"output": "∀x (¬T(x) → ¬S(x))"
},
{
"input": "Translate into first-order logic: All students belong to the university.",
"output": "∀x (BelongsToUniversity(x))"
},
{
"input": "Translate into first-order logic: If a student does not participate in research, then they do not belong to the university.",
"output": "∀x (¬ParticipatesInResearch(x) → ¬BelongsToUniversity(x))"
},
{
"input": "Translate into first-order logic: If a student does not participate in research, then they are not taking the thesis course.",
"output": "∀x (¬ParticipatesInResearch(x) → ¬TakesThesisCourse(x))"
},
{
"input": "Translate into first-order logic: All students are registered.",
"output": "∀x (IsRegistered(x))"
},
{
"input": "Translate into first-order logic: If a student belongs to the university, then they are taking the thesis course.",
"output": "∀x (BelongsToUniversity(x) → TakesThesisCourse(x))"
},
{
"input": "Translate into first-order logic: All students receive a scholarship.",
"output": "∀x (ReceivesScholarship(x))"
},
{
"input": "Translate into first-order logic: All students are taking the thesis course.",
"output": "∀x (TakesThesisCourse(x))"
},
{
"input": "Translate into first-order logic: If a student completes the capstone project, then they gain teamwork skills.",
"output": "∀x (CompletesCapstoneProject(x) → GainsTeamworkSkills(x))"
},
{
"input": "Translate into first-order logic: All students possess problem-solving ability.",
"output": "∀x (HasProblemSolvingAbility(x))"
},
{
"input": "Translate into first-order logic: If a student does not have teamwork skills, then they do not have critical thinking skills.",
"output": "∀x (¬GainsTeamworkSkills(x) → ¬HasCriticalThinkingSkills(x))"
},
{
"input": "Translate into first-order logic: All students have communication skills.",
"output": "∀x (HasCommunicationSkills(x))"
},
{
"input": "Translate into first-order logic: All students have critical thinking skills.",
"output": "∀x (HasCriticalThinkingSkills(x))"
},
{
"input": "Translate into first-order logic: If a student does not complete the capstone project, then they do not possess problem-solving ability.",
"output": "∀x (¬CompletesCapstoneProject(x) → ¬HasProblemSolvingAbility(x))"
},
{
"input": "Translate into first-order logic: If a student has problem-solving ability, then they have teamwork skills.",
"output": "∀x (HasProblemSolvingAbility(x) → GainsTeamworkSkills(x))"
},
{
"input": "Translate into first-order logic: All students complete the final project.",
"output": "∀x (CompletesFinalProject(x))"
},
{
"input": "Translate into first-order logic: If a student has presentation skills, then they receive a certificate.",
"output": "∀x (HasPresentationSkills(x) → ReceivesCertificate(x))"
},
{
"input": "Translate into first-order logic: All students have presentation skills.",
"output": "∀x (HasPresentationSkills(x))"
},
{
"input": "Translate into first-order logic: If a student writes a thesis, then they receive a certificate.",
"output": "∀x (WritesThesis(x) → ReceivesCertificate(x))"
},
{
"input": "Translate into first-order logic: All students have theoretical knowledge.",
"output": "∀x (HasTheoreticalKnowledge(x))"
},
{
"input": "Translate into first-order logic: If a student has theoretical knowledge, then they write a thesis.",
"output": "∀x (HasTheoreticalKnowledge(x) → WritesThesis(x))"
},
{
"input": "Translate into first-order logic: All students receive a certificate.",
"output": "∀x (ReceivesCertificate(x))"
},
{
"input": "Translate into first-order logic: All students pass the course.",
"output": "∀x (PassesCourse(x))"
},
{
"input": "Translate into first-order logic: If a student does not have high attendance, then they do not have good performance.",
"output": "∀x (¬HasHighAttendance(x) → ¬HasGoodPerformance(x))"
},
{
"input": "Translate into first-order logic: If a student does not submit assignments, then they do not have good performance.",
"output": "∀x (¬SubmitsAssignments(x) → ¬HasGoodPerformance(x))"
},
{
"input": "Translate into first-order logic: If a student does not submit their thesis, then they do not pass the course.",
"output": "∀x (¬SubmitsThesis(x) → ¬PassesCourse(x))"
},
{
"input": "Translate into first-order logic: If a student submits assignments, then they receive feedback.",
"output": "∀x (SubmitsAssignments(x) → ReceivesFeedback(x))"
},
{
"input": "Translate into first-order logic: If a student passes the course, then they have good performance.",
"output": "∀x (PassesCourse(x) → HasGoodPerformance(x))"
},
{
"input": "Translate into first-order logic: All students have high attendance.",
"output": "∀x (HasHighAttendance(x))"
},
{
"input": "Translate into first-order logic: If a student does not receive feedback, then they did not submit assignments.",
"output": "∀x (¬ReceivesFeedback(x) → ¬SubmitsAssignments(x))"
},
{
"input": "Translate into first-order logic: If a student gives a seminar, then they receive a recommendation.",
"output": "∀x (GivesSeminar(x) → ReceivesRecommendation(x))"
},
{
"input": "Translate into first-order logic: If a student participates in a project, then they earn a certification.",
"output": "∀x (ParticipatesInProject(x) → EarnsCertification(x))"
},
{
"input": "Translate into first-order logic: All students complete the training module.",
"output": "∀x (CompletesTrainingModule(x))"
},
{
"input": "Translate into first-order logic: If a student does not earn a certification, then they did not participate in a project.",
"output": "∀x (¬EarnsCertification(x) → ¬ParticipatesInProject(x))"
},
{
"input": "Translate into first-order logic: All students earn a certification.",
"output": "∀x (EarnsCertification(x))"
},
{
"input": "Translate into first-order logic: If a student participates in a project, then they give a seminar.",
"output": "∀x (ParticipatesInProject(x) → GivesSeminar(x))"
},
{
"input": "Translate into first-order logic: If a student gives a seminar, then they receive a recommendation.",
"output": "∀x (GivesSeminar(x) → ReceivesRecommendation(x))"
},
{
"input": "Translate into first-order logic: If a student participates in a project, then they earn a certification.",
"output": "∀x (ParticipatesInProject(x) → EarnsCertification(x))"
},
{
"input": "Translate into first-order logic: All students complete the training module.",
"output": "∀x (CompletesTrainingModule(x))"
},
{
"input": "Translate into first-order logic: If a student does not earn a certification, then they did not participate in a project.",
"output": "∀x (¬EarnsCertification(x) → ¬ParticipatesInProject(x))"
},
{
"input": "Translate into first-order logic: All students earn a certification.",
"output": "∀x (EarnsCertification(x))"
},
{
"input": "Translate into first-order logic: If a student participates in a project, then they give a seminar.",
"output": "∀x (ParticipatesInProject(x) → GivesSeminar(x))"
},
{
"input": "Translate into first-order logic: If a student does not pass the course, then they did not submit the assignment.",
"output": "∀x (¬PassesCourse(x) → ¬SubmitsAssignment(x))"
},
{
"input": "Translate into first-order logic: If a student submits their assignment, then they qualify for graduation.",
"output": "∀x (SubmitsAssignment(x) → QualifiesGraduation(x))"
},
{
"input": "Translate into first-order logic: All students attend the university.",
"output": "∀x (AttendsUniversity(x))"
},
{
"input": "Translate into first-order logic: All students take the exam.",
"output": "∀x (TakesExam(x))"
},
{
"input": "Translate into first-order logic: All students qualify for graduation.",
"output": "∀x (QualifiesGraduation(x))"
},
{
"input": "Translate into first-order logic: All students pass the course.",
"output": "∀x (PassesCourse(x))"
},
{
"input": "Translate into first-order logic: If a student completes the research project, then they submit the assignment.",
"output": "∀x (CompletesResearchProject(x) → SubmitsAssignment(x))"
},
{
"input": "Translate into first-order logic: If a student has a GPA ≥ 3.7, then they are eligible for a scholarship.",
"output": "∀x (GPA_GTE_3_7(x) → EligibleForScholarship(x))"
},
{
"input": "Translate into first-order logic: All students who are eligible for a scholarship submitted a personal statement.",
"output": "∀x (EligibleForScholarship(x) → SubmittedStatement(x))"
},
{
"input": "Translate into first-order logic: All students show strong academic commitment.",
"output": "∀x (HasAcademicCommitment(x))"
},
{
"input": "Translate into first-order logic: There exists at least one student who published a research paper.",
"output": "∃x (PublishedResearch(x))"
},
{
"input": "Translate into first-order logic: All students have a GPA ≥ 3.7.",
"output": "∀x (GPA_GTE_3_7(x))"
},
{
"input": "Translate into first-order logic: All students participated in extracurricular activities.",
"output": "∀x (ParticipatedExtracurricular(x))"
},
{
"input": "Translate into first-order logic: All students submitted a recommendation letter.",
"output": "∀x (SubmittedRecLetter(x))"
},
{
"input": "Translate into first-order logic: If a student does not show academic commitment, then they did not publish a research paper.",
"output": "∀x (¬HasAcademicCommitment(x) → ¬PublishedResearch(x))"
},
{
"input": "Translate into first-order logic: All students are eligible to conduct research.",
"output": "∀x (EligibleForResearch(x))"
},
{
"input": "Translate into first-order logic: If a student has completed the training session, then they have submitted a research proposal.",
"output": "∀x (CompletedTraining(x) → SubmittedProposal(x))"
},
{
"input": "Translate into first-order logic: If a student has not submitted a research proposal, then they are not eligible to conduct research.",
"output": "∀x (¬SubmittedProposal(x) → ¬EligibleForResearch(x))"
},
{
"input": "Translate into first-order logic: If a student has not completed the training session, then they are not eligible to conduct research.",
"output": "∀x (¬CompletedTraining(x) → ¬EligibleForResearch(x))"
},
{
"input": "Translate into first-order logic: If a student has completed the training session, then they have presented at a seminar.",
"output": "∀x (CompletedTraining(x) → PresentedAtSeminar(x))"
},
{
"input": "Translate into first-order logic: All students meet the qualification criteria.",
"output": "∀x (MeetsQualification(x))"
},
{
"input": "Translate into first-order logic: All students meet the eligibility criteria for studying abroad.",
"output": "∀x (EligibleForStudyAbroad(x))"
},
{
"input": "Translate into first-order logic: If a student does not have a high TOEFL score, then they cannot participate in the exchange program.",
"output": "∀x (¬HighTOEFLScore(x) → ¬CanJoinExchange(x))"
},
{
"input": "Translate into first-order logic: If a student receives a scholarship, then they have a high TOEFL score.",
"output": "∀x (ReceivesScholarship(x) → HighTOEFLScore(x))"
},
{
"input": "Translate into first-order logic: If a student cannot participate in the exchange program, then they are not eligible to study abroad.",
"output": "∀x (¬CanJoinExchange(x) → ¬EligibleForStudyAbroad(x))"
},
{
"input": "Translate into first-order logic: If a student wrote a motivation letter, then they can participate in the exchange program.",
"output": "∀x (WroteMotivationLetter(x) → CanJoinExchange(x))"
},
{
"input": "Translate into first-order logic: If a student did not write a motivation letter, then they are not eligible to study abroad.",
"output": "∀x (¬WroteMotivationLetter(x) → ¬EligibleForStudyAbroad(x))"
},
{
"input": "Translate into first-order logic: If a student is not eligible to study abroad, then they did not write a motivation letter.",
"output": "∀x (¬EligibleForStudyAbroad(x) → ¬WroteMotivationLetter(x))"
},
{
"input": "Translate into first-order logic: If a student applied for exchange, then they can participate in the exchange program.",
"output": "∀x (AppliedForExchange(x) → CanJoinExchange(x))"
},
{
"input": "Translate into first-order logic: All students in the dual degree program must maintain a GPA of 3.5 or higher.",
"output": "∀x (InDualDegree(x) → GPA_GTE_3_5(x))"
},
{
"input": "Translate into first-order logic: If a student completes a thesis, then they qualify for the second degree.",
"output": "∀x (CompletedThesis(x) → QualifiesSecondDegree(x))"
},
{
"input": "Translate into first-order logic: If a student does not participate in leadership activities, then they are not eligible for international exchange.",
"output": "∀x (¬ParticipatedLeadership(x) → ¬EligibleForExchange(x))"
},
{
"input": "Translate into first-order logic: All students are required to complete a capstone project.",
"output": "∀x (CompletedCapstone(x))"
},
{
"input": "Translate into first-order logic: All students are eligible for international exchange.",
"output": "∀x (EligibleForExchange(x))"
},
{
"input": "Translate into first-order logic: If a student completes the capstone project, then they complete a thesis.",
"output": "∀x (CompletedCapstone(x) → CompletedThesis(x))"
},
{
"input": "Translate into first-order logic: If a student participates in leadership activities, then they are in the dual degree program.",
"output": "∀x (ParticipatedLeadership(x) → InDualDegree(x))"
},
{
"input": "Translate into first-order logic: All students are in the dual degree program.",
"output": "∀x (InDualDegree(x))"
},
{
"input": "Translate into first-order logic: All students are enrolled in at least one online course.",
"output": "∀x (EnrolledInOnlineCourse(x))"
},
{
"input": "Translate into first-order logic: All students have access to the learning management system (LMS).",
"output": "∀x (HasLMSAccess(x))"
},
{
"input": "Translate into first-order logic: All students attend live sessions.",
"output": "∀x (AttendsLiveSession(x))"
},
{
"input": "Translate into first-order logic: If a student does not have LMS access, then they cannot view lecture recordings.",
"output": "∀x (¬HasLMSAccess(x) → ¬CanViewRecordings(x))"
},
{
"input": "Translate into first-order logic: All students can view lecture recordings.",
"output": "∀x (CanViewRecordings(x))"
},
{
"input": "Translate into first-order logic: There exists at least one student who joins discussion forums.",
"output": "∃x (JoinsDiscussionForum(x))"
},
{
"input": "Translate into first-order logic: If a student is enrolled in an online course, then they have LMS access.",
"output": "∀x (EnrolledInOnlineCourse(x) → HasLMSAccess(x))"
},
{
"input": "Translate into first-order logic: All students have completed the foundational course.",
"output": "∀x (CompletedFoundationCourse(x))"
},
{
"input": "Translate into first-order logic: If a student completed the foundational course, then they are eligible for advanced coursework.",
"output": "∀x (CompletedFoundationCourse(x) → EligibleAdvancedCoursework(x))"
},
{
"input": "Translate into first-order logic: If a student is not eligible for advanced coursework, then they did not complete the seminar.",
"output": "∀x (¬EligibleAdvancedCoursework(x) → ¬CompletedSeminar(x))"
},
{
"input": "Translate into first-order logic: If a student completed the seminar, then they passed the public speaking module.",
"output": "∀x (CompletedSeminar(x) → PassedSpeakingModule(x))"
},
{
"input": "Translate into first-order logic: If a student lacks presentation skills, then they are not eligible for advanced coursework.",
"output": "∀x (¬HasPresentationSkills(x) → ¬EligibleAdvancedCoursework(x))"
},
{
"input": "Translate into first-order logic: If a student is eligible for advanced coursework, then they passed the public speaking module.",
"output": "∀x (EligibleAdvancedCoursework(x) → PassedSpeakingModule(x))"
},
{
"input": "Translate into first-order logic: If a student completed the foundational course, then they submitted their thesis.",
"output": "∀x (CompletedFoundationCourse(x) → SubmittedThesis(x))"
},
{
"input": "Translate into first-order logic: All students have academic communication skills.",
"output": "∀x (HasAcademicCommunication(x))"
},
{
"input": "Translate into first-order logic: All students passed the public speaking module.",
"output": "∀x (PassedSpeakingModule(x))"
},
{
"input": "Translate into first-order logic: All students submitted their registration request.",
"output": "∀x (SubmittedRegistration(x))"
},
{
"input": "Translate into first-order logic: If a student did not complete prerequisite courses, then they cannot register for advanced subjects.",
"output": "∀x (¬CompletedPrerequisites(x) → ¬EligibleAdvancedCourse(x))"
},
{
"input": "Translate into first-order logic: If a student missed the deadline, then they cannot register for any courses.",
"output": "∀x (¬MetDeadline(x) → ¬RegisteredAnyCourse(x))"
},
{
"input": "Translate into first-order logic: All students completed the prerequisite verification.",
"output": "∀x (CompletedPrerequisites(x))"
},
{
"input": "Translate into first-order logic: All students added at least one course.",
"output": "∀x (AddedCourse(x))"
},
{
"input": "Translate into first-order logic: All students successfully registered for courses.",
"output": "∀x (RegisteredAnyCourse(x))"
},
{
"input": "Translate into first-order logic: If a student completed the prerequisite check, then they could enroll in waitlisted courses.",
"output": "∀x (CompletedPrerequisites(x) → EnrolledWaitlistCourse(x))"
},
{
"input": "Translate into first-order logic: All students are allowed to enroll in at least one course.",
"output": "∀x (CanEnroll(x))"
},
{
"input": "Translate into first-order logic: All students enrolled in Calculus I.",
"output": "∀x (EnrolledCalculusI(x))"
},
{
"input": "Translate into first-order logic: If a student registered for Advanced Physics, then they must have passed Classical Mechanics.",
"output": "∀x (RegisteredAdvPhysics(x) → PassedClassicalMech(x))"
},
{
"input": "Translate into first-order logic: If a student did not register for Advanced Physics, then they are not allowed to enroll in any course.",
"output": "∀x (¬RegisteredAdvPhysics(x) → ¬CanEnroll(x))"
},
{
"input": "Translate into first-order logic: All students passed the prerequisites.",
"output": "∀x (PassedPrerequisites(x))"
},
{
"input": "Translate into first-order logic: If a student passed Classical Mechanics, then they are allowed to take Data Structures.",
"output": "∀x (PassedClassicalMech(x) → CanTakeDataStructures(x))"
},
{
"input": "Translate into first-order logic: If a student is not allowed to enroll, then they cannot take Data Structures.",
"output": "∀x (¬CanEnroll(x) → ¬EnrolledDataStructures(x))"
},
{
"input": "Translate into first-order logic: There exists at least one student registered for Advanced Physics.",
"output": "∃x (RegisteredAdvPhysics(x))"
},
{
"input": "Translate into first-order logic: All students enrolled in Data Structures.",
"output": "∀x (EnrolledDataStructures(x))"
},
{
"input": "Translate into first-order logic: All students passed Classical Mechanics.",
"output": "∀x (PassedClassicalMech(x))"
},
{
"input": "Translate into first-order logic: If a student registered for Advanced Physics, then they are allowed to enroll in courses.",
"output": "∀x (RegisteredAdvPhysics(x) → CanEnroll(x))"
},
{
"input": "Translate into first-order logic: If a device has a motion sensor, then it is compatible with smart home apps.",
"output": "∀x (HasMotionSensor(x) → CompatibleWithApps(x))"
},
{
"input": "Translate into first-order logic: If a device is compatible with smart home apps, then it is energy efficient.",
"output": "∀x (CompatibleWithApps(x) → EnergyEfficient(x))"
},
{
"input": "Translate into first-order logic: If a device does not have a motion sensor, then it is not compatible with smart home apps.",
"output": "∀x (¬HasMotionSensor(x) → ¬CompatibleWithApps(x))"
},
{
"input": "Translate into first-order logic: Every book in the library is available.",
"output": "∀x A(x)"
},
{
"input": "Translate into first-order logic: If a book is well-catalogued, then it is available.",
"output": "∀x (W(x) → A(x))"
},
{
"input": "Translate into first-order logic: Every book is in high demand.",
"output": "∀x H(x)"
},
{
"input": "Translate into first-order logic: If a book is in good condition, then it is well-catalogued.",
"output": "∀x (G(x) → W(x))"
},
{
"input": "Translate into first-order logic: If a book is well-catalogued, then it is recommended.",
"output": "∀x (W(x) → R(x))"
},
{
"input": "Translate into first-order logic: If a book is not available, then it is not well-catalogued.",
"output": "∀x (¬A(x) → ¬W(x))"
},
{
"input": "Translate into first-order logic: If a book is available, then it is in good condition.",
"output": "∀x (A(x) → G(x))"
},
{
"input": "Translate into first-order logic: Every book is in good condition.",
"output": "∀x G(x)"
},
{
"input": "Translate into first-order logic: If a book is not in high demand, then it is not available.",
"output": "∀x (¬H(x) → ¬A(x))"
},
{
"input": "Translate into first-order logic: There is at least one book in good condition.",
"output": "∃x G(x)"
},
{
"input": "Translate into first-order logic: There is at least one available book.",
"output": "∃x A(x)"
},
{
"input": "Translate into first-order logic: If a book is not in good condition, then it is not well-catalogued.",
"output": "∀x (¬G(x) → ¬W(x))"
},
{
"input": "Translate into first-order logic: If a book is well-catalogued, then it is in good condition.",
"output": "∀x (W(x) → G(x))"
},
{
"input": "Translate into first-order logic: There is at least one well-catalogued book.",
"output": "∃x W(x)"
},
{
"input": "Translate into first-order logic: If a book is not frequently borrowed, then it is not in good condition.",
"output": "∀x (¬F(x) → ¬G(x))"
},
{
"input": "Translate into first-order logic: If a book is frequently borrowed, then it is recommended.",
"output": "∀x (F(x) → R(x))"
},
{
"input": "Translate into first-order logic: If a book is frequently borrowed, then it is well-catalogued.",
"output": "∀x (F(x) → W(x))"
},
{
"input": "Translate into first-order logic: If a book is recommended, then it is in good condition.",
"output": "∀x (R(x) → G(x))"
},
{
"input": "Translate into first-order logic: Every book is frequently borrowed.",
"output": "∀x F(x)"
},
{
"input": "Translate into first-order logic: If a book is not available, then it is not frequently borrowed.",
"output": "∀x (¬A(x) → ¬F(x))"
},
{
"input": "Translate into first-order logic: If not being in high demand implies a book is not available, then if a book is not available, it is not frequently borrowed.",
"output": "∀x (¬H(x) → ¬A(x)) → ∀x (¬A(x) → ¬F(x))"
},
{
"input": "Translate into first-order logic: If being frequently borrowed implies a book is well-catalogued, then if a book is not available, it is not well-catalogued.",
"output": "∀x (F(x) → W(x)) → ∀x (¬A(x) → ¬W(x))"
},
{
"input": "Translate into first-order logic: If every book is available, then every book is frequently borrowed.",
"output": "∀x A(x) → ∀x F(x)"
},
{
"input": "Translate into first-order logic: If the fact that frequently borrowed books are well-catalogued implies that unavailable books are not well-catalogued, then every book is in high demand.",
"output": "(∀x (F(x) → W(x)) → ∀x (¬A(x) → ¬W(x))) → ∀x H(x)"
},
{
"input": "Translate into first-order logic: If being in good condition implies a book is well-catalogued, then if frequently borrowed books are well-catalogued, an unavailable book is not well-catalogued.",
"output": "∀x (G(x) → W(x)) → (∀x (F(x) → W(x)) → ∀x (¬A(x) → ¬W(x)))"
},
{
"input": "Translate into first-order logic: If the previous implication holds, then every book is in good condition.",
"output": "(∀x (G(x) → W(x)) → (∀x (F(x) → W(x)) → ∀x (¬A(x) → ¬W(x)))) → ∀x G(x)"
},
{
"input": "Translate into first-order logic: There is at least one recommended book.",
"output": "∃x R(x)"
},
{
"input": "Translate into first-order logic: If a book is not in high demand, then it is not well-catalogued.",
"output": "∀x (¬H(x) → ¬W(x))"
},
{
"input": "Translate into first-order logic: If a book is not in high demand, then it is not frequently borrowed.",
"output": "∀x (¬H(x) → ¬F(x))"
},
{
"input": "Translate into first-order logic: If a bus route is energy efficient, then it is cost-effective.",
"output": "∀x (EnergyEfficient(x) → CostEffective(x))"
},
{
"input": "Translate into first-order logic: If a bus route is well-maintained, then it is cost-effective.",
"output": "∀x (WellMaintained(x) → CostEffective(x))"
},
{
"input": "Translate into first-order logic: There is at least one bus route that is well-maintained.",
"output": "∃x WellMaintained(x)"
},
{
"input": "Translate into first-order logic: There is at least one dish available today.",
"output": "∃x A(x)"
},
{
"input": "Translate into first-order logic: Every dish is well-prepared.",
"output": "∀x W(x)"
},
{
"input": "Translate into first-order logic: If a dish is a main course, then it is well-prepared.",
"output": "∀x (M(x) → W(x))"
},
{
"input": "Translate into first-order logic: If a dish is a main course, then it is spicy.",
"output": "∀x (M(x) → S(x))"
},
{
"input": "Translate into first-order logic: If a dish is available today, then it is popular.",
"output": "∀x (A(x) → P(x))"
},
{
"input": "Translate into first-order logic: There is at least one dish recommended by the chef.",
"output": "∃x R(x)"
},
{
"input": "Translate into first-order logic: There is at least one dish that is well-prepared.",
"output": "∃x W(x)"
},
{
"input": "Translate into first-order logic: If a dish is not spicy, then it is not recommended by the chef.",
"output": "∀x (¬S(x) → ¬R(x))"
},
{
"input": "Translate into first-order logic: If a dish is recommended by the chef, then it is well-prepared.",
"output": "∀x (R(x) → W(x))"
},
{
"input": "Translate into first-order logic: If a dish is not well-prepared, then it is not a main course.",
"output": "∀x (¬W(x) → ¬M(x))"
},
{
"input": "Translate into first-order logic: Every dish on the menu is a main course.",
"output": "∀x M(x)"
},
{
"input": "Translate into first-order logic: If a dish is not recommended by the chef, then it is not available today.",
"output": "∀x (¬R(x) → ¬A(x))"
},
{
"input": "Translate into first-order logic: Every dish is spicy.",
"output": "∀x S(x)"
},
{
"input": "Translate into first-order logic: There is at least one dish that is spicy.",
"output": "∃x S(x)"
},
{
"input": "Translate into first-order logic: Every dish is available today.",
"output": "∀x A(x)"
},
{
"input": "Translate into first-order logic: If every main course is spicy, then there is at least one dish recommended by the chef.",
"output": "∀x (M(x) → S(x)) → ∃x R(x)"
},
{
"input": "Translate into first-order logic: If every dish that is recommended is well-prepared, then if every main course is spicy, there is at least one dish recommended by the chef.",
"output": "∀x (R(x) → W(x)) → (∀x (M(x) → S(x)) → ∃x R(x))"
},
{
"input": "Translate into first-order logic: If every main course is spicy, then every dish is available today.",
"output": "∀x (M(x) → S(x)) → ∀x A(x)"
},
{
"input": "Translate into first-order logic: If the fact that every main course being spicy implies there is a recommended dish holds, then if a dish is available today, it is popular.",
"output": "(∀x (M(x) → S(x)) → ∃x R(x)) → ∀x (A(x) → P(x))"
},
{
"input": "Translate into first-order logic: If every main course being spicy implies there is a recommended dish, then there is at least one dish recommended by the chef.",
"output": "(∀x (M(x) → S(x)) → ∃x R(x)) → ∃x R(x)"
},
{
"input": "Translate into first-order logic: If a dish is spicy, then it is a main course.",
"output": "∀x (S(x) → M(x))"
},
{
"input": "Translate into first-order logic: If a dish is not recommended by the chef, then it is not a main course.",
"output": "∀x (¬R(x) → ¬M(x))"
},
{
"input": "Translate into first-order logic: If a dish is recommended by the chef, then it is popular.",
"output": "∀x (R(x) → P(x))"
},
{
"input": "Translate into first-order logic: If a dish is not a main course, then it is not popular.",
"output": "∀x (¬M(x) → ¬P(x))"
},
{
"input": "Translate into first-order logic: If a dish is not well-prepared, then it is not popular.",
"output": "∀x (¬W(x) → ¬P(x))"
},
{
"input": "Translate into first-order logic: If a dish is recommended by the chef, then it is available today.",
"output": "∀x (R(x) → A(x))"
},
{
"input": "Translate into first-order logic: If a dish is well-prepared, then it is recommended by the chef.",
"output": "∀x (W(x) → R(x))"
},
{
"input": "Translate into first-order logic: If a product is in stock, then it is of premium quality.",
"output": "∀x (InStock(x) → PremiumQuality(x))"
},
{
"input": "Translate into first-order logic: If a product is popular, then it is shipped today.",
"output": "∀x (Popular(x) → ShippedToday(x))"
},
{
"input": "Translate into first-order logic: There is at least one product that is popular.",
"output": "∃x Popular(x)"
},
{
"input": "Translate into first-order logic: If a product is in stock, then it is popular.",
"output": "∀x (InStock(x) → Popular(x))"
},
{
"input": "Translate into first-order logic: At least one travel package is available in winter.",
"output": "∃x (Package(x) ∧ Winter(x))"
},
{
"input": "Translate into first-order logic: Every travel package is highly popular.",
"output": "∀x (Package(x) → Popular(x))"
},
{
"input": "Translate into first-order logic: Every travel package offers sightseeing tours.",
"output": "∀x (Package(x) → Sightseeing(x))"
},
{
"input": "Translate into first-order logic: Every travel package includes flight tickets.",
"output": "∀x (Package(x) → Flight(x))"
},
{
"input": "Translate into first-order logic: Every travel package includes hotel reservations.",
"output": "∀x (Package(x) → Hotel(x))"
},
{
"input": "Translate into first-order logic: Every travel package is cost-effective.",
"output": "∀x (Package(x) → CostEffective(x))"
},
{
"input": "Translate into first-order logic: If a travel package is highly popular, then it is cost-effective.",
"output": "∀x (Package(x) ∧ Popular(x) → CostEffective(x))"
},
{
"input": "Translate into first-order logic: If a travel package is available in winter, then it is cost-effective.",
"output": "∀x (Package(x) ∧ Winter(x) → CostEffective(x))"
},
{
"input": "Translate into first-order logic: If a smartphone is water resistant, then it supports 5G connectivity.",
"output": "∀x (WaterResistant(x) → Supports5G(x))"
},
{
"input": "Translate into first-order logic: If a smartphone is water resistant, then it is of premium quality.",
"output": "∀x (WaterResistant(x) → PremiumQuality(x))"
},
{
"input": "Translate into first-order logic: There is at least one smartphone that is water resistant.",
"output": "∃x WaterResistant(x)"
},
{
"input": "Translate into first-order logic: There is at least one electric vehicle that is eco-friendly.",
"output": "∃x E(x)"
},
{
"input": "Translate into first-order logic: If an electric vehicle has a long range, then it supports fast charging.",
"output": "∀x (L(x) → F(x))"
},
{
"input": "Translate into first-order logic: There is at least one electric vehicle that supports fast charging.",
"output": "∃x F(x)"
},
{
"input": "Translate into first-order logic: Every electric vehicle has advanced safety features.",
"output": "∀x S(x)"
},
{
"input": "Translate into first-order logic: Every electric vehicle supports fast charging.",
"output": "∀x F(x)"
},
{
"input": "Translate into first-order logic: If an electric vehicle supports fast charging, then it has a long range.",
"output": "∀x (F(x) → L(x))"
},
{
"input": "Translate into first-order logic: If an electric vehicle is not affordable, then it does not support fast charging.",
"output": "∀x (¬A(x) → ¬F(x))"
},
{
"input": "Translate into first-order logic: There is at least one electric vehicle that is affordable.",
"output": "∃x A(x)"
},
{
"input": "Translate into first-order logic: Every electric vehicle has a long range.",
"output": "∀x L(x)"
},
{
"input": "Translate into first-order logic: If an electric vehicle is not eco-friendly, then it is not energy efficient.",
"output": "∀x (¬E(x) → ¬N(x))"
},
{
"input": "Translate into first-order logic: If an electric vehicle does not have advanced safety features, then it is not affordable.",
"output": "∀x (¬S(x) → ¬A(x))"
},
{
"input": "Translate into first-order logic: There is at least one electric vehicle that has a long range.",
"output": "∃x L(x)"
},
{
"input": "Translate into first-order logic: If an electric vehicle does not support fast charging, then it is not eco-friendly.",
"output": "∀x (¬F(x) → ¬E(x))"
},
{
"input": "Translate into first-order logic: If an electric vehicle is eco-friendly, then it is affordable.",
"output": "∀x (E(x) → A(x))"
},
{
"input": "Translate into first-order logic: If an electric vehicle is not eco-friendly, then it is not affordable.",
"output": "∀x (¬E(x) → ¬A(x))"
},
{
"input": "Translate into first-order logic: If an electric vehicle is not energy efficient, then it does not have a long range.",
"output": "∀x (¬N(x) → ¬L(x))"
},
{
"input": "Translate into first-order logic: If there is at least one electric vehicle with a long range, then if it is not affordable, it does not support fast charging.",
"output": "∃x L(x) → ∀x (¬A(x) → ¬F(x))"
},
{
"input": "Translate into first-order logic: If every electric vehicle has a long range, then if it is not energy efficient, then it does not have a long range.",
"output": "∀x L(x) → ∀x (¬N(x) → ¬L(x))"
},
{
"input": "Translate into first-order logic: If there is at least one electric vehicle that supports fast charging, then if it lacks advanced safety features, it is not affordable.",
"output": "∃x F(x) → ∀x (¬S(x) → ¬A(x))"
},
{
"input": "Translate into first-order logic: If every electric vehicle has a long range, then every electric vehicle supports fast charging.",
"output": "∀x L(x) → ∀x F(x)"
},
{
"input": "Translate into first-order logic: If the fact that every electric vehicle having a long range implies that if it is not energy efficient then it does not have a long range, then if an electric vehicle supports fast charging, it has a long range.",
"output": "(∀x L(x) → ∀x (¬N(x) → ¬L(x))) → ∀x (F(x) → L(x))"
},
{
"input": "Translate into first-order logic: If every electric vehicle having a long range implies that if it is not energy efficient then it does not have a long range, then if there is at least one electric vehicle with a long range, it follows that if it is not affordable, then it does not support fast charging.",
"output": "(∀x L(x) → ∀x (¬N(x) → ¬L(x))) → (∃x L(x) → ∀x (¬A(x) → ¬F(x)))"
},
{
"input": "Translate into first-order logic: If an electric vehicle has advanced safety features, then it is energy efficient.",
"output": "∀x (S(x) → N(x))"
},
{
"input": "Translate into first-order logic: If an electric vehicle is affordable, then it has advanced safety features.",
"output": "∀x (A(x) → S(x))"
},
{
"input": "Translate into first-order logic: If an electric vehicle does not support fast charging, then it is not affordable.",
"output": "∀x (¬F(x) → ¬A(x))"
},
{
"input": "Translate into first-order logic: If an electric vehicle is eco-friendly, then it has a long range.",
"output": "∀x (E(x) → L(x))"
},
{
"input": "Translate into first-order logic: There is at least one electric vehicle that is energy efficient.",
"output": "∃x N(x)"
},
{
"input": "Translate into first-order logic: If an electric vehicle is energy efficient, then it has advanced safety features.",
"output": "∀x (N(x) → S(x))"
},
{
"input": "Translate into first-order logic: If an electric vehicle has a long range, then it is energy efficient.",
"output": "∀x (L(x) → N(x))"
},
{
"input": "Translate into first-order logic: If a travel package is highly popular, then it is cost-effective.",
"output": "∀x (HighlyPopular(x) → CostEffective(x))"
},
{
"input": "Translate into first-order logic: There is at least one travel package that includes flight tickets.",
"output": "∃x IncludesFlight(x)"
},
{
"input": "Translate into first-order logic: Every travel package offers sightseeing tours.",
"output": "∀x OffersSightseeing(x)"
},
{
"input": "Translate into first-order logic: Every streaming service offers personalized recommendations.",
"output": "∀x P(x)"
},
{
"input": "Translate into first-order logic: If a streaming service is available globally, then it has a user-friendly interface.",
"output": "∀x (G(x) → I(x))"
},
{
"input": "Translate into first-order logic: Every streaming service has a user-friendly interface.",
"output": "∀x I(x)"
},
{
"input": "Translate into first-order logic: Every streaming service is available globally.",
"output": "∀x G(x)"
},
{
"input": "Translate into first-order logic: If a streaming service does not offer personalized recommendations, then it is not available globally.",
"output": "∀x (¬P(x) → ¬G(x))"
},
{
"input": "Translate into first-order logic: If a streaming service does not have a user-friendly interface, then it does not offer exclusive content.",
"output": "∀x (¬I(x) → ¬E(x))"
},
{
"input": "Translate into first-order logic: There is at least one streaming service that provides high-quality streaming.",
"output": "∃x H(x)"
},
{
"input": "Translate into first-order logic: Every streaming service is affordable.",
"output": "∀x A(x)"
},
{
"input": "Translate into first-order logic: If a streaming service does not provide high-quality streaming, then it is not available globally.",
"output": "∀x (¬H(x) → ¬G(x))"
},
{
"input": "Translate into first-order logic: If a streaming service provides high-quality streaming, then it offers exclusive content.",
"output": "∀x (H(x) → E(x))"
},
{
"input": "Translate into first-order logic: If a streaming service does not offer personalized recommendations, then it is not affordable.",
"output": "∀x (¬P(x) → ¬A(x))"
},
{
"input": "Translate into first-order logic: Every streaming service offers exclusive content.",
"output": "∀x E(x)"
},
{
"input": "Translate into first-order logic: There is at least one streaming service that offers exclusive content.",
"output": "∃x E(x)"
},
{
"input": "Translate into first-order logic: Every streaming service provides high-quality streaming.",
"output": "∀x H(x)"
},
{
"input": "Translate into first-order logic: If a streaming service does not provide high-quality streaming, then it does not offer exclusive content.",
"output": "∀x (¬H(x) → ¬E(x))"
},
{
"input": "Translate into first-order logic: If a streaming service is not available globally, then it is not affordable.",
"output": "∀x (¬G(x) → ¬A(x))"
},
{
"input": "Translate into first-order logic: If a streaming service provides high-quality streaming, then it offers personalized recommendations.",
"output": "∀x (H(x) → P(x))"
},
{
"input": "Translate into first-order logic: If a streaming service is not available globally, then it does not provide high-quality streaming.",
"output": "∀x (¬G(x) → ¬H(x))"
},
{
"input": "Translate into first-order logic: There is at least one streaming service that has a user-friendly interface.",
"output": "∃x I(x)"
},
{
"input": "Translate into first-order logic: If a streaming service does not offer exclusive content, then it is not available globally.",
"output": "∀x (¬E(x) → ¬G(x))"
},
{
"input": "Translate into first-order logic: If a streaming service does not offer exclusive content, then it is not affordable.",
"output": "∀x (¬E(x) → ¬A(x))"
},
{
"input": "Translate into first-order logic: If every streaming service is affordable, then non-exclusive streaming services are not affordable.",
"output": "∀x A(x) → ∀x (¬E(x) → ¬A(x))"
},
{
"input": "Translate into first-order logic: If every streaming service provides high-quality streaming, then any service that provides high-quality streaming offers exclusive content.",
"output": "∀x H(x) → ∀x (H(x) → E(x))"
},
{
"input": "Translate into first-order logic: If non-exclusive streaming services are not available globally, then every streaming service is available globally.",
"output": "∀x (¬E(x) → ¬G(x)) → ∀x G(x)"
},
{
"input": "Translate into first-order logic: If non-exclusive streaming services are not available globally, then non-global services do not provide high-quality streaming.",
"output": "∀x (¬E(x) → ¬G(x)) → ∀x (¬G(x) → ¬H(x))"
},
{
"input": "Translate into first-order logic: If the above implication holds, then every streaming service offers exclusive content.",
"output": "(∀x (¬E(x) → ¬G(x)) → ∀x (¬G(x) → ¬H(x))) → ∀x E(x)"
},
{
"input": "Translate into first-order logic: If there is at least one streaming service offering exclusive content, then any service that provides high-quality streaming offers exclusive content.",
"output": "∃x E(x) → ∀x (H(x) → E(x))"
},
{
"input": "Translate into first-order logic: If not being available globally implies not providing high-quality streaming, then every streaming service has a user-friendly interface.",
"output": "∀x (¬G(x) → ¬H(x)) → ∀x I(x)"
},
{
"input": "Translate into first-order logic: If the absence of personalized recommendations implies a service is not affordable, then there is at least one streaming service that offers exclusive content.",
"output": "∀x (¬P(x) → ¬A(x)) → ∃x E(x)"
},
{
"input": "Translate into first-order logic: If providing high-quality streaming implies offering personalized recommendations, then there is at least one streaming service that provides high-quality streaming.",
"output": "∀x (H(x) → P(x)) → ∃x H(x)"
},
{
"input": "Translate into first-order logic: If every streaming service offers personalized recommendations, then if high-quality streaming implies personalized recommendations, there is at least one service that provides high-quality streaming.",
"output": "∀x P(x) → (∀x (H(x) → P(x)) → ∃x H(x))"
},
{
"input": "Translate into first-order logic: If a streaming service is available globally, then it provides high-quality streaming.",
"output": "∀x (G(x) → H(x))"
},
{
"input": "Translate into first-order logic: There is at least one affordable streaming service.",
"output": "∃x A(x)"
},
{
"input": "Translate into first-order logic: If a streaming service is not available globally, then it does not offer personalized recommendations.",
"output": "∀x (¬G(x) → ¬P(x))"
},
{
"input": "Translate into first-order logic: If a streaming service is available globally, then it offers exclusive content.",
"output": "∀x (G(x) → E(x))"
},
{
"input": "Translate into first-order logic: If a streaming service does not offer exclusive content, then it does not offer personalized recommendations.",
"output": "∀x (¬E(x) → ¬P(x))"
},
{
"input": "Translate into first-order logic: If an online learning platform does not offer certified courses, then it does not provide community support.",
"output": "∀x (¬CertifiedCourses(x) → ¬CommunitySupport(x))"
},
{
"input": "Translate into first-order logic: If an online learning platform does not offer live webinars, then it does not offer interactive quizzes.",
"output": "∀x (¬LiveWebinar(x) → ¬InteractiveQuizzes(x))"
},
{
"input": "Translate into first-order logic: There is at least one online learning platform that offers live webinars.",
"output": "∃x LiveWebinar(x)"
},
{
"input": "Translate into first-order logic: If an e-commerce website offers competitive prices, then it has a secure payment system.",
"output": "∀x (C(x) → S(x))"
},
{
"input": "Translate into first-order logic: If an e-commerce website does not have a user-friendly interface, then it does not provide customer support.",
"output": "∀x (¬U(x) → ¬T(x))"
},
{
"input": "Translate into first-order logic: If an e-commerce website does not have a secure payment system, then it does not have a user-friendly interface.",
"output": "∀x (¬S(x) → ¬U(x))"
},
{
"input": "Translate into first-order logic: There is at least one e-commerce website that offers fast delivery.",
"output": "∃x F(x)"
},
{
"input": "Translate into first-order logic: If an e-commerce website provides customer support, then it has a wide product range.",
"output": "∀x (T(x) -> W(x))"
},
{
"input": "Translate into first-order logic: Every e-commerce website offers competitive prices.",
"output": "∀x C(x)"
},
{
"input": "Translate into first-order logic: If an e-commerce website has a user-friendly interface, then it has a wide product range.",
"output": "∀x (U(x) → W(x))"
},
{
"input": "Translate into first-order logic: There is at least one e-commerce website that has a secure payment system.",
"output": "∃x S(x)"
},
{
"input": "Translate into first-order logic: If an e-commerce website does not provide customer support, then it does not have a secure payment system.",
"output": "∀x (¬T(x) → ¬S(x))"
},
{
"input": "Translate into first-order logic: Every e-commerce website provides customer support.",
"output": "∀x T(x)"
},
{
"input": "Translate into first-order logic: If an e-commerce website does not have a wide product range, then it does not have a user-friendly interface.",
"output": "∀x (¬W(x) → ¬U(x))"
},
{
"input": "Translate into first-order logic: If an e-commerce website provides customer support, then it offers fast delivery.",
"output": "∀x (T(x) → F(x))"
},
{
"input": "Translate into first-order logic: If an e-commerce website does not have a secure payment system, then it does not provide customer support.",
"output": "∀x (¬S(x) → ¬T(x))"
},
{
"input": "Translate into first-order logic: Every e-commerce website has a secure payment system.",
"output": "∀x S(x)"
},
{
"input": "Translate into first-order logic: If an e-commerce website does not offer fast delivery, then it does not have a secure payment system.",
"output": "∀x (¬F(x) → ¬S(x))"
},
{
"input": "Translate into first-order logic: There is at least one e-commerce website that provides customer support.",
"output": "∃x T(x)"
},
{
"input": "Translate into first-order logic: If an e-commerce website offers competitive prices, then it has a user-friendly interface.",
"output": "∀x (C(x) → U(x))"
},
{
"input": "Translate into first-order logic: If an e-commerce website does not have a secure payment system, then it does not have a wide product range.",
"output": "∀x (¬S(x) → ¬W(x))"
},
{
"input": "Translate into first-order logic: If an e-commerce website provides customer support, then it offers competitive prices.",
"output": "∀x (T(x) → C(x))"
},
{
"input": "Translate into first-order logic: If an e-commerce website offers fast delivery, then it has a user-friendly interface.",
"output": "∀x (F(x) → U(x))"
},
{
"input": "Translate into first-order logic: There is at least one e-commerce website that offers competitive prices.",
"output": "∃x C(x)"
},
{
"input": "Translate into first-order logic: If every e-commerce website offers competitive prices, then if a website does not have a user-friendly interface, it does not provide customer support.",
"output": "∀x C(x) → ∀x (¬U(x) → ¬T(x))"
},
{
"input": "Translate into first-order logic: If the fact that every website offers competitive prices implies that lack of a user-friendly interface results in no customer support, then customer support implies fast delivery.",
"output": "(∀x C(x) → ∀x (¬U(x) → ¬T(x))) → ∀x (T(x) → F(x))"
},
{
"input": "Translate into first-order logic: If every e-commerce website has a secure payment system, then every website provides customer support.",
"output": "∀x S(x) → ∀x T(x)"
},
{
"input": "Translate into first-order logic: If customer support implies a wide product range, then lack of fast delivery implies lack of a secure payment system.",
"output": "∀x (T(x) → W(x)) → ∀x (¬F(x) → ¬S(x))"
},
{
"input": "Translate into first-order logic: If the implication from competitive prices to (lack of user-friendly interface leading to no customer support) implies that customer support leads to fast delivery, then fast delivery implies a user-friendly interface.",
"output": "((∀x C(x) → ∀x (¬U(x) → ¬T(x))) → ∀x (T(x) → F(x))) → ∀x (F(x) → U(x))"
},
{
"input": "Translate into first-order logic: If a user-friendly interface implies a wide product range, then customer support implies fast delivery.",
"output": "∀x (U(x) → W(x)) → ∀x (T(x) → F(x))"
},
{
"input": "Translate into first-order logic: If customer support implies a wide product range, then every website with a secure payment system provides customer support.",
"output": "∀x (T(x) → W(x)) → (∀x S(x) → ∀x T(x))"
},
{
"input": "Translate into first-order logic: If fast delivery implies a user-friendly interface, then lack of a secure payment system implies lack of a wide product range.",
"output": "∀x (F(x) → U(x)) → ∀x (¬S(x) → ¬W(x))"
},
{
"input": "Translate into first-order logic: If there is at least one website that offers competitive prices, then if it does not have a user-friendly interface, it does not provide customer support.",
"output": "∃x C(x) → ∀x (¬U(x) → ¬T(x))"
},
{
"input": "Translate into first-order logic: If lack of a wide product range implies lack of a user-friendly interface, then every website with a secure payment system provides customer support.",
"output": "∀x (¬W(x) → ¬U(x)) → (∀x S(x) → ∀x T(x))"
},
{
"input": "Translate into first-order logic: If an e-commerce website does not provide customer support, then it does not have a wide product range.",
"output": "∀x (¬T(x) → ¬W(x))"
},
{
"input": "Translate into first-order logic: Every e-commerce website offers fast delivery.",
"output": "∀x F(x)"
},
{
"input": "Translate into first-order logic: There is at least one e-commerce website that has a wide product range.",
"output": "∃x W(x)"
},
{
"input": "Translate into first-order logic: If an e-commerce website offers competitive prices, then it has a wide product range.",
"output": "∀x (C(x) → W(x))"
},
{
"input": "Translate into first-order logic: There is at least one e-commerce website that has a user-friendly interface.",
"output": "∃x U(x)"
},
{
"input": "Translate into first-order logic: If a security system has an alarm system, then it includes door sensors.",
"output": "∀x (AlarmSystem(x) → DoorSensor(x))"
},
{
"input": "Translate into first-order logic: If a security system detects motion, then it has an alarm system.",
"output": "∀x (MotionDetection(x) → AlarmSystem(x))"
},
{
"input": "Translate into first-order logic: Every security system provides video surveillance.",
"output": "∀x VideoSurveillance(x)"
},
{
"input": "Translate into first-order logic: If a security system provides video surveillance, then it integrates with smart home devices.",
"output": "∀x (VideoSurveillance(x) → SmartIntegration(x))"
},
{
"input": "Translate into first-order logic: If a drone lacks image stabilization, then it does not have a high-quality camera.",
"output": "∀x (¬S(x) → ¬C(x))"
},
{
"input": "Translate into first-order logic: Every drone has a long remote control range.",
"output": "∀x R(x)"
},
{
"input": "Translate into first-order logic: There is at least one drone that has obstacle avoidance.",
"output": "∃x O(x)"
},
{
"input": "Translate into first-order logic: If a drone does not have a long remote control range, then it does not have image stabilization.",
"output": "∀x (¬R(x) → ¬S(x))"
},
{
"input": "Translate into first-order logic: If a drone does not have a high-quality camera, then it does not have long battery life.",
"output": "∀x (¬C(x) → ¬B(x))"
},
{
"input": "Translate into first-order logic: If a drone has a high-quality camera, then it has a long remote control range.",
"output": "∀x (C(x) → R(x))"
},
{
"input": "Translate into first-order logic: There is at least one drone that has a long remote control range.",
"output": "∃x R(x)"
},
{
"input": "Translate into first-order logic: There is at least one drone that has GPS navigation.",
"output": "∃x G(x)"
},
{
"input": "Translate into first-order logic: If a drone has GPS navigation, then it has obstacle avoidance.",
"output": "∀x (G(x) → O(x))"
},
{
"input": "Translate into first-order logic: If a drone has image stabilization, then it has a long remote control range.",
"output": "∀x (S(x) → R(x))"
},
{
"input": "Translate into first-order logic: Every drone has image stabilization.",
"output": "∀x S(x)"
},
{
"input": "Translate into first-order logic: Every drone has a high-quality camera.",
"output": "∀x C(x)"
},
{
"input": "Translate into first-order logic: If a drone has a long remote control range, then it has obstacle avoidance.",
"output": "∀x (R(x) → O(x))"
},
{
"input": "Translate into first-order logic: There is at least one drone that has long battery life.",
"output": "∃x B(x)"
},
{
"input": "Translate into first-order logic: If a drone has obstacle avoidance, then it has a long remote control range.",
"output": "∀x (O(x) → R(x))"
},
{
"input": "Translate into first-order logic: Every drone has obstacle avoidance.",
"output": "∀x O(x)"
},
{
"input": "Translate into first-order logic: There is at least one drone that has a high-quality camera.",
"output": "∃x C(x)"
},
{
"input": "Translate into first-order logic: If a drone has long battery life, then it has a long remote control range.",
"output": "∀x (B(x) → R(x))"
},
{
"input": "Translate into first-order logic: If a drone does not have a high-quality camera, then it does not have a long remote control range.",
"output": "∀x (¬C(x) → ¬R(x))"
},
{
"input": "Translate into first-order logic: If a drone does not have a high-quality camera, then it does not have GPS navigation.",
"output": "∀x (¬C(x) → ¬G(x))"
},
{
"input": "Translate into first-order logic: If a drone does not have GPS navigation, then it does not have a long remote control range.",
"output": "∀x (¬G(x) → ¬R(x))"
},
{
"input": "Translate into first-order logic: If having a long remote control range implies obstacle avoidance, then every drone has a long remote control range.",
"output": "∀x (R(x) → O(x)) → ∀x R(x)"
},
{
"input": "Translate into first-order logic: If not having a high-quality camera implies not having a long remote control range, then every drone has obstacle avoidance.",
"output": "∀x (¬C(x) → ¬R(x)) → ∀x O(x)"
},
{
"input": "Translate into first-order logic: If having GPS navigation implies obstacle avoidance, then not having GPS navigation implies not having a long remote control range.",
"output": "∀x (G(x) → O(x)) → ∀x (¬G(x) → ¬R(x))"
},
{
"input": "Translate into first-order logic: If having long battery life implies a long remote control range, then there is at least one drone with long battery life.",
"output": "∀x (B(x) → R(x)) → ∃x B(x)"
},
{
"input": "Translate into first-order logic: If not having a high-quality camera implies not having long battery life, then every drone has a long remote control range.",
"output": "∀x (¬C(x) → ¬B(x)) → ∀x R(x)"
},
{
"input": "Translate into first-order logic: If having a long remote control range implies obstacle avoidance, then if a drone has GPS navigation, then it has obstacle avoidance.",
"output": "∀x (R(x) → O(x)) → ∀x (G(x) → O(x))"
},
{
"input": "Translate into first-order logic: If not having a long remote control range implies not having image stabilization, then if having a long remote control range implies obstacle avoidance, every drone has a long remote control range.",
"output": "∀x (¬R(x) → ¬S(x)) → (∀x (R(x) → O(x)) → ∀x R(x))"
},
{
"input": "Translate into first-order logic: If (if long battery life implies a long remote control range then there is at least one drone with long battery life) then if a long remote control range implies obstacle avoidance, every drone has a long remote control range.",
"output": "(∀x (B(x) → R(x)) → ∃x B(x)) → (∀x (R(x) → O(x)) → ∀x R(x))"
},
{
"input": "Translate into first-order logic: If there is at least one drone with a long remote control range, then there is at least one drone with GPS navigation.",
"output": "∃x R(x) → ∃x G(x)"
},
{
"input": "Translate into first-order logic: If having GPS navigation implies obstacle avoidance, then there is at least one drone with GPS navigation.",
"output": "∀x (G(x) → O(x)) → ∃x G(x)"
},
{
"input": "Translate into first-order logic: If a drone does not have long battery life, then it does not have image stabilization.",
"output": "∀x (¬B(x) → ¬S(x))"
},
{
"input": "Translate into first-order logic: If a drone has image stabilization, then it has a high-quality camera.",
"output": "∀x (S(x) → C(x))"
},
{
"input": "Translate into first-order logic: Every drone has GPS navigation.",
"output": "∀x G(x)"
},
{
"input": "Translate into first-order logic: If a drone does not have a high-quality camera, then it does not have obstacle avoidance.",
"output": "∀x (¬C(x) → ¬O(x))"
},
{
"input": "Translate into first-order logic: Every drone has long battery life.",
"output": "∀x B(x)"
},
{
"input": "Translate into first-order logic: If a VR headset does not have immersive sound, then it does not have high-resolution visuals.",
"output": "∀x (¬ImmersiveSound(x) → ¬HighRes(x))"
},
{
"input": "Translate into first-order logic: If a VR headset does not have high-resolution visuals, then it does not have low latency.",
"output": "∀x (¬HighRes(x) → ¬LowLatency(x))"
},
{
"input": "Translate into first-order logic: Every VR headset has high-resolution visuals.",
"output": "∀x HighRes(x)"
},
{
"input": "Translate into first-order logic: If a VR headset is ergonomic, then it has a wide field of view.",
"output": "∀x (Ergonomic(x) → WideFOV(x))"
},
{
"input": "Translate into first-order logic: If a VR headset has a wide field of view, then it has motion tracking.",
"output": "∀x (WideFOV(x) → MotionTracking(x))"
},
{
"input": "Translate into first-order logic: Nam has a GPA of 6.9 after completing 88 credits.",
"output": "GPA(Nam) = 6.9 ∧ AccumulatedCredits(Nam) = 88"
},
{
"input": "Translate into first-order logic: Nam retook 3 previously passed courses: C1 (4 credits, initial 5.2, retake1 7.0, retake2 3.5), C2 (3 credits, initial 6.0, retake1 6.8, retake2 6.0), C3 (5 credits, initial 7.5, retake1 5.0, retake2 4.0).",
"output": "RetakeCourses(Nam) = [C1(4, 5.2, 7.0, 3.5), C2(3, 6.0, 6.8, 6.0), C3(5, 7.5, 5.0, 4.0)]"
},
{
"input": "Translate into first-order logic: Nam repeated one failed course: C4 (3 credits, initial 3.0, repeat 6.5).",
"output": "RepeatCourses(Nam) = [C4(3, 3.0, 6.5)]"
},
{
"input": "Translate into first-order logic: Nam took two new courses: C5 (4 credits, score 8.0), C6 (2 credits, score 3.8).",
"output": "NewCourses(Nam) = [C5(4, 8.0), C6(2, 3.8)]"
},
{
"input": "Translate into first-order logic: A retake is re-registering a passed course (same course code) to improve the grade.",
"output": "RetakeDefinition(c): PassedBefore(c) ∧ SameCourseCode(c) ∧ AttemptToImprove(c)"
},
{
"input": "Translate into first-order logic: For GPA, use the highest score if ≥ 4.0; if all retake scores < 5.0, deduct 0.2 points per credit from the course’s grade points.",
"output": "GPAUsesMaxScore(c): GPA(c) = If Max(Score(All)) ≥ 4.0 then Max else 0; If AllRetakes(c) < 5.0 then Subtract(0.2 × Credits(c))"
},
{
"input": "Translate into first-order logic: Retaking a course does not add credits.",
"output": "CreditsUnchangedWhenRetake(Nam, c)"
},
{
"input": "Translate into first-order logic: Repeating a failed course means re-registering it.",
"output": "RepeatDefinition(c): FailedBefore(c) ∧ ReRegister(c)"
},
{
"input": "Translate into first-order logic: A failed course (score < 4.0) adds no credits.",
"output": "If Score(c) < 4.0 then AccumulatedCredit(c) = 0"
},
{
"input": "Translate into first-order logic: Repeating a failed course adds credits if the new score ≥ 4.0.",
"output": "RepeatCredits(c): If Score(New) ≥ 4.0 then Credit(c) else 0"
},
{
"input": "Translate into first-order logic: A student (Year 2) has 45 credits, withdrew 2 courses in Year 1 (penalty 1 credit), including C1 (4 credits, withdrawn), C2 (3 credits, withdrawn).",
"output": "Student(s1) ∧ Year(s1) = 2 ∧ TotalCredits(s1) = 45 ∧ Withdrawals(s1, Year1) = 2 ∧ TotalCreditsPenalty(s1, -1) ∧ Course(s1, c1, 4, Withdrawn) ∧ Course(s1, c2, 3, Withdrawn)"
},
{
"input": "Translate into first-order logic: In Year 2, semester S1, the student registered for 15 credits, withdrew C3 (5 credits), C4 (3 credits), attempted C5 (4 credits, passed).",
"output": "Courses(s1, Year2, S1) = [c3(5, Withdrawn), c4(3, Withdrawn), c5(4, Passed)] ∧ RegisteredCredits(s1, S1) = 15"
},
{
"input": "Translate into first-order logic: A student has 18 general credits, GPA 2.7, failed C1 (3 credits, grade 1.8, 2 attempts, $100 paid).",
"output": "Student(s1) ∧ GeneralCredits(s1) = 18 ∧ GeneralGPA(s1) = 2.7 ∧ Course(s1, c1, 3, 1.8, Attempts=2) ∧ RetakeFee(s1, c1, 100)"
},
{
"input": "Translate into first-order logic: The student retakes C1 (grade 2.2, $50), passes C2 (3 credits, grade 2.5), pays all fees.",
"output": "Courses(s1) = [c1_reenroll(3, 2.2, Fee=50), c2(3, 2.5)] ∧ FeesPaid(s1)"
},
{
"input": "Translate into first-order logic: Duy has 42 credits, 2 HT courses (Statistics, Economics, 3 credits each), scores pending.",
"output": "Student(Duy) ∧ TotalCredits(Duy) = 42 ∧ HT(Duy, 'Statistics') ∧ HT(Duy, 'Economics') ∧ Course('Statistics', 3) ∧ Course('Economics', 3)"
},
{
"input": "Translate into first-order logic: A student in year 1 has 20 credits, GPA 2.8, 1 violation (GPA penalty 0.1), failed 1 course (3 credits, 1 credit deducted).",
"output": "Student(s1) ∧ Year(s1) = 1 ∧ TotalCredits(s1) = 20 ∧ GPA(s1) = 2.8 ∧ Violations(s1) = 1 ∧ GPAPenalty(s1, 0.1) ∧ FailedCourse(s1, 1) ∧ CreditDeduction(s1, 1)"
},
{
"input": "Translate into first-order logic: In year 2, the student earns 10 credits (GPA 3.0 for new courses), fails 1 course (4 credits, 1 credit deducted), incurs 1 violation.",
"output": "Year(s1) = 2 ∧ NewCredits(s1, 10) ∧ NewGPA(s1, 3.0) ∧ FailedCourse(s1, 1) ∧ CreditDeduction(s1, 1) ∧ Violations(s1, 1)"
},
{
"input": "Translate into first-order logic: A student has a GPA of 7.4 with 60 credits, including two courses: C1 (4 credits, original grade 6.8), C2 (3 credits, original grade 5.5).",
"output": "Student(s1) ∧ GPA(s1) = 7.4 ∧ AccumulatedCredits(s1) = 60 ∧ Course(c1, 4, 6.8) ∧ Course(c2, 3, 5.5)"
},
{
"input": "Translate into first-order logic: For C1, the student retook for improvement three times, scoring 7.2, 3.5 (failed), 6.0.",
"output": "ImprovedGrades(s1, c1) = [Attempt1 = 7.2, Attempt2 = 3.5, Attempt3 = 6.0]"
},
{
"input": "Translate into first-order logic: For C2, the student retook for improvement twice, scoring 6.5, 7.0.",
"output": "ImprovedGrades(s1, c2) = [Attempt1 = 6.5, Attempt2 = 7.0]"
},
{
"input": "Translate into first-order logic: After C1’s failure, the student retook C1 (as a failed course) and scored 5.8.",
"output": "RetakeGrade(s1, c1, Attempt4) = 5.8"
},
{
"input": "Translate into first-order logic: The student took a new course, C3 (5 credits, scored 8.0).",
"output": "NewCourse(s1, c3) = (5, 8.0)"
},
{
"input": "Translate into first-order logic: A student (Year 2) has a GPA of 6.5, 40 credits, withdrew 2 courses in semester S1 (GPA penalty 0.2), including C1 (4 credits, 5.5, withdrawn), C2 (3 credits, 3.8, failed, not withdrawn).",
"output": "Student(s1) ∧ Year(s1) = 2 ∧ GPA(s1) = 6.5 ∧ AccumulatedCredits(s1) = 40 ∧ Withdrawals(s1, S1) = 2 ∧ GPAPenalty(s1, S1, -0.2) ∧ Course(s1, c1, 4, 5.5, Withdrawn) ∧ Course(s1, c2, 3, 3.8, Failed)"
},
{
"input": "Translate into first-order logic: In semester S2, the student withdrew C3 (5 credits, 6.0), attempted C4 (3 credits, 4.5), withdrew C5 (4 credits, 5.0).",
"output": "Courses(s1, S2) = [c3(5, 6.0, Withdrawn), c4(3, 4.5), c5(4, 5.0, Withdrawn)]"
},
{
"input": "Translate into first-order logic: Graduation requires ≥ 120 credits, GPA ≥ 5.0 (scale 0–10), and ≥ 100 hours of CTXH (social work).",
"output": "Graduate(s) ↔ AccumulatedCredits(s) ≥ 120 ∧ GPA(s) ≥ 5.0 ∧ CTXH_Hours(s) ≥ 100"
},
{
"input": "Translate into first-order logic: Students with ≥ 80 credits and < 100 CTXH hours can join extracurriculars, adding 10 CTXH hours.",
"output": "AccumulatedCredits(s) ≥ 80 ∧ CTXH_Hours(s) < 100 → CanJoinExtracurricular(s) ∧ CTXH_Hours(s) += 10"
},
{
"input": "Translate into first-order logic: A student has a GPA of 6.5 with 85 credits and 200 CTXH hours, including C1 (4 credits, grade 5.8, CTXH 15), C2 (5 credits, grade 7.0, CTXH 20).",
"output": "Student(s1) ∧ GPA(s1) = 6.5 ∧ AccumulatedCredits(s1) = 85 ∧ CTXH_Hours(s1) = 200 ∧ Course(s1, c1, 4, 5.8, 15) ∧ Course(s1, c2, 5, 7.0, 20)"
},
{
"input": "Translate into first-order logic: The student retook C1 (grade 3.5, failed), repeated C1 (grade 6.2), took C3 (3 credits, grade 8.0), and C4 (4 credits, grade 3.8, failed).",
"output": "Courses(s1) = [c1_retake(4, 3.5), c1_repeat(4, 6.2), c3(3, 8.0), c4(4, 3.8)]"
},
{
"input": "Translate into first-order logic: The student joined extracurriculars, adding CTXH hours.",
"output": "JoinedExtracurricular(s1) → CTXH_Hours(s1) += 10"
},
{
"input": "Translate into first-order logic: Students begin specialization before internships or projects.",
"output": "StartSpecialization(s) → Before(Internship(s) ∨ Project(s))"
},
{
"input": "Translate into first-order logic: Internship eligibility requires ≥ 80 credits, third year, and GPA ≥ 6.0 (scale 0–10).",
"output": "EligibleInternship(s) ↔ AccumulatedCredits(s) ≥ 80 ∧ Year(s) = 3 ∧ GPA(s) ≥ 6.0"
},
{
"input": "Translate into first-order logic: Major-specific project requires internship completion, ≥ 90 credits, and ≥ 12 social work days.",
"output": "EligibleMajorProject(s) ↔ After(Internship(s)) ∧ AccumulatedCredits(s) ≥ 90 ∧ SocialWorkDays(s) ≥ 12"
},
{
"input": "Translate into first-order logic: Thesis eligibility requires ≥ 100 credits, ≥ 15 social work days, MOS certificate, and language certificate.",
"output": "EligibleThesis(s) ↔ AccumulatedCredits(s) ≥ 100 ∧ SocialWorkDays(s) ≥ 15 ∧ HasMOSCertificate(s) ∧ HasLanguageCertificate(s)"
},
{
"input": "Translate into first-order logic: Graduation requires thesis completion, GPA ≥ 5.0, and ≥ 20 social work days.",
"output": "Graduate(s) ↔ CompletedThesis(s) ∧ GPA(s) ≥ 5.0 ∧ SocialWorkDays(s) ≥ 20"
},
{
"input": "Translate into first-order logic: A student has a GPA of 6.8 with 82 credits, including C1 (4 credits, grade 5.5, failed retake at 3.8), C2 (3 credits, grade 7.0).",
"output": "Student(s1) ∧ GPA(s1) = 6.8 ∧ AccumulatedCredits(s1) = 82 ∧ Course(s1, c1, 4, 5.5, Retake=3.8) ∧ Course(s1, c2, 3, 7.0)"
},
{
"input": "Translate into first-order logic: The student took C3 (5 credits, grade 8.0), repeated C1 (grade 6.0), and took C4 (4 credits, grade 3.5, failed).",
"output": "NewCourses(s1) = [c3(5, 8.0), c1_repeat(4, 6.0), c4(4, 3.5)]"
},
{
"input": "Translate into first-order logic: Minh’s initial courses: 6 credits at 8.0, 9 credits at 7.7.",
"output": "initialCourses(Minh) = [(8.0, 6), (7.7, 9)]"
},
{
"input": "Translate into first-order logic: A student has 15 credits, paid $400 tuition, 2 violations ($50 unpaid), no official schedule.",
"output": "Student(s1) ∧ TotalCredits(s1) = 15 ∧ TuitionPaid(s1, s1, 400) ∧ Violations(s1) = 2 ∧ Penalty(s1, 50) ∧ UnpaidPenalty(s1) ∧ ¬HasOfficialSchedule(s1)"
},
{
"input": "Translate into first-order logic: The student pays $200 more tuition, clears 1 violation ($25), enrolls 14 credits (schedule granted), incurs 1 new violation ($25).",
"output": "TuitionPaid(s1, s2, 200) ∧ ViolationsCleared(s1, 1) ∧ PenaltyPaid(s1, 25) ∧ RegisteredCredits(s1, s2, 14) ∧ HasOfficialSchedule(s1) ∧ Violations(s1, 1) ∧ Penalty(s1, 25)"
},
{
"input": "Translate into first-order logic: Graduation requires ≥ 130 credits, GPA ≥ 5.5 (scale 0–10), ≥ 120 CTXH hours, and a certificate.",
"output": "Graduate(s) ↔ AccumulatedCredits(s) ≥ 130 ∧ GPA(s) ≥ 5.5 ∧ CTXH_Hours(s) ≥ 120 ∧ HasCertificate(s)"
},
{
"input": "Translate into first-order logic: Social activities contribute CTXH: club = 20 hours, event = 10 hours; requires ≥ 50 credits to join.",
"output": "AccumulatedCredits(s) ≥ 50 → (Club(s) → CTXH_Hours(s) += 20) ∧ (Event(s) → CTXH_Hours(s) += 10)"
},
{
"input": "Translate into first-order logic: Students with GPA < 6.0 get 0.5 CTXH hours per credit instead of standard course hours.",
"output": "GPA(s) < 6.0 → CTXH_Hours(c) = 0.5 × AccumulatedCredits(c)"
},
{
"input": "Translate into first-order logic: A student has a GPA of 5.8 with 90 credits, 180 CTXH hours, no certificate, including C1 (3 credits, grade 6.0, CTXH 0), C2 (4 credits, grade 5.5, CTXH 0).",
"output": "Student(s1) ∧ GPA(s1) = 5.8 ∧ AccumulatedCredits(s1) = 90 ∧ CTXH_Hours(s1) = 180 ∧ ¬HasCertificate(s1) ∧ Course(s1, c1, 3, 6.0, 0) ∧ Course(s1, c2, 4, 5.5, 0)"
},
{
"input": "Translate into first-order logic: The student took C3 (5 credits, grade 7.0), C4 (3 credits, grade 3.8, failed), joined 2 clubs and 3 events.",
"output": "Courses(s1) = [c3(5, 7.0), c4(3, 3.8)] ∧ Clubs(s1) = 2 ∧ Events(s1) = 3"
},
{
"input": "Translate into first-order logic: Student takes 4 group A courses (grades: 8.0, 7.0, 9.0, 6.5; 6 credits each), 4 group B courses (6.0, 7.5, 8.0, 8.5; 4 credits each), 2 group C courses (7.0, 8.0; 3 credits each); group A is non-major.",
"output": "Courses(x) = {A: [(8.0, 6), (7.0, 6), (9.0, 6), (6.5, 6)], B: [(6.0, 4), (7.5, 4), (8.0, 4), (8.5, 4)], C: [(7.0, 3), (8.0, 3)]} ∧ ¬MajorCourse(A)"
},
{
"input": "Translate into first-order logic: Total program credits are 120; internship eligibility requires ≥ 78 credits (65%), GPA ≥ 6.0 (scale 0–10), and ≥ 50 internship prep hours.",
"output": "TotalCredits = 120 ∧ EligibleForInternship(s) ↔ AccumulatedCredits(s, accumulatedcredits) ≥ 78 ∧ GPA(s, gpa) ∧ gpa ≥ 6.0 ∧ PrepHours(s, prephours) ∧ prephours ≥ 50"
},
{
"input": "Translate into first-order logic: Third-year students (Year 3) with < 78 credits can join prep workshops (20 hours), if GPA ≥ 5.5.",
"output": "Year(x, y) ∧ y = 3 ∧ AccumulatedCredits(x, accumulatedcredits) < 78 ∧ GPA(x, gpa) ∧ gpa ≥ 5.5 → PrepHours(x) += 20"
},
{
"input": "Translate into first-order logic: A student (Year 2) has a GPA of 6.2, 80 credits, 120 prep hours, including C1 (3 credits, 5.8, 5 hours), C2 (4 credits, 6.5, 7 hours).",
"output": "Student(s1) ∧ Year(s1) = 2 ∧ GPA(s1) = 6.2 ∧ AccumulatedCredits(s1) = 80 ∧ PrepHours(s1) = 120 ∧ Course(s1, c1, 3, 5.8, 5) ∧ Course(s1, c2, 4, 6.5, 7)"
},
{
"input": "Translate into first-order logic: The student took C3 (5 credits, 7.0), retook C1 (6.8), took C4 (3 credits, 3.5, failed).",
"output": "Courses(s1) = [c3(5, 7.0), c1_retake(3, 6.8), c4(3, 3.5)]"
},
{
"input": "Translate into first-order logic: Thesis eligibility requires ≥ 100 credits, GPA ≥ 5.5 (scale 0–10), capstone completion, and ≥ 80 capstone hours.",
"output": "EligibleForThesis(s) ↔ AccumulatedCredits(s, accumulatedcredits) ∧ accumulatedcredits ≥ 100 ∧ GPA(s, gpa) ∧ gpa ≥ 5.5 ∧ CompletedCapstone(s) ∧ CapstoneHours(s, caphours) ∧ caphours ≥ 80"
},
{
"input": "Translate into first-order logic: Capstone completion requires ≥ 80 credits and a 5-credit capstone course (grade ≥ 4.0).",
"output": "CompletedCapstone(s) ↔ AccumulatedCredits(s) ≥ 80 ∧ ∃c: CapstoneCourse(c) ∧ Credits(c) = 5 ∧ Grade(c) ≥ 4.0"
},
{
"input": "Translate into first-order logic: Final-year students (Year 4) with capstone but < 80 hours can join capstone workshops (15 hours), if GPA ≥ 5.0.",
"output": "Year(x) = 4 ∧ CompletedCapstone(x) ∧ CapstoneHours(x) < 80 ∧ GPA(x) ≥ 5.0 → CapstoneHours(x) += 15"
},
{
"input": "Translate into first-order logic: A student (Year 3) has a GPA of 5.8, 85 credits, 100 capstone hours, no capstone course, including C1 (3 credits, 6.0, 6 hours), C2 (4 credits, 5.5, 8 hours).",
"output": "Student(s1) ∧ Year(s1) = 3 ∧ GPA(s1) = 5.8 ∧ AccumulatedCredits(s1) = 85 ∧ CapstoneHours(s1) = 100 ∧ ¬CompletedCapstone(s1) ∧ Course(s1, c1, 3, 6.0, 6) ∧ Course(s1, c2, 4, 5.5, 8)"
},
{
"input": "Translate into first-order logic: The student took capstone course C3 (5 credits, 4.5), retook C1 (6.5), took C4 (3 credits, 3.8, failed), joined 2 workshops.",
"output": "Courses(s1) = [c3_capstone(5, 4.5), c1_retake(3, 6.5), c4(3, 3.8)] ∧ Workshops(s1) = 2"
},
{
"input": "Translate into first-order logic: All people who regularly drink coffee are dependent on caffeine.",
"output": "∀x (Drinks(x) → Dependent(x))"
},
{
"input": "Translate into first-order logic: People either regularly drink coffee or joke about being addicted to caffeine.",
"output": "∀x (Drinks(x) ⊕ Jokes(x))"
},
{
"input": "Translate into first-order logic: No one who jokes about being addicted to caffeine is unaware that caffeine is a drug.",
"output": "∀x (Jokes(x) → ¬Unaware(x))"
},
{
"input": "Translate into first-order logic: Rina is either a student and unaware that caffeine is a drug, or neither a student nor unaware that caffeine is a drug.",
"output": "(Student(rina) ∧ Unaware(rina)) ⊕ ¬(Student(rina) ∨ Unaware(rina))"
},
{
"input": "Translate into first-order logic: If Rina is not a person dependent on caffeine and a student, then Rina is either a person dependent on caffeine and a student, or neither a person dependent on caffeine nor a student.",
"output": "¬(Dependent(rina) ∧ Student(rina)) → (Dependent(rina) ∧ Student(rina)) ⊕ ¬(Dependent(rina) ∨ Student(rina))"
},
{
"input": "Translate into first-order logic: All people who regularly drink coffee are dependent on caffeine.",
"output": "∀x (Drinks(x) → Dependent(x))"
},
{
"input": "Translate into first-order logic: People either regularly drink coffee or joke about being addicted to caffeine.",
"output": "∀x (Drinks(x) ⊕ Jokes(x))"
},
{
"input": "Translate into first-order logic: No one who jokes about being addicted to caffeine is unaware that caffeine is a drug.",
"output": "∀x (Jokes(x) → ¬Unaware(x))"
},
{
"input": "Translate into first-order logic: Rina is either a student and unaware that caffeine is a drug, or neither a student nor unaware that caffeine is a drug.",
"output": "(Student(rina) ∧ Unaware(rina)) ⊕ ¬(Student(rina) ∨ Unaware(rina))"
},
{
"input": "Translate into first-order logic: If Rina is not a person dependent on caffeine and a student, then Rina is either a person dependent on caffeine and a student, or neither a person dependent on caffeine nor a student.",
"output": "¬(Dependent(rina) ∧ Student(rina)) → (Dependent(rina) ∧ Student(rina)) ⊕ ¬(Dependent(rina) ∨ Student(rina))"
},
{
"input": "Translate into first-order logic: All people who regularly drink coffee are dependent on caffeine.",
"output": "∀x (Drinks(x) → Dependent(x))"
},
{
"input": "Translate into first-order logic: People either regularly drink coffee or joke about being addicted to caffeine.",
"output": "∀x (Drinks(x) ⊕ Jokes(x))"
},
{
"input": "Translate into first-order logic: No one who jokes about being addicted to caffeine is unaware that caffeine is a drug.",
"output": "∀x (Jokes(x) → ¬Unaware(x))"
},
{
"input": "Translate into first-order logic: Rina is either a student and unaware that caffeine is a drug, or neither a student nor unaware that caffeine is a drug.",
"output": "(Student(rina) ∧ Unaware(rina)) ⊕ ¬(Student(rina) ∨ Unaware(rina))"
},
{
"input": "Translate into first-order logic: If Rina is not a person dependent on caffeine and a student, then Rina is either a person dependent on caffeine and a student, or neither a person dependent on caffeine nor a student.",
"output": "¬(Dependent(rina) ∧ Student(rina)) → (Dependent(rina) ∧ Student(rina)) ⊕ ¬(Dependent(rina) ∨ Student(rina))"
},
{
"input": "Translate into first-order logic: All people who regularly drink coffee are dependent on caffeine.",
"output": "∀x (Drinks(x) → Dependent(x))"
},
{
"input": "Translate into first-order logic: People either regularly drink coffee or joke about being addicted to caffeine.",
"output": "∀x (Drinks(x) ⊕ Jokes(x))"
},
{
"input": "Translate into first-order logic: No one who jokes about being addicted to caffeine is unaware that caffeine is a drug.",
"output": "∀x (Jokes(x) → ¬Unaware(x))"
},
{
"input": "Translate into first-order logic: Rina is either a student and unaware that caffeine is a drug, or neither a student nor unaware that caffeine is a drug.",
"output": "(Student(rina) ∧ Unaware(rina)) ⊕ ¬(Student(rina) ∨ Unaware(rina))"
},
{
"input": "Translate into first-order logic: If Rina is not a person dependent on caffeine and a student, then Rina is either a person dependent on caffeine and a student, or neither a person dependent on caffeine nor a student.",
"output": "¬(Dependent(rina) ∧ Student(rina)) → (Dependent(rina) ∧ Student(rina)) ⊕ ¬(Dependent(rina) ∨ Student(rina))"
},
{
"input": "Translate into first-order logic: Miroslav Venhoda was a Czech choral conductor who specialized in the performance of Renaissance and Baroque music.",
"output": "Czech(miroslav) ∧ ChoralConductor(miroslav) ∧ Specialize(miroslav, renaissance) ∧ Specialize(miroslav, baroque)"
},
{
"input": "Translate into first-order logic: Any choral conductor is a musician.",
"output": "∀x (ChoralConductor(x) → Musician(x))"
},
{
"input": "Translate into first-order logic: Some musicians love music.",
"output": "∃x (Musician(x) → Love(x, music))"
},
{
"input": "Translate into first-order logic: Miroslav Venhoda published a book in 1946 called Method of Studying Gregorian Chant.",
"output": "Book(methodOfStudyingGregorianChant) ∧ Author(miroslav, methodOfStudyingGregorianChant) ∧ Publish(methodOfStudyingGregorianChant, year1946)"
},
{
"input": "Translate into first-order logic: Miroslav Venhoda was a Czech choral conductor who specialized in the performance of Renaissance and Baroque music.",
"output": "Czech(miroslav) ∧ ChoralConductor(miroslav) ∧ Specialize(miroslav, renaissance) ∧ Specialize(miroslav, baroque)"
},
{
"input": "Translate into first-order logic: Any choral conductor is a musician.",
"output": "∀x (ChoralConductor(x) → Musician(x))"
},
{
"input": "Translate into first-order logic: Some musicians love music.",
"output": "∃x (Musician(x) → Love(x, music))"
},
{
"input": "Translate into first-order logic: Miroslav Venhoda published a book in 1946 called Method of Studying Gregorian Chant.",
"output": "Book(methodOfStudyingGregorianChant) ∧ Author(miroslav, methodOfStudyingGregorianChant) ∧ Publish(methodOfStudyingGregorianChant, year1946)"
},
{
"input": "Translate into first-order logic: Miroslav Venhoda was a Czech choral conductor who specialized in the performance of Renaissance and Baroque music.",
"output": "Czech(miroslav) ∧ ChoralConductor(miroslav) ∧ Specialize(miroslav, renaissance) ∧ Specialize(miroslav, baroque)"
},
{
"input": "Translate into first-order logic: Any choral conductor is a musician.",
"output": "∀x (ChoralConductor(x) → Musician(x))"
},
{
"input": "Translate into first-order logic: Some musicians love music.",
"output": "∃x (Musician(x) → Love(x, music))"
},
{
"input": "Translate into first-order logic: Miroslav Venhoda published a book in 1946 called Method of Studying Gregorian Chant.",
"output": "Book(methodOfStudyingGregorianChant) ∧ Author(miroslav, methodOfStudyingGregorianChant) ∧ Publish(methodOfStudyingGregorianChant, year1946)"
},
{
"input": "Translate into first-order logic: All eels are fish.",
"output": "∀x  (Eel (x)→  Fish (x))"
},
{
"input": "Translate into first-order logic: No fish are plants.",
"output": "∀x  (Fish (x)→ ¬ Plant (x))"
},
{
"input": "Translate into first-order logic: A thing is either a plant or animal.",
"output": "∀x ( Plant (x) ∨  Animal (x))"
},
{
"input": "Translate into first-order logic: Nothing that breathes is paper.",
"output": "∀x  (Breathe (x)→ ¬ Paper (x))"
},
{
"input": "Translate into first-order logic: All animals breathe.",
"output": "∀x  (Animal (x)→  Breathe (x))"
},
{
"input": "Translate into first-order logic: If a sea eel is either an eel or a plant, then a sea eel is an eel or an animal.",
"output": " Eel (seaEel) ⊕ Plant (seaEel) → Eel (seaEel) ∨ Animal (seaEel) "
},
{
"input": "Translate into first-order logic: All eels are fish.",
"output": "∀x  (Eel (x)→  Fish (x))"
},
{
"input": "Translate into first-order logic: No fish are plants.",
"output": "∀x  (Fish (x)→ ¬ Plant (x))"
},
{
"input": "Translate into first-order logic: A thing is either a plant or animal.",
"output": "∀x ( Plant (x) ∨  Animal (x))"
},
{
"input": "Translate into first-order logic: Nothing that breathes is paper.",
"output": "∀x  (Breathe (x)→ ¬ Paper (x))"
},
{
"input": "Translate into first-order logic: All animals breathe.",
"output": "∀x  (Animal (x)→  Breathe (x))"
},
{
"input": "Translate into first-order logic: If a sea eel is either an eel or a plant, then a sea eel is an eel or an animal.",
"output": " Eel (seaEel) ⊕ Plant (seaEel) → Eel (seaEel) ∨ Animal (seaEel) "
},
{
"input": "Translate into first-order logic: All eels are fish.",
"output": "∀x  (Eel (x)→  Fish (x))"
},
{
"input": "Translate into first-order logic: No fish are plants.",
"output": "∀x  (Fish (x)→ ¬ Plant (x))"
},
{
"input": "Translate into first-order logic: A thing is either a plant or animal.",
"output": "∀x ( Plant (x) ∨  Animal (x))"
},
{
"input": "Translate into first-order logic: Nothing that breathes is paper.",
"output": "∀x  (Breathe (x)→ ¬ Paper (x))"
},
{
"input": "Translate into first-order logic: All animals breathe.",
"output": "∀x  (Animal (x)→  Breathe (x))"
},
{
"input": "Translate into first-order logic: If a sea eel is either an eel or a plant, then a sea eel is an eel or an animal.",
"output": " Eel (seaEel) ⊕ Plant (seaEel) → Eel (seaEel) ∨ Animal (seaEel) "
},
{
"input": "Translate into first-order logic: The Blake McFall Company Building is a commercial warehouse listed on the National Register of Historic Places.",
"output": "∀x (Blake(x) → Building(x))"
},
{
"input": "Translate into first-order logic: The Blake McFall Company Building was added to the National Register of Historic Places in 1990.",
"output": "∀x (Blake(x) → Historic(x, year1990))"
},
{
"input": "Translate into first-order logic: The Emmet Building is a five-story building in Portland, Oregon.",
"output": "∀x (Emmet(x) → Building(x) ∧ FiveStory(x) ∧ Locate(x, portland))"
},
{
"input": "Translate into first-order logic: The Emmet Building was built in 1915.",
"output": "∀x (Emmet(x) → Construct(x, year1915))"
},
{
"input": "Translate into first-order logic: The Emmet Building is another name for the Blake McFall Company Building.",
"output": "∀x (Emmet(x) ↔ Blake(x))"
},
{
"input": "Translate into first-order logic: John works at the Emmet Building.",
"output": "∃x (Emmet(x) ∧ Work(john, x))"
},
{
"input": "Translate into first-order logic: The Blake McFall Company Building is a commercial warehouse listed on the National Register of Historic Places.",
"output": "∀x (Blake(x) → Building(x))"
},
{
"input": "Translate into first-order logic: The Blake McFall Company Building was added to the National Register of Historic Places in 1990.",
"output": "∀x (Blake(x) → Historic(x, year1990))"
},
{
"input": "Translate into first-order logic: The Emmet Building is a five-story building in Portland, Oregon.",
"output": "∀x (Emmet(x) → Building(x) ∧ FiveStory(x) ∧ Locate(x, portland))"
},
{
"input": "Translate into first-order logic: The Emmet Building was built in 1915.",
"output": "∀x (Emmet(x) → Construct(x, year1915))"
},
{
"input": "Translate into first-order logic: The Emmet Building is another name for the Blake McFall Company Building.",
"output": "∀x (Emmet(x) ↔ Blake(x))"
},
{
"input": "Translate into first-order logic: John works at the Emmet Building.",
"output": "∃x (Emmet(x) ∧ Work(john, x))"
},
{
"input": "Translate into first-order logic: The Blake McFall Company Building is a commercial warehouse listed on the National Register of Historic Places.",
"output": "∀x (Blake(x) → Building(x))"
},
{
"input": "Translate into first-order logic: The Blake McFall Company Building was added to the National Register of Historic Places in 1990.",
"output": "∀x (Blake(x) → Historic(x, year1990))"
},
{
"input": "Translate into first-order logic: The Emmet Building is a five-story building in Portland, Oregon.",
"output": "∀x (Emmet(x) → Building(x) ∧ FiveStory(x) ∧ Locate(x, portland))"
},
{
"input": "Translate into first-order logic: The Emmet Building was built in 1915.",
"output": "∀x (Emmet(x) → Construct(x, year1915))"
},
{
"input": "Translate into first-order logic: The Emmet Building is another name for the Blake McFall Company Building.",
"output": "∀x (Emmet(x) ↔ Blake(x))"
},
{
"input": "Translate into first-order logic: John works at the Emmet Building.",
"output": "∃x (Emmet(x) ∧ Work(john, x))"
},
{
"input": "Translate into first-order logic: William Dickinson was a British politician who sat in the House of Commons",
"output": "BritishPolitician(williamdickinson) ∧ SatInHouseOfCommons(williamdickinson)"
},
{
"input": "Translate into first-order logic: William Dickinson attended Westminster school for high school and then the University of Edinburgh.",
"output": "Attended(williamdickinson, westminster) ∧ Highschool(westminster) ∧ Attended(williamdickinson, universityofedinburgh)"
},
{
"input": "Translate into first-order logic: The University of Edinburgh is a university located in the United Kingdom.",
"output": "LocatedIn(universityofedinburgh, unitedkingdom) ∧ University(universityofedinburgh)"
},
{
"input": "Translate into first-order logic: William Dickinson supported the Portland Whigs.",
"output": "Supported(williamdickinson, portlandwhigs)"
},
{
"input": "Translate into first-order logic: People who supported the Portland Whigs did not get a seat in the Parliament.",
"output": "∀x (Supported(x, portlandwhigs) → ¬SeatInParliament(x))"
},
{
"input": "Translate into first-order logic: William Dickinson was a British politician who sat in the House of Commons",
"output": "BritishPolitician(williamdickinson) ∧ SatInHouseOfCommons(williamdickinson)"
},
{
"input": "Translate into first-order logic: William Dickinson attended Westminster school for high school and then the University of Edinburgh.",
"output": "Attended(williamdickinson, westminster) ∧ Highschool(westminster) ∧ Attended(williamdickinson, universityofedinburgh)"
},
{
"input": "Translate into first-order logic: The University of Edinburgh is a university located in the United Kingdom.",
"output": "LocatedIn(universityofedinburgh, unitedkingdom) ∧ University(universityofedinburgh)"
},
{
"input": "Translate into first-order logic: William Dickinson supported the Portland Whigs.",
"output": "Supported(williamdickinson, portlandwhigs)"
},
{
"input": "Translate into first-order logic: People who supported the Portland Whigs did not get a seat in the Parliament.",
"output": "∀x (Supported(x, portlandwhigs) → ¬SeatInParliament(x))"
},
{
"input": "Translate into first-order logic: William Dickinson was a British politician who sat in the House of Commons",
"output": "BritishPolitician(williamdickinson) ∧ SatInHouseOfCommons(williamdickinson)"
},
{
"input": "Translate into first-order logic: William Dickinson attended Westminster school for high school and then the University of Edinburgh.",
"output": "Attended(williamdickinson, westminster) ∧ Highschool(westminster) ∧ Attended(williamdickinson, universityofedinburgh)"
},
{
"input": "Translate into first-order logic: The University of Edinburgh is a university located in the United Kingdom.",
"output": "LocatedIn(universityofedinburgh, unitedkingdom) ∧ University(universityofedinburgh)"
},
{
"input": "Translate into first-order logic: William Dickinson supported the Portland Whigs.",
"output": "Supported(williamdickinson, portlandwhigs)"
},
{
"input": "Translate into first-order logic: People who supported the Portland Whigs did not get a seat in the Parliament.",
"output": "∀x (Supported(x, portlandwhigs) → ¬SeatInParliament(x))"
},
{
"input": "Translate into first-order logic: William Dickinson was a British politician who sat in the House of Commons",
"output": "BritishPolitician(williamdickinson) ∧ SatInHouseOfCommons(williamdickinson)"
},
{
"input": "Translate into first-order logic: William Dickinson attended Westminster school for high school and then the University of Edinburgh.",
"output": "Attended(williamdickinson, westminster) ∧ Highschool(westminster) ∧ Attended(williamdickinson, universityofedinburgh)"
},
{
"input": "Translate into first-order logic: The University of Edinburgh is a university located in the United Kingdom.",
"output": "LocatedIn(universityofedinburgh, unitedkingdom) ∧ University(universityofedinburgh)"
},
{
"input": "Translate into first-order logic: William Dickinson supported the Portland Whigs.",
"output": "Supported(williamdickinson, portlandwhigs)"
},
{
"input": "Translate into first-order logic: People who supported the Portland Whigs did not get a seat in the Parliament.",
"output": "∀x (Supported(x, portlandwhigs) → ¬SeatInParliament(x))"
},
{
"input": "Translate into first-order logic: LanguageA is a universal language",
"output": "UniversalLanguage(languageA)"
},
{
"input": "Translate into first-order logic: If a universal language exists, then for every two people if they both know the same universal language they can communicate.",
"output": "∀x ∀y (∃z (Know(x, z) ∧ Know(y, z) ∧ UniversalLanguage(z)) → Communicate(x, y))"
},
{
"input": "Translate into first-order logic: Katya cannot communicate with Danil.",
"output": "Know(katya, languageA)"
},
{
"input": "Translate into first-order logic: Katya knows LanguageA.",
"output": "¬Communicate(katya, danil)"
},
{
"input": "Translate into first-order logic: All customers who are subscribed to AMC List are available to watch 3 movies every week without any additional fees.",
"output": "∀x (AMC(x) → ThreeMovies(x))"
},
{
"input": "Translate into first-order logic: Some customers go to cinemas every week",
"output": "∃x (CinemaEveryWeek(x))"
},
{
"input": "Translate into first-order logic: Customers either subscribe to AMC service or HBO service.",
"output": "∀x (AMC(x) ∨ HBO(x))"
},
{
"input": "Translate into first-order logic: Customers who prefer TV series more and will not watch TV series in cinemas.",
"output": "∀x (PreferTVSeries(x) → ¬WatchTVInCinema(x))"
},
{
"input": "Translate into first-order logic: All customers who subscribe to HBO services prefer TV series to movies.",
"output": "∀x (HBO(x) → PreferTVSeries(x))"
},
{
"input": "Translate into first-order logic: James watches TV series in cinemas.",
"output": "WatchTVInCinema(james)"
},
{
"input": "Translate into first-order logic: All customers who are subscribed to AMC List are available to watch 3 movies every week without any additional fees.",
"output": "∀x (AMC(x) → ThreeMovies(x))"
},
{
"input": "Translate into first-order logic: Some customers go to cinemas every week",
"output": "∃x (CinemaEveryWeek(x))"
},
{
"input": "Translate into first-order logic: Customers either subscribe to AMC service or HBO service.",
"output": "∀x (AMC(x) ∨ HBO(x))"
},
{
"input": "Translate into first-order logic: Customers who prefer TV series more and will not watch TV series in cinemas.",
"output": "∀x (PreferTVSeries(x) → ¬WatchTVInCinema(x))"
},
{
"input": "Translate into first-order logic: All customers who subscribe to HBO services prefer TV series to movies.",
"output": "∀x (HBO(x) → PreferTVSeries(x))"
},
{
"input": "Translate into first-order logic: James watches TV series in cinemas.",
"output": "WatchTVInCinema(james)"
},
{
"input": "Translate into first-order logic: All customers who are subscribed to AMC List are available to watch 3 movies every week without any additional fees.",
"output": "∀x (AMC(x) → ThreeMovies(x))"
},
{
"input": "Translate into first-order logic: Some customers go to cinemas every week",
"output": "∃x (CinemaEveryWeek(x))"
},
{
"input": "Translate into first-order logic: Customers either subscribe to AMC service or HBO service.",
"output": "∀x (AMC(x) ∨ HBO(x))"
},
{
"input": "Translate into first-order logic: Customers who prefer TV series more and will not watch TV series in cinemas.",
"output": "∀x (PreferTVSeries(x) → ¬WatchTVInCinema(x))"
},
{
"input": "Translate into first-order logic: All customers who subscribe to HBO services prefer TV series to movies.",
"output": "∀x (HBO(x) → PreferTVSeries(x))"
},
{
"input": "Translate into first-order logic: James watches TV series in cinemas.",
"output": "WatchTVInCinema(james)"
},
{
"input": "Translate into first-order logic: All customers who are subscribed to AMC List are available to watch 3 movies every week without any additional fees.",
"output": "∀x (AMC(x) → ThreeMovies(x))"
},
{
"input": "Translate into first-order logic: Some customers go to cinemas every week",
"output": "∃x (CinemaEveryWeek(x))"
},
{
"input": "Translate into first-order logic: Customers either subscribe to AMC service or HBO service.",
"output": "∀x (AMC(x) ∨ HBO(x))"
},
{
"input": "Translate into first-order logic: Customers who prefer TV series more and will not watch TV series in cinemas.",
"output": "∀x (PreferTVSeries(x) → ¬WatchTVInCinema(x))"
},
{
"input": "Translate into first-order logic: All customers who subscribe to HBO services prefer TV series to movies.",
"output": "∀x (HBO(x) → PreferTVSeries(x))"
},
{
"input": "Translate into first-order logic: James watches TV series in cinemas.",
"output": "WatchTVInCinema(james)"
},
{
"input": "Translate into first-order logic: All customers who are subscribed to AMC List are available to watch 3 movies every week without any additional fees.",
"output": "∀x (AMC(x) → ThreeMovies(x))"
},
{
"input": "Translate into first-order logic: Some customers go to cinemas every week",
"output": "∃x (CinemaEveryWeek(x))"
},
{
"input": "Translate into first-order logic: Customers either subscribe to AMC service or HBO service.",
"output": "∀x (AMC(x) ∨ HBO(x))"
},
{
"input": "Translate into first-order logic: Customers who prefer TV series more and will not watch TV series in cinemas.",
"output": "∀x (PreferTVSeries(x) → ¬WatchTVInCinema(x))"
},
{
"input": "Translate into first-order logic: All customers who subscribe to HBO services prefer TV series to movies.",
"output": "∀x (HBO(x) → PreferTVSeries(x))"
},
{
"input": "Translate into first-order logic: James watches TV series in cinemas.",
"output": "WatchTVInCinema(james)"
},
{
"input": "Translate into first-order logic: A La Liga soccer team ranks higher than another if it receives more points.",
"output": "∀x ∀y (LaLiga(x) ∧ LaLiga(y) ∧ MorePoints(x, y) → HigherRank(x, y))"
},
{
"input": "Translate into first-order logic: If two La Liga soccer teams recieve the same points, the team which recieves more points from the games between the two teams ranks higher.",
"output": "∀x ∀y (LaLiga(x) ∧ LaLiga(y) ∧ ¬MorePoints(x, y) ∧ ¬MorePoints(y, x) ∧ MorePointsInGameBetween(x, y) → HigherRank(x, y))"
},
{
"input": "Translate into first-order logic: Real Madrid and Barcelona are both La Liga soccer teams.",
"output": "LaLiga(realMadrid) ∧ LaLiga(barcelona)"
},
{
"input": "Translate into first-order logic: In La Liga 2021-2022, Real Madrid recieves 86 points and Barcelon recieves 73 points.",
"output": "MorePoints(realMadrid, barcelona)"
},
{
"input": "Translate into first-order logic: In La Liga 2021-2022, Real Madrid and Barcelona both recieve 3 points from the games between them.",
"output": "¬MorePointsInGameBetween(realMadrid, barcelona) ∧ ¬MorePointsInGameBetween(barcelona, realMadrid)"
},
{
"input": "Translate into first-order logic: A La Liga soccer team ranks higher than another if it receives more points.",
"output": "∀x ∀y (LaLiga(x) ∧ LaLiga(y) ∧ MorePoints(x, y) → HigherRank(x, y))"
},
{
"input": "Translate into first-order logic: If two La Liga soccer teams recieve the same points, the team which recieves more points from the games between the two teams ranks higher.",
"output": "∀x ∀y (LaLiga(x) ∧ LaLiga(y) ∧ ¬MorePoints(x, y) ∧ ¬MorePoints(y, x) ∧ MorePointsInGameBetween(x, y) → HigherRank(x, y))"
},
{
"input": "Translate into first-order logic: Real Madrid and Barcelona are both La Liga soccer teams.",
"output": "LaLiga(realMadrid) ∧ LaLiga(barcelona)"
},
{
"input": "Translate into first-order logic: In La Liga 2021-2022, Real Madrid recieves 86 points and Barcelon recieves 73 points.",
"output": "MorePoints(realMadrid, barcelona)"
},
{
"input": "Translate into first-order logic: In La Liga 2021-2022, Real Madrid and Barcelona both recieve 3 points from the games between them.",
"output": "¬MorePointsInGameBetween(realMadrid, barcelona) ∧ ¬MorePointsInGameBetween(barcelona, realMadrid)"
},
{
"input": "Translate into first-order logic: Lawton Park is a neighbourhood in Seattle.",
"output": "Neighbourhoodin(lawtonPark, seattle)"
},
{
"input": "Translate into first-order logic: All citizens of Lawton Park use the zip code 98199.",
"output": "∀x (Citizenof(x, lawtonPark) → Usezipcode(x, number98199))"
},
{
"input": "Translate into first-order logic: Tom is a citizen of Lawton Park.",
"output": "Citizenof(tom, lawtonPark)"
},
{
"input": "Translate into first-order logic: Daniel uses the zip code 98199.",
"output": "Usezipcode(daniel, number98199)"
},
{
"input": "Translate into first-order logic: Lawton Park is a neighbourhood in Seattle.",
"output": "Neighbourhoodin(lawtonPark, seattle)"
},
{
"input": "Translate into first-order logic: All citizens of Lawton Park use the zip code 98199.",
"output": "∀x (Citizenof(x, lawtonPark) → Usezipcode(x, number98199))"
},
{
"input": "Translate into first-order logic: Tom is a citizen of Lawton Park.",
"output": "Citizenof(tom, lawtonPark)"
},
{
"input": "Translate into first-order logic: Daniel uses the zip code 98199.",
"output": "Usezipcode(daniel, number98199)"
},
{
"input": "Translate into first-order logic: Lawton Park is a neighbourhood in Seattle.",
"output": "Neighbourhoodin(lawtonPark, seattle)"
},
{
"input": "Translate into first-order logic: All citizens of Lawton Park use the zip code 98199.",
"output": "∀x (Citizenof(x, lawtonPark) → Usezipcode(x, number98199))"
},
{
"input": "Translate into first-order logic: Tom is a citizen of Lawton Park.",
"output": "Citizenof(tom, lawtonPark)"
},
{
"input": "Translate into first-order logic: Daniel uses the zip code 98199.",
"output": "Usezipcode(daniel, number98199)"
},
{
"input": "Translate into first-order logic: Lawton Park is a neighbourhood in Seattle.",
"output": "Neighbourhoodin(lawtonPark, seattle)"
},
{
"input": "Translate into first-order logic: All citizens of Lawton Park use the zip code 98199.",
"output": "∀x (Citizenof(x, lawtonPark) → Usezipcode(x, number98199))"
},
{
"input": "Translate into first-order logic: Tom is a citizen of Lawton Park.",
"output": "Citizenof(tom, lawtonPark)"
},
{
"input": "Translate into first-order logic: Daniel uses the zip code 98199.",
"output": "Usezipcode(daniel, number98199)"
},
{
"input": "Translate into first-order logic: If a legislator is found guilty of stealing government funds, they will be suspended from office.",
"output": "∀x (IsLegislator(x) ∧ StealsFunds(x) → Suspended(x))"
},
{
"input": "Translate into first-order logic: Tiffany T. Alston was a legislator in Maryland's House of Delegates from 2011 to 2013.",
"output": "IsLegislator(tiffanyTAlston)"
},
{
"input": "Translate into first-order logic: Tiffany T. Alston was found guilty of stealing government funds in 2012.",
"output": "StealsFunds(tiffanyTAlston)"
},
{
"input": "Translate into first-order logic: If a legislator is found guilty of stealing government funds, they will be suspended from office.",
"output": "∀x (IsLegislator(x) ∧ StealsFunds(x) → Suspended(x))"
},
{
"input": "Translate into first-order logic: Tiffany T. Alston was a legislator in Maryland's House of Delegates from 2011 to 2013.",
"output": "IsLegislator(tiffanyTAlston)"
},
{
"input": "Translate into first-order logic: Tiffany T. Alston was found guilty of stealing government funds in 2012.",
"output": "StealsFunds(tiffanyTAlston)"
},
{
"input": "Translate into first-order logic: If a legislator is found guilty of stealing government funds, they will be suspended from office.",
"output": "∀x (IsLegislator(x) ∧ StealsFunds(x) → Suspended(x))"
},
{
"input": "Translate into first-order logic: Tiffany T. Alston was a legislator in Maryland's House of Delegates from 2011 to 2013.",
"output": "IsLegislator(tiffanyTAlston)"
},
{
"input": "Translate into first-order logic: Tiffany T. Alston was found guilty of stealing government funds in 2012.",
"output": "StealsFunds(tiffanyTAlston)"
},
{
"input": "Translate into first-order logic: Some fish may sting.",
"output": "∃x ∃y (Fish(x) → Sting(x,y))"
},
{
"input": "Translate into first-order logic: Stonefish is a fish.",
"output": "Fish(stonefish)"
},
{
"input": "Translate into first-order logic: It stings to step on a stonefish.",
"output": "∀x (StepOn(stonefish, x) → Sting(stonefish, x))"
},
{
"input": "Translate into first-order logic: Stonefish stings cause death if not treated.",
"output": "∀x (Sting(stonefish, x) ∧ ¬Treated(x) → CauseDeath(x))"
},
{
"input": "Translate into first-order logic: To treat stonefish stings, apply heat to the affected area or use an antivenom.",
"output": "∀x (Sting(stonefish, x) ∧ (ApplyHeat(x) ∨ UseAntivenom(x)) → Treated(x))"
},
{
"input": "Translate into first-order logic: Some fish may sting.",
"output": "∃x ∃y (Fish(x) → Sting(x,y))"
},
{
"input": "Translate into first-order logic: Stonefish is a fish.",
"output": "Fish(stonefish)"
},
{
"input": "Translate into first-order logic: It stings to step on a stonefish.",
"output": "∀x (StepOn(stonefish, x) → Sting(stonefish, x))"
},
{
"input": "Translate into first-order logic: Stonefish stings cause death if not treated.",
"output": "∀x (Sting(stonefish, x) ∧ ¬Treated(x) → CauseDeath(x))"
},
{
"input": "Translate into first-order logic: To treat stonefish stings, apply heat to the affected area or use an antivenom.",
"output": "∀x (Sting(stonefish, x) ∧ (ApplyHeat(x) ∨ UseAntivenom(x)) → Treated(x))"
},
{
"input": "Translate into first-order logic: Some fish may sting.",
"output": "∃x ∃y (Fish(x) → Sting(x,y))"
},
{
"input": "Translate into first-order logic: Stonefish is a fish.",
"output": "Fish(stonefish)"
},
{
"input": "Translate into first-order logic: It stings to step on a stonefish.",
"output": "∀x (StepOn(stonefish, x) → Sting(stonefish, x))"
},
{
"input": "Translate into first-order logic: Stonefish stings cause death if not treated.",
"output": "∀x (Sting(stonefish, x) ∧ ¬Treated(x) → CauseDeath(x))"
},
{
"input": "Translate into first-order logic: To treat stonefish stings, apply heat to the affected area or use an antivenom.",
"output": "∀x (Sting(stonefish, x) ∧ (ApplyHeat(x) ∨ UseAntivenom(x)) → Treated(x))"
},
{
"input": "Translate into first-order logic: Some monitors produced by LG have a type-c port.",
"output": "∃x (LG(x) ∧ TypeC(x))"
},
{
"input": "Translate into first-order logic: If the monitor has a type-c port, then it is not produced by AOC.",
"output": "∀x (TypeC(x) → ¬AOC(x))"
},
{
"input": "Translate into first-order logic: All monitors in the library are produced by AOC.",
"output": "∀x (Library(x) → AOC(x))"
},
{
"input": "Translate into first-order logic: L-2021 is either in the library or has a type-c port.",
"output": "Library(l-2021) ⊕ TypeC(l-2021) "
},
{
"input": "Translate into first-order logic: L-2021 is either produced by AOC and produced by LG, or neither produced by AOC nor produced by LG.",
"output": "¬(AOC(l-2021) ⊕ LG(l-2021))"
},
{
"input": "Translate into first-order logic: Some monitors produced by LG have a type-c port.",
"output": "∃x (LG(x) ∧ TypeC(x))"
},
{
"input": "Translate into first-order logic: If the monitor has a type-c port, then it is not produced by AOC.",
"output": "∀x (TypeC(x) → ¬AOC(x))"
},
{
"input": "Translate into first-order logic: All monitors in the library are produced by AOC.",
"output": "∀x (Library(x) → AOC(x))"
},
{
"input": "Translate into first-order logic: L-2021 is either in the library or has a type-c port.",
"output": "Library(l-2021) ⊕ TypeC(l-2021) "
},
{
"input": "Translate into first-order logic: L-2021 is either produced by AOC and produced by LG, or neither produced by AOC nor produced by LG.",
"output": "¬(AOC(l-2021) ⊕ LG(l-2021))"
},
{
"input": "Translate into first-order logic: Some monitors produced by LG have a type-c port.",
"output": "∃x (LG(x) ∧ TypeC(x))"
},
{
"input": "Translate into first-order logic: If the monitor has a type-c port, then it is not produced by AOC.",
"output": "∀x (TypeC(x) → ¬AOC(x))"
},
{
"input": "Translate into first-order logic: All monitors in the library are produced by AOC.",
"output": "∀x (Library(x) → AOC(x))"
},
{
"input": "Translate into first-order logic: L-2021 is either in the library or has a type-c port.",
"output": "Library(l-2021) ⊕ TypeC(l-2021) "
},
{
"input": "Translate into first-order logic: L-2021 is either produced by AOC and produced by LG, or neither produced by AOC nor produced by LG.",
"output": "¬(AOC(l-2021) ⊕ LG(l-2021))"
},
{
"input": "Translate into first-order logic: Some monitors produced by LG have a type-c port.",
"output": "∃x (LG(x) ∧ TypeC(x))"
},
{
"input": "Translate into first-order logic: If the monitor has a type-c port, then it is not produced by AOC.",
"output": "∀x (TypeC(x) → ¬AOC(x))"
},
{
"input": "Translate into first-order logic: All monitors in the library are produced by AOC.",
"output": "∀x (Library(x) → AOC(x))"
},
{
"input": "Translate into first-order logic: L-2021 is either in the library or has a type-c port.",
"output": "Library(l-2021) ⊕ TypeC(l-2021) "
},
{
"input": "Translate into first-order logic: L-2021 is either produced by AOC and produced by LG, or neither produced by AOC nor produced by LG.",
"output": "¬(AOC(l-2021) ⊕ LG(l-2021))"
},
{
"input": "Translate into first-order logic: Some monitors produced by LG have a type-c port.",
"output": "∃x (LG(x) ∧ TypeC(x))"
},
{
"input": "Translate into first-order logic: If the monitor has a type-c port, then it is not produced by AOC.",
"output": "∀x (TypeC(x) → ¬AOC(x))"
},
{
"input": "Translate into first-order logic: All monitors in the library are produced by AOC.",
"output": "∀x (Library(x) → AOC(x))"
},
{
"input": "Translate into first-order logic: L-2021 is either in the library or has a type-c port.",
"output": "Library(l-2021) ⊕ TypeC(l-2021) "
},
{
"input": "Translate into first-order logic: L-2021 is either produced by AOC and produced by LG, or neither produced by AOC nor produced by LG.",
"output": "¬(AOC(l-2021) ⊕ LG(l-2021))"
},
{
"input": "Translate into first-order logic: People eat meat regularly or are vegetation.",
"output": "∀x (Meat(x) ∨ Vegetarian(x))"
},
{
"input": "Translate into first-order logic: If people eat meat regularly, then they enjoy eating hamburgers and steaks.",
"output": "∀x (Meat(x) → Hamburgers(x))"
},
{
"input": "Translate into first-order logic: All people who are vegetarian are conscious of the environment or their health.",
"output": "∀x (Vegetarian(x) → Conscious(x))"
},
{
"input": "Translate into first-order logic: If people are conscious about the environment or their health, then they do not go to fast food places often.",
"output": "∀x (Conscious(x) → ¬FastFood(x))"
},
{
"input": "Translate into first-order logic: If people have busy schedules without time to cook, then they go to fast food places often.",
"output": "∀x (Busy(x) → FastFood(x))"
},
{
"input": "Translate into first-order logic: If Jeremy does not both go to fast food places often and is conscious about the environment or their health, then he goes to fast food places often.",
"output": "¬(FastFood(jeremy) ∧ Conscious(jeremy)) → FastFood(jeremy)"
},
{
"input": "Translate into first-order logic: People eat meat regularly or are vegetation.",
"output": "∀x (Meat(x) ∨ Vegetarian(x))"
},
{
"input": "Translate into first-order logic: If people eat meat regularly, then they enjoy eating hamburgers and steaks.",
"output": "∀x (Meat(x) → Hamburgers(x))"
},
{
"input": "Translate into first-order logic: All people who are vegetarian are conscious of the environment or their health.",
"output": "∀x (Vegetarian(x) → Conscious(x))"
},
{
"input": "Translate into first-order logic: If people are conscious about the environment or their health, then they do not go to fast food places often.",
"output": "∀x (Conscious(x) → ¬FastFood(x))"
},
{
"input": "Translate into first-order logic: If people have busy schedules without time to cook, then they go to fast food places often.",
"output": "∀x (Busy(x) → FastFood(x))"
},
{
"input": "Translate into first-order logic: If Jeremy does not both go to fast food places often and is conscious about the environment or their health, then he goes to fast food places often.",
"output": "¬(FastFood(jeremy) ∧ Conscious(jeremy)) → FastFood(jeremy)"
},
{
"input": "Translate into first-order logic: People eat meat regularly or are vegetation.",
"output": "∀x (Meat(x) ∨ Vegetarian(x))"
},
{
"input": "Translate into first-order logic: If people eat meat regularly, then they enjoy eating hamburgers and steaks.",
"output": "∀x (Meat(x) → Hamburgers(x))"
},
{
"input": "Translate into first-order logic: All people who are vegetarian are conscious of the environment or their health.",
"output": "∀x (Vegetarian(x) → Conscious(x))"
},
{
"input": "Translate into first-order logic: If people are conscious about the environment or their health, then they do not go to fast food places often.",
"output": "∀x (Conscious(x) → ¬FastFood(x))"
},
{
"input": "Translate into first-order logic: If people have busy schedules without time to cook, then they go to fast food places often.",
"output": "∀x (Busy(x) → FastFood(x))"
},
{
"input": "Translate into first-order logic: If Jeremy does not both go to fast food places often and is conscious about the environment or their health, then he goes to fast food places often.",
"output": "¬(FastFood(jeremy) ∧ Conscious(jeremy)) → FastFood(jeremy)"
},
{
"input": "Translate into first-order logic: Sam is doing a project.",
"output": "∃x (Project(x) ∧ Do(sam, x))"
},
{
"input": "Translate into first-order logic: A project is written either in C++ or in Python.",
"output": " ∀x (Project(x) → (WrittenIn(x, python) ⊕ WrittenIn(x, c++)))"
},
{
"input": "Translate into first-order logic: If Sam does a project written in Python, he will not use a Mac.",
"output": " ∀x (Project(x) ∧ WrittenIn(x, python) ∧ Do(sam, x) → ¬Use(sam, mac))"
},
{
"input": "Translate into first-order logic: Sam is using a Mac.",
"output": " Use(sam, mac)"
},
{
"input": "Translate into first-order logic: If Sam uses a Mac, he will play a song.",
"output": " Use(sam, mac) → ∃x (Song(x) ∧ Play(sam, x))"
},
{
"input": "Translate into first-order logic: If a song is not \"Perfect\", Sam will never play it.",
"output": " ∀x (¬Be(x, perfect) → ¬Play(sam, x))"
},
{
"input": "Translate into first-order logic: Sam is doing a project.",
"output": "∃x (Project(x) ∧ Do(sam, x))"
},
{
"input": "Translate into first-order logic: A project is written either in C++ or in Python.",
"output": " ∀x (Project(x) → (WrittenIn(x, python) ⊕ WrittenIn(x, c++)))"
},
{
"input": "Translate into first-order logic: If Sam does a project written in Python, he will not use a Mac.",
"output": " ∀x (Project(x) ∧ WrittenIn(x, python) ∧ Do(sam, x) → ¬Use(sam, mac))"
},
{
"input": "Translate into first-order logic: Sam is using a Mac.",
"output": " Use(sam, mac)"
},
{
"input": "Translate into first-order logic: If Sam uses a Mac, he will play a song.",
"output": " Use(sam, mac) → ∃x (Song(x) ∧ Play(sam, x))"
},
{
"input": "Translate into first-order logic: If a song is not \"Perfect\", Sam will never play it.",
"output": " ∀x (¬Be(x, perfect) → ¬Play(sam, x))"
},
{
"input": "Translate into first-order logic: Sam is doing a project.",
"output": "∃x (Project(x) ∧ Do(sam, x))"
},
{
"input": "Translate into first-order logic: A project is written either in C++ or in Python.",
"output": " ∀x (Project(x) → (WrittenIn(x, python) ⊕ WrittenIn(x, c++)))"
},
{
"input": "Translate into first-order logic: If Sam does a project written in Python, he will not use a Mac.",
"output": " ∀x (Project(x) ∧ WrittenIn(x, python) ∧ Do(sam, x) → ¬Use(sam, mac))"
},
{
"input": "Translate into first-order logic: Sam is using a Mac.",
"output": " Use(sam, mac)"
},
{
"input": "Translate into first-order logic: If Sam uses a Mac, he will play a song.",
"output": " Use(sam, mac) → ∃x (Song(x) ∧ Play(sam, x))"
},
{
"input": "Translate into first-order logic: If a song is not \"Perfect\", Sam will never play it.",
"output": " ∀x (¬Be(x, perfect) → ¬Play(sam, x))"
},
{
"input": "Translate into first-order logic: All rabbits have fur",
"output": "∀x (Rabbit(x) → HasFur(x))"
},
{
"input": "Translate into first-order logic: Some pets are rabbits.",
"output": "∃x (Pet(x) ∧ Reptile(x))"
},
{
"input": "Translate into first-order logic: All video applications are software.",
"output": "∀x (App(x) → Software(x))"
},
{
"input": "Translate into first-order logic: All YouTube-related applications are video applications.",
"output": "∀x (Youtube(x) → App(x))"
},
{
"input": "Translate into first-order logic: An APP is either related to YouTube or Instagram.",
"output": "∀x (Youtube(x) ∨ Instagram(x))"
},
{
"input": "Translate into first-order logic: All Instagram is entertainment.",
"output": "∀x (Instagram(x) → Entertainment(x))"
},
{
"input": "Translate into first-order logic: All software is programmed.",
"output": "∀x (Software(x) → Program(x))"
},
{
"input": "Translate into first-order logic: All entertainments are interesting.",
"output": "∀x (Entertainment(x) → Interesting(x))"
},
{
"input": "Translate into first-order logic: If something is interesting, then it is good.",
"output": "∀x (Interesting(x) → Good(x))"
},
{
"input": "Translate into first-order logic: TikTok is not good.",
"output": "¬Good(tiktok)"
},
{
"input": "Translate into first-order logic: All video applications are software.",
"output": "∀x (App(x) → Software(x))"
},
{
"input": "Translate into first-order logic: All YouTube-related applications are video applications.",
"output": "∀x (Youtube(x) → App(x))"
},
{
"input": "Translate into first-order logic: An APP is either related to YouTube or Instagram.",
"output": "∀x (Youtube(x) ∨ Instagram(x))"
},
{
"input": "Translate into first-order logic: All Instagram is entertainment.",
"output": "∀x (Instagram(x) → Entertainment(x))"
},
{
"input": "Translate into first-order logic: All software is programmed.",
"output": "∀x (Software(x) → Program(x))"
},
{
"input": "Translate into first-order logic: All entertainments are interesting.",
"output": "∀x (Entertainment(x) → Interesting(x))"
},
{
"input": "Translate into first-order logic: If something is interesting, then it is good.",
"output": "∀x (Interesting(x) → Good(x))"
},
{
"input": "Translate into first-order logic: TikTok is not good.",
"output": "¬Good(tiktok)"
},
{
"input": "Translate into first-order logic: All video applications are software.",
"output": "∀x (App(x) → Software(x))"
},
{
"input": "Translate into first-order logic: All YouTube-related applications are video applications.",
"output": "∀x (Youtube(x) → App(x))"
},
{
"input": "Translate into first-order logic: An APP is either related to YouTube or Instagram.",
"output": "∀x (Youtube(x) ∨ Instagram(x))"
},
{
"input": "Translate into first-order logic: All Instagram is entertainment.",
"output": "∀x (Instagram(x) → Entertainment(x))"
},
{
"input": "Translate into first-order logic: All software is programmed.",
"output": "∀x (Software(x) → Program(x))"
},
{
"input": "Translate into first-order logic: All entertainments are interesting.",
"output": "∀x (Entertainment(x) → Interesting(x))"
},
{
"input": "Translate into first-order logic: If something is interesting, then it is good.",
"output": "∀x (Interesting(x) → Good(x))"
},
{
"input": "Translate into first-order logic: TikTok is not good.",
"output": "¬Good(tiktok)"
},
{
"input": "Translate into first-order logic: All video applications are software.",
"output": "∀x (App(x) → Software(x))"
},
{
"input": "Translate into first-order logic: All YouTube-related applications are video applications.",
"output": "∀x (Youtube(x) → App(x))"
},
{
"input": "Translate into first-order logic: An APP is either related to YouTube or Instagram.",
"output": "∀x (Youtube(x) ∨ Instagram(x))"
},
{
"input": "Translate into first-order logic: All Instagram is entertainment.",
"output": "∀x (Instagram(x) → Entertainment(x))"
},
{
"input": "Translate into first-order logic: All software is programmed.",
"output": "∀x (Software(x) → Program(x))"
},
{
"input": "Translate into first-order logic: All entertainments are interesting.",
"output": "∀x (Entertainment(x) → Interesting(x))"
},
{
"input": "Translate into first-order logic: If something is interesting, then it is good.",
"output": "∀x (Interesting(x) → Good(x))"
},
{
"input": "Translate into first-order logic: TikTok is not good.",
"output": "¬Good(tiktok)"
},
{
"input": "Translate into first-order logic: Ordinary is an unincorporated community.",
"output": "UnincorporatedCommunity(ordinary)"
},
{
"input": "Translate into first-order logic: Located within Elliot County, Ordinary is on Kentucky Route 32.",
"output": "In(ordinary, elliotcounty) ∧ On(ordinary, kentuckyroute32)"
},
{
"input": "Translate into first-order logic: Ordinary is located northwest of Sandy Hook.",
"output": "NorthwestOf(ordinary, sandyhook)"
},
{
"input": "Translate into first-order logic: Ordinary is an unincorporated community.",
"output": "UnincorporatedCommunity(ordinary)"
},
{
"input": "Translate into first-order logic: Located within Elliot County, Ordinary is on Kentucky Route 32.",
"output": "In(ordinary, elliotcounty) ∧ On(ordinary, kentuckyroute32)"
},
{
"input": "Translate into first-order logic: Ordinary is located northwest of Sandy Hook.",
"output": "NorthwestOf(ordinary, sandyhook)"
},
{
"input": "Translate into first-order logic: All young adults go on a diet.",
"output": "∀x (YoungAdult(x) → GoOnDiet(x))"
},
{
"input": "Translate into first-order logic: All college students are young adults.",
"output": "∀x (CollegeStudent(x) → YoungAdult(x))"
},
{
"input": "Translate into first-order logic: All Yale students are college students.",
"output": "∀x (YaleStudent(x) → CollegeStudent(x))"
},
{
"input": "Translate into first-order logic: Someone is either a Yale student or a Harvard student.",
"output": "∀x (YaleStudent(x) ∨ HarvardStudent(x))"
},
{
"input": "Translate into first-order logic: All Harvard students are diligent.",
"output": "∀x (HarvardStudent(x) → Diligent(x))"
},
{
"input": "Translate into first-order logic: If Susan is a Harvard student, then she is a young adult.",
"output": "HarvardStudent(susan) → YoungAdult(susan)"
},
{
"input": "Translate into first-order logic: If Susan is a Yale student, then she does not go on a diet.",
"output": "YaleStudent(susan) → ¬GoOnDiet(susan)"
},
{
"input": "Translate into first-order logic: All young adults go on a diet.",
"output": "∀x (YoungAdult(x) → GoOnDiet(x))"
},
{
"input": "Translate into first-order logic: All college students are young adults.",
"output": "∀x (CollegeStudent(x) → YoungAdult(x))"
},
{
"input": "Translate into first-order logic: All Yale students are college students.",
"output": "∀x (YaleStudent(x) → CollegeStudent(x))"
},
{
"input": "Translate into first-order logic: Someone is either a Yale student or a Harvard student.",
"output": "∀x (YaleStudent(x) ∨ HarvardStudent(x))"
},
{
"input": "Translate into first-order logic: All Harvard students are diligent.",
"output": "∀x (HarvardStudent(x) → Diligent(x))"
},
{
"input": "Translate into first-order logic: If Susan is a Harvard student, then she is a young adult.",
"output": "HarvardStudent(susan) → YoungAdult(susan)"
},
{
"input": "Translate into first-order logic: If Susan is a Yale student, then she does not go on a diet.",
"output": "YaleStudent(susan) → ¬GoOnDiet(susan)"
},
{
"input": "Translate into first-order logic: All young adults go on a diet.",
"output": "∀x (YoungAdult(x) → GoOnDiet(x))"
},
{
"input": "Translate into first-order logic: All college students are young adults.",
"output": "∀x (CollegeStudent(x) → YoungAdult(x))"
},
{
"input": "Translate into first-order logic: All Yale students are college students.",
"output": "∀x (YaleStudent(x) → CollegeStudent(x))"
},
{
"input": "Translate into first-order logic: Someone is either a Yale student or a Harvard student.",
"output": "∀x (YaleStudent(x) ∨ HarvardStudent(x))"
},
{
"input": "Translate into first-order logic: All Harvard students are diligent.",
"output": "∀x (HarvardStudent(x) → Diligent(x))"
},
{
"input": "Translate into first-order logic: If Susan is a Harvard student, then she is a young adult.",
"output": "HarvardStudent(susan) → YoungAdult(susan)"
},
{
"input": "Translate into first-order logic: If Susan is a Yale student, then she does not go on a diet.",
"output": "YaleStudent(susan) → ¬GoOnDiet(susan)"
},
{
"input": "Translate into first-order logic: Vic DiCara plays guitar and bass.",
"output": "Play(vicdicara, guitar) ∧ Play(vicdicara, bass)"
},
{
"input": "Translate into first-order logic: The only style of music Vic DiCara plays is punk music.",
"output": "¬(∃x (Music (vicdicara, punk) ∧ Music (vicdicara, x)))"
},
{
"input": "Translate into first-order logic: Vic DiCara played in the band Inside Out.",
"output": "Band(vicdicara, insideOut)"
},
{
"input": "Translate into first-order logic: Vic DiCara plays guitar and bass.",
"output": "Play(vicdicara, guitar) ∧ Play(vicdicara, bass)"
},
{
"input": "Translate into first-order logic: The only style of music Vic DiCara plays is punk music.",
"output": "¬(∃x (Music (vicdicara, punk) ∧ Music (vicdicara, x)))"
},
{
"input": "Translate into first-order logic: Vic DiCara played in the band Inside Out.",
"output": "Band(vicdicara, insideOut)"
},
{
"input": "Translate into first-order logic: All athletes are good at sports.",
"output": "∀x (Athlete(x) → GoodAtSports(x))"
},
{
"input": "Translate into first-order logic: All Olympic gold medal winners are good athletes.",
"output": "∀x (OlympicGoldMedalWinner(x) → Athlete(x))"
},
{
"input": "Translate into first-order logic: No scientists are good at sports.",
"output": "∀x (Scientist(x) → ¬GoodAtSports(x))"
},
{
"input": "Translate into first-order logic: All Nobel laureates are scientists.",
"output": "∀x (NobelLaureate(x) → Scientist(x))"
},
{
"input": "Translate into first-order logic: Amy is good at sports or Amy is an Olympic gold medal winner.",
"output": "GoodAtSports(amy) ∨ OlympicGoldMedalWinner(amy)"
},
{
"input": "Translate into first-order logic: If Amy is not a Nobel laureate, then Amy is not an Olympic gold medal winner.",
"output": "¬NobelLaureate(amy) → ¬OlympicGoldMedalWinner(amy)"
},
{
"input": "Translate into first-order logic: All athletes are good at sports.",
"output": "∀x (Athlete(x) → GoodAtSports(x))"
},
{
"input": "Translate into first-order logic: All Olympic gold medal winners are good athletes.",
"output": "∀x (OlympicGoldMedalWinner(x) → Athlete(x))"
},
{
"input": "Translate into first-order logic: No scientists are good at sports.",
"output": "∀x (Scientist(x) → ¬GoodAtSports(x))"
},
{
"input": "Translate into first-order logic: All Nobel laureates are scientists.",
"output": "∀x (NobelLaureate(x) → Scientist(x))"
},
{
"input": "Translate into first-order logic: Amy is good at sports or Amy is an Olympic gold medal winner.",
"output": "GoodAtSports(amy) ∨ OlympicGoldMedalWinner(amy)"
},
{
"input": "Translate into first-order logic: If Amy is not a Nobel laureate, then Amy is not an Olympic gold medal winner.",
"output": "¬NobelLaureate(amy) → ¬OlympicGoldMedalWinner(amy)"
},
{
"input": "Translate into first-order logic: All athletes are good at sports.",
"output": "∀x (Athlete(x) → GoodAtSports(x))"
},
{
"input": "Translate into first-order logic: All Olympic gold medal winners are good athletes.",
"output": "∀x (OlympicGoldMedalWinner(x) → Athlete(x))"
},
{
"input": "Translate into first-order logic: No scientists are good at sports.",
"output": "∀x (Scientist(x) → ¬GoodAtSports(x))"
},
{
"input": "Translate into first-order logic: All Nobel laureates are scientists.",
"output": "∀x (NobelLaureate(x) → Scientist(x))"
},
{
"input": "Translate into first-order logic: Amy is good at sports or Amy is an Olympic gold medal winner.",
"output": "GoodAtSports(amy) ∨ OlympicGoldMedalWinner(amy)"
},
{
"input": "Translate into first-order logic: If Amy is not a Nobel laureate, then Amy is not an Olympic gold medal winner.",
"output": "¬NobelLaureate(amy) → ¬OlympicGoldMedalWinner(amy)"
},
{
"input": "Translate into first-order logic: All fruits with the color red contain a large amount of vitamin C.",
"output": "∀x (RedFruit(x) → VC(x))"
},
{
"input": "Translate into first-order logic: All apples are fruits with the color red.",
"output": "∀x (Apple(x) → RedFruit(x))"
},
{
"input": "Translate into first-order logic: All fruits containing a large amount of vitamin C are beneficial to people.",
"output": "∀x (VC(x) → Benefit(x))"
},
{
"input": "Translate into first-order logic: No fruits that are beneficial to people are on a warning list.",
"output": "∀x (Benefit(x) → ¬WarningList(x))"
},
{
"input": "Translate into first-order logic: If K is not beneficial to people and also not an apple, then it is a fruit with the color red.",
"output": "¬(Benefit(k) ∧ Apple(k)) → RedFruit(k)"
},
{
"input": "Translate into first-order logic: All fruits with the color red contain a large amount of vitamin C.",
"output": "∀x (RedFruit(x) → VC(x))"
},
{
"input": "Translate into first-order logic: All apples are fruits with the color red.",
"output": "∀x (Apple(x) → RedFruit(x))"
},
{
"input": "Translate into first-order logic: All fruits containing a large amount of vitamin C are beneficial to people.",
"output": "∀x (VC(x) → Benefit(x))"
},
{
"input": "Translate into first-order logic: No fruits that are beneficial to people are on a warning list.",
"output": "∀x (Benefit(x) → ¬WarningList(x))"
},
{
"input": "Translate into first-order logic: If K is not beneficial to people and also not an apple, then it is a fruit with the color red.",
"output": "¬(Benefit(k) ∧ Apple(k)) → RedFruit(k)"
},
{
"input": "Translate into first-order logic: All fruits with the color red contain a large amount of vitamin C.",
"output": "∀x (RedFruit(x) → VC(x))"
},
{
"input": "Translate into first-order logic: All apples are fruits with the color red.",
"output": "∀x (Apple(x) → RedFruit(x))"
},
{
"input": "Translate into first-order logic: All fruits containing a large amount of vitamin C are beneficial to people.",
"output": "∀x (VC(x) → Benefit(x))"
},
{
"input": "Translate into first-order logic: No fruits that are beneficial to people are on a warning list.",
"output": "∀x (Benefit(x) → ¬WarningList(x))"
},
{
"input": "Translate into first-order logic: If K is not beneficial to people and also not an apple, then it is a fruit with the color red.",
"output": "¬(Benefit(k) ∧ Apple(k)) → RedFruit(k)"
},
{
"input": "Translate into first-order logic: All fruits with the color red contain a large amount of vitamin C.",
"output": "∀x (RedFruit(x) → VC(x))"
},
{
"input": "Translate into first-order logic: All apples are fruits with the color red.",
"output": "∀x (Apple(x) → RedFruit(x))"
},
{
"input": "Translate into first-order logic: All fruits containing a large amount of vitamin C are beneficial to people.",
"output": "∀x (VC(x) → Benefit(x))"
},
{
"input": "Translate into first-order logic: No fruits that are beneficial to people are on a warning list.",
"output": "∀x (Benefit(x) → ¬WarningList(x))"
},
{
"input": "Translate into first-order logic: If K is not beneficial to people and also not an apple, then it is a fruit with the color red.",
"output": "¬(Benefit(k) ∧ Apple(k)) → RedFruit(k)"
},
{
"input": "Translate into first-order logic: All fruits with the color red contain a large amount of vitamin C.",
"output": "∀x (RedFruit(x) → VC(x))"
},
{
"input": "Translate into first-order logic: All apples are fruits with the color red.",
"output": "∀x (Apple(x) → RedFruit(x))"
},
{
"input": "Translate into first-order logic: All fruits containing a large amount of vitamin C are beneficial to people.",
"output": "∀x (VC(x) → Benefit(x))"
},
{
"input": "Translate into first-order logic: No fruits that are beneficial to people are on a warning list.",
"output": "∀x (Benefit(x) → ¬WarningList(x))"
},
{
"input": "Translate into first-order logic: If K is not beneficial to people and also not an apple, then it is a fruit with the color red.",
"output": "¬(Benefit(k) ∧ Apple(k)) → RedFruit(k)"
},
{
"input": "Translate into first-order logic: Everyone working at Meta has a high income.",
"output": "∀x (Meta(x) → HighIncome(x))"
},
{
"input": "Translate into first-order logic: If a person has a high income, then he/she will not take a bus to their destination.",
"output": "∀x (HighIncome(x) → ¬Bus(x))"
},
{
"input": "Translate into first-order logic: People will either take a bus or drive to their destination.",
"output": "∀x (Bus(x) ∨ Drive(x))"
},
{
"input": "Translate into first-order logic: Everyone who has a car will choose to drive to their destination.",
"output": "∀x (HaveCars(x) → Drive(x))"
},
{
"input": "Translate into first-order logic: No students drive to their destination.",
"output": "∀x (Student(x) → ¬Drive(x))"
},
{
"input": "Translate into first-order logic: James has a car or works at Meta.",
"output": "HaveCars(james) ∨ Meta(james)"
},
{
"input": "Translate into first-order logic: Everyone working at Meta has a high income.",
"output": "∀x (Meta(x) → HighIncome(x))"
},
{
"input": "Translate into first-order logic: If a person has a high income, then he/she will not take a bus to their destination.",
"output": "∀x (HighIncome(x) → ¬Bus(x))"
},
{
"input": "Translate into first-order logic: People will either take a bus or drive to their destination.",
"output": "∀x (Bus(x) ∨ Drive(x))"
},
{
"input": "Translate into first-order logic: Everyone who has a car will choose to drive to their destination.",
"output": "∀x (HaveCars(x) → Drive(x))"
},
{
"input": "Translate into first-order logic: No students drive to their destination.",
"output": "∀x (Student(x) → ¬Drive(x))"
},
{
"input": "Translate into first-order logic: James has a car or works at Meta.",
"output": "HaveCars(james) ∨ Meta(james)"
},
{
"input": "Translate into first-order logic: Everyone working at Meta has a high income.",
"output": "∀x (Meta(x) → HighIncome(x))"
},
{
"input": "Translate into first-order logic: If a person has a high income, then he/she will not take a bus to their destination.",
"output": "∀x (HighIncome(x) → ¬Bus(x))"
},
{
"input": "Translate into first-order logic: People will either take a bus or drive to their destination.",
"output": "∀x (Bus(x) ∨ Drive(x))"
},
{
"input": "Translate into first-order logic: Everyone who has a car will choose to drive to their destination.",
"output": "∀x (HaveCars(x) → Drive(x))"
},
{
"input": "Translate into first-order logic: No students drive to their destination.",
"output": "∀x (Student(x) → ¬Drive(x))"
},
{
"input": "Translate into first-order logic: James has a car or works at Meta.",
"output": "HaveCars(james) ∨ Meta(james)"
},
{
"input": "Translate into first-order logic: Everyone working at Meta has a high income.",
"output": "∀x (Meta(x) → HighIncome(x))"
},
{
"input": "Translate into first-order logic: If a person has a high income, then he/she will not take a bus to their destination.",
"output": "∀x (HighIncome(x) → ¬Bus(x))"
},
{
"input": "Translate into first-order logic: People will either take a bus or drive to their destination.",
"output": "∀x (Bus(x) ∨ Drive(x))"
},
{
"input": "Translate into first-order logic: Everyone who has a car will choose to drive to their destination.",
"output": "∀x (HaveCars(x) → Drive(x))"
},
{
"input": "Translate into first-order logic: No students drive to their destination.",
"output": "∀x (Student(x) → ¬Drive(x))"
},
{
"input": "Translate into first-order logic: James has a car or works at Meta.",
"output": "HaveCars(james) ∨ Meta(james)"
},
{
"input": "Translate into first-order logic: Everyone working at Meta has a high income.",
"output": "∀x (Meta(x) → HighIncome(x))"
},
{
"input": "Translate into first-order logic: If a person has a high income, then he/she will not take a bus to their destination.",
"output": "∀x (HighIncome(x) → ¬Bus(x))"
},
{
"input": "Translate into first-order logic: People will either take a bus or drive to their destination.",
"output": "∀x (Bus(x) ∨ Drive(x))"
},
{
"input": "Translate into first-order logic: Everyone who has a car will choose to drive to their destination.",
"output": "∀x (HaveCars(x) → Drive(x))"
},
{
"input": "Translate into first-order logic: No students drive to their destination.",
"output": "∀x (Student(x) → ¬Drive(x))"
},
{
"input": "Translate into first-order logic: James has a car or works at Meta.",
"output": "HaveCars(james) ∨ Meta(james)"
},
{
"input": "Translate into first-order logic: Everyone working at Meta has a high income.",
"output": "∀x (Meta(x) → HighIncome(x))"
},
{
"input": "Translate into first-order logic: If a person has a high income, then he/she will not take a bus to their destination.",
"output": "∀x (HighIncome(x) → ¬Bus(x))"
},
{
"input": "Translate into first-order logic: People will either take a bus or drive to their destination.",
"output": "∀x (Bus(x) ∨ Drive(x))"
},
{
"input": "Translate into first-order logic: Everyone who has a car will choose to drive to their destination.",
"output": "∀x (HaveCars(x) → Drive(x))"
},
{
"input": "Translate into first-order logic: No students drive to their destination.",
"output": "∀x (Student(x) → ¬Drive(x))"
},
{
"input": "Translate into first-order logic: James has a car or works at Meta.",
"output": "HaveCars(james) ∨ Meta(james)"
},
{
"input": "Translate into first-order logic: Students either go to the park or go to the movies.",
"output": "∀x (Park(x) ⊕ Movies(x))"
},
{
"input": "Translate into first-order logic: No student who enjoys nature has free time during the weekend.",
"output": "∀x (Nature(x) → ¬FreeTime(x))"
},
{
"input": "Translate into first-order logic: All students who go to the movies enjoy nature.",
"output": "∀x (Movies(x) → Nature(x))"
},
{
"input": "Translate into first-order logic: All students who do not have class during the weekend have free time during the weekend.",
"output": "∀x (NoClass(x) → FreeTime(x))"
},
{
"input": "Translate into first-order logic: All students not in summer camp do not have class during the weekend.",
"output": "∀x (SummerCamp(x) → NoClass(x))"
},
{
"input": "Translate into first-order logic: James does not have class during the weekend.",
"output": "NoClass(james)"
},
{
"input": "Translate into first-order logic: Students either go to the park or go to the movies.",
"output": "∀x (Park(x) ⊕ Movies(x))"
},
{
"input": "Translate into first-order logic: No student who enjoys nature has free time during the weekend.",
"output": "∀x (Nature(x) → ¬FreeTime(x))"
},
{
"input": "Translate into first-order logic: All students who go to the movies enjoy nature.",
"output": "∀x (Movies(x) → Nature(x))"
},
{
"input": "Translate into first-order logic: All students who do not have class during the weekend have free time during the weekend.",
"output": "∀x (NoClass(x) → FreeTime(x))"
},
{
"input": "Translate into first-order logic: All students not in summer camp do not have class during the weekend.",
"output": "∀x (SummerCamp(x) → NoClass(x))"
},
{
"input": "Translate into first-order logic: James does not have class during the weekend.",
"output": "NoClass(james)"
},
{
"input": "Translate into first-order logic: No television stars are certified public accountants.",
"output": "∀x (TelevisionStar(x) → ¬CertifiedPublicAccoutant(x))"
},
{
"input": "Translate into first-order logic: All certified public accountants have good business sense.",
"output": "∀x (CertifiedPublicAccoutant(x) → GoodBusinessSense(x))"
},
{
"input": "Translate into first-order logic: Some students good at math are good at chemistry.",
"output": "∃x (Math(x) ∧ Chemistry(x))"
},
{
"input": "Translate into first-order logic: All students good at chemistry enjoy conducting experiments.",
"output": "∀x (Chemistry(x) → Experiment(x))"
},
{
"input": "Translate into first-order logic: All students that enjoy conducting experiments are good at planning.",
"output": "∀x (Experiment(x) → Planning(x))"
},
{
"input": "Translate into first-order logic: No student good at planning is awarded the Dean's List.",
"output": "∀x (Planning(x) → ¬Award(x))"
},
{
"input": "Translate into first-order logic: James is either good at chemistry and awarded the Dean's List, or neither good at chemistry nor awarded the Dean's List.",
"output": "¬(Chemistry(james) ⊕ Award(james))"
},
{
"input": "Translate into first-order logic: Some students good at math are good at chemistry.",
"output": "∃x (Math(x) ∧ Chemistry(x))"
},
{
"input": "Translate into first-order logic: All students good at chemistry enjoy conducting experiments.",
"output": "∀x (Chemistry(x) → Experiment(x))"
},
{
"input": "Translate into first-order logic: All students that enjoy conducting experiments are good at planning.",
"output": "∀x (Experiment(x) → Planning(x))"
},
{
"input": "Translate into first-order logic: No student good at planning is awarded the Dean's List.",
"output": "∀x (Planning(x) → ¬Award(x))"
},
{
"input": "Translate into first-order logic: James is either good at chemistry and awarded the Dean's List, or neither good at chemistry nor awarded the Dean's List.",
"output": "¬(Chemistry(james) ⊕ Award(james))"
},
{
"input": "Translate into first-order logic: Some students good at math are good at chemistry.",
"output": "∃x (Math(x) ∧ Chemistry(x))"
},
{
"input": "Translate into first-order logic: All students good at chemistry enjoy conducting experiments.",
"output": "∀x (Chemistry(x) → Experiment(x))"
},
{
"input": "Translate into first-order logic: All students that enjoy conducting experiments are good at planning.",
"output": "∀x (Experiment(x) → Planning(x))"
},
{
"input": "Translate into first-order logic: No student good at planning is awarded the Dean's List.",
"output": "∀x (Planning(x) → ¬Award(x))"
},
{
"input": "Translate into first-order logic: James is either good at chemistry and awarded the Dean's List, or neither good at chemistry nor awarded the Dean's List.",
"output": "¬(Chemistry(james) ⊕ Award(james))"
},
{
"input": "Translate into first-order logic: Some students good at math are good at chemistry.",
"output": "∃x (Math(x) ∧ Chemistry(x))"
},
{
"input": "Translate into first-order logic: All students good at chemistry enjoy conducting experiments.",
"output": "∀x (Chemistry(x) → Experiment(x))"
},
{
"input": "Translate into first-order logic: All students that enjoy conducting experiments are good at planning.",
"output": "∀x (Experiment(x) → Planning(x))"
},
{
"input": "Translate into first-order logic: No student good at planning is awarded the Dean's List.",
"output": "∀x (Planning(x) → ¬Award(x))"
},
{
"input": "Translate into first-order logic: James is either good at chemistry and awarded the Dean's List, or neither good at chemistry nor awarded the Dean's List.",
"output": "¬(Chemistry(james) ⊕ Award(james))"
},
{
"input": "Translate into first-order logic: If a Leetcode problem is at the easy level, then its AC rate is lower than 20 percent.",
"output": "∀x (Easy(x) → LowerAC(x))"
},
{
"input": "Translate into first-order logic: All Leetcode problems that are recommended to novices are easy.",
"output": "∀x (Recommended(x) → Easy(x))"
},
{
"input": "Translate into first-order logic: A Leetode problem is either easy or hard.",
"output": "∀x (Easy(x) ⊕ Hard(x))"
},
{
"input": "Translate into first-order logic: Leetcode problems that are starred by more than 1 thousand users are hard.",
"output": "∀x (Starred(x) → Hard(x))"
},
{
"input": "Translate into first-order logic: 2Sum is recommended to novices.",
"output": "Recommended(twosum) "
},
{
"input": "Translate into first-order logic: 4Sum is starred by more than 1 thousand users.",
"output": "Starred(foursum)"
},
{
"input": "Translate into first-order logic: If a Leetcode problem is at the easy level, then its AC rate is lower than 20 percent.",
"output": "∀x (Easy(x) → LowerAC(x))"
},
{
"input": "Translate into first-order logic: All Leetcode problems that are recommended to novices are easy.",
"output": "∀x (Recommended(x) → Easy(x))"
},
{
"input": "Translate into first-order logic: A Leetode problem is either easy or hard.",
"output": "∀x (Easy(x) ⊕ Hard(x))"
},
{
"input": "Translate into first-order logic: Leetcode problems that are starred by more than 1 thousand users are hard.",
"output": "∀x (Starred(x) → Hard(x))"
},
{
"input": "Translate into first-order logic: 2Sum is recommended to novices.",
"output": "Recommended(twosum) "
},
{
"input": "Translate into first-order logic: 4Sum is starred by more than 1 thousand users.",
"output": "Starred(foursum)"
},
{
"input": "Translate into first-order logic: If a Leetcode problem is at the easy level, then its AC rate is lower than 20 percent.",
"output": "∀x (Easy(x) → LowerAC(x))"
},
{
"input": "Translate into first-order logic: All Leetcode problems that are recommended to novices are easy.",
"output": "∀x (Recommended(x) → Easy(x))"
},
{
"input": "Translate into first-order logic: A Leetode problem is either easy or hard.",
"output": "∀x (Easy(x) ⊕ Hard(x))"
},
{
"input": "Translate into first-order logic: Leetcode problems that are starred by more than 1 thousand users are hard.",
"output": "∀x (Starred(x) → Hard(x))"
},
{
"input": "Translate into first-order logic: 2Sum is recommended to novices.",
"output": "Recommended(twosum) "
},
{
"input": "Translate into first-order logic: 4Sum is starred by more than 1 thousand users.",
"output": "Starred(foursum)"
},
{
"input": "Translate into first-order logic: All rental cars cost the renter money.",
"output": "∀x (Rent(x, car) → Spend(x, money))"
},
{
"input": "Translate into first-order logic: Whenever Sarah goes to Vermont, Sarah drives there.",
"output": "GoesTo(sarah, vermont) → DriveTo(sarah, vermont)"
},
{
"input": "Translate into first-order logic: For someone who does not own a car to drive somewhere, they must either borrow a car or rent a car.",
"output": "∀x ∀y (¬Own(x, car) ∧ DriveTo(x, y) → Borrow(x, car) ⊕ Rent(x, car))"
},
{
"input": "Translate into first-order logic: Sarah doesn’t own a car.",
"output": "¬Own(sarah, car)"
},
{
"input": "Translate into first-order logic: Sarah never borrows a car to go camping.",
"output": "∀x (Camping(sarah, x) → ¬(Borrow(sarah, car)))"
},
{
"input": "Translate into first-order logic: Sarah is going to go camping in Vermont this weekend.",
"output": "Camping(sarah, vermont)"
},
{
"input": "Translate into first-order logic: To go camping somewhere, you must go to that place.",
"output": "∀x ∀y (Camping(x, y) → GoesTo(x, y))"
},
{
"input": "Translate into first-order logic: All people who attend weddings are getting married or have friends who are getting married.",
"output": "∀x Weddings(x) → GettingMarried(x)"
},
{
"input": "Translate into first-order logic: No preteens and other young children are getting married or have friends who are getting married.",
"output": "∀x PreTeen(x) → ¬GettingMarried(x)"
},
{
"input": "Translate into first-order logic: If people enjoy celebrating life milestone events with other people, then they attend weddings.",
"output": "∀x Celebrating(x) → Weddings(x)"
},
{
"input": "Translate into first-order logic: If people are fond of large organized group functions, then they enjoy celebrating life milestone events with other people.",
"output": "∀x LargeGathering(x) → Celebrating(x)"
},
{
"input": "Translate into first-order logic: All people who are outgoing and very spirited are fond of large organized group functions.",
"output": "∀x Outgoing(x) → LargeGathering(x)"
},
{
"input": "Translate into first-order logic: If Carol is not both a pre-teen or other young child and attends weddings, then Carol is not getting married or has friends who are getting married.",
"output": "¬(PreTeen(Carol) ∧ Weddings(Carol)) → ¬GettingMarried(Carol)"
},
{
"input": "Translate into first-order logic: All people who attend weddings are getting married or have friends who are getting married.",
"output": "∀x Weddings(x) → GettingMarried(x)"
},
{
"input": "Translate into first-order logic: No preteens and other young children are getting married or have friends who are getting married.",
"output": "∀x PreTeen(x) → ¬GettingMarried(x)"
},
{
"input": "Translate into first-order logic: If people enjoy celebrating life milestone events with other people, then they attend weddings.",
"output": "∀x Celebrating(x) → Weddings(x)"
},
{
"input": "Translate into first-order logic: If people are fond of large organized group functions, then they enjoy celebrating life milestone events with other people.",
"output": "∀x LargeGathering(x) → Celebrating(x)"
},
{
"input": "Translate into first-order logic: All people who are outgoing and very spirited are fond of large organized group functions.",
"output": "∀x Outgoing(x) → LargeGathering(x)"
},
{
"input": "Translate into first-order logic: If Carol is not both a pre-teen or other young child and attends weddings, then Carol is not getting married or has friends who are getting married.",
"output": "¬(PreTeen(Carol) ∧ Weddings(Carol)) → ¬GettingMarried(Carol)"
},
{
"input": "Translate into first-order logic: All people who attend weddings are getting married or have friends who are getting married.",
"output": "∀x Weddings(x) → GettingMarried(x)"
},
{
"input": "Translate into first-order logic: No preteens and other young children are getting married or have friends who are getting married.",
"output": "∀x PreTeen(x) → ¬GettingMarried(x)"
},
{
"input": "Translate into first-order logic: If people enjoy celebrating life milestone events with other people, then they attend weddings.",
"output": "∀x Celebrating(x) → Weddings(x)"
},
{
"input": "Translate into first-order logic: If people are fond of large organized group functions, then they enjoy celebrating life milestone events with other people.",
"output": "∀x LargeGathering(x) → Celebrating(x)"
},
{
"input": "Translate into first-order logic: All people who are outgoing and very spirited are fond of large organized group functions.",
"output": "∀x Outgoing(x) → LargeGathering(x)"
},
{
"input": "Translate into first-order logic: If Carol is not both a pre-teen or other young child and attends weddings, then Carol is not getting married or has friends who are getting married.",
"output": "¬(PreTeen(Carol) ∧ Weddings(Carol)) → ¬GettingMarried(Carol)"
},
{
"input": "Translate into first-order logic: All Republicans are anti-abortion.",
"output": "∀x (Republicans(x) → Anti-abortion(x))"
},
{
"input": "Translate into first-order logic: Either Republicans or Democrats.",
"output": " ∀x (Republicans(x) ∨ Democrats(x))"
},
{
"input": "Translate into first-order logic: No Democrats are conservative.",
"output": " ∀x (Democrats(x) → ¬Conservative(x))"
},
{
"input": "Translate into first-order logic: Either conservative or liberal.",
"output": " ∀x (Conservative(x) ∨ Liberal(x))"
},
{
"input": "Translate into first-order logic: A U.S government official is either conservative or a Republican.",
"output": " Conservative(anU.SGovernmentOfficial) ⊕ Republicans(anU.SGovernmentOfficial)"
},
{
"input": "Translate into first-order logic: All Republicans are anti-abortion.",
"output": "∀x (Republicans(x) → Anti-abortion(x))"
},
{
"input": "Translate into first-order logic: Either Republicans or Democrats.",
"output": " ∀x (Republicans(x) ∨ Democrats(x))"
},
{
"input": "Translate into first-order logic: No Democrats are conservative.",
"output": " ∀x (Democrats(x) → ¬Conservative(x))"
},
{
"input": "Translate into first-order logic: Either conservative or liberal.",
"output": " ∀x (Conservative(x) ∨ Liberal(x))"
},
{
"input": "Translate into first-order logic: A U.S government official is either conservative or a Republican.",
"output": " Conservative(anU.SGovernmentOfficial) ⊕ Republicans(anU.SGovernmentOfficial)"
},
{
"input": "Translate into first-order logic: All Republicans are anti-abortion.",
"output": "∀x (Republicans(x) → Anti-abortion(x))"
},
{
"input": "Translate into first-order logic: Either Republicans or Democrats.",
"output": " ∀x (Republicans(x) ∨ Democrats(x))"
},
{
"input": "Translate into first-order logic: No Democrats are conservative.",
"output": " ∀x (Democrats(x) → ¬Conservative(x))"
},
{
"input": "Translate into first-order logic: Either conservative or liberal.",
"output": " ∀x (Conservative(x) ∨ Liberal(x))"
},
{
"input": "Translate into first-order logic: A U.S government official is either conservative or a Republican.",
"output": " Conservative(anU.SGovernmentOfficial) ⊕ Republicans(anU.SGovernmentOfficial)"
},
{
"input": "Translate into first-order logic: All Republicans are anti-abortion.",
"output": "∀x (Republicans(x) → Anti-abortion(x))"
},
{
"input": "Translate into first-order logic: Either Republicans or Democrats.",
"output": " ∀x (Republicans(x) ∨ Democrats(x))"
},
{
"input": "Translate into first-order logic: No Democrats are conservative.",
"output": " ∀x (Democrats(x) → ¬Conservative(x))"
},
{
"input": "Translate into first-order logic: Either conservative or liberal.",
"output": " ∀x (Conservative(x) ∨ Liberal(x))"
},
{
"input": "Translate into first-order logic: A U.S government official is either conservative or a Republican.",
"output": " Conservative(anU.SGovernmentOfficial) ⊕ Republicans(anU.SGovernmentOfficial)"
},
{
"input": "Translate into first-order logic: All Republicans are anti-abortion.",
"output": "∀x (Republicans(x) → Anti-abortion(x))"
},
{
"input": "Translate into first-order logic: Either Republicans or Democrats.",
"output": " ∀x (Republicans(x) ∨ Democrats(x))"
},
{
"input": "Translate into first-order logic: No Democrats are conservative.",
"output": " ∀x (Democrats(x) → ¬Conservative(x))"
},
{
"input": "Translate into first-order logic: Either conservative or liberal.",
"output": " ∀x (Conservative(x) ∨ Liberal(x))"
},
{
"input": "Translate into first-order logic: A U.S government official is either conservative or a Republican.",
"output": " Conservative(anU.SGovernmentOfficial) ⊕ Republicans(anU.SGovernmentOfficial)"
},
{
"input": "Translate into first-order logic: All Republicans are anti-abortion.",
"output": "∀x (Republicans(x) → Anti-abortion(x))"
},
{
"input": "Translate into first-order logic: Either Republicans or Democrats.",
"output": " ∀x (Republicans(x) ∨ Democrats(x))"
},
{
"input": "Translate into first-order logic: No Democrats are conservative.",
"output": " ∀x (Democrats(x) → ¬Conservative(x))"
},
{
"input": "Translate into first-order logic: Either conservative or liberal.",
"output": " ∀x (Conservative(x) ∨ Liberal(x))"
},
{
"input": "Translate into first-order logic: A U.S government official is either conservative or a Republican.",
"output": " Conservative(anU.SGovernmentOfficial) ⊕ Republicans(anU.SGovernmentOfficial)"
},
{
"input": "Translate into first-order logic: All Republicans are anti-abortion.",
"output": "∀x (Republicans(x) → Anti-abortion(x))"
},
{
"input": "Translate into first-order logic: Either Republicans or Democrats.",
"output": " ∀x (Republicans(x) ∨ Democrats(x))"
},
{
"input": "Translate into first-order logic: No Democrats are conservative.",
"output": " ∀x (Democrats(x) → ¬Conservative(x))"
},
{
"input": "Translate into first-order logic: Either conservative or liberal.",
"output": " ∀x (Conservative(x) ∨ Liberal(x))"
},
{
"input": "Translate into first-order logic: A U.S government official is either conservative or a Republican.",
"output": " Conservative(anU.SGovernmentOfficial) ⊕ Republicans(anU.SGovernmentOfficial)"
},
{
"input": "Translate into first-order logic: All Republicans are anti-abortion.",
"output": "∀x (Republicans(x) → Anti-abortion(x))"
},
{
"input": "Translate into first-order logic: Either Republicans or Democrats.",
"output": " ∀x (Republicans(x) ∨ Democrats(x))"
},
{
"input": "Translate into first-order logic: No Democrats are conservative.",
"output": " ∀x (Democrats(x) → ¬Conservative(x))"
},
{
"input": "Translate into first-order logic: Either conservative or liberal.",
"output": " ∀x (Conservative(x) ∨ Liberal(x))"
},
{
"input": "Translate into first-order logic: A U.S government official is either conservative or a Republican.",
"output": " Conservative(anU.SGovernmentOfficial) ⊕ Republicans(anU.SGovernmentOfficial)"
},
{
"input": "Translate into first-order logic: All advocates of high tariff rates are Republicans.",
"output": "∀x (AdvocateOfHighTariff(x) → Republican(x))"
},
{
"input": "Translate into first-order logic: Some Republicans are not conservatives.",
"output": "∃x (Republican(x) ∧ ¬Conservative(x))"
},
{
"input": "Translate into first-order logic: No athletes are slow runners.",
"output": "∀x (Athlete(x) → ¬SlowRunner(x))"
},
{
"input": "Translate into first-order logic: All professional basketball players are athletes.",
"output": "∀x (ProfessionalBasketballPlayer(x) → Athlete(x))"
},
{
"input": "Translate into first-order logic: All NBA players are professional basketball players.",
"output": "∀x (NBAPlayer(x) → ProfessionalBasketballPlayer(x))"
},
{
"input": "Translate into first-order logic: All Knicks players are NBA players.",
"output": "∀x (KnicksPlayer(x) → NBAPlayer(x))"
},
{
"input": "Translate into first-order logic: Jim is either not a professional basketball player or not a slow runner.",
"output": "¬(ProfessionalBasketballPlayer(jim) ⊕ SlowRunner(jim))"
},
{
"input": "Translate into first-order logic: No athletes are slow runners.",
"output": "∀x (Athlete(x) → ¬SlowRunner(x))"
},
{
"input": "Translate into first-order logic: All professional basketball players are athletes.",
"output": "∀x (ProfessionalBasketballPlayer(x) → Athlete(x))"
},
{
"input": "Translate into first-order logic: All NBA players are professional basketball players.",
"output": "∀x (NBAPlayer(x) → ProfessionalBasketballPlayer(x))"
},
{
"input": "Translate into first-order logic: All Knicks players are NBA players.",
"output": "∀x (KnicksPlayer(x) → NBAPlayer(x))"
},
{
"input": "Translate into first-order logic: Jim is either not a professional basketball player or not a slow runner.",
"output": "¬(ProfessionalBasketballPlayer(jim) ⊕ SlowRunner(jim))"
},
{
"input": "Translate into first-order logic: No athletes are slow runners.",
"output": "∀x (Athlete(x) → ¬SlowRunner(x))"
},
{
"input": "Translate into first-order logic: All professional basketball players are athletes.",
"output": "∀x (ProfessionalBasketballPlayer(x) → Athlete(x))"
},
{
"input": "Translate into first-order logic: All NBA players are professional basketball players.",
"output": "∀x (NBAPlayer(x) → ProfessionalBasketballPlayer(x))"
},
{
"input": "Translate into first-order logic: All Knicks players are NBA players.",
"output": "∀x (KnicksPlayer(x) → NBAPlayer(x))"
},
{
"input": "Translate into first-order logic: Jim is either not a professional basketball player or not a slow runner.",
"output": "¬(ProfessionalBasketballPlayer(jim) ⊕ SlowRunner(jim))"
},
{
"input": "Translate into first-order logic: All kids love animals.",
"output": "∀x (Kid(x) → LoveAnimals(x))"
},
{
"input": "Translate into first-order logic: All toddlers are kids.",
"output": "∀x (Toddler(x) → Kid(x))"
},
{
"input": "Translate into first-order logic: If someone loves animals, then they are not bad.",
"output": "∀x (LoveAnimals(x) → ¬Bad(x))"
},
{
"input": "Translate into first-order logic: All pirates are bad.",
"output": "∀x (Pirate(x) → Bad(x))"
},
{
"input": "Translate into first-order logic: If Nancy is not a pirate, then Nancy loves animals.",
"output": "¬Pirate(nancy) → LoveAnimals(nancy)"
},
{
"input": "Translate into first-order logic: If Nancy is not a toddler, then Nancy is bad.",
"output": "¬Toddler(nancy) → Bad(nancy)"
},
{
"input": "Translate into first-order logic: All kids love animals.",
"output": "∀x (Kid(x) → LoveAnimals(x))"
},
{
"input": "Translate into first-order logic: All toddlers are kids.",
"output": "∀x (Toddler(x) → Kid(x))"
},
{
"input": "Translate into first-order logic: If someone loves animals, then they are not bad.",
"output": "∀x (LoveAnimals(x) → ¬Bad(x))"
},
{
"input": "Translate into first-order logic: All pirates are bad.",
"output": "∀x (Pirate(x) → Bad(x))"
},
{
"input": "Translate into first-order logic: If Nancy is not a pirate, then Nancy loves animals.",
"output": "¬Pirate(nancy) → LoveAnimals(nancy)"
},
{
"input": "Translate into first-order logic: If Nancy is not a toddler, then Nancy is bad.",
"output": "¬Toddler(nancy) → Bad(nancy)"
},
{
"input": "Translate into first-order logic: All kids love animals.",
"output": "∀x (Kid(x) → LoveAnimals(x))"
},
{
"input": "Translate into first-order logic: All toddlers are kids.",
"output": "∀x (Toddler(x) → Kid(x))"
},
{
"input": "Translate into first-order logic: If someone loves animals, then they are not bad.",
"output": "∀x (LoveAnimals(x) → ¬Bad(x))"
},
{
"input": "Translate into first-order logic: All pirates are bad.",
"output": "∀x (Pirate(x) → Bad(x))"
},
{
"input": "Translate into first-order logic: If Nancy is not a pirate, then Nancy loves animals.",
"output": "¬Pirate(nancy) → LoveAnimals(nancy)"
},
{
"input": "Translate into first-order logic: If Nancy is not a toddler, then Nancy is bad.",
"output": "¬Toddler(nancy) → Bad(nancy)"
},
{
"input": "Translate into first-order logic: Lana Wilson directed After Tiller, The Departure, and Miss Americana.",
"output": "DirectedBy(after_Tiller, lana_Wilson) ∧ DirectedBy(the_Departure, lana_Wilson) ∧ DirectedBy(miss_Americana, lana_Wilson)"
},
{
"input": "Translate into first-order logic: If a film is directedy by a person, the person is a filmmaker.",
"output": "∀x ∃y (DirectedBy(y, x) → Filmmaker(x))"
},
{
"input": "Translate into first-order logic: After Tiller is a documentary.",
"output": "IsDocumentary(after_Tiller)"
},
{
"input": "Translate into first-order logic: The documentary is a type of films.",
"output": "∀x (IsDocumentary(x) → IsFilm(x))"
},
{
"input": "Translate into first-order logic: Lana Wilson is from Kirkland.",
"output": "FromCity(lana_Wilson, kirkland)"
},
{
"input": "Translate into first-order logic: Kirkland is a US city.",
"output": "CityCountry(kirkland, us)"
},
{
"input": "Translate into first-order logic: If a person is from a city in a country, the person is from the country.",
"output": "∀x ∀y ∀z (FromCity(x, y) ∧ CityCountry(y, z) → FromCountry(x, z))"
},
{
"input": "Translate into first-order logic: After Tiller is nominated for the Independent Spirit Award for Best Documentary.",
"output": "Nomination(after_Tiller, the_Independent_Spirit_Award_for_Best_Documentary)"
},
{
"input": "Translate into first-order logic: Lana Wilson directed After Tiller, The Departure, and Miss Americana.",
"output": "DirectedBy(after_Tiller, lana_Wilson) ∧ DirectedBy(the_Departure, lana_Wilson) ∧ DirectedBy(miss_Americana, lana_Wilson)"
},
{
"input": "Translate into first-order logic: If a film is directedy by a person, the person is a filmmaker.",
"output": "∀x ∃y (DirectedBy(y, x) → Filmmaker(x))"
},
{
"input": "Translate into first-order logic: After Tiller is a documentary.",
"output": "IsDocumentary(after_Tiller)"
},
{
"input": "Translate into first-order logic: The documentary is a type of films.",
"output": "∀x (IsDocumentary(x) → IsFilm(x))"
},
{
"input": "Translate into first-order logic: Lana Wilson is from Kirkland.",
"output": "FromCity(lana_Wilson, kirkland)"
},
{
"input": "Translate into first-order logic: Kirkland is a US city.",
"output": "CityCountry(kirkland, us)"
},
{
"input": "Translate into first-order logic: If a person is from a city in a country, the person is from the country.",
"output": "∀x ∀y ∀z (FromCity(x, y) ∧ CityCountry(y, z) → FromCountry(x, z))"
},
{
"input": "Translate into first-order logic: After Tiller is nominated for the Independent Spirit Award for Best Documentary.",
"output": "Nomination(after_Tiller, the_Independent_Spirit_Award_for_Best_Documentary)"
},
{
"input": "Translate into first-order logic: Lana Wilson directed After Tiller, The Departure, and Miss Americana.",
"output": "DirectedBy(after_Tiller, lana_Wilson) ∧ DirectedBy(the_Departure, lana_Wilson) ∧ DirectedBy(miss_Americana, lana_Wilson)"
},
{
"input": "Translate into first-order logic: If a film is directedy by a person, the person is a filmmaker.",
"output": "∀x ∃y (DirectedBy(y, x) → Filmmaker(x))"
},
{
"input": "Translate into first-order logic: After Tiller is a documentary.",
"output": "IsDocumentary(after_Tiller)"
},
{
"input": "Translate into first-order logic: The documentary is a type of films.",
"output": "∀x (IsDocumentary(x) → IsFilm(x))"
},
{
"input": "Translate into first-order logic: Lana Wilson is from Kirkland.",
"output": "FromCity(lana_Wilson, kirkland)"
},
{
"input": "Translate into first-order logic: Kirkland is a US city.",
"output": "CityCountry(kirkland, us)"
},
{
"input": "Translate into first-order logic: If a person is from a city in a country, the person is from the country.",
"output": "∀x ∀y ∀z (FromCity(x, y) ∧ CityCountry(y, z) → FromCountry(x, z))"
},
{
"input": "Translate into first-order logic: After Tiller is nominated for the Independent Spirit Award for Best Documentary.",
"output": "Nomination(after_Tiller, the_Independent_Spirit_Award_for_Best_Documentary)"
},
{
"input": "Translate into first-order logic: All bears in zoos are not wild.",
"output": "∀x ((Bear(x) ∧ InZoo(x)) → ¬Wild(x))"
},
{
"input": "Translate into first-order logic: Some bears are in zoos.",
"output": "∃x (Bear(x) ∧ InZoo(x)) "
},
{
"input": "Translate into first-order logic: If a person is the leader of a country for life, that person is in a monarchy.",
"output": "∀x (Leader(x) → InMonarchy(x))"
},
{
"input": "Translate into first-order logic: Leaders are either a king or a queen.",
"output": "∀x (Leader(x) → King(x) ⊕ Queen(x))"
},
{
"input": "Translate into first-order logic: Queens are female.",
"output": "∀x (Queen(x) → Female(x))"
},
{
"input": "Translate into first-order logic: Kings are male.",
"output": "∀x (King(x) → Male(x))"
},
{
"input": "Translate into first-order logic: Elizabeth is a queen.",
"output": "Queen(elizabeth)"
},
{
"input": "Translate into first-order logic: Elizabeth is a leader",
"output": "Leader(elizabeth)"
},
{
"input": "Translate into first-order logic: If a person is the leader of a country for life, that person is in a monarchy.",
"output": "∀x (Leader(x) → InMonarchy(x))"
},
{
"input": "Translate into first-order logic: Leaders are either a king or a queen.",
"output": "∀x (Leader(x) → King(x) ⊕ Queen(x))"
},
{
"input": "Translate into first-order logic: Queens are female.",
"output": "∀x (Queen(x) → Female(x))"
},
{
"input": "Translate into first-order logic: Kings are male.",
"output": "∀x (King(x) → Male(x))"
},
{
"input": "Translate into first-order logic: Elizabeth is a queen.",
"output": "Queen(elizabeth)"
},
{
"input": "Translate into first-order logic: Elizabeth is a leader",
"output": "Leader(elizabeth)"
},
{
"input": "Translate into first-order logic: If a person is the leader of a country for life, that person is in a monarchy.",
"output": "∀x (Leader(x) → InMonarchy(x))"
},
{
"input": "Translate into first-order logic: Leaders are either a king or a queen.",
"output": "∀x (Leader(x) → King(x) ⊕ Queen(x))"
},
{
"input": "Translate into first-order logic: Queens are female.",
"output": "∀x (Queen(x) → Female(x))"
},
{
"input": "Translate into first-order logic: Kings are male.",
"output": "∀x (King(x) → Male(x))"
},
{
"input": "Translate into first-order logic: Elizabeth is a queen.",
"output": "Queen(elizabeth)"
},
{
"input": "Translate into first-order logic: Elizabeth is a leader",
"output": "Leader(elizabeth)"
},
{
"input": "Translate into first-order logic: If people make their own matcha teas every morning with ceremonial-grade matcha powder, then they do not wake up late and start their schedules past noon regularly.",
"output": "∀x (Matcha(x) → ¬Late(x))"
},
{
"input": "Translate into first-order logic: If people live in California and attend yoga classes regularly, then they make their own matcha teas every morning with ceremonial-grade matcha powder.",
"output": "∀x (California(x) → Matcha(x))"
},
{
"input": "Translate into first-order logic: If people work in the entertainment industry as high-profile celebrities, then they wake up late and start their schedules past noon regularly.",
"output": "∀x (Celebrities(x) → Late(x))"
},
{
"input": "Translate into first-order logic: If people do not have regular 9-5 jobs, then they work in the entertainment industry as high-profile celebrities.",
"output": "∀x (Jobs(x) → Celebrities(x))"
},
{
"input": "Translate into first-order logic: All people who prefer working at home over going to the office every day do not have regular 9-5 jobs.",
"output": "∀x (WorkHome(x) → Jobs(x))"
},
{
"input": "Translate into first-order logic: Clay either both prefers to work at home over going to the office every day and makes his own matcha teas every morning with ceremonial-grade matcha powder, or he neither prefers to work at home over going to the office every day nor makes his own matcha teas every morning with ceremonial-grade matcha powder.",
"output": "(WorkHome(clay) ∧ Matcha(clay)) ⊕ (¬WorkHome(clay) ∧ ¬Matcha(clay))"
},
{
"input": "Translate into first-order logic: If people make their own matcha teas every morning with ceremonial-grade matcha powder, then they do not wake up late and start their schedules past noon regularly.",
"output": "∀x (Matcha(x) → ¬Late(x))"
},
{
"input": "Translate into first-order logic: If people live in California and attend yoga classes regularly, then they make their own matcha teas every morning with ceremonial-grade matcha powder.",
"output": "∀x (California(x) → Matcha(x))"
},
{
"input": "Translate into first-order logic: If people work in the entertainment industry as high-profile celebrities, then they wake up late and start their schedules past noon regularly.",
"output": "∀x (Celebrities(x) → Late(x))"
},
{
"input": "Translate into first-order logic: If people do not have regular 9-5 jobs, then they work in the entertainment industry as high-profile celebrities.",
"output": "∀x (Jobs(x) → Celebrities(x))"
},
{
"input": "Translate into first-order logic: All people who prefer working at home over going to the office every day do not have regular 9-5 jobs.",
"output": "∀x (WorkHome(x) → Jobs(x))"
},
{
"input": "Translate into first-order logic: Clay either both prefers to work at home over going to the office every day and makes his own matcha teas every morning with ceremonial-grade matcha powder, or he neither prefers to work at home over going to the office every day nor makes his own matcha teas every morning with ceremonial-grade matcha powder.",
"output": "(WorkHome(clay) ∧ Matcha(clay)) ⊕ (¬WorkHome(clay) ∧ ¬Matcha(clay))"
},
{
"input": "Translate into first-order logic: If people make their own matcha teas every morning with ceremonial-grade matcha powder, then they do not wake up late and start their schedules past noon regularly.",
"output": "∀x (Matcha(x) → ¬Late(x))"
},
{
"input": "Translate into first-order logic: If people live in California and attend yoga classes regularly, then they make their own matcha teas every morning with ceremonial-grade matcha powder.",
"output": "∀x (California(x) → Matcha(x))"
},
{
"input": "Translate into first-order logic: If people work in the entertainment industry as high-profile celebrities, then they wake up late and start their schedules past noon regularly.",
"output": "∀x (Celebrities(x) → Late(x))"
},
{
"input": "Translate into first-order logic: If people do not have regular 9-5 jobs, then they work in the entertainment industry as high-profile celebrities.",
"output": "∀x (Jobs(x) → Celebrities(x))"
},
{
"input": "Translate into first-order logic: All people who prefer working at home over going to the office every day do not have regular 9-5 jobs.",
"output": "∀x (WorkHome(x) → Jobs(x))"
},
{
"input": "Translate into first-order logic: Clay either both prefers to work at home over going to the office every day and makes his own matcha teas every morning with ceremonial-grade matcha powder, or he neither prefers to work at home over going to the office every day nor makes his own matcha teas every morning with ceremonial-grade matcha powder.",
"output": "(WorkHome(clay) ∧ Matcha(clay)) ⊕ (¬WorkHome(clay) ∧ ¬Matcha(clay))"
},
{
"input": "Translate into first-order logic: Thomas Barber was an English professional footballer.",
"output": "English(thomasBarber) ∧ ProfessionalFootballer(thomasBarber)"
},
{
"input": "Translate into first-order logic: Thomas Barber played in the Football League for Aston Villa.",
"output": "PlayedInTheFootballLeagueFor(thomasBarber, astonVilla)"
},
{
"input": "Translate into first-order logic: Thomas Barber played as a half back and inside left.",
"output": "PlayedAs(thomasBarber, aHalfBack) ∧ PlayedAs(thomasBarber, anInsideLeft)"
},
{
"input": "Translate into first-order logic: Thomas Barber scored the winning goal in the 1913 FA Cup Final.",
"output": "ScoredTheWinningGoalIn(thomasBarber, facupfinal1913)"
},
{
"input": "Translate into first-order logic: Thomas Barber was an English professional footballer.",
"output": "English(thomasBarber) ∧ ProfessionalFootballer(thomasBarber)"
},
{
"input": "Translate into first-order logic: Thomas Barber played in the Football League for Aston Villa.",
"output": "PlayedInTheFootballLeagueFor(thomasBarber, astonVilla)"
},
{
"input": "Translate into first-order logic: Thomas Barber played as a half back and inside left.",
"output": "PlayedAs(thomasBarber, aHalfBack) ∧ PlayedAs(thomasBarber, anInsideLeft)"
},
{
"input": "Translate into first-order logic: Thomas Barber scored the winning goal in the 1913 FA Cup Final.",
"output": "ScoredTheWinningGoalIn(thomasBarber, facupfinal1913)"
},
{
"input": "Translate into first-order logic: Thomas Barber was an English professional footballer.",
"output": "English(thomasBarber) ∧ ProfessionalFootballer(thomasBarber)"
},
{
"input": "Translate into first-order logic: Thomas Barber played in the Football League for Aston Villa.",
"output": "PlayedInTheFootballLeagueFor(thomasBarber, astonVilla)"
},
{
"input": "Translate into first-order logic: Thomas Barber played as a half back and inside left.",
"output": "PlayedAs(thomasBarber, aHalfBack) ∧ PlayedAs(thomasBarber, anInsideLeft)"
},
{
"input": "Translate into first-order logic: Thomas Barber scored the winning goal in the 1913 FA Cup Final.",
"output": "ScoredTheWinningGoalIn(thomasBarber, facupfinal1913)"
},
{
"input": "Translate into first-order logic: If people play the instrument in the concert, then he is good at playing this kind of instrument.",
"output": "∀y (∀x (PlayInConcert(y, x) → GoodAt(y, x)))"
},
{
"input": "Translate into first-order logic: Peter plays piano, violin, and saxophone.",
"output": "Play(peter, piano) ∧Play(peter, violin)"
},
{
"input": "Translate into first-order logic: Peter was invited to play piano at the concert hall.",
"output": "PlayInConcert(peter, piano)"
},
{
"input": "Translate into first-order logic: Oliver and Peter were both invited to perform in the concert.",
"output": "PlayerInConcert(peter) ∧ PlayerInConcert(oliver)"
},
{
"input": "Translate into first-order logic: Oliver plays a different musical instrument from Peter in the concert.",
"output": "¬PlayInConcert(oliver, piano)"
},
{
"input": "Translate into first-order logic: If people play the instrument in the concert, then he is good at playing this kind of instrument.",
"output": "∀y (∀x (PlayInConcert(y, x) → GoodAt(y, x)))"
},
{
"input": "Translate into first-order logic: Peter plays piano, violin, and saxophone.",
"output": "Play(peter, piano) ∧Play(peter, violin)"
},
{
"input": "Translate into first-order logic: Peter was invited to play piano at the concert hall.",
"output": "PlayInConcert(peter, piano)"
},
{
"input": "Translate into first-order logic: Oliver and Peter were both invited to perform in the concert.",
"output": "PlayerInConcert(peter) ∧ PlayerInConcert(oliver)"
},
{
"input": "Translate into first-order logic: Oliver plays a different musical instrument from Peter in the concert.",
"output": "¬PlayInConcert(oliver, piano)"
},
{
"input": "Translate into first-order logic: If people play the instrument in the concert, then he is good at playing this kind of instrument.",
"output": "∀y (∀x (PlayInConcert(y, x) → GoodAt(y, x)))"
},
{
"input": "Translate into first-order logic: Peter plays piano, violin, and saxophone.",
"output": "Play(peter, piano) ∧Play(peter, violin)"
},
{
"input": "Translate into first-order logic: Peter was invited to play piano at the concert hall.",
"output": "PlayInConcert(peter, piano)"
},
{
"input": "Translate into first-order logic: Oliver and Peter were both invited to perform in the concert.",
"output": "PlayerInConcert(peter) ∧ PlayerInConcert(oliver)"
},
{
"input": "Translate into first-order logic: Oliver plays a different musical instrument from Peter in the concert.",
"output": "¬PlayInConcert(oliver, piano)"
},
{
"input": "Translate into first-order logic: If something can go underwater, then it enjoys water.",
"output": "∀x (GoesUnderwater(x) → EnjoysWater(x))"
},
{
"input": "Translate into first-order logic: All animals that can swim can go underwater.",
"output": "∀x (CanSwim(x) → GoesUnderwater(x))"
},
{
"input": "Translate into first-order logic: Either an animal can swim or it can walk.",
"output": "∀x (CanSwim(x) ∨ CanWalk(x))"
},
{
"input": "Translate into first-order logic: Animals that can walk travel on land.",
"output": "∀x (CanWalk(x) → TravelsOnLand(x))"
},
{
"input": "Translate into first-order logic: Animals that enjoy water splash water around.",
"output": "∀x (EnjoysWater(x) → Splashes(x))"
},
{
"input": "Translate into first-order logic: Every animal that travels on land enjoys basking in the sun.",
"output": "∀x (TravelsOnLand(x) → EnjoysBasking(x))"
},
{
"input": "Translate into first-order logic: George splashes water around and can swim.",
"output": "Splashes(george) ∧ CanSwim(george)"
},
{
"input": "Translate into first-order logic: Liam is either an animal that can walk and enjoys water, or is neither an animal that can walk nor enjoys water.",
"output": "(CanWalk(liam) ∧ EnjoysWater(liam)) ∨ (¬CanWalk(liam) ∧ ¬EnjoysWater(liam))"
},
{
"input": "Translate into first-order logic: If something can go underwater, then it enjoys water.",
"output": "∀x (GoesUnderwater(x) → EnjoysWater(x))"
},
{
"input": "Translate into first-order logic: All animals that can swim can go underwater.",
"output": "∀x (CanSwim(x) → GoesUnderwater(x))"
},
{
"input": "Translate into first-order logic: Either an animal can swim or it can walk.",
"output": "∀x (CanSwim(x) ∨ CanWalk(x))"
},
{
"input": "Translate into first-order logic: Animals that can walk travel on land.",
"output": "∀x (CanWalk(x) → TravelsOnLand(x))"
},
{
"input": "Translate into first-order logic: Animals that enjoy water splash water around.",
"output": "∀x (EnjoysWater(x) → Splashes(x))"
},
{
"input": "Translate into first-order logic: Every animal that travels on land enjoys basking in the sun.",
"output": "∀x (TravelsOnLand(x) → EnjoysBasking(x))"
},
{
"input": "Translate into first-order logic: George splashes water around and can swim.",
"output": "Splashes(george) ∧ CanSwim(george)"
},
{
"input": "Translate into first-order logic: Liam is either an animal that can walk and enjoys water, or is neither an animal that can walk nor enjoys water.",
"output": "(CanWalk(liam) ∧ EnjoysWater(liam)) ∨ (¬CanWalk(liam) ∧ ¬EnjoysWater(liam))"
},
{
"input": "Translate into first-order logic: If something can go underwater, then it enjoys water.",
"output": "∀x (GoesUnderwater(x) → EnjoysWater(x))"
},
{
"input": "Translate into first-order logic: All animals that can swim can go underwater.",
"output": "∀x (CanSwim(x) → GoesUnderwater(x))"
},
{
"input": "Translate into first-order logic: Either an animal can swim or it can walk.",
"output": "∀x (CanSwim(x) ∨ CanWalk(x))"
},
{
"input": "Translate into first-order logic: Animals that can walk travel on land.",
"output": "∀x (CanWalk(x) → TravelsOnLand(x))"
},
{
"input": "Translate into first-order logic: Animals that enjoy water splash water around.",
"output": "∀x (EnjoysWater(x) → Splashes(x))"
},
{
"input": "Translate into first-order logic: Every animal that travels on land enjoys basking in the sun.",
"output": "∀x (TravelsOnLand(x) → EnjoysBasking(x))"
},
{
"input": "Translate into first-order logic: George splashes water around and can swim.",
"output": "Splashes(george) ∧ CanSwim(george)"
},
{
"input": "Translate into first-order logic: Liam is either an animal that can walk and enjoys water, or is neither an animal that can walk nor enjoys water.",
"output": "(CanWalk(liam) ∧ EnjoysWater(liam)) ∨ (¬CanWalk(liam) ∧ ¬EnjoysWater(liam))"
},
{
"input": "Translate into first-order logic: Cancer biology is finding genetic alterations that confer selective advantage to cancer cells.",
"output": "FindingGeneticAlterationsConferSelectiveAdvantageCancerCells(cancerBiology)"
},
{
"input": "Translate into first-order logic: Cancer researchers have frequently ranked the importance of substitutions to cancer growth by P value.",
"output": " PValue(cancerResearchers, theImportanceOfSubstitutionsToCancerGrowth)"
},
{
"input": "Translate into first-order logic: P values are thresholds for belief, not metrics of effect.",
"output": " ∀x (PValue(x) → ThresholdsForBelief(x) ∧ ¬MetricsOfEffect(x))"
},
{
"input": "Translate into first-order logic: Cancer biology is finding genetic alterations that confer selective advantage to cancer cells.",
"output": "FindingGeneticAlterationsConferSelectiveAdvantageCancerCells(cancerBiology)"
},
{
"input": "Translate into first-order logic: Cancer researchers have frequently ranked the importance of substitutions to cancer growth by P value.",
"output": " PValue(cancerResearchers, theImportanceOfSubstitutionsToCancerGrowth)"
},
{
"input": "Translate into first-order logic: P values are thresholds for belief, not metrics of effect.",
"output": " ∀x (PValue(x) → ThresholdsForBelief(x) ∧ ¬MetricsOfEffect(x))"
},
{
"input": "Translate into first-order logic: Cancer biology is finding genetic alterations that confer selective advantage to cancer cells.",
"output": "FindingGeneticAlterationsConferSelectiveAdvantageCancerCells(cancerBiology)"
},
{
"input": "Translate into first-order logic: Cancer researchers have frequently ranked the importance of substitutions to cancer growth by P value.",
"output": " PValue(cancerResearchers, theImportanceOfSubstitutionsToCancerGrowth)"
},
{
"input": "Translate into first-order logic: P values are thresholds for belief, not metrics of effect.",
"output": " ∀x (PValue(x) → ThresholdsForBelief(x) ∧ ¬MetricsOfEffect(x))"
},
{
"input": "Translate into first-order logic: Cancer biology is finding genetic alterations that confer selective advantage to cancer cells.",
"output": "FindingGeneticAlterationsConferSelectiveAdvantageCancerCells(cancerBiology)"
},
{
"input": "Translate into first-order logic: Cancer researchers have frequently ranked the importance of substitutions to cancer growth by P value.",
"output": " PValue(cancerResearchers, theImportanceOfSubstitutionsToCancerGrowth)"
},
{
"input": "Translate into first-order logic: P values are thresholds for belief, not metrics of effect.",
"output": " ∀x (PValue(x) → ThresholdsForBelief(x) ∧ ¬MetricsOfEffect(x))"
},
{
"input": "Translate into first-order logic: All dispensable things are environment-friendly.",
"output": "∀x (Dispensable(x) → EnvironmentFriendly(x))"
},
{
"input": "Translate into first-order logic: All woodware is dispensable.",
"output": "∀x (Woodware(x) → Dispensable(x))"
},
{
"input": "Translate into first-order logic: All paper is woodware.",
"output": "∀x (Paper(x) → Woodware(x))"
},
{
"input": "Translate into first-order logic: No good things are bad.",
"output": "∀x (Good(x) → ¬Bad(x))"
},
{
"input": "Translate into first-order logic: All environment-friendly things are good.",
"output": "∀x (EnvironmentFriendly(x) → Good(x))"
},
{
"input": "Translate into first-order logic: A worksheet is either paper or is environment-friendly.",
"output": "Paper(worksheet) ⊕ EnvironmentFriendly(worksheet)"
},
{
"input": "Translate into first-order logic: All dispensable things are environment-friendly.",
"output": "∀x (Dispensable(x) → EnvironmentFriendly(x))"
},
{
"input": "Translate into first-order logic: All woodware is dispensable.",
"output": "∀x (Woodware(x) → Dispensable(x))"
},
{
"input": "Translate into first-order logic: All paper is woodware.",
"output": "∀x (Paper(x) → Woodware(x))"
},
{
"input": "Translate into first-order logic: No good things are bad.",
"output": "∀x (Good(x) → ¬Bad(x))"
},
{
"input": "Translate into first-order logic: All environment-friendly things are good.",
"output": "∀x (EnvironmentFriendly(x) → Good(x))"
},
{
"input": "Translate into first-order logic: A worksheet is either paper or is environment-friendly.",
"output": "Paper(worksheet) ⊕ EnvironmentFriendly(worksheet)"
},
{
"input": "Translate into first-order logic: All dispensable things are environment-friendly.",
"output": "∀x (Dispensable(x) → EnvironmentFriendly(x))"
},
{
"input": "Translate into first-order logic: All woodware is dispensable.",
"output": "∀x (Woodware(x) → Dispensable(x))"
},
{
"input": "Translate into first-order logic: All paper is woodware.",
"output": "∀x (Paper(x) → Woodware(x))"
},
{
"input": "Translate into first-order logic: No good things are bad.",
"output": "∀x (Good(x) → ¬Bad(x))"
},
{
"input": "Translate into first-order logic: All environment-friendly things are good.",
"output": "∀x (EnvironmentFriendly(x) → Good(x))"
},
{
"input": "Translate into first-order logic: A worksheet is either paper or is environment-friendly.",
"output": "Paper(worksheet) ⊕ EnvironmentFriendly(worksheet)"
},
{
"input": "Translate into first-order logic: All dispensable things are environment-friendly.",
"output": "∀x (Dispensable(x) → EnvironmentFriendly(x))"
},
{
"input": "Translate into first-order logic: All woodware is dispensable.",
"output": "∀x (Woodware(x) → Dispensable(x))"
},
{
"input": "Translate into first-order logic: All paper is woodware.",
"output": "∀x (Paper(x) → Woodware(x))"
},
{
"input": "Translate into first-order logic: No good things are bad.",
"output": "∀x (Good(x) → ¬Bad(x))"
},
{
"input": "Translate into first-order logic: All environment-friendly things are good.",
"output": "∀x (EnvironmentFriendly(x) → Good(x))"
},
{
"input": "Translate into first-order logic: A worksheet is either paper or is environment-friendly.",
"output": "Paper(worksheet) ⊕ EnvironmentFriendly(worksheet)"
},
{
"input": "Translate into first-order logic: No reptile has fur.",
"output": "∀x (Reptile(x) → ¬HasFur(x))"
},
{
"input": "Translate into first-order logic: All snakes are reptiles.",
"output": "∀x (Snake(x) → Reptile(x))"
},
{
"input": "Translate into first-order logic: All buildings in New Haven are low.",
"output": "∀x (Located(newhaven, x) → ¬High(x))"
},
{
"input": "Translate into first-order logic: All buildings managed by the Yale Housing are located in New Haven.",
"output": "∀x (YaleHousing(x) → Located(newhaven, x))"
},
{
"input": "Translate into first-order logic: All buildings in Manhattans are high.",
"output": "∀x (Located(manhattans, x) → High(x))"
},
{
"input": "Translate into first-order logic: All buildings owned by Bloomberg are located in Manhattans.",
"output": "∀x (Bloomberg(x) → Located(manhattans, x))"
},
{
"input": "Translate into first-order logic: All buildings with the Bloomberg logo are owned by Bloomberg.",
"output": "∀x (BloombergLogo(x) → Bloomberg(x))"
},
{
"input": "Translate into first-order logic: Tower A is managed by the Yale Housing.",
"output": "YaleHousing(tower-a)"
},
{
"input": "Translate into first-order logic: Tower B is with the Bloomberg logo.",
"output": "BloombergLogo(tower-b)"
},
{
"input": "Translate into first-order logic: All buildings in New Haven are low.",
"output": "∀x (Located(newhaven, x) → ¬High(x))"
},
{
"input": "Translate into first-order logic: All buildings managed by the Yale Housing are located in New Haven.",
"output": "∀x (YaleHousing(x) → Located(newhaven, x))"
},
{
"input": "Translate into first-order logic: All buildings in Manhattans are high.",
"output": "∀x (Located(manhattans, x) → High(x))"
},
{
"input": "Translate into first-order logic: All buildings owned by Bloomberg are located in Manhattans.",
"output": "∀x (Bloomberg(x) → Located(manhattans, x))"
},
{
"input": "Translate into first-order logic: All buildings with the Bloomberg logo are owned by Bloomberg.",
"output": "∀x (BloombergLogo(x) → Bloomberg(x))"
},
{
"input": "Translate into first-order logic: Tower A is managed by the Yale Housing.",
"output": "YaleHousing(tower-a)"
},
{
"input": "Translate into first-order logic: Tower B is with the Bloomberg logo.",
"output": "BloombergLogo(tower-b)"
},
{
"input": "Translate into first-order logic: All buildings in New Haven are low.",
"output": "∀x (Located(newhaven, x) → ¬High(x))"
},
{
"input": "Translate into first-order logic: All buildings managed by the Yale Housing are located in New Haven.",
"output": "∀x (YaleHousing(x) → Located(newhaven, x))"
},
{
"input": "Translate into first-order logic: All buildings in Manhattans are high.",
"output": "∀x (Located(manhattans, x) → High(x))"
},
{
"input": "Translate into first-order logic: All buildings owned by Bloomberg are located in Manhattans.",
"output": "∀x (Bloomberg(x) → Located(manhattans, x))"
},
{
"input": "Translate into first-order logic: All buildings with the Bloomberg logo are owned by Bloomberg.",
"output": "∀x (BloombergLogo(x) → Bloomberg(x))"
},
{
"input": "Translate into first-order logic: Tower A is managed by the Yale Housing.",
"output": "YaleHousing(tower-a)"
},
{
"input": "Translate into first-order logic: Tower B is with the Bloomberg logo.",
"output": "BloombergLogo(tower-b)"
},
{
"input": "Translate into first-order logic: No cold-blooded animals are birds.",
"output": "∀x (ColdBlooded(x) → ¬Bird(x))"
},
{
"input": "Translate into first-order logic: All reptiles are cold-blooded.",
"output": "∀x (Reptile(x) → ColdBlooded(x))"
},
{
"input": "Translate into first-order logic: Either an animal is a bird or it eats other animals.",
"output": "∀x (Bird(x) ∨ EatOtherAnimals(x))"
},
{
"input": "Translate into first-order logic: If an animal eats other animals, then it is a carnivore.",
"output": "∀x (EatOtherAnimals(x) → Carnivore(x))"
},
{
"input": "Translate into first-order logic: Ron is neither a cold-blooded animal nor a carnivore.",
"output": "¬ColdBlooded(ron) ∧ ¬Carnivore(ron)"
},
{
"input": "Translate into first-order logic: Henry is neither a carnivore nor a lizard.",
"output": "¬Carnivore(henry) ∧ ¬Lizard(henry)"
},
{
"input": "Translate into first-order logic: No cold-blooded animals are birds.",
"output": "∀x (ColdBlooded(x) → ¬Bird(x))"
},
{
"input": "Translate into first-order logic: All reptiles are cold-blooded.",
"output": "∀x (Reptile(x) → ColdBlooded(x))"
},
{
"input": "Translate into first-order logic: Either an animal is a bird or it eats other animals.",
"output": "∀x (Bird(x) ∨ EatOtherAnimals(x))"
},
{
"input": "Translate into first-order logic: If an animal eats other animals, then it is a carnivore.",
"output": "∀x (EatOtherAnimals(x) → Carnivore(x))"
},
{
"input": "Translate into first-order logic: Ron is neither a cold-blooded animal nor a carnivore.",
"output": "¬ColdBlooded(ron) ∧ ¬Carnivore(ron)"
},
{
"input": "Translate into first-order logic: Henry is neither a carnivore nor a lizard.",
"output": "¬Carnivore(henry) ∧ ¬Lizard(henry)"
},
{
"input": "Translate into first-order logic: No cold-blooded animals are birds.",
"output": "∀x (ColdBlooded(x) → ¬Bird(x))"
},
{
"input": "Translate into first-order logic: All reptiles are cold-blooded.",
"output": "∀x (Reptile(x) → ColdBlooded(x))"
},
{
"input": "Translate into first-order logic: Either an animal is a bird or it eats other animals.",
"output": "∀x (Bird(x) ∨ EatOtherAnimals(x))"
},
{
"input": "Translate into first-order logic: If an animal eats other animals, then it is a carnivore.",
"output": "∀x (EatOtherAnimals(x) → Carnivore(x))"
},
{
"input": "Translate into first-order logic: Ron is neither a cold-blooded animal nor a carnivore.",
"output": "¬ColdBlooded(ron) ∧ ¬Carnivore(ron)"
},
{
"input": "Translate into first-order logic: Henry is neither a carnivore nor a lizard.",
"output": "¬Carnivore(henry) ∧ ¬Lizard(henry)"
},
{
"input": "Translate into first-order logic: Ambiortus is a prehistoric bird genus.",
"output": "Prehistoric(ambiortus) ∧ BirdGenus(ambiortus)"
},
{
"input": "Translate into first-order logic: Ambiorus Dementjevi is the only known species of Ambiortus.",
"output": "∀x (Species(x, ambiortus) → AmbiortusDementjevi(x))"
},
{
"input": "Translate into first-order logic: The Mongol region was where Ambiorus Dementjevi lived.",
"output": "∀x (AmbiortusDementjevi(x) → Lived(x, mongolregion))"
},
{
"input": "Translate into first-order logic: Yevgeny Kurochkin was the discoverer of Ambiortus.",
"output": "Discovered(yevgenykurochkin, ambiortus)"
},
{
"input": "Translate into first-order logic: Ambiortus is a prehistoric bird genus.",
"output": "Prehistoric(ambiortus) ∧ BirdGenus(ambiortus)"
},
{
"input": "Translate into first-order logic: Ambiorus Dementjevi is the only known species of Ambiortus.",
"output": "∀x (Species(x, ambiortus) → AmbiortusDementjevi(x))"
},
{
"input": "Translate into first-order logic: The Mongol region was where Ambiorus Dementjevi lived.",
"output": "∀x (AmbiortusDementjevi(x) → Lived(x, mongolregion))"
},
{
"input": "Translate into first-order logic: Yevgeny Kurochkin was the discoverer of Ambiortus.",
"output": "Discovered(yevgenykurochkin, ambiortus)"
},
{
"input": "Translate into first-order logic: Ambiortus is a prehistoric bird genus.",
"output": "Prehistoric(ambiortus) ∧ BirdGenus(ambiortus)"
},
{
"input": "Translate into first-order logic: Ambiorus Dementjevi is the only known species of Ambiortus.",
"output": "∀x (Species(x, ambiortus) → AmbiortusDementjevi(x))"
},
{
"input": "Translate into first-order logic: The Mongol region was where Ambiorus Dementjevi lived.",
"output": "∀x (AmbiortusDementjevi(x) → Lived(x, mongolregion))"
},
{
"input": "Translate into first-order logic: Yevgeny Kurochkin was the discoverer of Ambiortus.",
"output": "Discovered(yevgenykurochkin, ambiortus)"
},
{
"input": "Translate into first-order logic: Ambiortus is a prehistoric bird genus.",
"output": "Prehistoric(ambiortus) ∧ BirdGenus(ambiortus)"
},
{
"input": "Translate into first-order logic: Ambiorus Dementjevi is the only known species of Ambiortus.",
"output": "∀x (Species(x, ambiortus) → AmbiortusDementjevi(x))"
},
{
"input": "Translate into first-order logic: The Mongol region was where Ambiorus Dementjevi lived.",
"output": "∀x (AmbiortusDementjevi(x) → Lived(x, mongolregion))"
},
{
"input": "Translate into first-order logic: Yevgeny Kurochkin was the discoverer of Ambiortus.",
"output": "Discovered(yevgenykurochkin, ambiortus)"
},
{
"input": "Translate into first-order logic: Everyone that uses a football can throw a football.",
"output": "∀x (UseFootball(x) → ThrowFootball(x))"
},
{
"input": "Translate into first-order logic: If someone plays football, then they use a football.",
"output": "∀x (PlayFootball(x) → UseFootball(x))"
},
{
"input": "Translate into first-order logic: Either someone is a football player or a basketball player.",
"output": "∀x (BasketballPlayer(x) ∨ PlayFootball(x))"
},
{
"input": "Translate into first-order logic: Every basketball player is tall.",
"output": "∀x (BasketballPlayer(x) → Tall(x))"
},
{
"input": "Translate into first-order logic: Everyone that can throw a football can throw a football with a spiral.",
"output": "∀x (ThrowFootball(x) → ThrowFootballSpiral(x))"
},
{
"input": "Translate into first-order logic: If someone is tall, then they are in shape.",
"output": "∀x (Tall(x) → InShape(x))"
},
{
"input": "Translate into first-order logic: If Jack is neither tall nor a basketball player,  then Jack is neither tall nor can throw a football.",
"output": "¬Tall(jack) ∧ ¬BasketballPlayer(jack) → ¬Tall(jack) ∧ ¬ThrowFootball(jack)"
},
{
"input": "Translate into first-order logic: Everyone that uses a football can throw a football.",
"output": "∀x (UseFootball(x) → ThrowFootball(x))"
},
{
"input": "Translate into first-order logic: If someone plays football, then they use a football.",
"output": "∀x (PlayFootball(x) → UseFootball(x))"
},
{
"input": "Translate into first-order logic: Either someone is a football player or a basketball player.",
"output": "∀x (BasketballPlayer(x) ∨ PlayFootball(x))"
},
{
"input": "Translate into first-order logic: Every basketball player is tall.",
"output": "∀x (BasketballPlayer(x) → Tall(x))"
},
{
"input": "Translate into first-order logic: Everyone that can throw a football can throw a football with a spiral.",
"output": "∀x (ThrowFootball(x) → ThrowFootballSpiral(x))"
},
{
"input": "Translate into first-order logic: If someone is tall, then they are in shape.",
"output": "∀x (Tall(x) → InShape(x))"
},
{
"input": "Translate into first-order logic: If Jack is neither tall nor a basketball player,  then Jack is neither tall nor can throw a football.",
"output": "¬Tall(jack) ∧ ¬BasketballPlayer(jack) → ¬Tall(jack) ∧ ¬ThrowFootball(jack)"
},
{
"input": "Translate into first-order logic: Everyone that uses a football can throw a football.",
"output": "∀x (UseFootball(x) → ThrowFootball(x))"
},
{
"input": "Translate into first-order logic: If someone plays football, then they use a football.",
"output": "∀x (PlayFootball(x) → UseFootball(x))"
},
{
"input": "Translate into first-order logic: Either someone is a football player or a basketball player.",
"output": "∀x (BasketballPlayer(x) ∨ PlayFootball(x))"
},
{
"input": "Translate into first-order logic: Every basketball player is tall.",
"output": "∀x (BasketballPlayer(x) → Tall(x))"
},
{
"input": "Translate into first-order logic: Everyone that can throw a football can throw a football with a spiral.",
"output": "∀x (ThrowFootball(x) → ThrowFootballSpiral(x))"
},
{
"input": "Translate into first-order logic: If someone is tall, then they are in shape.",
"output": "∀x (Tall(x) → InShape(x))"
},
{
"input": "Translate into first-order logic: If Jack is neither tall nor a basketball player,  then Jack is neither tall nor can throw a football.",
"output": "¬Tall(jack) ∧ ¬BasketballPlayer(jack) → ¬Tall(jack) ∧ ¬ThrowFootball(jack)"
},
{
"input": "Translate into first-order logic: Fort Ticonderoga is the current name for Fort Carillon.",
"output": "CurrentName(fortticonderoga, fortcarillon)"
},
{
"input": "Translate into first-order logic: Pierre de Rigaud de Vaudreuil built Fort Carillon.",
"output": "Built(pierrederigauddevaudreuil, fortcarillon)"
},
{
"input": "Translate into first-order logic: Fort Carillon was located in New France.",
"output": "LocatedIn(fortcarillon, newfrance)"
},
{
"input": "Translate into first-order logic: New France is not in Europe.",
"output": "¬LocatedIn(newfrance, europe)"
},
{
"input": "Translate into first-order logic: Fort Ticonderoga is the current name for Fort Carillon.",
"output": "CurrentName(fortticonderoga, fortcarillon)"
},
{
"input": "Translate into first-order logic: Pierre de Rigaud de Vaudreuil built Fort Carillon.",
"output": "Built(pierrederigauddevaudreuil, fortcarillon)"
},
{
"input": "Translate into first-order logic: Fort Carillon was located in New France.",
"output": "LocatedIn(fortcarillon, newfrance)"
},
{
"input": "Translate into first-order logic: New France is not in Europe.",
"output": "¬LocatedIn(newfrance, europe)"
},
{
"input": "Translate into first-order logic: Fort Ticonderoga is the current name for Fort Carillon.",
"output": "CurrentName(fortticonderoga, fortcarillon)"
},
{
"input": "Translate into first-order logic: Pierre de Rigaud de Vaudreuil built Fort Carillon.",
"output": "Built(pierrederigauddevaudreuil, fortcarillon)"
},
{
"input": "Translate into first-order logic: Fort Carillon was located in New France.",
"output": "LocatedIn(fortcarillon, newfrance)"
},
{
"input": "Translate into first-order logic: New France is not in Europe.",
"output": "¬LocatedIn(newfrance, europe)"
},
{
"input": "Translate into first-order logic: No soccer players are professional basketball players.",
"output": "¬(∃x (SoccerPlayer(x) ∧ ProfessionalBasketballPlayer(x)))"
},
{
"input": "Translate into first-order logic: All NBA players are professional basketball players.",
"output": "∀x (NBAPlayer(x) → ProfessionalBasketballPlayer(x))"
},
{
"input": "Translate into first-order logic: All defenders are soccer players.",
"output": "∀x (Defender(x) → SoccerPlayer(x))"
},
{
"input": "Translate into first-order logic: All centerback players are defenders.",
"output": "∀x (Centerback(x) → Defender(x))"
},
{
"input": "Translate into first-order logic: If Stephen Curry is an NBA player or a soccer player, then he is a professional basketball player.",
"output": "(NBAPlayer(stephencurry) ⊕ SoccerPlayer(stephencurry)) → ProfessionalBasketballPlayer(stephencurry)"
},
{
"input": "Translate into first-order logic: No soccer players are professional basketball players.",
"output": "¬(∃x (SoccerPlayer(x) ∧ ProfessionalBasketballPlayer(x)))"
},
{
"input": "Translate into first-order logic: All NBA players are professional basketball players.",
"output": "∀x (NBAPlayer(x) → ProfessionalBasketballPlayer(x))"
},
{
"input": "Translate into first-order logic: All defenders are soccer players.",
"output": "∀x (Defender(x) → SoccerPlayer(x))"
},
{
"input": "Translate into first-order logic: All centerback players are defenders.",
"output": "∀x (Centerback(x) → Defender(x))"
},
{
"input": "Translate into first-order logic: If Stephen Curry is an NBA player or a soccer player, then he is a professional basketball player.",
"output": "(NBAPlayer(stephencurry) ⊕ SoccerPlayer(stephencurry)) → ProfessionalBasketballPlayer(stephencurry)"
},
{
"input": "Translate into first-order logic: No soccer players are professional basketball players.",
"output": "¬(∃x (SoccerPlayer(x) ∧ ProfessionalBasketballPlayer(x)))"
},
{
"input": "Translate into first-order logic: All NBA players are professional basketball players.",
"output": "∀x (NBAPlayer(x) → ProfessionalBasketballPlayer(x))"
},
{
"input": "Translate into first-order logic: All defenders are soccer players.",
"output": "∀x (Defender(x) → SoccerPlayer(x))"
},
{
"input": "Translate into first-order logic: All centerback players are defenders.",
"output": "∀x (Centerback(x) → Defender(x))"
},
{
"input": "Translate into first-order logic: If Stephen Curry is an NBA player or a soccer player, then he is a professional basketball player.",
"output": "(NBAPlayer(stephencurry) ⊕ SoccerPlayer(stephencurry)) → ProfessionalBasketballPlayer(stephencurry)"
},
{
"input": "Translate into first-order logic: No songs are visual.",
"output": "∀x (Song(x) → ¬Visual(x))"
},
{
"input": "Translate into first-order logic: All folk songs are songs.",
"output": "∀x (FolkSong(x) → Song(x))"
},
{
"input": "Translate into first-order logic: All videos are visual.",
"output": "∀x (Video(x) → Visual(x))"
},
{
"input": "Translate into first-order logic: All movies are videos.",
"output": "∀x (Movie(x) → Video(x))"
},
{
"input": "Translate into first-order logic: All sci-fi movies are movies.",
"output": "∀x (ScifiMovie(x) → Movie(x))"
},
{
"input": "Translate into first-order logic: Inception is a sci-fi movie.",
"output": "ScifiMovie(inception)"
},
{
"input": "Translate into first-order logic: Mac is neither a folk song nor a sci-fi movie.",
"output": "¬FolkSong(mac) ∧ ¬ScifiMovie(mac)"
},
{
"input": "Translate into first-order logic: No songs are visual.",
"output": "∀x (Song(x) → ¬Visual(x))"
},
{
"input": "Translate into first-order logic: All folk songs are songs.",
"output": "∀x (FolkSong(x) → Song(x))"
},
{
"input": "Translate into first-order logic: All videos are visual.",
"output": "∀x (Video(x) → Visual(x))"
},
{
"input": "Translate into first-order logic: All movies are videos.",
"output": "∀x (Movie(x) → Video(x))"
},
{
"input": "Translate into first-order logic: All sci-fi movies are movies.",
"output": "∀x (ScifiMovie(x) → Movie(x))"
},
{
"input": "Translate into first-order logic: Inception is a sci-fi movie.",
"output": "ScifiMovie(inception)"
},
{
"input": "Translate into first-order logic: Mac is neither a folk song nor a sci-fi movie.",
"output": "¬FolkSong(mac) ∧ ¬ScifiMovie(mac)"
},
{
"input": "Translate into first-order logic: No songs are visual.",
"output": "∀x (Song(x) → ¬Visual(x))"
},
{
"input": "Translate into first-order logic: All folk songs are songs.",
"output": "∀x (FolkSong(x) → Song(x))"
},
{
"input": "Translate into first-order logic: All videos are visual.",
"output": "∀x (Video(x) → Visual(x))"
},
{
"input": "Translate into first-order logic: All movies are videos.",
"output": "∀x (Movie(x) → Video(x))"
},
{
"input": "Translate into first-order logic: All sci-fi movies are movies.",
"output": "∀x (ScifiMovie(x) → Movie(x))"
},
{
"input": "Translate into first-order logic: Inception is a sci-fi movie.",
"output": "ScifiMovie(inception)"
},
{
"input": "Translate into first-order logic: Mac is neither a folk song nor a sci-fi movie.",
"output": "¬FolkSong(mac) ∧ ¬ScifiMovie(mac)"
},
{
"input": "Translate into first-order logic: No songs are visual.",
"output": "∀x (Song(x) → ¬Visual(x))"
},
{
"input": "Translate into first-order logic: All folk songs are songs.",
"output": "∀x (FolkSong(x) → Song(x))"
},
{
"input": "Translate into first-order logic: All videos are visual.",
"output": "∀x (Video(x) → Visual(x))"
},
{
"input": "Translate into first-order logic: All movies are videos.",
"output": "∀x (Movie(x) → Video(x))"
},
{
"input": "Translate into first-order logic: All sci-fi movies are movies.",
"output": "∀x (ScifiMovie(x) → Movie(x))"
},
{
"input": "Translate into first-order logic: Inception is a sci-fi movie.",
"output": "ScifiMovie(inception)"
},
{
"input": "Translate into first-order logic: Mac is neither a folk song nor a sci-fi movie.",
"output": "¬FolkSong(mac) ∧ ¬ScifiMovie(mac)"
},
{
"input": "Translate into first-order logic: All extroverts are overtly expressive.",
"output": "∀x (Extroverts(x) → OvertlyExpressive(x))"
},
{
"input": "Translate into first-order logic: People are either extroverts or introverts.",
"output": " ∀x (Extroverts(x) ∨ Introverts(x)) "
},
{
"input": "Translate into first-order logic: If someone is an introvert, then they are shy and reticent.",
"output": " ∀x (Introverts(x) → ShyAndReticentPerson(x))"
},
{
"input": "Translate into first-order logic: No shy and reticent person likes to talk to strangers.",
"output": " ∀x (ShyAndReticentPerson(x) → ¬LikeToTalkToStrangers(x))"
},
{
"input": "Translate into first-order logic: Jeff is not an extrovert and someone who likes to talk to strangers.",
"output": " ¬Extroverts(jeff) ∧ ¬LikeToTalkToStrangers(jeff)"
},
{
"input": "Translate into first-order logic: All extroverts are overtly expressive.",
"output": "∀x (Extroverts(x) → OvertlyExpressive(x))"
},
{
"input": "Translate into first-order logic: People are either extroverts or introverts.",
"output": " ∀x (Extroverts(x) ∨ Introverts(x)) "
},
{
"input": "Translate into first-order logic: If someone is an introvert, then they are shy and reticent.",
"output": " ∀x (Introverts(x) → ShyAndReticentPerson(x))"
},
{
"input": "Translate into first-order logic: No shy and reticent person likes to talk to strangers.",
"output": " ∀x (ShyAndReticentPerson(x) → ¬LikeToTalkToStrangers(x))"
},
{
"input": "Translate into first-order logic: Jeff is not an extrovert and someone who likes to talk to strangers.",
"output": " ¬Extroverts(jeff) ∧ ¬LikeToTalkToStrangers(jeff)"
},
{
"input": "Translate into first-order logic: All extroverts are overtly expressive.",
"output": "∀x (Extroverts(x) → OvertlyExpressive(x))"
},
{
"input": "Translate into first-order logic: People are either extroverts or introverts.",
"output": " ∀x (Extroverts(x) ∨ Introverts(x)) "
},
{
"input": "Translate into first-order logic: If someone is an introvert, then they are shy and reticent.",
"output": " ∀x (Introverts(x) → ShyAndReticentPerson(x))"
},
{
"input": "Translate into first-order logic: No shy and reticent person likes to talk to strangers.",
"output": " ∀x (ShyAndReticentPerson(x) → ¬LikeToTalkToStrangers(x))"
},
{
"input": "Translate into first-order logic: Jeff is not an extrovert and someone who likes to talk to strangers.",
"output": " ¬Extroverts(jeff) ∧ ¬LikeToTalkToStrangers(jeff)"
},
{
"input": "Translate into first-order logic: No low-scoring players are top players in the league.",
"output": "∀x (LowScore(x) → ¬TopPlayer(x))"
},
{
"input": "Translate into first-order logic: Basketball players are either top players in the league or successfully shoot a high percentage of 3-pointers.",
"output": "∀x (TopPlayer(x) ∨ ThreePointer(x))"
},
{
"input": "Translate into first-order logic: All players who successfully shoot a high percentage of 3-pointers are solid at shooting 2-pointers.",
"output": "∀x (ThreePointer(x) → TwoPointer(x))"
},
{
"input": "Translate into first-order logic: No players who are solid at shooting 2-pointers are bad at mid-range shots.",
"output": "∀x (TwoPointer(x) → ¬BadMid(x))"
},
{
"input": "Translate into first-order logic: Candace is either a low-scoring player or successfully shoots a high percentage of 3-pointers.",
"output": "LowScore(candace) ⊕ ThreePointer(candace)"
},
{
"input": "Translate into first-order logic: No low-scoring players are top players in the league.",
"output": "∀x (LowScore(x) → ¬TopPlayer(x))"
},
{
"input": "Translate into first-order logic: Basketball players are either top players in the league or successfully shoot a high percentage of 3-pointers.",
"output": "∀x (TopPlayer(x) ∨ ThreePointer(x))"
},
{
"input": "Translate into first-order logic: All players who successfully shoot a high percentage of 3-pointers are solid at shooting 2-pointers.",
"output": "∀x (ThreePointer(x) → TwoPointer(x))"
},
{
"input": "Translate into first-order logic: No players who are solid at shooting 2-pointers are bad at mid-range shots.",
"output": "∀x (TwoPointer(x) → ¬BadMid(x))"
},
{
"input": "Translate into first-order logic: Candace is either a low-scoring player or successfully shoots a high percentage of 3-pointers.",
"output": "LowScore(candace) ⊕ ThreePointer(candace)"
},
{
"input": "Translate into first-order logic: No low-scoring players are top players in the league.",
"output": "∀x (LowScore(x) → ¬TopPlayer(x))"
},
{
"input": "Translate into first-order logic: Basketball players are either top players in the league or successfully shoot a high percentage of 3-pointers.",
"output": "∀x (TopPlayer(x) ∨ ThreePointer(x))"
},
{
"input": "Translate into first-order logic: All players who successfully shoot a high percentage of 3-pointers are solid at shooting 2-pointers.",
"output": "∀x (ThreePointer(x) → TwoPointer(x))"
},
{
"input": "Translate into first-order logic: No players who are solid at shooting 2-pointers are bad at mid-range shots.",
"output": "∀x (TwoPointer(x) → ¬BadMid(x))"
},
{
"input": "Translate into first-order logic: Candace is either a low-scoring player or successfully shoots a high percentage of 3-pointers.",
"output": "LowScore(candace) ⊕ ThreePointer(candace)"
},
{
"input": "Translate into first-order logic: No low-scoring players are top players in the league.",
"output": "∀x (LowScore(x) → ¬TopPlayer(x))"
},
{
"input": "Translate into first-order logic: Basketball players are either top players in the league or successfully shoot a high percentage of 3-pointers.",
"output": "∀x (TopPlayer(x) ∨ ThreePointer(x))"
},
{
"input": "Translate into first-order logic: All players who successfully shoot a high percentage of 3-pointers are solid at shooting 2-pointers.",
"output": "∀x (ThreePointer(x) → TwoPointer(x))"
},
{
"input": "Translate into first-order logic: No players who are solid at shooting 2-pointers are bad at mid-range shots.",
"output": "∀x (TwoPointer(x) → ¬BadMid(x))"
},
{
"input": "Translate into first-order logic: Candace is either a low-scoring player or successfully shoots a high percentage of 3-pointers.",
"output": "LowScore(candace) ⊕ ThreePointer(candace)"
},
{
"input": "Translate into first-order logic: No low-scoring players are top players in the league.",
"output": "∀x (LowScore(x) → ¬TopPlayer(x))"
},
{
"input": "Translate into first-order logic: Basketball players are either top players in the league or successfully shoot a high percentage of 3-pointers.",
"output": "∀x (TopPlayer(x) ∨ ThreePointer(x))"
},
{
"input": "Translate into first-order logic: All players who successfully shoot a high percentage of 3-pointers are solid at shooting 2-pointers.",
"output": "∀x (ThreePointer(x) → TwoPointer(x))"
},
{
"input": "Translate into first-order logic: No players who are solid at shooting 2-pointers are bad at mid-range shots.",
"output": "∀x (TwoPointer(x) → ¬BadMid(x))"
},
{
"input": "Translate into first-order logic: Candace is either a low-scoring player or successfully shoots a high percentage of 3-pointers.",
"output": "LowScore(candace) ⊕ ThreePointer(candace)"
},
{
"input": "Translate into first-order logic: No low-scoring players are top players in the league.",
"output": "∀x (LowScore(x) → ¬TopPlayer(x))"
},
{
"input": "Translate into first-order logic: Basketball players are either top players in the league or successfully shoot a high percentage of 3-pointers.",
"output": "∀x (TopPlayer(x) ∨ ThreePointer(x))"
},
{
"input": "Translate into first-order logic: All players who successfully shoot a high percentage of 3-pointers are solid at shooting 2-pointers.",
"output": "∀x (ThreePointer(x) → TwoPointer(x))"
},
{
"input": "Translate into first-order logic: No players who are solid at shooting 2-pointers are bad at mid-range shots.",
"output": "∀x (TwoPointer(x) → ¬BadMid(x))"
},
{
"input": "Translate into first-order logic: Candace is either a low-scoring player or successfully shoots a high percentage of 3-pointers.",
"output": "LowScore(candace) ⊕ ThreePointer(candace)"
},
{
"input": "Translate into first-order logic: No low-scoring players are top players in the league.",
"output": "∀x (LowScore(x) → ¬TopPlayer(x))"
},
{
"input": "Translate into first-order logic: Basketball players are either top players in the league or successfully shoot a high percentage of 3-pointers.",
"output": "∀x (TopPlayer(x) ∨ ThreePointer(x))"
},
{
"input": "Translate into first-order logic: All players who successfully shoot a high percentage of 3-pointers are solid at shooting 2-pointers.",
"output": "∀x (ThreePointer(x) → TwoPointer(x))"
},
{
"input": "Translate into first-order logic: No players who are solid at shooting 2-pointers are bad at mid-range shots.",
"output": "∀x (TwoPointer(x) → ¬BadMid(x))"
},
{
"input": "Translate into first-order logic: Candace is either a low-scoring player or successfully shoots a high percentage of 3-pointers.",
"output": "LowScore(candace) ⊕ ThreePointer(candace)"
},
{
"input": "Translate into first-order logic: No low-scoring players are top players in the league.",
"output": "∀x (LowScore(x) → ¬TopPlayer(x))"
},
{
"input": "Translate into first-order logic: Basketball players are either top players in the league or successfully shoot a high percentage of 3-pointers.",
"output": "∀x (TopPlayer(x) ∨ ThreePointer(x))"
},
{
"input": "Translate into first-order logic: All players who successfully shoot a high percentage of 3-pointers are solid at shooting 2-pointers.",
"output": "∀x (ThreePointer(x) → TwoPointer(x))"
},
{
"input": "Translate into first-order logic: No players who are solid at shooting 2-pointers are bad at mid-range shots.",
"output": "∀x (TwoPointer(x) → ¬BadMid(x))"
},
{
"input": "Translate into first-order logic: Candace is either a low-scoring player or successfully shoots a high percentage of 3-pointers.",
"output": "LowScore(candace) ⊕ ThreePointer(candace)"
},
{
"input": "Translate into first-order logic: No low-scoring players are top players in the league.",
"output": "∀x (LowScore(x) → ¬TopPlayer(x))"
},
{
"input": "Translate into first-order logic: Basketball players are either top players in the league or successfully shoot a high percentage of 3-pointers.",
"output": "∀x (TopPlayer(x) ∨ ThreePointer(x))"
},
{
"input": "Translate into first-order logic: All players who successfully shoot a high percentage of 3-pointers are solid at shooting 2-pointers.",
"output": "∀x (ThreePointer(x) → TwoPointer(x))"
},
{
"input": "Translate into first-order logic: No players who are solid at shooting 2-pointers are bad at mid-range shots.",
"output": "∀x (TwoPointer(x) → ¬BadMid(x))"
},
{
"input": "Translate into first-order logic: Candace is either a low-scoring player or successfully shoots a high percentage of 3-pointers.",
"output": "LowScore(candace) ⊕ ThreePointer(candace)"
},
{
"input": "Translate into first-order logic: No plants are fungi.",
"output": "∀x (Plant(x) → ¬Fungi(x))"
},
{
"input": "Translate into first-order logic: Mushrooms are fungi.",
"output": "∀x (Mushroom(x) → Fungi(x))"
},
{
"input": "Translate into first-order logic: No road is clean.",
"output": "∀x (Road(x) → ¬Clean(x))"
},
{
"input": "Translate into first-order logic: And some streets are roads.",
"output": "∃x (Street(x) ∧ Road(x))"
},
{
"input": "Translate into first-order logic: New York City is on the East Coast.",
"output": "On(newyorkcity, eastcoast)"
},
{
"input": "Translate into first-order logic: Seattle is on the West Coast.",
"output": "On(seattle, westcoast)"
},
{
"input": "Translate into first-order logic: If a person from a city on the East coast is traveling to a city on the west coast, they will be on a long flight.",
"output": "∀x ∀y ∀z ((TravelingFrom(x, y) ∧ On(y, eastcoast) ∧ TravelingTo(x, z) ∧ On(z, westcoast)) → OnLongFlight(x))"
},
{
"input": "Translate into first-order logic: Most passengers on flights to Seattle from New York City are not in first class.",
"output": "∃x (¬InFirstClass(x) ∧ TravelingFrom(x, newyorkcity) ∧ TravelingTo(x, seattle))"
},
{
"input": "Translate into first-order logic: People on long flights are uncomfortable unless they're in first class",
"output": "∀x (OnLongFlight(x) ∧ ¬InFirstClass(x) → Uncomfortable(x))"
},
{
"input": "Translate into first-order logic: Musicians have very busy lives.",
"output": "∀x (Musician(x) → Busy(x))"
},
{
"input": "Translate into first-order logic: Singh Kaur is a musician and famous.",
"output": "Musician(singhKaur) ∧ Famous(singhKaur)"
},
{
"input": "Translate into first-order logic: If a musician is not famous, that musician will not make a lot of money.",
"output": "∀x (Musician(x) ∧ ¬Famous(x) → ¬MakeMoney(x))"
},
{
"input": "Translate into first-order logic: A musician can be a singer or a writer.",
"output": "∃x (Musician(x) ∧ Singer(x) ∨ Writer(x))"
},
{
"input": "Translate into first-order logic: Musicians have very busy lives.",
"output": "∀x (Musician(x) → Busy(x))"
},
{
"input": "Translate into first-order logic: Singh Kaur is a musician and famous.",
"output": "Musician(singhKaur) ∧ Famous(singhKaur)"
},
{
"input": "Translate into first-order logic: If a musician is not famous, that musician will not make a lot of money.",
"output": "∀x (Musician(x) ∧ ¬Famous(x) → ¬MakeMoney(x))"
},
{
"input": "Translate into first-order logic: A musician can be a singer or a writer.",
"output": "∃x (Musician(x) ∧ Singer(x) ∨ Writer(x))"
},
{
"input": "Translate into first-order logic: Musicians have very busy lives.",
"output": "∀x (Musician(x) → Busy(x))"
},
{
"input": "Translate into first-order logic: Singh Kaur is a musician and famous.",
"output": "Musician(singhKaur) ∧ Famous(singhKaur)"
},
{
"input": "Translate into first-order logic: If a musician is not famous, that musician will not make a lot of money.",
"output": "∀x (Musician(x) ∧ ¬Famous(x) → ¬MakeMoney(x))"
},
{
"input": "Translate into first-order logic: A musician can be a singer or a writer.",
"output": "∃x (Musician(x) ∧ Singer(x) ∨ Writer(x))"
},
{
"input": "Translate into first-order logic: Each building is tall.",
"output": "∀x (Building(x) → ¬Tall(x))"
},
{
"input": "Translate into first-order logic: Everything tall has  height.",
"output": "∀x (Tall(x) → HasHeight(x))"
},
{
"input": "Translate into first-order logic: A cat named Garfield, which is the main character of the film Garfield, is orange and fat and likes having lasagna.",
"output": "Cat(garfield) ∧ MainCharacterGarfield(garfield) ∧ BeOrange(garfield) ∧ BeFat(garfield) ∧ LikeLasagna(garfield)"
},
{
"input": "Translate into first-order logic: Garfield and Odie, who is another pet of Jon, share the same home.",
"output": "Pet(garfield, jon) ∧ Pet(odie, jon) ∧ ShareHome(garfield, odie)"
},
{
"input": "Translate into first-order logic: Garfield hates Odie.",
"output": "Hate(garfield, odie)"
},
{
"input": "Translate into first-order logic: A pet who hates the pet with whom he shares the same owner is childish and possessive.",
"output": "∀x ∀y ∃z (Pet(x, z) ∧ Pet(y, z) ∧ Hate(x, y) → BeChildish(x) ∧ BePossessive(x))"
},
{
"input": "Translate into first-order logic: Cats are pets.",
"output": "∀x ∃y (Cat(x) → Pet(x, y))"
},
{
"input": "Translate into first-order logic: All humans eat.",
"output": "∀x (Human(x) → Eat(x))"
},
{
"input": "Translate into first-order logic: If something eats, then it is not a plant.",
"output": "∀x (Eat(x) → ¬Plant(x))"
},
{
"input": "Translate into first-order logic: A thing is either plant or animal.",
"output": "∀x (Plant(x) ∨ Animal(x))"
},
{
"input": "Translate into first-order logic: All goats are animals.",
"output": "∀x (Goat(x) → Animal(x))"
},
{
"input": "Translate into first-order logic: No dirt is an animal.",
"output": "∀x (Dirt(x) → ¬Animal(x))"
},
{
"input": "Translate into first-order logic: Hulu is a goat or a human.",
"output": "Goat(hulu) ∨ Human(hulu)"
},
{
"input": "Translate into first-order logic: All humans eat.",
"output": "∀x (Human(x) → Eat(x))"
},
{
"input": "Translate into first-order logic: If something eats, then it is not a plant.",
"output": "∀x (Eat(x) → ¬Plant(x))"
},
{
"input": "Translate into first-order logic: A thing is either plant or animal.",
"output": "∀x (Plant(x) ∨ Animal(x))"
},
{
"input": "Translate into first-order logic: All goats are animals.",
"output": "∀x (Goat(x) → Animal(x))"
},
{
"input": "Translate into first-order logic: No dirt is an animal.",
"output": "∀x (Dirt(x) → ¬Animal(x))"
},
{
"input": "Translate into first-order logic: Hulu is a goat or a human.",
"output": "Goat(hulu) ∨ Human(hulu)"
},
{
"input": "Translate into first-order logic: All humans eat.",
"output": "∀x (Human(x) → Eat(x))"
},
{
"input": "Translate into first-order logic: If something eats, then it is not a plant.",
"output": "∀x (Eat(x) → ¬Plant(x))"
},
{
"input": "Translate into first-order logic: A thing is either plant or animal.",
"output": "∀x (Plant(x) ∨ Animal(x))"
},
{
"input": "Translate into first-order logic: All goats are animals.",
"output": "∀x (Goat(x) → Animal(x))"
},
{
"input": "Translate into first-order logic: No dirt is an animal.",
"output": "∀x (Dirt(x) → ¬Animal(x))"
},
{
"input": "Translate into first-order logic: Hulu is a goat or a human.",
"output": "Goat(hulu) ∨ Human(hulu)"
},
{
"input": "Translate into first-order logic: All humans eat.",
"output": "∀x (Human(x) → Eat(x))"
},
{
"input": "Translate into first-order logic: If something eats, then it is not a plant.",
"output": "∀x (Eat(x) → ¬Plant(x))"
},
{
"input": "Translate into first-order logic: A thing is either plant or animal.",
"output": "∀x (Plant(x) ∨ Animal(x))"
},
{
"input": "Translate into first-order logic: All goats are animals.",
"output": "∀x (Goat(x) → Animal(x))"
},
{
"input": "Translate into first-order logic: No dirt is an animal.",
"output": "∀x (Dirt(x) → ¬Animal(x))"
},
{
"input": "Translate into first-order logic: Hulu is a goat or a human.",
"output": "Goat(hulu) ∨ Human(hulu)"
},
{
"input": "Translate into first-order logic: All humans eat.",
"output": "∀x (Human(x) → Eat(x))"
},
{
"input": "Translate into first-order logic: If something eats, then it is not a plant.",
"output": "∀x (Eat(x) → ¬Plant(x))"
},
{
"input": "Translate into first-order logic: A thing is either plant or animal.",
"output": "∀x (Plant(x) ∨ Animal(x))"
},
{
"input": "Translate into first-order logic: All goats are animals.",
"output": "∀x (Goat(x) → Animal(x))"
},
{
"input": "Translate into first-order logic: No dirt is an animal.",
"output": "∀x (Dirt(x) → ¬Animal(x))"
},
{
"input": "Translate into first-order logic: Hulu is a goat or a human.",
"output": "Goat(hulu) ∨ Human(hulu)"
},
{
"input": "Translate into first-order logic: All humans eat.",
"output": "∀x (Human(x) → Eat(x))"
},
{
"input": "Translate into first-order logic: If something eats, then it is not a plant.",
"output": "∀x (Eat(x) → ¬Plant(x))"
},
{
"input": "Translate into first-order logic: A thing is either plant or animal.",
"output": "∀x (Plant(x) ∨ Animal(x))"
},
{
"input": "Translate into first-order logic: All goats are animals.",
"output": "∀x (Goat(x) → Animal(x))"
},
{
"input": "Translate into first-order logic: No dirt is an animal.",
"output": "∀x (Dirt(x) → ¬Animal(x))"
},
{
"input": "Translate into first-order logic: Hulu is a goat or a human.",
"output": "Goat(hulu) ∨ Human(hulu)"
},
{
"input": "Translate into first-order logic: A controlled substance is a drug.",
"output": "∀x (ControlledSubstances(x) → Drugs(x))"
},
{
"input": "Translate into first-order logic: There exist both harmful and beneficial controlled substances.",
"output": "∃x ∃x (ControlledSubstances(x) ∧ ControlledSubstances(y) ∧ Beneficial(x) ∧ Harmful(y))"
},
{
"input": "Translate into first-order logic: If a child is exposed to a controlled substance, he or she is in chemical endangerment.",
"output": "∀x ∀y (ExposedToControlledSubstance(x, y) → ChemicalEndangerment(x))"
},
{
"input": "Translate into first-order logic: Chemical Endangerment is harmful.",
"output": "∀x (ChemicalEndangerment(x) → Harmful(x))"
},
{
"input": "Translate into first-order logic: The Controlled Substances Act was an act passed in 1971.",
"output": "PassedIn(controlledSubstancesAct, year1971) ∧ Act(controlledSubstancesAct)"
},
{
"input": "Translate into first-order logic: Some Acts prevent harmful things.",
"output": "∃x (Act(x) ∧ PreventsHarm(x))"
},
{
"input": "Translate into first-order logic: A controlled substance is a drug.",
"output": "∀x (ControlledSubstances(x) → Drugs(x))"
},
{
"input": "Translate into first-order logic: There exist both harmful and beneficial controlled substances.",
"output": "∃x ∃x (ControlledSubstances(x) ∧ ControlledSubstances(y) ∧ Beneficial(x) ∧ Harmful(y))"
},
{
"input": "Translate into first-order logic: If a child is exposed to a controlled substance, he or she is in chemical endangerment.",
"output": "∀x ∀y (ExposedToControlledSubstance(x, y) → ChemicalEndangerment(x))"
},
{
"input": "Translate into first-order logic: Chemical Endangerment is harmful.",
"output": "∀x (ChemicalEndangerment(x) → Harmful(x))"
},
{
"input": "Translate into first-order logic: The Controlled Substances Act was an act passed in 1971.",
"output": "PassedIn(controlledSubstancesAct, year1971) ∧ Act(controlledSubstancesAct)"
},
{
"input": "Translate into first-order logic: Some Acts prevent harmful things.",
"output": "∃x (Act(x) ∧ PreventsHarm(x))"
},
{
"input": "Translate into first-order logic: A controlled substance is a drug.",
"output": "∀x (ControlledSubstances(x) → Drugs(x))"
},
{
"input": "Translate into first-order logic: There exist both harmful and beneficial controlled substances.",
"output": "∃x ∃x (ControlledSubstances(x) ∧ ControlledSubstances(y) ∧ Beneficial(x) ∧ Harmful(y))"
},
{
"input": "Translate into first-order logic: If a child is exposed to a controlled substance, he or she is in chemical endangerment.",
"output": "∀x ∀y (ExposedToControlledSubstance(x, y) → ChemicalEndangerment(x))"
},
{
"input": "Translate into first-order logic: Chemical Endangerment is harmful.",
"output": "∀x (ChemicalEndangerment(x) → Harmful(x))"
},
{
"input": "Translate into first-order logic: The Controlled Substances Act was an act passed in 1971.",
"output": "PassedIn(controlledSubstancesAct, year1971) ∧ Act(controlledSubstancesAct)"
},
{
"input": "Translate into first-order logic: Some Acts prevent harmful things.",
"output": "∃x (Act(x) ∧ PreventsHarm(x))"
},
{
"input": "Translate into first-order logic: No people who work at corporate jobs are starting a new company.",
"output": "∀x (WorkAtCorporateJobs(x) → ¬StartingANewCompany(x))"
},
{
"input": "Translate into first-order logic: All entrepreneurs are starting a new company.",
"output": " ∀x (Entrepreneurs(x) → StartingANewCompany(x))"
},
{
"input": "Translate into first-order logic: All risk-averse people are people who work at corporate jobs.",
"output": " ∀x (Risk-averse(x) → WorkAtCorporateJobs(x))"
},
{
"input": "Translate into first-order logic: All people who hate working for others are entrepreneurs.",
"output": " ∀x (HateWorkingForOthers(x) → Entrepreneurs(x))"
},
{
"input": "Translate into first-order logic: If Mark Zuckerberg is neither an entrepreneur nor a person who hates working for others, then Mark Zuckerberg is not a risk-averse person.",
"output": " ¬Entrepreneurs(markZuckerberg) ∨ ¬HateWorkingForOthers(markZuckerberg) → ¬Risk-averse(markZuckerberg)"
},
{
"input": "Translate into first-order logic: No people who work at corporate jobs are starting a new company.",
"output": "∀x (WorkAtCorporateJobs(x) → ¬StartingANewCompany(x))"
},
{
"input": "Translate into first-order logic: All entrepreneurs are starting a new company.",
"output": " ∀x (Entrepreneurs(x) → StartingANewCompany(x))"
},
{
"input": "Translate into first-order logic: All risk-averse people are people who work at corporate jobs.",
"output": " ∀x (Risk-averse(x) → WorkAtCorporateJobs(x))"
},
{
"input": "Translate into first-order logic: All people who hate working for others are entrepreneurs.",
"output": " ∀x (HateWorkingForOthers(x) → Entrepreneurs(x))"
},
{
"input": "Translate into first-order logic: If Mark Zuckerberg is neither an entrepreneur nor a person who hates working for others, then Mark Zuckerberg is not a risk-averse person.",
"output": " ¬Entrepreneurs(markZuckerberg) ∨ ¬HateWorkingForOthers(markZuckerberg) → ¬Risk-averse(markZuckerberg)"
},
{
"input": "Translate into first-order logic: No people who work at corporate jobs are starting a new company.",
"output": "∀x (WorkAtCorporateJobs(x) → ¬StartingANewCompany(x))"
},
{
"input": "Translate into first-order logic: All entrepreneurs are starting a new company.",
"output": " ∀x (Entrepreneurs(x) → StartingANewCompany(x))"
},
{
"input": "Translate into first-order logic: All risk-averse people are people who work at corporate jobs.",
"output": " ∀x (Risk-averse(x) → WorkAtCorporateJobs(x))"
},
{
"input": "Translate into first-order logic: All people who hate working for others are entrepreneurs.",
"output": " ∀x (HateWorkingForOthers(x) → Entrepreneurs(x))"
},
{
"input": "Translate into first-order logic: If Mark Zuckerberg is neither an entrepreneur nor a person who hates working for others, then Mark Zuckerberg is not a risk-averse person.",
"output": " ¬Entrepreneurs(markZuckerberg) ∨ ¬HateWorkingForOthers(markZuckerberg) → ¬Risk-averse(markZuckerberg)"
},
{
"input": "Translate into first-order logic: There are two kitchens in the house: the upstairs kitchen and the downstairs kitchen.",
"output": "∀x (Kitchen(x) → Up(x) ⊕ Down(x))"
},
{
"input": "Translate into first-order logic: When someone is cooking in the downstairs kitchen, the first floor becomes smokey unless the air conditioner is running.",
"output": "(Cook(downstairs) ∧ ¬Run(ac)) → Smokey(firstFloor)"
},
{
"input": "Translate into first-order logic: If the air conditioner is running and someone is cooking in the downstairs kitchen, all the smoke travels to the second floor.",
"output": "(Cook(downstairs) ∧ Run(ac)) → Smokey(secondFloor)"
},
{
"input": "Translate into first-order logic: There are two kitchens in the house: the upstairs kitchen and the downstairs kitchen.",
"output": "∀x (Kitchen(x) → Up(x) ⊕ Down(x))"
},
{
"input": "Translate into first-order logic: When someone is cooking in the downstairs kitchen, the first floor becomes smokey unless the air conditioner is running.",
"output": "(Cook(downstairs) ∧ ¬Run(ac)) → Smokey(firstFloor)"
},
{
"input": "Translate into first-order logic: If the air conditioner is running and someone is cooking in the downstairs kitchen, all the smoke travels to the second floor.",
"output": "(Cook(downstairs) ∧ Run(ac)) → Smokey(secondFloor)"
},
{
"input": "Translate into first-order logic: There are two kitchens in the house: the upstairs kitchen and the downstairs kitchen.",
"output": "∀x (Kitchen(x) → Up(x) ⊕ Down(x))"
},
{
"input": "Translate into first-order logic: When someone is cooking in the downstairs kitchen, the first floor becomes smokey unless the air conditioner is running.",
"output": "(Cook(downstairs) ∧ ¬Run(ac)) → Smokey(firstFloor)"
},
{
"input": "Translate into first-order logic: If the air conditioner is running and someone is cooking in the downstairs kitchen, all the smoke travels to the second floor.",
"output": "(Cook(downstairs) ∧ Run(ac)) → Smokey(secondFloor)"
},
{
"input": "Translate into first-order logic: New York City is Located in the United States of America.",
"output": "Locate(nyc, usa)"
},
{
"input": "Translate into first-order logic: United States of America is part of North America.",
"output": "Locate(usa, northAmerica)"
},
{
"input": "Translate into first-order logic: North America is in the western hemisphere of the earth.",
"output": "Locate(northAmerica, westHemisphere)"
},
{
"input": "Translate into first-order logic: New York City is a highly developed city.",
"output": "HighlyDeveloped(nyc)"
},
{
"input": "Translate into first-order logic: If place A is located in place B and place B is located in place C, then place A is located in place C.",
"output": "∀x ∀y ∀z ((Locate(x, y) ∧ Locate(y, z)) → Locate(x, z))"
},
{
"input": "Translate into first-order logic: New York City is Located in the United States of America.",
"output": "Locate(nyc, usa)"
},
{
"input": "Translate into first-order logic: United States of America is part of North America.",
"output": "Locate(usa, northAmerica)"
},
{
"input": "Translate into first-order logic: North America is in the western hemisphere of the earth.",
"output": "Locate(northAmerica, westHemisphere)"
},
{
"input": "Translate into first-order logic: New York City is a highly developed city.",
"output": "HighlyDeveloped(nyc)"
},
{
"input": "Translate into first-order logic: If place A is located in place B and place B is located in place C, then place A is located in place C.",
"output": "∀x ∀y ∀z ((Locate(x, y) ∧ Locate(y, z)) → Locate(x, z))"
},
{
"input": "Translate into first-order logic: New York City is Located in the United States of America.",
"output": "Locate(nyc, usa)"
},
{
"input": "Translate into first-order logic: United States of America is part of North America.",
"output": "Locate(usa, northAmerica)"
},
{
"input": "Translate into first-order logic: North America is in the western hemisphere of the earth.",
"output": "Locate(northAmerica, westHemisphere)"
},
{
"input": "Translate into first-order logic: New York City is a highly developed city.",
"output": "HighlyDeveloped(nyc)"
},
{
"input": "Translate into first-order logic: If place A is located in place B and place B is located in place C, then place A is located in place C.",
"output": "∀x ∀y ∀z ((Locate(x, y) ∧ Locate(y, z)) → Locate(x, z))"
},
{
"input": "Translate into first-order logic: Callus 4 is a poem that was written by the ancient Roman writer Catullus.",
"output": "Poem(callus4) ∧ WrittenBy(callus4, catullus) ∧ Roman(catullus)"
},
{
"input": "Translate into first-order logic: Callus 4 is a story about the retirement of a well-traveled ship.",
"output": "RetirementShip(callus4)"
},
{
"input": "Translate into first-order logic: There is a strong analogy of human aging in the poem Callus 4.",
"output": "Poem(callus4) → AgingAnalogy(callus4)"
},
{
"input": "Translate into first-order logic: Callus 4 is written in an unusual iambic trimeter to convey a sense of speed over the waves.",
"output": "Poem(callus4) → Lambic(callus4) ∧ Waves(callus4)"
},
{
"input": "Translate into first-order logic: Callus 4 is a poem that was written by the ancient Roman writer Catullus.",
"output": "Poem(callus4) ∧ WrittenBy(callus4, catullus) ∧ Roman(catullus)"
},
{
"input": "Translate into first-order logic: Callus 4 is a story about the retirement of a well-traveled ship.",
"output": "RetirementShip(callus4)"
},
{
"input": "Translate into first-order logic: There is a strong analogy of human aging in the poem Callus 4.",
"output": "Poem(callus4) → AgingAnalogy(callus4)"
},
{
"input": "Translate into first-order logic: Callus 4 is written in an unusual iambic trimeter to convey a sense of speed over the waves.",
"output": "Poem(callus4) → Lambic(callus4) ∧ Waves(callus4)"
},
{
"input": "Translate into first-order logic: Callus 4 is a poem that was written by the ancient Roman writer Catullus.",
"output": "Poem(callus4) ∧ WrittenBy(callus4, catullus) ∧ Roman(catullus)"
},
{
"input": "Translate into first-order logic: Callus 4 is a story about the retirement of a well-traveled ship.",
"output": "RetirementShip(callus4)"
},
{
"input": "Translate into first-order logic: There is a strong analogy of human aging in the poem Callus 4.",
"output": "Poem(callus4) → AgingAnalogy(callus4)"
},
{
"input": "Translate into first-order logic: Callus 4 is written in an unusual iambic trimeter to convey a sense of speed over the waves.",
"output": "Poem(callus4) → Lambic(callus4) ∧ Waves(callus4)"
},
{
"input": "Translate into first-order logic: Westworld is an American science fiction-thriller TV series.",
"output": "TVSeries(westworld) ∧ American(westworld) ∧ ScienceFictionThriller(westworld)"
},
{
"input": "Translate into first-order logic: In 2016, a new television series named Westworld debuted on HBO.",
"output": "Debut(westworld, year2016)"
},
{
"input": "Translate into first-order logic: The TV series Westworld is adapted from the original film in 1973, which was written and directed by Michael Crichton.",
"output": "∃x (Adapt(westworld, x) ∧ Produce(x, year1973) ∧ Write(michael, x) ∧ Direct(michael, x))"
},
{
"input": "Translate into first-order logic: The 1973 film Westworld is about robots that malfunction and begin killing the human visitors.",
"output": "About(westworld, robots)"
},
{
"input": "Translate into first-order logic: Westworld is an American science fiction-thriller TV series.",
"output": "TVSeries(westworld) ∧ American(westworld) ∧ ScienceFictionThriller(westworld)"
},
{
"input": "Translate into first-order logic: In 2016, a new television series named Westworld debuted on HBO.",
"output": "Debut(westworld, year2016)"
},
{
"input": "Translate into first-order logic: The TV series Westworld is adapted from the original film in 1973, which was written and directed by Michael Crichton.",
"output": "∃x (Adapt(westworld, x) ∧ Produce(x, year1973) ∧ Write(michael, x) ∧ Direct(michael, x))"
},
{
"input": "Translate into first-order logic: The 1973 film Westworld is about robots that malfunction and begin killing the human visitors.",
"output": "About(westworld, robots)"
},
{
"input": "Translate into first-order logic: The 2008 Summer Olympics were held in Beijing, China.",
"output": "HeldIn(summer2008olympics, beijingchina)"
},
{
"input": "Translate into first-order logic: The 2008 Summer Olympics were the second Summer Olympic Games to be held in a communist state.",
"output": "SecondToBe(summer2008olympics, heldincommuniststate)"
},
{
"input": "Translate into first-order logic: China won the most gold medals (48) in the 2008 Summer Olympics.",
"output": "Won(china, mostgoldmedals)"
},
{
"input": "Translate into first-order logic: The United States placed second in the gold medal tally but won the highest number of medals overall (112) in the 2008 Summer Olympics.",
"output": "Placed(unitedstates, secondingoldmedals) ∧ Won(unitedstates, highestnumberofmedals)"
},
{
"input": "Translate into first-order logic: The third place in the gold medal tally was achieved by Russia in the 2008 Summer Olympics.",
"output": "Placed(russia, thirdingoldmedals)"
},
{
"input": "Translate into first-order logic: If a country places third in gold medals, then they had fewer gold medals than the team that won the most gold medals.",
"output": "∀x ∀y (Placed(x, thirdingoldmedals) ∧ Won(y, mostgoldmedals) → FewerGoldMedalsThan(x, y))"
},
{
"input": "Translate into first-order logic: 87 countries won at least one medal during the 2008 Games.",
"output": "∃x (Country(x) ∧ Won(x, medal))"
},
{
"input": "Translate into first-order logic: The 2008 Summer Olympics were held in Beijing, China.",
"output": "HeldIn(summer2008olympics, beijingchina)"
},
{
"input": "Translate into first-order logic: The 2008 Summer Olympics were the second Summer Olympic Games to be held in a communist state.",
"output": "SecondToBe(summer2008olympics, heldincommuniststate)"
},
{
"input": "Translate into first-order logic: China won the most gold medals (48) in the 2008 Summer Olympics.",
"output": "Won(china, mostgoldmedals)"
},
{
"input": "Translate into first-order logic: The United States placed second in the gold medal tally but won the highest number of medals overall (112) in the 2008 Summer Olympics.",
"output": "Placed(unitedstates, secondingoldmedals) ∧ Won(unitedstates, highestnumberofmedals)"
},
{
"input": "Translate into first-order logic: The third place in the gold medal tally was achieved by Russia in the 2008 Summer Olympics.",
"output": "Placed(russia, thirdingoldmedals)"
},
{
"input": "Translate into first-order logic: If a country places third in gold medals, then they had fewer gold medals than the team that won the most gold medals.",
"output": "∀x ∀y (Placed(x, thirdingoldmedals) ∧ Won(y, mostgoldmedals) → FewerGoldMedalsThan(x, y))"
},
{
"input": "Translate into first-order logic: 87 countries won at least one medal during the 2008 Games.",
"output": "∃x (Country(x) ∧ Won(x, medal))"
},
{
"input": "Translate into first-order logic: The 2008 Summer Olympics were held in Beijing, China.",
"output": "HeldIn(summer2008olympics, beijingchina)"
},
{
"input": "Translate into first-order logic: The 2008 Summer Olympics were the second Summer Olympic Games to be held in a communist state.",
"output": "SecondToBe(summer2008olympics, heldincommuniststate)"
},
{
"input": "Translate into first-order logic: China won the most gold medals (48) in the 2008 Summer Olympics.",
"output": "Won(china, mostgoldmedals)"
},
{
"input": "Translate into first-order logic: The United States placed second in the gold medal tally but won the highest number of medals overall (112) in the 2008 Summer Olympics.",
"output": "Placed(unitedstates, secondingoldmedals) ∧ Won(unitedstates, highestnumberofmedals)"
},
{
"input": "Translate into first-order logic: The third place in the gold medal tally was achieved by Russia in the 2008 Summer Olympics.",
"output": "Placed(russia, thirdingoldmedals)"
},
{
"input": "Translate into first-order logic: If a country places third in gold medals, then they had fewer gold medals than the team that won the most gold medals.",
"output": "∀x ∀y (Placed(x, thirdingoldmedals) ∧ Won(y, mostgoldmedals) → FewerGoldMedalsThan(x, y))"
},
{
"input": "Translate into first-order logic: 87 countries won at least one medal during the 2008 Games.",
"output": "∃x (Country(x) ∧ Won(x, medal))"
},
{
"input": "Translate into first-order logic: Xiufeng, Xiangshan, Diecai, Qixing are districts in the city of Guilin.",
"output": "DistrictIn(xiufeng, guilin) ∧ DistrictIn(xiangshan, guilin) ∧ DistrictIn(diecai, guilin) ∧ DistrictIn(qixing, guilin) ∧ City(guilin)"
},
{
"input": "Translate into first-order logic: Yangshuo is not a district in Guilin.",
"output": "¬DistrictIn(yangshuo, guilin)"
},
{
"input": "Translate into first-order logic: Xiufeng, Xiangshan, Diecai, Qixing are districts in the city of Guilin.",
"output": "DistrictIn(xiufeng, guilin) ∧ DistrictIn(xiangshan, guilin) ∧ DistrictIn(diecai, guilin) ∧ DistrictIn(qixing, guilin) ∧ City(guilin)"
},
{
"input": "Translate into first-order logic: Yangshuo is not a district in Guilin.",
"output": "¬DistrictIn(yangshuo, guilin)"
},
{
"input": "Translate into first-order logic: Xiufeng, Xiangshan, Diecai, Qixing are districts in the city of Guilin.",
"output": "DistrictIn(xiufeng, guilin) ∧ DistrictIn(xiangshan, guilin) ∧ DistrictIn(diecai, guilin) ∧ DistrictIn(qixing, guilin) ∧ City(guilin)"
},
{
"input": "Translate into first-order logic: Yangshuo is not a district in Guilin.",
"output": "¬DistrictIn(yangshuo, guilin)"
},
{
"input": "Translate into first-order logic: All people who grow their own fresh vegetables in their home garden also have ample space.",
"output": "∀x (Garden(x) → Space(x))"
},
{
"input": "Translate into first-order logic: If people are young working professionals who live in large cities, then they do not have ample space.",
"output": "∀x (Professional(x) → ¬Space(x))"
},
{
"input": "Translate into first-order logic: If people order takeout from delivery services often, then they grow their own fresh vegetables in their home garden.",
"output": "∀x (Takeout(x) → Garden(x))"
},
{
"input": "Translate into first-order logic: If people enjoy going out often to restaurants with friends, then they order takeout from delivery services often.",
"output": "∀x (GoingOut(x) → Takeout(x))"
},
{
"input": "Translate into first-order logic: If people regularly tout the benefits of homegrown and homecooked meals over fast food, then they enjoy going out often to restaurants with friends.",
"output": "∀x (Homecooked(x) → GoingOut(x))"
},
{
"input": "Translate into first-order logic: Michael grows his own fresh vegetables in his home garden or regularly touts the benefits of homegrown and homecooked meals over fast food.",
"output": "Garden(michael) ∨ Homecooked(michael)"
},
{
"input": "Translate into first-order logic: All people who grow their own fresh vegetables in their home garden also have ample space.",
"output": "∀x (Garden(x) → Space(x))"
},
{
"input": "Translate into first-order logic: If people are young working professionals who live in large cities, then they do not have ample space.",
"output": "∀x (Professional(x) → ¬Space(x))"
},
{
"input": "Translate into first-order logic: If people order takeout from delivery services often, then they grow their own fresh vegetables in their home garden.",
"output": "∀x (Takeout(x) → Garden(x))"
},
{
"input": "Translate into first-order logic: If people enjoy going out often to restaurants with friends, then they order takeout from delivery services often.",
"output": "∀x (GoingOut(x) → Takeout(x))"
},
{
"input": "Translate into first-order logic: If people regularly tout the benefits of homegrown and homecooked meals over fast food, then they enjoy going out often to restaurants with friends.",
"output": "∀x (Homecooked(x) → GoingOut(x))"
},
{
"input": "Translate into first-order logic: Michael grows his own fresh vegetables in his home garden or regularly touts the benefits of homegrown and homecooked meals over fast food.",
"output": "Garden(michael) ∨ Homecooked(michael)"
},
{
"input": "Translate into first-order logic: All people who grow their own fresh vegetables in their home garden also have ample space.",
"output": "∀x (Garden(x) → Space(x))"
},
{
"input": "Translate into first-order logic: If people are young working professionals who live in large cities, then they do not have ample space.",
"output": "∀x (Professional(x) → ¬Space(x))"
},
{
"input": "Translate into first-order logic: If people order takeout from delivery services often, then they grow their own fresh vegetables in their home garden.",
"output": "∀x (Takeout(x) → Garden(x))"
},
{
"input": "Translate into first-order logic: If people enjoy going out often to restaurants with friends, then they order takeout from delivery services often.",
"output": "∀x (GoingOut(x) → Takeout(x))"
},
{
"input": "Translate into first-order logic: If people regularly tout the benefits of homegrown and homecooked meals over fast food, then they enjoy going out often to restaurants with friends.",
"output": "∀x (Homecooked(x) → GoingOut(x))"
},
{
"input": "Translate into first-order logic: Michael grows his own fresh vegetables in his home garden or regularly touts the benefits of homegrown and homecooked meals over fast food.",
"output": "Garden(michael) ∨ Homecooked(michael)"
},
{
"input": "Translate into first-order logic: All devices belonging to the company are connected to Google Home.",
"output": "∀x (Company(x) → GoogleHome(x))"
},
{
"input": "Translate into first-order logic: All devices belonging to employees are connected to the company's wifi.",
"output": "∀x (Employee(x) → Wifi(x))"
},
{
"input": "Translate into first-order logic: All devices connected to Google Home are controlled by the managers.",
"output": "∀x (GoogleHome(x) → Controlled(x))"
},
{
"input": "Translate into first-order logic: All devices that connect to the company's wifi are easy to operate.",
"output": "∀x (Wifi(x) → EasyToOperate(x))"
},
{
"input": "Translate into first-order logic: IPod1 belongs to employees.",
"output": "Employee(iPod1)"
},
{
"input": "Translate into first-order logic: All devices belonging to the company are connected to Google Home.",
"output": "∀x (Company(x) → GoogleHome(x))"
},
{
"input": "Translate into first-order logic: All devices belonging to employees are connected to the company's wifi.",
"output": "∀x (Employee(x) → Wifi(x))"
},
{
"input": "Translate into first-order logic: All devices connected to Google Home are controlled by the managers.",
"output": "∀x (GoogleHome(x) → Controlled(x))"
},
{
"input": "Translate into first-order logic: All devices that connect to the company's wifi are easy to operate.",
"output": "∀x (Wifi(x) → EasyToOperate(x))"
},
{
"input": "Translate into first-order logic: IPod1 belongs to employees.",
"output": "Employee(iPod1)"
},
{
"input": "Translate into first-order logic: All devices belonging to the company are connected to Google Home.",
"output": "∀x (Company(x) → GoogleHome(x))"
},
{
"input": "Translate into first-order logic: All devices belonging to employees are connected to the company's wifi.",
"output": "∀x (Employee(x) → Wifi(x))"
},
{
"input": "Translate into first-order logic: All devices connected to Google Home are controlled by the managers.",
"output": "∀x (GoogleHome(x) → Controlled(x))"
},
{
"input": "Translate into first-order logic: All devices that connect to the company's wifi are easy to operate.",
"output": "∀x (Wifi(x) → EasyToOperate(x))"
},
{
"input": "Translate into first-order logic: IPod1 belongs to employees.",
"output": "Employee(iPod1)"
},
{
"input": "Translate into first-order logic: No touring musicians are permanent members of an orchestra.",
"output": "∀x (Orchestra(x) → ¬Touring(x))"
},
{
"input": "Translate into first-order logic: Musicians are either permanent members of an orchestra or have a unique musical voice or style.",
"output": "∀x (Orchestra(x) ⊕ Unique(x))"
},
{
"input": "Translate into first-order logic: All musicians who have a unique musical voice or style are interesting as individual performers.",
"output": "∀x (Unique(x) → Interesting(x))"
},
{
"input": "Translate into first-order logic: All musicians who are interesting as individual performers are capable of attracting large audiences.",
"output": "∀x (Interesting(x) → Capable(x))"
},
{
"input": "Translate into first-order logic: If Ryan is interesting as an individual performer and has a unique musical voice or style, then Ryan is either a touring soloist musician and capable of attracting large audiences, or neither a touring soloist musician nor capable of attracting large audiences.",
"output": "(Interesting(ryan) ∧ Unique(ryan)) → ¬(Touring(ryan) ⊕ Capable(ryan))"
},
{
"input": "Translate into first-order logic: No touring musicians are permanent members of an orchestra.",
"output": "∀x (Orchestra(x) → ¬Touring(x))"
},
{
"input": "Translate into first-order logic: Musicians are either permanent members of an orchestra or have a unique musical voice or style.",
"output": "∀x (Orchestra(x) ⊕ Unique(x))"
},
{
"input": "Translate into first-order logic: All musicians who have a unique musical voice or style are interesting as individual performers.",
"output": "∀x (Unique(x) → Interesting(x))"
},
{
"input": "Translate into first-order logic: All musicians who are interesting as individual performers are capable of attracting large audiences.",
"output": "∀x (Interesting(x) → Capable(x))"
},
{
"input": "Translate into first-order logic: If Ryan is interesting as an individual performer and has a unique musical voice or style, then Ryan is either a touring soloist musician and capable of attracting large audiences, or neither a touring soloist musician nor capable of attracting large audiences.",
"output": "(Interesting(ryan) ∧ Unique(ryan)) → ¬(Touring(ryan) ⊕ Capable(ryan))"
},
{
"input": "Translate into first-order logic: No touring musicians are permanent members of an orchestra.",
"output": "∀x (Orchestra(x) → ¬Touring(x))"
},
{
"input": "Translate into first-order logic: Musicians are either permanent members of an orchestra or have a unique musical voice or style.",
"output": "∀x (Orchestra(x) ⊕ Unique(x))"
},
{
"input": "Translate into first-order logic: All musicians who have a unique musical voice or style are interesting as individual performers.",
"output": "∀x (Unique(x) → Interesting(x))"
},
{
"input": "Translate into first-order logic: All musicians who are interesting as individual performers are capable of attracting large audiences.",
"output": "∀x (Interesting(x) → Capable(x))"
},
{
"input": "Translate into first-order logic: If Ryan is interesting as an individual performer and has a unique musical voice or style, then Ryan is either a touring soloist musician and capable of attracting large audiences, or neither a touring soloist musician nor capable of attracting large audiences.",
"output": "(Interesting(ryan) ∧ Unique(ryan)) → ¬(Touring(ryan) ⊕ Capable(ryan))"
},
{
"input": "Translate into first-order logic: If someone yells, then they are not cool.",
"output": "∀x (Yell(x) → ¬Cool(x))"
},
{
"input": "Translate into first-order logic: If someone is angry, then they yell.",
"output": "∀x (Angry(x) → Yell(x))"
},
{
"input": "Translate into first-order logic: If someone flies, then they are cool.",
"output": "∀x (Fly(x) → Cool(x))"
},
{
"input": "Translate into first-order logic: Every person that knows magic can fly.",
"output": "∀x (KnowMagic(x) → Fly(x))"
},
{
"input": "Translate into first-order logic: All wizards know magic.",
"output": "∀x (Wizard(x) → KnowMagic(x))"
},
{
"input": "Translate into first-order logic: Harry either yells and flies, or neither yells nor flies.",
"output": "(Yell(harry) ∧ Fly(harry)) ⊕ (¬Yell(harry) ∧ ¬Fly(harry))"
},
{
"input": "Translate into first-order logic: Potter is a wizard and flies.",
"output": "Wizard(potter) ∧ Fly(potter)"
},
{
"input": "Translate into first-order logic: If someone yells, then they are not cool.",
"output": "∀x (Yell(x) → ¬Cool(x))"
},
{
"input": "Translate into first-order logic: If someone is angry, then they yell.",
"output": "∀x (Angry(x) → Yell(x))"
},
{
"input": "Translate into first-order logic: If someone flies, then they are cool.",
"output": "∀x (Fly(x) → Cool(x))"
},
{
"input": "Translate into first-order logic: Every person that knows magic can fly.",
"output": "∀x (KnowMagic(x) → Fly(x))"
},
{
"input": "Translate into first-order logic: All wizards know magic.",
"output": "∀x (Wizard(x) → KnowMagic(x))"
},
{
"input": "Translate into first-order logic: Harry either yells and flies, or neither yells nor flies.",
"output": "(Yell(harry) ∧ Fly(harry)) ⊕ (¬Yell(harry) ∧ ¬Fly(harry))"
},
{
"input": "Translate into first-order logic: Potter is a wizard and flies.",
"output": "Wizard(potter) ∧ Fly(potter)"
},
{
"input": "Translate into first-order logic: If someone yells, then they are not cool.",
"output": "∀x (Yell(x) → ¬Cool(x))"
},
{
"input": "Translate into first-order logic: If someone is angry, then they yell.",
"output": "∀x (Angry(x) → Yell(x))"
},
{
"input": "Translate into first-order logic: If someone flies, then they are cool.",
"output": "∀x (Fly(x) → Cool(x))"
},
{
"input": "Translate into first-order logic: Every person that knows magic can fly.",
"output": "∀x (KnowMagic(x) → Fly(x))"
},
{
"input": "Translate into first-order logic: All wizards know magic.",
"output": "∀x (Wizard(x) → KnowMagic(x))"
},
{
"input": "Translate into first-order logic: Harry either yells and flies, or neither yells nor flies.",
"output": "(Yell(harry) ∧ Fly(harry)) ⊕ (¬Yell(harry) ∧ ¬Fly(harry))"
},
{
"input": "Translate into first-order logic: Potter is a wizard and flies.",
"output": "Wizard(potter) ∧ Fly(potter)"
},
{
"input": "Translate into first-order logic: If someone yells, then they are not cool.",
"output": "∀x (Yell(x) → ¬Cool(x))"
},
{
"input": "Translate into first-order logic: If someone is angry, then they yell.",
"output": "∀x (Angry(x) → Yell(x))"
},
{
"input": "Translate into first-order logic: If someone flies, then they are cool.",
"output": "∀x (Fly(x) → Cool(x))"
},
{
"input": "Translate into first-order logic: Every person that knows magic can fly.",
"output": "∀x (KnowMagic(x) → Fly(x))"
},
{
"input": "Translate into first-order logic: All wizards know magic.",
"output": "∀x (Wizard(x) → KnowMagic(x))"
},
{
"input": "Translate into first-order logic: Harry either yells and flies, or neither yells nor flies.",
"output": "(Yell(harry) ∧ Fly(harry)) ⊕ (¬Yell(harry) ∧ ¬Fly(harry))"
},
{
"input": "Translate into first-order logic: Potter is a wizard and flies.",
"output": "Wizard(potter) ∧ Fly(potter)"
},
{
"input": "Translate into first-order logic: Products are either produced in China or the US.",
"output": "∀x (China(x) ⊕ US(x))"
},
{
"input": "Translate into first-order logic: All produced in China are labeled.",
"output": "∀x (China(x) → Labeled(x))"
},
{
"input": "Translate into first-order logic: All produced in the US are sold in the US.",
"output": "∀x (US(x) → SoldInUS(x))"
},
{
"input": "Translate into first-order logic: If labeled, then the product is cheaper.",
"output": "∀x (Labeled(x) → Cheaper(x))"
},
{
"input": "Translate into first-order logic: All sold in the US are sold in Walmart.",
"output": "∀x (SoldInUS(x) → SoldInWalmart(x))"
},
{
"input": "Translate into first-order logic: All displayed on the homepage are sold in Walmart.",
"output": "∀x (DisplayedInHomepage(x) → SoldInWalmart(x))"
},
{
"input": "Translate into first-order logic: No products returned by customers are sold in Walmart.",
"output": "∀x (ReturnedByCustomer(x) → ¬SoldInWalmart(x))"
},
{
"input": "Translate into first-order logic: G-910 is either displayed on the homepage or cheaper.",
"output": "¬(DisplayedInHomepage(g910) ⊕ Cheaper(g910))"
},
{
"input": "Translate into first-order logic: Products are either produced in China or the US.",
"output": "∀x (China(x) ⊕ US(x))"
},
{
"input": "Translate into first-order logic: All produced in China are labeled.",
"output": "∀x (China(x) → Labeled(x))"
},
{
"input": "Translate into first-order logic: All produced in the US are sold in the US.",
"output": "∀x (US(x) → SoldInUS(x))"
},
{
"input": "Translate into first-order logic: If labeled, then the product is cheaper.",
"output": "∀x (Labeled(x) → Cheaper(x))"
},
{
"input": "Translate into first-order logic: All sold in the US are sold in Walmart.",
"output": "∀x (SoldInUS(x) → SoldInWalmart(x))"
},
{
"input": "Translate into first-order logic: All displayed on the homepage are sold in Walmart.",
"output": "∀x (DisplayedInHomepage(x) → SoldInWalmart(x))"
},
{
"input": "Translate into first-order logic: No products returned by customers are sold in Walmart.",
"output": "∀x (ReturnedByCustomer(x) → ¬SoldInWalmart(x))"
},
{
"input": "Translate into first-order logic: G-910 is either displayed on the homepage or cheaper.",
"output": "¬(DisplayedInHomepage(g910) ⊕ Cheaper(g910))"
},
{
"input": "Translate into first-order logic: Products are either produced in China or the US.",
"output": "∀x (China(x) ⊕ US(x))"
},
{
"input": "Translate into first-order logic: All produced in China are labeled.",
"output": "∀x (China(x) → Labeled(x))"
},
{
"input": "Translate into first-order logic: All produced in the US are sold in the US.",
"output": "∀x (US(x) → SoldInUS(x))"
},
{
"input": "Translate into first-order logic: If labeled, then the product is cheaper.",
"output": "∀x (Labeled(x) → Cheaper(x))"
},
{
"input": "Translate into first-order logic: All sold in the US are sold in Walmart.",
"output": "∀x (SoldInUS(x) → SoldInWalmart(x))"
},
{
"input": "Translate into first-order logic: All displayed on the homepage are sold in Walmart.",
"output": "∀x (DisplayedInHomepage(x) → SoldInWalmart(x))"
},
{
"input": "Translate into first-order logic: No products returned by customers are sold in Walmart.",
"output": "∀x (ReturnedByCustomer(x) → ¬SoldInWalmart(x))"
},
{
"input": "Translate into first-order logic: G-910 is either displayed on the homepage or cheaper.",
"output": "¬(DisplayedInHomepage(g910) ⊕ Cheaper(g910))"
},
{
"input": "Translate into first-order logic: Products are either produced in China or the US.",
"output": "∀x (China(x) ⊕ US(x))"
},
{
"input": "Translate into first-order logic: All produced in China are labeled.",
"output": "∀x (China(x) → Labeled(x))"
},
{
"input": "Translate into first-order logic: All produced in the US are sold in the US.",
"output": "∀x (US(x) → SoldInUS(x))"
},
{
"input": "Translate into first-order logic: If labeled, then the product is cheaper.",
"output": "∀x (Labeled(x) → Cheaper(x))"
},
{
"input": "Translate into first-order logic: All sold in the US are sold in Walmart.",
"output": "∀x (SoldInUS(x) → SoldInWalmart(x))"
},
{
"input": "Translate into first-order logic: All displayed on the homepage are sold in Walmart.",
"output": "∀x (DisplayedInHomepage(x) → SoldInWalmart(x))"
},
{
"input": "Translate into first-order logic: No products returned by customers are sold in Walmart.",
"output": "∀x (ReturnedByCustomer(x) → ¬SoldInWalmart(x))"
},
{
"input": "Translate into first-order logic: G-910 is either displayed on the homepage or cheaper.",
"output": "¬(DisplayedInHomepage(g910) ⊕ Cheaper(g910))"
},
{
"input": "Translate into first-order logic: Products are either produced in China or the US.",
"output": "∀x (China(x) ⊕ US(x))"
},
{
"input": "Translate into first-order logic: All produced in China are labeled.",
"output": "∀x (China(x) → Labeled(x))"
},
{
"input": "Translate into first-order logic: All produced in the US are sold in the US.",
"output": "∀x (US(x) → SoldInUS(x))"
},
{
"input": "Translate into first-order logic: If labeled, then the product is cheaper.",
"output": "∀x (Labeled(x) → Cheaper(x))"
},
{
"input": "Translate into first-order logic: All sold in the US are sold in Walmart.",
"output": "∀x (SoldInUS(x) → SoldInWalmart(x))"
},
{
"input": "Translate into first-order logic: All displayed on the homepage are sold in Walmart.",
"output": "∀x (DisplayedInHomepage(x) → SoldInWalmart(x))"
},
{
"input": "Translate into first-order logic: No products returned by customers are sold in Walmart.",
"output": "∀x (ReturnedByCustomer(x) → ¬SoldInWalmart(x))"
},
{
"input": "Translate into first-order logic: G-910 is either displayed on the homepage or cheaper.",
"output": "¬(DisplayedInHomepage(g910) ⊕ Cheaper(g910))"
},
{
"input": "Translate into first-order logic: People either order a lot of Amazon packages or are environmentally conscious.",
"output": "∀x (Amazon(x) ⊕ Environmental(x))"
},
{
"input": "Translate into first-order logic: If people order a lot of Amazon packages, then they get a lot of daily mail delivered.",
"output": "∀x (Amazon(x) → DailyMail(x))"
},
{
"input": "Translate into first-order logic: If people are environmentally conscious, then they have solar panels in their homes.",
"output": "∀x (Environmental(x) → Solar(x))"
},
{
"input": "Translate into first-order logic: If people get a lot of daily mail delivered, then they are very involved with their neighborhood.",
"output": "∀x (DailyMail(x) → Neighborhood(x))"
},
{
"input": "Translate into first-order logic: If people have solar panels in their homes, then they save a lot of money.",
"output": "∀x (Solar(x) → SaveMoney(x))"
},
{
"input": "Translate into first-order logic: If Marcy either gets a lot of mail and is very involved with her neighborhood or if she does not order a lot of Amazon packages nor is very involved with her neighborhood, then Marcy does not both get a lot of daily mail and order a lot of Amazon packages.",
"output": "¬(DailyMail(marcy) ⊕ Neighborhood(marcy)) → (¬DailyMail(marcy) ∨ ¬Amazon(marcy))"
},
{
"input": "Translate into first-order logic: People either order a lot of Amazon packages or are environmentally conscious.",
"output": "∀x (Amazon(x) ⊕ Environmental(x))"
},
{
"input": "Translate into first-order logic: If people order a lot of Amazon packages, then they get a lot of daily mail delivered.",
"output": "∀x (Amazon(x) → DailyMail(x))"
},
{
"input": "Translate into first-order logic: If people are environmentally conscious, then they have solar panels in their homes.",
"output": "∀x (Environmental(x) → Solar(x))"
},
{
"input": "Translate into first-order logic: If people get a lot of daily mail delivered, then they are very involved with their neighborhood.",
"output": "∀x (DailyMail(x) → Neighborhood(x))"
},
{
"input": "Translate into first-order logic: If people have solar panels in their homes, then they save a lot of money.",
"output": "∀x (Solar(x) → SaveMoney(x))"
},
{
"input": "Translate into first-order logic: If Marcy either gets a lot of mail and is very involved with her neighborhood or if she does not order a lot of Amazon packages nor is very involved with her neighborhood, then Marcy does not both get a lot of daily mail and order a lot of Amazon packages.",
"output": "¬(DailyMail(marcy) ⊕ Neighborhood(marcy)) → (¬DailyMail(marcy) ∨ ¬Amazon(marcy))"
},
{
"input": "Translate into first-order logic: Indonesia is a country.",
"output": "Country(indonesia)"
},
{
"input": "Translate into first-order logic: In Indonesia, the prosecutor only personally investigates cases of some special crimes.",
"output": "∃x ∃y (Country(indonesia) ∧ Prosecutor(x) ∧ Crime(y) → InvestigatePersonally(x, y))"
},
{
"input": "Translate into first-order logic: Corruption is a type of crime.",
"output": "Crime(corruption)"
},
{
"input": "Translate into first-order logic: Once the police complete investigations of a crime, they hand the evidence to the prosecutor.",
"output": "∀x ∀y (Crime(y) ∧ PoliceCompInves(y) ∧ Prosecutor(x) → Evidence(y) ∧ HandToProsecutor(x, y))"
},
{
"input": "Translate into first-order logic: Evidence can be either satisfactory or unsatisfactory.",
"output": "∀x (Crime(x) ∧ Evidence(x) ∧ (Satisfactory(x) ⊕ Unsatisfactory(x)))"
},
{
"input": "Translate into first-order logic: If the police hand the evidence to the prosecutor and the evidence is satisfactory, the prosecutor will prosecute the offender in an appropriate court.",
"output": "∀x ∀y (Evidence(y) ∧ HandToProsecutor(x, y) ∧ Satisfactory(y) → ProsecuteTheOffender(x, y))"
},
{
"input": "Translate into first-order logic: Indonesia is a country.",
"output": "Country(indonesia)"
},
{
"input": "Translate into first-order logic: In Indonesia, the prosecutor only personally investigates cases of some special crimes.",
"output": "∃x ∃y (Country(indonesia) ∧ Prosecutor(x) ∧ Crime(y) → InvestigatePersonally(x, y))"
},
{
"input": "Translate into first-order logic: Corruption is a type of crime.",
"output": "Crime(corruption)"
},
{
"input": "Translate into first-order logic: Once the police complete investigations of a crime, they hand the evidence to the prosecutor.",
"output": "∀x ∀y (Crime(y) ∧ PoliceCompInves(y) ∧ Prosecutor(x) → Evidence(y) ∧ HandToProsecutor(x, y))"
},
{
"input": "Translate into first-order logic: Evidence can be either satisfactory or unsatisfactory.",
"output": "∀x (Crime(x) ∧ Evidence(x) ∧ (Satisfactory(x) ⊕ Unsatisfactory(x)))"
},
{
"input": "Translate into first-order logic: If the police hand the evidence to the prosecutor and the evidence is satisfactory, the prosecutor will prosecute the offender in an appropriate court.",
"output": "∀x ∀y (Evidence(y) ∧ HandToProsecutor(x, y) ∧ Satisfactory(y) → ProsecuteTheOffender(x, y))"
},
{
"input": "Translate into first-order logic: Indonesia is a country.",
"output": "Country(indonesia)"
},
{
"input": "Translate into first-order logic: In Indonesia, the prosecutor only personally investigates cases of some special crimes.",
"output": "∃x ∃y (Country(indonesia) ∧ Prosecutor(x) ∧ Crime(y) → InvestigatePersonally(x, y))"
},
{
"input": "Translate into first-order logic: Corruption is a type of crime.",
"output": "Crime(corruption)"
},
{
"input": "Translate into first-order logic: Once the police complete investigations of a crime, they hand the evidence to the prosecutor.",
"output": "∀x ∀y (Crime(y) ∧ PoliceCompInves(y) ∧ Prosecutor(x) → Evidence(y) ∧ HandToProsecutor(x, y))"
},
{
"input": "Translate into first-order logic: Evidence can be either satisfactory or unsatisfactory.",
"output": "∀x (Crime(x) ∧ Evidence(x) ∧ (Satisfactory(x) ⊕ Unsatisfactory(x)))"
},
{
"input": "Translate into first-order logic: If the police hand the evidence to the prosecutor and the evidence is satisfactory, the prosecutor will prosecute the offender in an appropriate court.",
"output": "∀x ∀y (Evidence(y) ∧ HandToProsecutor(x, y) ∧ Satisfactory(y) → ProsecuteTheOffender(x, y))"
},
{
"input": "Translate into first-order logic: No watch that is battery-powered is automatic.",
"output": "∀x (BatteryPoweredWatch(x) → ¬AutomaticWatch(x))"
},
{
"input": "Translate into first-order logic: All digital watches are battery-powered.",
"output": "∀x (DigitalWatch(x) → BatteryPoweredWatch(x))"
},
{
"input": "Translate into first-order logic: Some mechanical watches are automatic.",
"output": "∃x (MechanicalWatch(x) ∧ AutomaticWatch(x))"
},
{
"input": "Translate into first-order logic: All smart watches are digital.",
"output": "∀x (SmartWatch(x) → DigitalWatch(x))"
},
{
"input": "Translate into first-order logic: Moonwatch is not a digital watch or an automatic.",
"output": "¬DigitalWatch(moonwatch) ⊕ AutomaticWatch(moonwatch)"
},
{
"input": "Translate into first-order logic: No watch that is battery-powered is automatic.",
"output": "∀x (BatteryPoweredWatch(x) → ¬AutomaticWatch(x))"
},
{
"input": "Translate into first-order logic: All digital watches are battery-powered.",
"output": "∀x (DigitalWatch(x) → BatteryPoweredWatch(x))"
},
{
"input": "Translate into first-order logic: Some mechanical watches are automatic.",
"output": "∃x (MechanicalWatch(x) ∧ AutomaticWatch(x))"
},
{
"input": "Translate into first-order logic: All smart watches are digital.",
"output": "∀x (SmartWatch(x) → DigitalWatch(x))"
},
{
"input": "Translate into first-order logic: Moonwatch is not a digital watch or an automatic.",
"output": "¬DigitalWatch(moonwatch) ⊕ AutomaticWatch(moonwatch)"
},
{
"input": "Translate into first-order logic: No watch that is battery-powered is automatic.",
"output": "∀x (BatteryPoweredWatch(x) → ¬AutomaticWatch(x))"
},
{
"input": "Translate into first-order logic: All digital watches are battery-powered.",
"output": "∀x (DigitalWatch(x) → BatteryPoweredWatch(x))"
},
{
"input": "Translate into first-order logic: Some mechanical watches are automatic.",
"output": "∃x (MechanicalWatch(x) ∧ AutomaticWatch(x))"
},
{
"input": "Translate into first-order logic: All smart watches are digital.",
"output": "∀x (SmartWatch(x) → DigitalWatch(x))"
},
{
"input": "Translate into first-order logic: Moonwatch is not a digital watch or an automatic.",
"output": "¬DigitalWatch(moonwatch) ⊕ AutomaticWatch(moonwatch)"
},
{
"input": "Translate into first-order logic: No watch that is battery-powered is automatic.",
"output": "∀x (BatteryPoweredWatch(x) → ¬AutomaticWatch(x))"
},
{
"input": "Translate into first-order logic: All digital watches are battery-powered.",
"output": "∀x (DigitalWatch(x) → BatteryPoweredWatch(x))"
},
{
"input": "Translate into first-order logic: Some mechanical watches are automatic.",
"output": "∃x (MechanicalWatch(x) ∧ AutomaticWatch(x))"
},
{
"input": "Translate into first-order logic: All smart watches are digital.",
"output": "∀x (SmartWatch(x) → DigitalWatch(x))"
},
{
"input": "Translate into first-order logic: Moonwatch is not a digital watch or an automatic.",
"output": "¬DigitalWatch(moonwatch) ⊕ AutomaticWatch(moonwatch)"
},
{
"input": "Translate into first-order logic: If a person can distinguish the taste of different condiments, then he/she can also use different condiments to cook.",
"output": "∀x (People(x) ∧ DistinguishCondiments(x) → UseDiffCondiments(x)) ∧ (∃x (People(x) ∧ ¬DistinguishCondiments(x) ∧ UseDiffCondiments(x))) ∧ ¬(∀x (People(x) ∧ DistinguishCondiments(x)))"
},
{
"input": "Translate into first-order logic: People who have the talent of cooking can distinguish the taste of different condiments.",
"output": "∀x (People(x) ∧ TalentCooking(x) → DistinguishCondiments(x))"
},
{
"input": "Translate into first-order logic: Only people with the talent of cooking can make delicious meals.",
"output": "∀x ∀y (MakeMeal(x, y) ∧ Delicious(y) ∧ People(x) → TalentCooking(x)) "
},
{
"input": "Translate into first-order logic: If the meal is popular at the party, then it is delicious.",
"output": "∀x ∀y (MakeMeal(x, y) ∧ People(x) ∧ Popular(y) → Delicious(y))"
},
{
"input": "Translate into first-order logic: John can make meals which are popular at the party.",
"output": "∃x (People(john) ∧ MakeMeal(john, x) ∧ Popular(x) ∧ People(peter) ∧ ¬UseDiffCondiments(peter))"
},
{
"input": "Translate into first-order logic: Effective monetary policy is possible with successful inflation control and a strong national currency.",
"output": "∀x (EffMonPolicy(x) → InfControl(x) ∧ StongCurr(x))"
},
{
"input": "Translate into first-order logic: A country cannot simultaneously regulate the exchange rate and successfully control inflation.",
"output": "¬(∀x (InfControl(x) ∧ ExRate(x)))"
},
{
"input": "Translate into first-order logic: The introduction of an embargo on foreign trade goods in a country leads to a sharp decrease in exports.",
"output": "∀x (Embargo(x) → ExportFall(x))"
},
{
"input": "Translate into first-order logic: If exports fall sharply, the national currency cannot be in this country.",
"output": "∀x (ExportFall(x) → ¬StongCurr(x))"
},
{
"input": "Translate into first-order logic: Regulation of the exchange rate is required to have a strong national currency.",
"output": "∀x (ExRate(x) → StongCurr(x))"
},
{
"input": "Translate into first-order logic: There is an embargo on Russian foreign trade goods.",
"output": "Embargo(russia)"
},
{
"input": "Translate into first-order logic: Video Gag is a French television series that airs weekly.",
"output": "∀x (VideoGag(x) → FrenchTelevision(x) ∧ AirsWeekly(x))"
},
{
"input": "Translate into first-order logic: Video Gag airs on the French broadcast channel TF1.",
"output": "∀x (VideoGag(x) → ChannelTF1(x))"
},
{
"input": "Translate into first-order logic: If viewers send in funny videos to the French broadcast channel, then Video Gag airs them on television.",
"output": "∀x (FunnyVideos(x) → AirsWeekly(x))"
},
{
"input": "Translate into first-order logic: All videos aired on Video Gag are in French.",
"output": "∀x (VideoGag(x) → AirsWeekly(x) ∧ French(x))"
},
{
"input": "Translate into first-order logic: Video Gag is a French television series that airs weekly.",
"output": "∀x (VideoGag(x) → FrenchTelevision(x) ∧ AirsWeekly(x))"
},
{
"input": "Translate into first-order logic: Video Gag airs on the French broadcast channel TF1.",
"output": "∀x (VideoGag(x) → ChannelTF1(x))"
},
{
"input": "Translate into first-order logic: If viewers send in funny videos to the French broadcast channel, then Video Gag airs them on television.",
"output": "∀x (FunnyVideos(x) → AirsWeekly(x))"
},
{
"input": "Translate into first-order logic: All videos aired on Video Gag are in French.",
"output": "∀x (VideoGag(x) → AirsWeekly(x) ∧ French(x))"
},
{
"input": "Translate into first-order logic: All phones are things.",
"output": "∀x (Phone(x) → Thing(x))"
},
{
"input": "Translate into first-order logic: All cellphones are phones.",
"output": "∀x (Cellphone(x) → Phone(x))"
},
{
"input": "Translate into first-order logic: All iPhones are cellphones.",
"output": "∀x (Iphone(x) → Cellphone(x))"
},
{
"input": "Translate into first-order logic: All engineers are workers.",
"output": "∀x (Engineer(x) → Worker(x))"
},
{
"input": "Translate into first-order logic: All workers are human.",
"output": "∀x (Worker(x) → Human(x))"
},
{
"input": "Translate into first-order logic: Jack is either an engineer or a worker.",
"output": "Engineer(jack) ⊕ Worker(jack) "
},
{
"input": "Translate into first-order logic: Jack is is either a human or a phone.",
"output": "Human(jack) ⊕ Phone(jack)"
},
{
"input": "Translate into first-order logic: All phones are things.",
"output": "∀x (Phone(x) → Thing(x))"
},
{
"input": "Translate into first-order logic: All cellphones are phones.",
"output": "∀x (Cellphone(x) → Phone(x))"
},
{
"input": "Translate into first-order logic: All iPhones are cellphones.",
"output": "∀x (Iphone(x) → Cellphone(x))"
},
{
"input": "Translate into first-order logic: All engineers are workers.",
"output": "∀x (Engineer(x) → Worker(x))"
},
{
"input": "Translate into first-order logic: All workers are human.",
"output": "∀x (Worker(x) → Human(x))"
},
{
"input": "Translate into first-order logic: Jack is either an engineer or a worker.",
"output": "Engineer(jack) ⊕ Worker(jack) "
},
{
"input": "Translate into first-order logic: Jack is is either a human or a phone.",
"output": "Human(jack) ⊕ Phone(jack)"
},
{
"input": "Translate into first-order logic: All phones are things.",
"output": "∀x (Phone(x) → Thing(x))"
},
{
"input": "Translate into first-order logic: All cellphones are phones.",
"output": "∀x (Cellphone(x) → Phone(x))"
},
{
"input": "Translate into first-order logic: All iPhones are cellphones.",
"output": "∀x (Iphone(x) → Cellphone(x))"
},
{
"input": "Translate into first-order logic: All engineers are workers.",
"output": "∀x (Engineer(x) → Worker(x))"
},
{
"input": "Translate into first-order logic: All workers are human.",
"output": "∀x (Worker(x) → Human(x))"
},
{
"input": "Translate into first-order logic: Jack is either an engineer or a worker.",
"output": "Engineer(jack) ⊕ Worker(jack) "
},
{
"input": "Translate into first-order logic: Jack is is either a human or a phone.",
"output": "Human(jack) ⊕ Phone(jack)"
},
{
"input": "Translate into first-order logic: All phones are things.",
"output": "∀x (Phone(x) → Thing(x))"
},
{
"input": "Translate into first-order logic: All cellphones are phones.",
"output": "∀x (Cellphone(x) → Phone(x))"
},
{
"input": "Translate into first-order logic: All iPhones are cellphones.",
"output": "∀x (Iphone(x) → Cellphone(x))"
},
{
"input": "Translate into first-order logic: All engineers are workers.",
"output": "∀x (Engineer(x) → Worker(x))"
},
{
"input": "Translate into first-order logic: All workers are human.",
"output": "∀x (Worker(x) → Human(x))"
},
{
"input": "Translate into first-order logic: Jack is either an engineer or a worker.",
"output": "Engineer(jack) ⊕ Worker(jack) "
},
{
"input": "Translate into first-order logic: Jack is is either a human or a phone.",
"output": "Human(jack) ⊕ Phone(jack)"
},
{
"input": "Translate into first-order logic: All iPhones are electronic.",
"output": "∀x (IPhone(x) → Electronic(x))"
},
{
"input": "Translate into first-order logic: Some phones are iPhones.",
"output": "∃x (Phone(x) ∧ IPhone(x))"
},
{
"input": "Translate into first-order logic: Metropolitan Museum of Art is a museum in NYC.",
"output": "Museum(metropolitanMuseumofArt) ∧ InNYC(metropolitanMuseumofArt)"
},
{
"input": "Translate into first-order logic: Whitney Museum of American Art is a museum in NYC.",
"output": "Museum(whitneyMuseumofAmericanArt) ∧ InNYC(whitneyMuseumofAmericanArt)"
},
{
"input": "Translate into first-order logic: Museum of Modern Art (MoMA) is a museum if NYC.",
"output": "Museum(museumofModernArt) ∧ InNYC(museumofModernArt)"
},
{
"input": "Translate into first-order logic: Metropolitan Museum of Art includes Bytantine and Islamic Art.",
"output": "Include(metropolitanMuseumofArt, byzantineArt) ∧ Include(metropolitanMuseumofArt, islamicArt)"
},
{
"input": "Translate into first-order logic: Whitney Museum of American Art includes American art.",
"output": "Include(whitneyMuseumofAmericanArt, americanArt)"
},
{
"input": "Translate into first-order logic: Metropolitan Museum of Art is a museum in NYC.",
"output": "Museum(metropolitanMuseumofArt) ∧ InNYC(metropolitanMuseumofArt)"
},
{
"input": "Translate into first-order logic: Whitney Museum of American Art is a museum in NYC.",
"output": "Museum(whitneyMuseumofAmericanArt) ∧ InNYC(whitneyMuseumofAmericanArt)"
},
{
"input": "Translate into first-order logic: Museum of Modern Art (MoMA) is a museum if NYC.",
"output": "Museum(museumofModernArt) ∧ InNYC(museumofModernArt)"
},
{
"input": "Translate into first-order logic: Metropolitan Museum of Art includes Bytantine and Islamic Art.",
"output": "Include(metropolitanMuseumofArt, byzantineArt) ∧ Include(metropolitanMuseumofArt, islamicArt)"
},
{
"input": "Translate into first-order logic: Whitney Museum of American Art includes American art.",
"output": "Include(whitneyMuseumofAmericanArt, americanArt)"
},
{
"input": "Translate into first-order logic: Metropolitan Museum of Art is a museum in NYC.",
"output": "Museum(metropolitanMuseumofArt) ∧ InNYC(metropolitanMuseumofArt)"
},
{
"input": "Translate into first-order logic: Whitney Museum of American Art is a museum in NYC.",
"output": "Museum(whitneyMuseumofAmericanArt) ∧ InNYC(whitneyMuseumofAmericanArt)"
},
{
"input": "Translate into first-order logic: Museum of Modern Art (MoMA) is a museum if NYC.",
"output": "Museum(museumofModernArt) ∧ InNYC(museumofModernArt)"
},
{
"input": "Translate into first-order logic: Metropolitan Museum of Art includes Bytantine and Islamic Art.",
"output": "Include(metropolitanMuseumofArt, byzantineArt) ∧ Include(metropolitanMuseumofArt, islamicArt)"
},
{
"input": "Translate into first-order logic: Whitney Museum of American Art includes American art.",
"output": "Include(whitneyMuseumofAmericanArt, americanArt)"
},
{
"input": "Translate into first-order logic: A person either likes eating cheese or is a francophile.",
"output": "∀x (Spanish(x) ∨ Francophile(x))"
},
{
"input": "Translate into first-order logic: No francophiles are people who like Spain as their favorite country.",
"output": "∀x (Francophile(x) → ¬SpainFav(x))"
},
{
"input": "Translate into first-order logic: A person likes Spain as their favorite country or likes eating cheese.",
"output": "∀x (SpainFav(x) ∨ Cheese(x))"
},
{
"input": "Translate into first-order logic: Benji is not a person who likes eating cheese and a person who studies Spanish.",
"output": "¬(Cheese(benji) ∧ Spanish(benji))"
},
{
"input": "Translate into first-order logic: If Benji is neither a person who studies Spanish nor a person that studies French, then Benji is a person who studies Spanish or a person that studies French.",
"output": "¬(Spanish(benji) ∨ French(benji)) → ¬(Cheese(benji) ⊕ French(benji))"
},
{
"input": "Translate into first-order logic: A person either likes eating cheese or is a francophile.",
"output": "∀x (Spanish(x) ∨ Francophile(x))"
},
{
"input": "Translate into first-order logic: No francophiles are people who like Spain as their favorite country.",
"output": "∀x (Francophile(x) → ¬SpainFav(x))"
},
{
"input": "Translate into first-order logic: A person likes Spain as their favorite country or likes eating cheese.",
"output": "∀x (SpainFav(x) ∨ Cheese(x))"
},
{
"input": "Translate into first-order logic: Benji is not a person who likes eating cheese and a person who studies Spanish.",
"output": "¬(Cheese(benji) ∧ Spanish(benji))"
},
{
"input": "Translate into first-order logic: If Benji is neither a person who studies Spanish nor a person that studies French, then Benji is a person who studies Spanish or a person that studies French.",
"output": "¬(Spanish(benji) ∨ French(benji)) → ¬(Cheese(benji) ⊕ French(benji))"
},
{
"input": "Translate into first-order logic: A person either likes eating cheese or is a francophile.",
"output": "∀x (Spanish(x) ∨ Francophile(x))"
},
{
"input": "Translate into first-order logic: No francophiles are people who like Spain as their favorite country.",
"output": "∀x (Francophile(x) → ¬SpainFav(x))"
},
{
"input": "Translate into first-order logic: A person likes Spain as their favorite country or likes eating cheese.",
"output": "∀x (SpainFav(x) ∨ Cheese(x))"
},
{
"input": "Translate into first-order logic: Benji is not a person who likes eating cheese and a person who studies Spanish.",
"output": "¬(Cheese(benji) ∧ Spanish(benji))"
},
{
"input": "Translate into first-order logic: If Benji is neither a person who studies Spanish nor a person that studies French, then Benji is a person who studies Spanish or a person that studies French.",
"output": "¬(Spanish(benji) ∨ French(benji)) → ¬(Cheese(benji) ⊕ French(benji))"
},
{
"input": "Translate into first-order logic: Gasteren is village located in the province of Drenthe.",
"output": "Village(gasteren) ∧ Province(drenthe) ∧ LocatedIn(gasteren, drenthe)"
},
{
"input": "Translate into first-order logic: Drenthe is a Dutch province.",
"output": "Province(drenthe) ∧ Dutch(drenthe)"
},
{
"input": "Translate into first-order logic: No cities are villages.",
"output": "∀x (City(x) → ¬Village(x))"
},
{
"input": "Translate into first-order logic: The population of a village in Drenthe was 155 people.",
"output": "∃x (Population155(x) ∧ Village(x) ∧ LocatedIn(x, drenthe))"
},
{
"input": "Translate into first-order logic: Gasteren is village located in the province of Drenthe.",
"output": "Village(gasteren) ∧ Province(drenthe) ∧ LocatedIn(gasteren, drenthe)"
},
{
"input": "Translate into first-order logic: Drenthe is a Dutch province.",
"output": "Province(drenthe) ∧ Dutch(drenthe)"
},
{
"input": "Translate into first-order logic: No cities are villages.",
"output": "∀x (City(x) → ¬Village(x))"
},
{
"input": "Translate into first-order logic: The population of a village in Drenthe was 155 people.",
"output": "∃x (Population155(x) ∧ Village(x) ∧ LocatedIn(x, drenthe))"
},
{
"input": "Translate into first-order logic: Gasteren is village located in the province of Drenthe.",
"output": "Village(gasteren) ∧ Province(drenthe) ∧ LocatedIn(gasteren, drenthe)"
},
{
"input": "Translate into first-order logic: Drenthe is a Dutch province.",
"output": "Province(drenthe) ∧ Dutch(drenthe)"
},
{
"input": "Translate into first-order logic: No cities are villages.",
"output": "∀x (City(x) → ¬Village(x))"
},
{
"input": "Translate into first-order logic: The population of a village in Drenthe was 155 people.",
"output": "∃x (Population155(x) ∧ Village(x) ∧ LocatedIn(x, drenthe))"
},
{
"input": "Translate into first-order logic: The only types of mammals that lay eggs are platypuses and echidnas.",
"output": "∀x ((Mammal(x) ∧ LayEgg(x)) → (Platypuses(x) ⊕ Echidnas(x)))"
},
{
"input": "Translate into first-order logic: Platypuses are not hyrax.",
"output": "∀x (Platypuses(x) → ¬Hyrax(x))"
},
{
"input": "Translate into first-order logic: Echidnas are not hyrax.",
"output": "∀x (Echidnas(x) → ¬Hyrax(x))"
},
{
"input": "Translate into first-order logic: No mammals are invertebrates.",
"output": "∀x (Mammal(x) → ¬Invertebrate(x))"
},
{
"input": "Translate into first-order logic: All animals are either vertebrates or invertebrates.",
"output": "∀x (Animal(x) → Invertebrate(x) ⊕ Vertebrate(x))"
},
{
"input": "Translate into first-order logic: Mammals are animals.",
"output": "∀x (Mammal(x) → Animal(x))"
},
{
"input": "Translate into first-order logic: Hyraxes are mammals.",
"output": "∀x (Hyrax(x) → Mammal(x))"
},
{
"input": "Translate into first-order logic: Grebes lay eggs.",
"output": "∀x (Grebes(x) → LayEgg(x))"
},
{
"input": "Translate into first-order logic: Grebes are not platypuses and also not echidnas.",
"output": "∀x (Grebes(x) → (¬Platypuses(x) ∧ ¬Echidnas(x)))"
},
{
"input": "Translate into first-order logic: The only types of mammals that lay eggs are platypuses and echidnas.",
"output": "∀x ((Mammal(x) ∧ LayEgg(x)) → (Platypuses(x) ⊕ Echidnas(x)))"
},
{
"input": "Translate into first-order logic: Platypuses are not hyrax.",
"output": "∀x (Platypuses(x) → ¬Hyrax(x))"
},
{
"input": "Translate into first-order logic: Echidnas are not hyrax.",
"output": "∀x (Echidnas(x) → ¬Hyrax(x))"
},
{
"input": "Translate into first-order logic: No mammals are invertebrates.",
"output": "∀x (Mammal(x) → ¬Invertebrate(x))"
},
{
"input": "Translate into first-order logic: All animals are either vertebrates or invertebrates.",
"output": "∀x (Animal(x) → Invertebrate(x) ⊕ Vertebrate(x))"
},
{
"input": "Translate into first-order logic: Mammals are animals.",
"output": "∀x (Mammal(x) → Animal(x))"
},
{
"input": "Translate into first-order logic: Hyraxes are mammals.",
"output": "∀x (Hyrax(x) → Mammal(x))"
},
{
"input": "Translate into first-order logic: Grebes lay eggs.",
"output": "∀x (Grebes(x) → LayEgg(x))"
},
{
"input": "Translate into first-order logic: Grebes are not platypuses and also not echidnas.",
"output": "∀x (Grebes(x) → (¬Platypuses(x) ∧ ¬Echidnas(x)))"
},
{
"input": "Translate into first-order logic: The only types of mammals that lay eggs are platypuses and echidnas.",
"output": "∀x ((Mammal(x) ∧ LayEgg(x)) → (Platypuses(x) ⊕ Echidnas(x)))"
},
{
"input": "Translate into first-order logic: Platypuses are not hyrax.",
"output": "∀x (Platypuses(x) → ¬Hyrax(x))"
},
{
"input": "Translate into first-order logic: Echidnas are not hyrax.",
"output": "∀x (Echidnas(x) → ¬Hyrax(x))"
},
{
"input": "Translate into first-order logic: No mammals are invertebrates.",
"output": "∀x (Mammal(x) → ¬Invertebrate(x))"
},
{
"input": "Translate into first-order logic: All animals are either vertebrates or invertebrates.",
"output": "∀x (Animal(x) → Invertebrate(x) ⊕ Vertebrate(x))"
},
{
"input": "Translate into first-order logic: Mammals are animals.",
"output": "∀x (Mammal(x) → Animal(x))"
},
{
"input": "Translate into first-order logic: Hyraxes are mammals.",
"output": "∀x (Hyrax(x) → Mammal(x))"
},
{
"input": "Translate into first-order logic: Grebes lay eggs.",
"output": "∀x (Grebes(x) → LayEgg(x))"
},
{
"input": "Translate into first-order logic: Grebes are not platypuses and also not echidnas.",
"output": "∀x (Grebes(x) → (¬Platypuses(x) ∧ ¬Echidnas(x)))"
},
{
"input": "Translate into first-order logic: Bobby Flynn is a singer-songwriter.",
"output": "Singer(bobbyFlynn) ∧ SongWriter(bobbyFlynn)"
},
{
"input": "Translate into first-order logic: Bobby Flynn finished 7th while competing on Australian Idol.",
"output": "Finished7th(bobbyFlynn) ∧ CompetedOnAustralianIdol(bobbyFlynn)"
},
{
"input": "Translate into first-order logic: Australian Idol competitors are Australian citizens.",
"output": "∀x (CompetedOnAustralianIdol(x) → AustralianCitizen(x))"
},
{
"input": "Translate into first-order logic: The Omega Three band made a nationwide tour in 2007.",
"output": "MadeNationWideTour2007(theOmegaThreeBand) "
},
{
"input": "Translate into first-order logic: Bobby Flynn is a member of The Omega Three band.",
"output": "IsMember(bobbyFlynn, theOmegaThreeBand)"
},
{
"input": "Translate into first-order logic: Bobby Flynn was born in Queensland.",
"output": "BornIn(bobbyFlynn, queensland)"
},
{
"input": "Translate into first-order logic: Bobby Flynn is a singer-songwriter.",
"output": "Singer(bobbyFlynn) ∧ SongWriter(bobbyFlynn)"
},
{
"input": "Translate into first-order logic: Bobby Flynn finished 7th while competing on Australian Idol.",
"output": "Finished7th(bobbyFlynn) ∧ CompetedOnAustralianIdol(bobbyFlynn)"
},
{
"input": "Translate into first-order logic: Australian Idol competitors are Australian citizens.",
"output": "∀x (CompetedOnAustralianIdol(x) → AustralianCitizen(x))"
},
{
"input": "Translate into first-order logic: The Omega Three band made a nationwide tour in 2007.",
"output": "MadeNationWideTour2007(theOmegaThreeBand) "
},
{
"input": "Translate into first-order logic: Bobby Flynn is a member of The Omega Three band.",
"output": "IsMember(bobbyFlynn, theOmegaThreeBand)"
},
{
"input": "Translate into first-order logic: Bobby Flynn was born in Queensland.",
"output": "BornIn(bobbyFlynn, queensland)"
},
{
"input": "Translate into first-order logic: Bobby Flynn is a singer-songwriter.",
"output": "Singer(bobbyFlynn) ∧ SongWriter(bobbyFlynn)"
},
{
"input": "Translate into first-order logic: Bobby Flynn finished 7th while competing on Australian Idol.",
"output": "Finished7th(bobbyFlynn) ∧ CompetedOnAustralianIdol(bobbyFlynn)"
},
{
"input": "Translate into first-order logic: Australian Idol competitors are Australian citizens.",
"output": "∀x (CompetedOnAustralianIdol(x) → AustralianCitizen(x))"
},
{
"input": "Translate into first-order logic: The Omega Three band made a nationwide tour in 2007.",
"output": "MadeNationWideTour2007(theOmegaThreeBand) "
},
{
"input": "Translate into first-order logic: Bobby Flynn is a member of The Omega Three band.",
"output": "IsMember(bobbyFlynn, theOmegaThreeBand)"
},
{
"input": "Translate into first-order logic: Bobby Flynn was born in Queensland.",
"output": "BornIn(bobbyFlynn, queensland)"
},
{
"input": "Translate into first-order logic: All proteins are organic compounds.",
"output": "∀x (Protein(x) → OrganicCompound(x))"
},
{
"input": "Translate into first-order logic: All enzymes are organic compounds.",
"output": "∀x (Enzyme(x) → OrganicCompound(x))"
},
{
"input": "Translate into first-order logic: One American screenwriter and producer is Maggie Friedman.",
"output": "American(maggiefriedman) ∧ Screenwriter(maggiefriedman) ∧ Producer(maggiefriedman)"
},
{
"input": "Translate into first-order logic: Maggie Friedman was the showrunner and executive producer of the lifetime television series Witches of East End.",
"output": "ShowRunnerOf(maggiefriedman, witchesofeastend) ∧ ExecutiveProducerOf(maggiefriedman, witchesofeastend) ∧ LifetimeTelevisionSeries(maggiefriedman)"
},
{
"input": "Translate into first-order logic: Witches of East End is a fantasy-drama series.",
"output": "Fantasy-Drama(witchesofeastend) ∧ Series(witchesofeastend)"
},
{
"input": "Translate into first-order logic: Maggie Friedman produced and developed Eastwick.",
"output": "Produced(maggiefriedman, eastwick) ∧ Developed(maggiefriedman, eastwick)"
},
{
"input": "Translate into first-order logic: Eastwick is a series by ABC.",
"output": "Series(eastwick) ∧ By(eastwick, abc)"
},
{
"input": "Translate into first-order logic: One American screenwriter and producer is Maggie Friedman.",
"output": "American(maggiefriedman) ∧ Screenwriter(maggiefriedman) ∧ Producer(maggiefriedman)"
},
{
"input": "Translate into first-order logic: Maggie Friedman was the showrunner and executive producer of the lifetime television series Witches of East End.",
"output": "ShowRunnerOf(maggiefriedman, witchesofeastend) ∧ ExecutiveProducerOf(maggiefriedman, witchesofeastend) ∧ LifetimeTelevisionSeries(maggiefriedman)"
},
{
"input": "Translate into first-order logic: Witches of East End is a fantasy-drama series.",
"output": "Fantasy-Drama(witchesofeastend) ∧ Series(witchesofeastend)"
},
{
"input": "Translate into first-order logic: Maggie Friedman produced and developed Eastwick.",
"output": "Produced(maggiefriedman, eastwick) ∧ Developed(maggiefriedman, eastwick)"
},
{
"input": "Translate into first-order logic: Eastwick is a series by ABC.",
"output": "Series(eastwick) ∧ By(eastwick, abc)"
},
{
"input": "Translate into first-order logic: One American screenwriter and producer is Maggie Friedman.",
"output": "American(maggiefriedman) ∧ Screenwriter(maggiefriedman) ∧ Producer(maggiefriedman)"
},
{
"input": "Translate into first-order logic: Maggie Friedman was the showrunner and executive producer of the lifetime television series Witches of East End.",
"output": "ShowRunnerOf(maggiefriedman, witchesofeastend) ∧ ExecutiveProducerOf(maggiefriedman, witchesofeastend) ∧ LifetimeTelevisionSeries(maggiefriedman)"
},
{
"input": "Translate into first-order logic: Witches of East End is a fantasy-drama series.",
"output": "Fantasy-Drama(witchesofeastend) ∧ Series(witchesofeastend)"
},
{
"input": "Translate into first-order logic: Maggie Friedman produced and developed Eastwick.",
"output": "Produced(maggiefriedman, eastwick) ∧ Developed(maggiefriedman, eastwick)"
},
{
"input": "Translate into first-order logic: Eastwick is a series by ABC.",
"output": "Series(eastwick) ∧ By(eastwick, abc)"
},
{
"input": "Translate into first-order logic: Evangelos Eleftheriou is a Greek electrical engineer.",
"output": "Greek(evangeloseleftheriou) ∧ ElectricalEngineer(evangeloseleftheriou)"
},
{
"input": "Translate into first-order logic: Evangelos Eleftheriou worked for IBM in Zurich.",
"output": "WorkedFor(evangeloseleftheriou, ibm) ∧ WorkedIn(evangeloseleftheriou, zurich)"
},
{
"input": "Translate into first-order logic: If a company has employees working for them somewhere, then they have an office there.",
"output": "∀x ∀x ∀z (Company(x) ∧ WorkedFor(y, x) ∧ WorkedIn(y, z) → HasOfficeIn(x, z))"
},
{
"input": "Translate into first-order logic: IBM is a company.",
"output": "Company(ibm)"
},
{
"input": "Translate into first-order logic: Evangelos Eleftheriou is a Greek electrical engineer.",
"output": "Greek(evangeloseleftheriou) ∧ ElectricalEngineer(evangeloseleftheriou)"
},
{
"input": "Translate into first-order logic: Evangelos Eleftheriou worked for IBM in Zurich.",
"output": "WorkedFor(evangeloseleftheriou, ibm) ∧ WorkedIn(evangeloseleftheriou, zurich)"
},
{
"input": "Translate into first-order logic: If a company has employees working for them somewhere, then they have an office there.",
"output": "∀x ∀x ∀z (Company(x) ∧ WorkedFor(y, x) ∧ WorkedIn(y, z) → HasOfficeIn(x, z))"
},
{
"input": "Translate into first-order logic: IBM is a company.",
"output": "Company(ibm)"
},
{
"input": "Translate into first-order logic: Before releasing their single, \"Hooray! Hooray! It's a Holi-Holiday!\", Boney M. had had seven consecutive German #1 singles.",
"output": "∃x (Song(x) ∧ By(x, boneym) ∧ N1GermanSingle(x))"
},
{
"input": "Translate into first-order logic: \"Hooray! Hooray! It's a Holi-Holiday!\" was a big hit all over Europe.",
"output": "Song(hooray) ∧ HitEurope(hooray)"
},
{
"input": "Translate into first-order logic: Nevertheless, \"Hooray! Hooray! It's a Holi-Holiday!\" broke Boney M's streak of consecutive German #1 singles.",
"output": "Song(hooray) ∧ ¬N1GermanSingle(hooray)"
},
{
"input": "Translate into first-order logic: A song that peaks below #1 on the german charts is also a song that is not the #1 single",
"output": "∀x (PeaksBelowN1(x) ↔ ¬N1GermanSingle(x))"
},
{
"input": "Translate into first-order logic: Before releasing their single, \"Hooray! Hooray! It's a Holi-Holiday!\", Boney M. had had seven consecutive German #1 singles.",
"output": "∃x (Song(x) ∧ By(x, boneym) ∧ N1GermanSingle(x))"
},
{
"input": "Translate into first-order logic: \"Hooray! Hooray! It's a Holi-Holiday!\" was a big hit all over Europe.",
"output": "Song(hooray) ∧ HitEurope(hooray)"
},
{
"input": "Translate into first-order logic: Nevertheless, \"Hooray! Hooray! It's a Holi-Holiday!\" broke Boney M's streak of consecutive German #1 singles.",
"output": "Song(hooray) ∧ ¬N1GermanSingle(hooray)"
},
{
"input": "Translate into first-order logic: A song that peaks below #1 on the german charts is also a song that is not the #1 single",
"output": "∀x (PeaksBelowN1(x) ↔ ¬N1GermanSingle(x))"
},
{
"input": "Translate into first-order logic: Before releasing their single, \"Hooray! Hooray! It's a Holi-Holiday!\", Boney M. had had seven consecutive German #1 singles.",
"output": "∃x (Song(x) ∧ By(x, boneym) ∧ N1GermanSingle(x))"
},
{
"input": "Translate into first-order logic: \"Hooray! Hooray! It's a Holi-Holiday!\" was a big hit all over Europe.",
"output": "Song(hooray) ∧ HitEurope(hooray)"
},
{
"input": "Translate into first-order logic: Nevertheless, \"Hooray! Hooray! It's a Holi-Holiday!\" broke Boney M's streak of consecutive German #1 singles.",
"output": "Song(hooray) ∧ ¬N1GermanSingle(hooray)"
},
{
"input": "Translate into first-order logic: A song that peaks below #1 on the german charts is also a song that is not the #1 single",
"output": "∀x (PeaksBelowN1(x) ↔ ¬N1GermanSingle(x))"
},
{
"input": "Translate into first-order logic: Every chef can cook.",
"output": "∀x (Chef(x) → Cook(x))"
},
{
"input": "Translate into first-order logic: Some people who aren’t chefs can cook.",
"output": "∃x (¬Chef(x) ∧ Cook(x))"
},
{
"input": "Translate into first-order logic: People who cook can make scrambled eggs and pasta.",
"output": "∀x (Cook(x) → (MakeScrambledEggs(x) ∧ MakePasta(x)))"
},
{
"input": "Translate into first-order logic: If someone can make cookies and muffins, they are a baker.",
"output": "∀x (MakeCookies(x) ∧ MakeMuffins(x) → Baker(x))"
},
{
"input": "Translate into first-order logic: Bakers who can also make scrambled eggs can make a good breakfast.",
"output": "∀x ((Baker(x) ∧ MakeScrambledEggs(x)) → MakeGoodBreakfast(x))"
},
{
"input": "Translate into first-order logic: Luke can make cookies, scrambled eggs, and muffins, but not pasta.",
"output": "MakeCookies(luke) ∧ MakeScrambledEggs(luke) ∧ MakeMuffins(luke) ∧ ¬MakePasta(luke)"
},
{
"input": "Translate into first-order logic: Every chef can cook.",
"output": "∀x (Chef(x) → Cook(x))"
},
{
"input": "Translate into first-order logic: Some people who aren’t chefs can cook.",
"output": "∃x (¬Chef(x) ∧ Cook(x))"
},
{
"input": "Translate into first-order logic: People who cook can make scrambled eggs and pasta.",
"output": "∀x (Cook(x) → (MakeScrambledEggs(x) ∧ MakePasta(x)))"
},
{
"input": "Translate into first-order logic: If someone can make cookies and muffins, they are a baker.",
"output": "∀x (MakeCookies(x) ∧ MakeMuffins(x) → Baker(x))"
},
{
"input": "Translate into first-order logic: Bakers who can also make scrambled eggs can make a good breakfast.",
"output": "∀x ((Baker(x) ∧ MakeScrambledEggs(x)) → MakeGoodBreakfast(x))"
},
{
"input": "Translate into first-order logic: Luke can make cookies, scrambled eggs, and muffins, but not pasta.",
"output": "MakeCookies(luke) ∧ MakeScrambledEggs(luke) ∧ MakeMuffins(luke) ∧ ¬MakePasta(luke)"
},
{
"input": "Translate into first-order logic: ETS develops various standardized tests primarily in the United States for K-12 and higher education.",
"output": "∃x (Develops(ets, x) ∧ StandardizedTest(x) ∧ In(x, unitedstates) ∧ For(x, k-12andhighereducation))"
},
{
"input": "Translate into first-order logic: ETS administers international tests including the TOEFL, TOEIC, GRE and subject tests in more than 180 countries.",
"output": "∃x (Administers(ets, x) ∧ InternationalTest(x) ∧ (TOEFL(x) ∨ TOEIC(x) ∨ GRE(x) ∨ SubjectTests(x)))"
},
{
"input": "Translate into first-order logic: Many of the assessments ETS develops are associated with entry to the US tertiary and quaternary education institutions.",
"output": "∃x (Develops(ets, x) ∧ AssociatedWith(x, entrytouseducationinstitutions))"
},
{
"input": "Translate into first-order logic: ETS also develops K-12 statewide assessments used for accountability testing in many states.",
"output": "∃x (Develops(ets, x) ∧ StateWideAssesment(x) ∧ UsedFor(x, accountabilitytesting))"
},
{
"input": "Translate into first-order logic: ETS develops various standardized tests primarily in the United States for K-12 and higher education.",
"output": "∃x (Develops(ets, x) ∧ StandardizedTest(x) ∧ In(x, unitedstates) ∧ For(x, k-12andhighereducation))"
},
{
"input": "Translate into first-order logic: ETS administers international tests including the TOEFL, TOEIC, GRE and subject tests in more than 180 countries.",
"output": "∃x (Administers(ets, x) ∧ InternationalTest(x) ∧ (TOEFL(x) ∨ TOEIC(x) ∨ GRE(x) ∨ SubjectTests(x)))"
},
{
"input": "Translate into first-order logic: Many of the assessments ETS develops are associated with entry to the US tertiary and quaternary education institutions.",
"output": "∃x (Develops(ets, x) ∧ AssociatedWith(x, entrytouseducationinstitutions))"
},
{
"input": "Translate into first-order logic: ETS also develops K-12 statewide assessments used for accountability testing in many states.",
"output": "∃x (Develops(ets, x) ∧ StateWideAssesment(x) ∧ UsedFor(x, accountabilitytesting))"
},
{
"input": "Translate into first-order logic: ETS develops various standardized tests primarily in the United States for K-12 and higher education.",
"output": "∃x (Develops(ets, x) ∧ StandardizedTest(x) ∧ In(x, unitedstates) ∧ For(x, k-12andhighereducation))"
},
{
"input": "Translate into first-order logic: ETS administers international tests including the TOEFL, TOEIC, GRE and subject tests in more than 180 countries.",
"output": "∃x (Administers(ets, x) ∧ InternationalTest(x) ∧ (TOEFL(x) ∨ TOEIC(x) ∨ GRE(x) ∨ SubjectTests(x)))"
},
{
"input": "Translate into first-order logic: Many of the assessments ETS develops are associated with entry to the US tertiary and quaternary education institutions.",
"output": "∃x (Develops(ets, x) ∧ AssociatedWith(x, entrytouseducationinstitutions))"
},
{
"input": "Translate into first-order logic: ETS also develops K-12 statewide assessments used for accountability testing in many states.",
"output": "∃x (Develops(ets, x) ∧ StateWideAssesment(x) ∧ UsedFor(x, accountabilitytesting))"
},
{
"input": "Translate into first-order logic: All people who enjoy eating gelato ice cream would enjoy a vacation to Italy.",
"output": "∀x (Gelato(x) → Italy(x))"
},
{
"input": "Translate into first-order logic: There are no people who can resist the hallmark delectable drinks and desserts that are famed in Italy.",
"output": "∀x (¬Resist(x))"
},
{
"input": "Translate into first-order logic: People either enjoy eating gelato ice cream or love to travel and vacation often.",
"output": "∀x (Gelato(x) ∨ Travel(x))"
},
{
"input": "Translate into first-order logic: If people often take study abroad semesters to Europe, then they do not regret their college experiences.",
"output": "∀x (Europe(x) → ¬Regret(x))"
},
{
"input": "Translate into first-order logic: If people love to travel and vacation often, then they often take study abroad semesters to Europe.",
"output": "∀x (Travel(x) → Europe(x))"
},
{
"input": "Translate into first-order logic: Robert either enjoys eating gelato ice cream and loves to travel and vacation often, or he neither enjoys eating gelato ice cream nor loves to travel and vacation often.",
"output": "(Gelato(robert) ∧ Travel(robert)) ∨ (¬Gelato(robert) ∧ ¬Travel(robert))"
},
{
"input": "Translate into first-order logic: All people who enjoy eating gelato ice cream would enjoy a vacation to Italy.",
"output": "∀x (Gelato(x) → Italy(x))"
},
{
"input": "Translate into first-order logic: There are no people who can resist the hallmark delectable drinks and desserts that are famed in Italy.",
"output": "∀x (¬Resist(x))"
},
{
"input": "Translate into first-order logic: People either enjoy eating gelato ice cream or love to travel and vacation often.",
"output": "∀x (Gelato(x) ∨ Travel(x))"
},
{
"input": "Translate into first-order logic: If people often take study abroad semesters to Europe, then they do not regret their college experiences.",
"output": "∀x (Europe(x) → ¬Regret(x))"
},
{
"input": "Translate into first-order logic: If people love to travel and vacation often, then they often take study abroad semesters to Europe.",
"output": "∀x (Travel(x) → Europe(x))"
},
{
"input": "Translate into first-order logic: Robert either enjoys eating gelato ice cream and loves to travel and vacation often, or he neither enjoys eating gelato ice cream nor loves to travel and vacation often.",
"output": "(Gelato(robert) ∧ Travel(robert)) ∨ (¬Gelato(robert) ∧ ¬Travel(robert))"
},
{
"input": "Translate into first-order logic: All people who enjoy eating gelato ice cream would enjoy a vacation to Italy.",
"output": "∀x (Gelato(x) → Italy(x))"
},
{
"input": "Translate into first-order logic: There are no people who can resist the hallmark delectable drinks and desserts that are famed in Italy.",
"output": "∀x (¬Resist(x))"
},
{
"input": "Translate into first-order logic: People either enjoy eating gelato ice cream or love to travel and vacation often.",
"output": "∀x (Gelato(x) ∨ Travel(x))"
},
{
"input": "Translate into first-order logic: If people often take study abroad semesters to Europe, then they do not regret their college experiences.",
"output": "∀x (Europe(x) → ¬Regret(x))"
},
{
"input": "Translate into first-order logic: If people love to travel and vacation often, then they often take study abroad semesters to Europe.",
"output": "∀x (Travel(x) → Europe(x))"
},
{
"input": "Translate into first-order logic: Robert either enjoys eating gelato ice cream and loves to travel and vacation often, or he neither enjoys eating gelato ice cream nor loves to travel and vacation often.",
"output": "(Gelato(robert) ∧ Travel(robert)) ∨ (¬Gelato(robert) ∧ ¬Travel(robert))"
},
{
"input": "Translate into first-order logic: To get a student visa, you must be full-time enrolled in an academic program.",
"output": "∀x (StudentVisa(x) → FullTimeAcademic(x))"
},
{
"input": "Translate into first-order logic: Those who are full-time enrolled in an academic program can not work full-time.",
"output": "∀x (FullTimeAcademic(x) → ¬WorkFullTime(x))"
},
{
"input": "Translate into first-order logic: Everyone who wants to study abroad needs to have a student visa.",
"output": "∀x (StudyAbroad(x) → StudentVisa(x))"
},
{
"input": "Translate into first-order logic: All PhD graduates can work full time.",
"output": "∀x (PhdGraduate(x) → WorkFullTime(x))"
},
{
"input": "Translate into first-order logic: If Tom does not want to study abroad, he is full-time enrolled in an educational program.",
"output": "¬StudyAbroad(tom) → FullTimeAcademic(tom)"
},
{
"input": "Translate into first-order logic: To get a student visa, you must be full-time enrolled in an academic program.",
"output": "∀x (StudentVisa(x) → FullTimeAcademic(x))"
},
{
"input": "Translate into first-order logic: Those who are full-time enrolled in an academic program can not work full-time.",
"output": "∀x (FullTimeAcademic(x) → ¬WorkFullTime(x))"
},
{
"input": "Translate into first-order logic: Everyone who wants to study abroad needs to have a student visa.",
"output": "∀x (StudyAbroad(x) → StudentVisa(x))"
},
{
"input": "Translate into first-order logic: All PhD graduates can work full time.",
"output": "∀x (PhdGraduate(x) → WorkFullTime(x))"
},
{
"input": "Translate into first-order logic: If Tom does not want to study abroad, he is full-time enrolled in an educational program.",
"output": "¬StudyAbroad(tom) → FullTimeAcademic(tom)"
},
{
"input": "Translate into first-order logic: To get a student visa, you must be full-time enrolled in an academic program.",
"output": "∀x (StudentVisa(x) → FullTimeAcademic(x))"
},
{
"input": "Translate into first-order logic: Those who are full-time enrolled in an academic program can not work full-time.",
"output": "∀x (FullTimeAcademic(x) → ¬WorkFullTime(x))"
},
{
"input": "Translate into first-order logic: Everyone who wants to study abroad needs to have a student visa.",
"output": "∀x (StudyAbroad(x) → StudentVisa(x))"
},
{
"input": "Translate into first-order logic: All PhD graduates can work full time.",
"output": "∀x (PhdGraduate(x) → WorkFullTime(x))"
},
{
"input": "Translate into first-order logic: If Tom does not want to study abroad, he is full-time enrolled in an educational program.",
"output": "¬StudyAbroad(tom) → FullTimeAcademic(tom)"
},
{
"input": "Translate into first-order logic: The installment sales method is the approach to recognize revenue under the US GAAP.",
"output": "∀x (UsesGAAP(x) → UsesInstallmentMethod(x))"
},
{
"input": "Translate into first-order logic: In accrual accounting, revenues are recognized when they are realized.",
"output": "∀x (UsesAccruralAccounting(x) → RecognizedWhen(revenues, realized))"
},
{
"input": "Translate into first-order logic: In cash accounting, revenues are recognized when cash is received.",
"output": "∀x (UsesCashAccounting(x) → RecognizedWhen(revenues, cashrecieved))"
},
{
"input": "Translate into first-order logic: The US GAAP is the accounting standard developed and used by the US Securities and Exchange Commission.",
"output": "DevelopedBy(usgaap, ussecuritiesandexchangecommission) ∧ UsesGAAP(ussecuritiesandexchangecommission)"
},
{
"input": "Translate into first-order logic: Sally works for the US Securities and Exchange Commission.",
"output": "WorksFor(sally, ussecuritiesandexchangecommission)"
},
{
"input": "Translate into first-order logic: The installment sales method is the approach to recognize revenue under the US GAAP.",
"output": "∀x (UsesGAAP(x) → UsesInstallmentMethod(x))"
},
{
"input": "Translate into first-order logic: In accrual accounting, revenues are recognized when they are realized.",
"output": "∀x (UsesAccruralAccounting(x) → RecognizedWhen(revenues, realized))"
},
{
"input": "Translate into first-order logic: In cash accounting, revenues are recognized when cash is received.",
"output": "∀x (UsesCashAccounting(x) → RecognizedWhen(revenues, cashrecieved))"
},
{
"input": "Translate into first-order logic: The US GAAP is the accounting standard developed and used by the US Securities and Exchange Commission.",
"output": "DevelopedBy(usgaap, ussecuritiesandexchangecommission) ∧ UsesGAAP(ussecuritiesandexchangecommission)"
},
{
"input": "Translate into first-order logic: Sally works for the US Securities and Exchange Commission.",
"output": "WorksFor(sally, ussecuritiesandexchangecommission)"
},
{
"input": "Translate into first-order logic: The installment sales method is the approach to recognize revenue under the US GAAP.",
"output": "∀x (UsesGAAP(x) → UsesInstallmentMethod(x))"
},
{
"input": "Translate into first-order logic: In accrual accounting, revenues are recognized when they are realized.",
"output": "∀x (UsesAccruralAccounting(x) → RecognizedWhen(revenues, realized))"
},
{
"input": "Translate into first-order logic: In cash accounting, revenues are recognized when cash is received.",
"output": "∀x (UsesCashAccounting(x) → RecognizedWhen(revenues, cashrecieved))"
},
{
"input": "Translate into first-order logic: The US GAAP is the accounting standard developed and used by the US Securities and Exchange Commission.",
"output": "DevelopedBy(usgaap, ussecuritiesandexchangecommission) ∧ UsesGAAP(ussecuritiesandexchangecommission)"
},
{
"input": "Translate into first-order logic: Sally works for the US Securities and Exchange Commission.",
"output": "WorksFor(sally, ussecuritiesandexchangecommission)"
},
{
"input": "Translate into first-order logic: All people who are respected by others are people who contribute to the country.",
"output": "∀x (Respected(x) → ContributeToCountry(x))"
},
{
"input": "Translate into first-order logic: If a person is respected by others, then he/she contributes to the country.",
"output": "∀x (Respected(x) → ContributeToCountry(x))"
},
{
"input": "Translate into first-order logic: All people available to have a visit without any fees are those respected by others.",
"output": "∀x (HaveVisitWithoutAnyFees(x) → Respected(x))"
},
{
"input": "Translate into first-order logic: All Customers who once served in the army are available to have a visit without any fees.",
"output": "∀x (Army(x) → HaveVisitWithoutAnyFees(x))"
},
{
"input": "Translate into first-order logic: All people who once were sentenced for thief stayed in prison for some time.",
"output": "∀x (Thief(x) → Prison(x))"
},
{
"input": "Translate into first-order logic: All people who once stayed in prison for some time have a bad record in the local state.",
"output": "∀x (Prison(x) → BadRecord(x))"
},
{
"input": "Translate into first-order logic: James was either once sentenced for thief or stayed in prison for some time.",
"output": "Thief(james) ⊕ Prison(james) "
},
{
"input": "Translate into first-order logic: James is either with a bad record in the local state or respected by others.",
"output": "BadRecord(james) ⊕ Respected(james)"
},
{
"input": "Translate into first-order logic: All people who are respected by others are people who contribute to the country.",
"output": "∀x (Respected(x) → ContributeToCountry(x))"
},
{
"input": "Translate into first-order logic: If a person is respected by others, then he/she contributes to the country.",
"output": "∀x (Respected(x) → ContributeToCountry(x))"
},
{
"input": "Translate into first-order logic: All people available to have a visit without any fees are those respected by others.",
"output": "∀x (HaveVisitWithoutAnyFees(x) → Respected(x))"
},
{
"input": "Translate into first-order logic: All Customers who once served in the army are available to have a visit without any fees.",
"output": "∀x (Army(x) → HaveVisitWithoutAnyFees(x))"
},
{
"input": "Translate into first-order logic: All people who once were sentenced for thief stayed in prison for some time.",
"output": "∀x (Thief(x) → Prison(x))"
},
{
"input": "Translate into first-order logic: All people who once stayed in prison for some time have a bad record in the local state.",
"output": "∀x (Prison(x) → BadRecord(x))"
},
{
"input": "Translate into first-order logic: James was either once sentenced for thief or stayed in prison for some time.",
"output": "Thief(james) ⊕ Prison(james) "
},
{
"input": "Translate into first-order logic: James is either with a bad record in the local state or respected by others.",
"output": "BadRecord(james) ⊕ Respected(james)"
},
{
"input": "Translate into first-order logic: All people who are respected by others are people who contribute to the country.",
"output": "∀x (Respected(x) → ContributeToCountry(x))"
},
{
"input": "Translate into first-order logic: If a person is respected by others, then he/she contributes to the country.",
"output": "∀x (Respected(x) → ContributeToCountry(x))"
},
{
"input": "Translate into first-order logic: All people available to have a visit without any fees are those respected by others.",
"output": "∀x (HaveVisitWithoutAnyFees(x) → Respected(x))"
},
{
"input": "Translate into first-order logic: All Customers who once served in the army are available to have a visit without any fees.",
"output": "∀x (Army(x) → HaveVisitWithoutAnyFees(x))"
},
{
"input": "Translate into first-order logic: All people who once were sentenced for thief stayed in prison for some time.",
"output": "∀x (Thief(x) → Prison(x))"
},
{
"input": "Translate into first-order logic: All people who once stayed in prison for some time have a bad record in the local state.",
"output": "∀x (Prison(x) → BadRecord(x))"
},
{
"input": "Translate into first-order logic: James was either once sentenced for thief or stayed in prison for some time.",
"output": "Thief(james) ⊕ Prison(james) "
},
{
"input": "Translate into first-order logic: James is either with a bad record in the local state or respected by others.",
"output": "BadRecord(james) ⊕ Respected(james)"
},
{
"input": "Translate into first-order logic: All people who are respected by others are people who contribute to the country.",
"output": "∀x (Respected(x) → ContributeToCountry(x))"
},
{
"input": "Translate into first-order logic: If a person is respected by others, then he/she contributes to the country.",
"output": "∀x (Respected(x) → ContributeToCountry(x))"
},
{
"input": "Translate into first-order logic: All people available to have a visit without any fees are those respected by others.",
"output": "∀x (HaveVisitWithoutAnyFees(x) → Respected(x))"
},
{
"input": "Translate into first-order logic: All Customers who once served in the army are available to have a visit without any fees.",
"output": "∀x (Army(x) → HaveVisitWithoutAnyFees(x))"
},
{
"input": "Translate into first-order logic: All people who once were sentenced for thief stayed in prison for some time.",
"output": "∀x (Thief(x) → Prison(x))"
},
{
"input": "Translate into first-order logic: All people who once stayed in prison for some time have a bad record in the local state.",
"output": "∀x (Prison(x) → BadRecord(x))"
},
{
"input": "Translate into first-order logic: James was either once sentenced for thief or stayed in prison for some time.",
"output": "Thief(james) ⊕ Prison(james) "
},
{
"input": "Translate into first-order logic: James is either with a bad record in the local state or respected by others.",
"output": "BadRecord(james) ⊕ Respected(james)"
},
{
"input": "Translate into first-order logic: The Croton River watershed is the drainage basin of the Croton River.",
"output": "DrainageBasinOf(crotonriverwatershed, crotonriver)"
},
{
"input": "Translate into first-order logic: The Croton River is in southwestern New York.",
"output": "In(crotonriver, southwesternnewyork)"
},
{
"input": "Translate into first-order logic: Water from the Croton River watershed flows to the Bronx.",
"output": "∃x (Water(x) ∧ From(x, crotonriverwatershed) ∧ FlowsTo(x, bronx))"
},
{
"input": "Translate into first-order logic: The Bronx is in New York.",
"output": "In(bronx, newyork)"
},
{
"input": "Translate into first-order logic: The Croton River watershed is the drainage basin of the Croton River.",
"output": "DrainageBasinOf(crotonriverwatershed, crotonriver)"
},
{
"input": "Translate into first-order logic: The Croton River is in southwestern New York.",
"output": "In(crotonriver, southwesternnewyork)"
},
{
"input": "Translate into first-order logic: Water from the Croton River watershed flows to the Bronx.",
"output": "∃x (Water(x) ∧ From(x, crotonriverwatershed) ∧ FlowsTo(x, bronx))"
},
{
"input": "Translate into first-order logic: The Bronx is in New York.",
"output": "In(bronx, newyork)"
},
{
"input": "Translate into first-order logic: The Croton River watershed is the drainage basin of the Croton River.",
"output": "DrainageBasinOf(crotonriverwatershed, crotonriver)"
},
{
"input": "Translate into first-order logic: The Croton River is in southwestern New York.",
"output": "In(crotonriver, southwesternnewyork)"
},
{
"input": "Translate into first-order logic: Water from the Croton River watershed flows to the Bronx.",
"output": "∃x (Water(x) ∧ From(x, crotonriverwatershed) ∧ FlowsTo(x, bronx))"
},
{
"input": "Translate into first-order logic: The Bronx is in New York.",
"output": "In(bronx, newyork)"
},
{
"input": "Translate into first-order logic: All nuclear-powered submarines are warships.",
"output": "∀x (NuclearPoweredSubmarine(x) → Warship(x))"
},
{
"input": "Translate into first-order logic: No nuclear-powered submarines are commercial vessels.",
"output": "∀x (NuclearPoweredSubmarine(x) → ¬CommercialVessel(x))"
},
{
"input": "Translate into first-order logic: If a album is written by a rock band, then the genre of the album is rock.",
"output": "∀x ∀y ∀z (AlbumByBand(x, y) ∧ RockBand(y, z) → Genre(x, rock))"
},
{
"input": "Translate into first-order logic: If a band writes a album winning an award, then this band wins this award.",
"output": "∀x ∀y ∀z (AlbumByBand(x, y) ∧ AlbumAward(x, z) → RockBandAward(y, z))"
},
{
"input": "Translate into first-order logic: Trouble at the Henhouse is an album by The Tragically Hip.",
"output": "AlbumByBand(trouble_at_the_Henhouse, the_Tragically_Hip)"
},
{
"input": "Translate into first-order logic: The Tragically Hip is a Canadian rock band.",
"output": "RockBand(the_Tragically_Hip, canada)"
},
{
"input": "Translate into first-order logic: The song \"Butts Wigglin'\" is in Trouble at the Henhouse.",
"output": "SongInAlbum(butts_Wigglin, trouble_at_the_Henhouse)"
},
{
"input": "Translate into first-order logic: Trouble at the Henhouse won the Album of the Year award.",
"output": "AlbumAward(trouble_at_the_Henhouse, the_Album_of_the_Year)"
},
{
"input": "Translate into first-order logic: A song in Trouble at the Henhouse appeared in a film.",
"output": "∃x (SongInFilm(x) ∧ SongInAlbum(x, trouble_at_the_Henhouse))"
},
{
"input": "Translate into first-order logic: If a album is written by a rock band, then the genre of the album is rock.",
"output": "∀x ∀y ∀z (AlbumByBand(x, y) ∧ RockBand(y, z) → Genre(x, rock))"
},
{
"input": "Translate into first-order logic: If a band writes a album winning an award, then this band wins this award.",
"output": "∀x ∀y ∀z (AlbumByBand(x, y) ∧ AlbumAward(x, z) → RockBandAward(y, z))"
},
{
"input": "Translate into first-order logic: Trouble at the Henhouse is an album by The Tragically Hip.",
"output": "AlbumByBand(trouble_at_the_Henhouse, the_Tragically_Hip)"
},
{
"input": "Translate into first-order logic: The Tragically Hip is a Canadian rock band.",
"output": "RockBand(the_Tragically_Hip, canada)"
},
{
"input": "Translate into first-order logic: The song \"Butts Wigglin'\" is in Trouble at the Henhouse.",
"output": "SongInAlbum(butts_Wigglin, trouble_at_the_Henhouse)"
},
{
"input": "Translate into first-order logic: Trouble at the Henhouse won the Album of the Year award.",
"output": "AlbumAward(trouble_at_the_Henhouse, the_Album_of_the_Year)"
},
{
"input": "Translate into first-order logic: A song in Trouble at the Henhouse appeared in a film.",
"output": "∃x (SongInFilm(x) ∧ SongInAlbum(x, trouble_at_the_Henhouse))"
},
{
"input": "Translate into first-order logic: If a album is written by a rock band, then the genre of the album is rock.",
"output": "∀x ∀y ∀z (AlbumByBand(x, y) ∧ RockBand(y, z) → Genre(x, rock))"
},
{
"input": "Translate into first-order logic: If a band writes a album winning an award, then this band wins this award.",
"output": "∀x ∀y ∀z (AlbumByBand(x, y) ∧ AlbumAward(x, z) → RockBandAward(y, z))"
},
{
"input": "Translate into first-order logic: Trouble at the Henhouse is an album by The Tragically Hip.",
"output": "AlbumByBand(trouble_at_the_Henhouse, the_Tragically_Hip)"
},
{
"input": "Translate into first-order logic: The Tragically Hip is a Canadian rock band.",
"output": "RockBand(the_Tragically_Hip, canada)"
},
{
"input": "Translate into first-order logic: The song \"Butts Wigglin'\" is in Trouble at the Henhouse.",
"output": "SongInAlbum(butts_Wigglin, trouble_at_the_Henhouse)"
},
{
"input": "Translate into first-order logic: Trouble at the Henhouse won the Album of the Year award.",
"output": "AlbumAward(trouble_at_the_Henhouse, the_Album_of_the_Year)"
},
{
"input": "Translate into first-order logic: A song in Trouble at the Henhouse appeared in a film.",
"output": "∃x (SongInFilm(x) ∧ SongInAlbum(x, trouble_at_the_Henhouse))"
},
{
"input": "Translate into first-order logic: Daniel is a software engineer and he works at Palantir Technologies.",
"output": "SoftwareEngineer(daniel) ∧ WorksAt(daniel, palantirTechnologies)"
},
{
"input": "Translate into first-order logic: Daniel studied bioengineering during his undergraduate at Rice University.",
"output": " StudiedBioengineering(daniel, riceUniversity)"
},
{
"input": "Translate into first-order logic: Daniel’s older sister works at Meta as a technical sourcer.",
"output": " WorksAtMeta(danielsOlderSister) ∧ TechnicalSourcer(danielsOlderSister)"
},
{
"input": "Translate into first-order logic: Daniel’s dad and older sister both graduated from Stanford University.",
"output": " GraduatedFromStanfordUniversity(danielsOlderSister) ∧ GraduatedFromStanfordUniversity(danielsDad)"
},
{
"input": "Translate into first-order logic: Daniel’s dad is a doctor practicing internal medicine at a veteran’s hospital in Minneapolis",
"output": " DoctorPracticingInternalMedicine(danielsDad, veteransHospitalInMinneapolis)"
},
{
"input": "Translate into first-order logic: Daniel is a software engineer and he works at Palantir Technologies.",
"output": "SoftwareEngineer(daniel) ∧ WorksAt(daniel, palantirTechnologies)"
},
{
"input": "Translate into first-order logic: Daniel studied bioengineering during his undergraduate at Rice University.",
"output": " StudiedBioengineering(daniel, riceUniversity)"
},
{
"input": "Translate into first-order logic: Daniel’s older sister works at Meta as a technical sourcer.",
"output": " WorksAtMeta(danielsOlderSister) ∧ TechnicalSourcer(danielsOlderSister)"
},
{
"input": "Translate into first-order logic: Daniel’s dad and older sister both graduated from Stanford University.",
"output": " GraduatedFromStanfordUniversity(danielsOlderSister) ∧ GraduatedFromStanfordUniversity(danielsDad)"
},
{
"input": "Translate into first-order logic: Daniel’s dad is a doctor practicing internal medicine at a veteran’s hospital in Minneapolis",
"output": " DoctorPracticingInternalMedicine(danielsDad, veteransHospitalInMinneapolis)"
},
{
"input": "Translate into first-order logic: Daniel is a software engineer and he works at Palantir Technologies.",
"output": "SoftwareEngineer(daniel) ∧ WorksAt(daniel, palantirTechnologies)"
},
{
"input": "Translate into first-order logic: Daniel studied bioengineering during his undergraduate at Rice University.",
"output": " StudiedBioengineering(daniel, riceUniversity)"
},
{
"input": "Translate into first-order logic: Daniel’s older sister works at Meta as a technical sourcer.",
"output": " WorksAtMeta(danielsOlderSister) ∧ TechnicalSourcer(danielsOlderSister)"
},
{
"input": "Translate into first-order logic: Daniel’s dad and older sister both graduated from Stanford University.",
"output": " GraduatedFromStanfordUniversity(danielsOlderSister) ∧ GraduatedFromStanfordUniversity(danielsDad)"
},
{
"input": "Translate into first-order logic: Daniel’s dad is a doctor practicing internal medicine at a veteran’s hospital in Minneapolis",
"output": " DoctorPracticingInternalMedicine(danielsDad, veteransHospitalInMinneapolis)"
},
{
"input": "Translate into first-order logic: All commerical aircraft are produced by either Boeing or Airbus.",
"output": "∀x (CommercialAircraft(x) → ProducedBy(x, boeing) ⊕ ProducedBy(x, airbus))"
},
{
"input": "Translate into first-order logic: All American Airlines jets are commerical aircraft.",
"output": "∀x (AmericanAirlinesAircraft(x) → CommercialAircraft(x))"
},
{
"input": "Translate into first-order logic: Airbus made more in revenue than Boeing last year.",
"output": "MoreinRevenue(airbus, boeing)"
},
{
"input": "Translate into first-order logic: All commerical aircraft are produced by either Boeing or Airbus.",
"output": "∀x (CommercialAircraft(x) → ProducedBy(x, boeing) ⊕ ProducedBy(x, airbus))"
},
{
"input": "Translate into first-order logic: All American Airlines jets are commerical aircraft.",
"output": "∀x (AmericanAirlinesAircraft(x) → CommercialAircraft(x))"
},
{
"input": "Translate into first-order logic: Airbus made more in revenue than Boeing last year.",
"output": "MoreinRevenue(airbus, boeing)"
},
{
"input": "Translate into first-order logic: All commerical aircraft are produced by either Boeing or Airbus.",
"output": "∀x (CommercialAircraft(x) → ProducedBy(x, boeing) ⊕ ProducedBy(x, airbus))"
},
{
"input": "Translate into first-order logic: All American Airlines jets are commerical aircraft.",
"output": "∀x (AmericanAirlinesAircraft(x) → CommercialAircraft(x))"
},
{
"input": "Translate into first-order logic: Airbus made more in revenue than Boeing last year.",
"output": "MoreinRevenue(airbus, boeing)"
},
{
"input": "Translate into first-order logic: All commerical aircraft are produced by either Boeing or Airbus.",
"output": "∀x (CommercialAircraft(x) → ProducedBy(x, boeing) ⊕ ProducedBy(x, airbus))"
},
{
"input": "Translate into first-order logic: All American Airlines jets are commerical aircraft.",
"output": "∀x (AmericanAirlinesAircraft(x) → CommercialAircraft(x))"
},
{
"input": "Translate into first-order logic: Airbus made more in revenue than Boeing last year.",
"output": "MoreinRevenue(airbus, boeing)"
},
{
"input": "Translate into first-order logic: Luzon is an island in the Philippines.",
"output": "Island(luzon) ∧ In(luzon, philippines)"
},
{
"input": "Translate into first-order logic: In December 1999, an earthquake struck Luzon.",
"output": "∃x (Earthquake(x) ∧ StruckIn(x, december1999) ∧ Struck(x, luzon))"
},
{
"input": "Translate into first-order logic: People died in the December 1999 earthquake in Luzon.",
"output": "∃x (Earthquake(x) ∧ StruckIn(x, december1999) ∧ Struck(x, luzon) ∧ Killed(x))"
},
{
"input": "Translate into first-order logic: Luzon is an island in the Philippines.",
"output": "Island(luzon) ∧ In(luzon, philippines)"
},
{
"input": "Translate into first-order logic: In December 1999, an earthquake struck Luzon.",
"output": "∃x (Earthquake(x) ∧ StruckIn(x, december1999) ∧ Struck(x, luzon))"
},
{
"input": "Translate into first-order logic: People died in the December 1999 earthquake in Luzon.",
"output": "∃x (Earthquake(x) ∧ StruckIn(x, december1999) ∧ Struck(x, luzon) ∧ Killed(x))"
},
{
"input": "Translate into first-order logic: Luzon is an island in the Philippines.",
"output": "Island(luzon) ∧ In(luzon, philippines)"
},
{
"input": "Translate into first-order logic: In December 1999, an earthquake struck Luzon.",
"output": "∃x (Earthquake(x) ∧ StruckIn(x, december1999) ∧ Struck(x, luzon))"
},
{
"input": "Translate into first-order logic: People died in the December 1999 earthquake in Luzon.",
"output": "∃x (Earthquake(x) ∧ StruckIn(x, december1999) ∧ Struck(x, luzon) ∧ Killed(x))"
},
{
"input": "Translate into first-order logic: People either invest in the public stock market regularly or enjoy gambling regularly.",
"output": "∀x (Invests(x) ∨ Gambling(x))"
},
{
"input": "Translate into first-order logic: If people invest in the public stock market regularly, then they read the Wall Street Journal and other newspapers regularly to keep updated on financial metrics.",
"output": "∀x (Invests(x) → Newspapers(x))"
},
{
"input": "Translate into first-order logic: All people who enjoy gambling regularly spend a lot of money at casinos and other betting games.",
"output": "∀x (Gambling(x) → Casinos(x))"
},
{
"input": "Translate into first-order logic: People who spend a lot of money at casinos and other betting games visit the Las Vegas Strip regularly.",
"output": "∀x (Casinos(x) → LasVegas(x))"
},
{
"input": "Translate into first-order logic: People who spend a lot of money at casinos and other betting games have a lot of disposable income to spend.",
"output": "∀x (Casinos(x) → DisposableIncome(x))"
},
{
"input": "Translate into first-order logic: If Matt invests in the public stock market regularly, then Matt neither has a lot of disposable income to spend nor invests in the public stock market regularly.",
"output": "Invests(matt) → ¬DisposableIncome(matt) ∧ ¬Invests(matt)"
},
{
"input": "Translate into first-order logic: People either invest in the public stock market regularly or enjoy gambling regularly.",
"output": "∀x (Invests(x) ∨ Gambling(x))"
},
{
"input": "Translate into first-order logic: If people invest in the public stock market regularly, then they read the Wall Street Journal and other newspapers regularly to keep updated on financial metrics.",
"output": "∀x (Invests(x) → Newspapers(x))"
},
{
"input": "Translate into first-order logic: All people who enjoy gambling regularly spend a lot of money at casinos and other betting games.",
"output": "∀x (Gambling(x) → Casinos(x))"
},
{
"input": "Translate into first-order logic: People who spend a lot of money at casinos and other betting games visit the Las Vegas Strip regularly.",
"output": "∀x (Casinos(x) → LasVegas(x))"
},
{
"input": "Translate into first-order logic: People who spend a lot of money at casinos and other betting games have a lot of disposable income to spend.",
"output": "∀x (Casinos(x) → DisposableIncome(x))"
},
{
"input": "Translate into first-order logic: If Matt invests in the public stock market regularly, then Matt neither has a lot of disposable income to spend nor invests in the public stock market regularly.",
"output": "Invests(matt) → ¬DisposableIncome(matt) ∧ ¬Invests(matt)"
},
{
"input": "Translate into first-order logic: People either invest in the public stock market regularly or enjoy gambling regularly.",
"output": "∀x (Invests(x) ∨ Gambling(x))"
},
{
"input": "Translate into first-order logic: If people invest in the public stock market regularly, then they read the Wall Street Journal and other newspapers regularly to keep updated on financial metrics.",
"output": "∀x (Invests(x) → Newspapers(x))"
},
{
"input": "Translate into first-order logic: All people who enjoy gambling regularly spend a lot of money at casinos and other betting games.",
"output": "∀x (Gambling(x) → Casinos(x))"
},
{
"input": "Translate into first-order logic: People who spend a lot of money at casinos and other betting games visit the Las Vegas Strip regularly.",
"output": "∀x (Casinos(x) → LasVegas(x))"
},
{
"input": "Translate into first-order logic: People who spend a lot of money at casinos and other betting games have a lot of disposable income to spend.",
"output": "∀x (Casinos(x) → DisposableIncome(x))"
},
{
"input": "Translate into first-order logic: If Matt invests in the public stock market regularly, then Matt neither has a lot of disposable income to spend nor invests in the public stock market regularly.",
"output": "Invests(matt) → ¬DisposableIncome(matt) ∧ ¬Invests(matt)"
},
{
"input": "Translate into first-order logic: All students learning piano can strike the right notes.",
"output": "∀x (Student(x) ∧ LearningPiano(x) → StrikeRightNotes(x))"
},
{
"input": "Translate into first-order logic: All students who can strike the right note can get the rhythms right.",
"output": "∀x (Student(x) ∧ StrikeRightNotes(x) → GetRhythmRight(x))"
},
{
"input": "Translate into first-order logic: If a student can get the rhythms right, he will start working on coordination between the left and the right hands.",
"output": "∀x (Student(x) ∧ GetRhythmRight(x) → StartCoordination(x))"
},
{
"input": "Translate into first-order logic: Some students who start working on coordination between the left and the right hands become good at it. The other students find it challenging.",
"output": "∀x (Student(x) ∧ StartCoordination(x) → GoodAtCoordination(x) ⊕ FindCoordinationChallenging(x))"
},
{
"input": "Translate into first-order logic: If John can strike the right notes, get the rhythms right and is good at coordination between right and left hands, then he puts emotions into his playing.",
"output": "StrikeRightNotes(john) ∧ GetRhythmRight(john) ∧ GoodAtCoordination(john) → PutEmotion(john)"
},
{
"input": "Translate into first-order logic: John is a student learning piano.",
"output": "Student(john) ∧ LearningPiano(john)"
},
{
"input": "Translate into first-order logic: John does not find coordination between the left and the right hands challenging.",
"output": "¬FindCoordinationChallenging(john)"
},
{
"input": "Translate into first-order logic: All students learning piano can strike the right notes.",
"output": "∀x (Student(x) ∧ LearningPiano(x) → StrikeRightNotes(x))"
},
{
"input": "Translate into first-order logic: All students who can strike the right note can get the rhythms right.",
"output": "∀x (Student(x) ∧ StrikeRightNotes(x) → GetRhythmRight(x))"
},
{
"input": "Translate into first-order logic: If a student can get the rhythms right, he will start working on coordination between the left and the right hands.",
"output": "∀x (Student(x) ∧ GetRhythmRight(x) → StartCoordination(x))"
},
{
"input": "Translate into first-order logic: Some students who start working on coordination between the left and the right hands become good at it. The other students find it challenging.",
"output": "∀x (Student(x) ∧ StartCoordination(x) → GoodAtCoordination(x) ⊕ FindCoordinationChallenging(x))"
},
{
"input": "Translate into first-order logic: If John can strike the right notes, get the rhythms right and is good at coordination between right and left hands, then he puts emotions into his playing.",
"output": "StrikeRightNotes(john) ∧ GetRhythmRight(john) ∧ GoodAtCoordination(john) → PutEmotion(john)"
},
{
"input": "Translate into first-order logic: John is a student learning piano.",
"output": "Student(john) ∧ LearningPiano(john)"
},
{
"input": "Translate into first-order logic: John does not find coordination between the left and the right hands challenging.",
"output": "¬FindCoordinationChallenging(john)"
},
{
"input": "Translate into first-order logic: Barbara Ann Marshall is a former swimmer and former world record-holder.",
"output": "FormerSwimmer(barbaraannmarshall) ∧ FormerWorldRecordHolder(barbaraannmarshall)"
},
{
"input": "Translate into first-order logic: Barbara Ann Marshall participated in the 1972 Summer Olympics.",
"output": "ParticipatedIn(barbaraannmarshall, summer1972olympics)"
},
{
"input": "Translate into first-order logic: Barbara Ann Marshall's home country is the United States.",
"output": "HomeCountry(barbaraannmarshall, unitedstates)"
},
{
"input": "Translate into first-order logic: All people who compete in the 1972 Summer Olympics represent their home country.",
"output": "∀x ∃y (ParticipatedIn(x, summer1972olympics) ∧ HomeCountry(x, y) → Represented(x, y))"
},
{
"input": "Translate into first-order logic: Barbara Ann Marshall participated in the preliminary heat in the freestyle relay.",
"output": "ParticipatedIn(barbaraannmarshall, preliminaryheatfreestylerelay)"
},
{
"input": "Translate into first-order logic: Barbara Ann Marshall did not participate in the event final of the 1972 Summer Olympics freestyle relay.",
"output": "¬ParticipatedIn(barbaraannmarshall, finalheatfreestylerelay)"
},
{
"input": "Translate into first-order logic: Only relay swimmers who participated in the event final received medals.",
"output": "∀x ((RelaySwimmer(x) ∧ ¬ParticipatedIn(x, finalheatfreerelay)) ↔ ¬Recieved(x, medal)))"
},
{
"input": "Translate into first-order logic: Barbara Ann Marshall is a former swimmer and former world record-holder.",
"output": "FormerSwimmer(barbaraannmarshall) ∧ FormerWorldRecordHolder(barbaraannmarshall)"
},
{
"input": "Translate into first-order logic: Barbara Ann Marshall participated in the 1972 Summer Olympics.",
"output": "ParticipatedIn(barbaraannmarshall, summer1972olympics)"
},
{
"input": "Translate into first-order logic: Barbara Ann Marshall's home country is the United States.",
"output": "HomeCountry(barbaraannmarshall, unitedstates)"
},
{
"input": "Translate into first-order logic: All people who compete in the 1972 Summer Olympics represent their home country.",
"output": "∀x ∃y (ParticipatedIn(x, summer1972olympics) ∧ HomeCountry(x, y) → Represented(x, y))"
},
{
"input": "Translate into first-order logic: Barbara Ann Marshall participated in the preliminary heat in the freestyle relay.",
"output": "ParticipatedIn(barbaraannmarshall, preliminaryheatfreestylerelay)"
},
{
"input": "Translate into first-order logic: Barbara Ann Marshall did not participate in the event final of the 1972 Summer Olympics freestyle relay.",
"output": "¬ParticipatedIn(barbaraannmarshall, finalheatfreestylerelay)"
},
{
"input": "Translate into first-order logic: Only relay swimmers who participated in the event final received medals.",
"output": "∀x ((RelaySwimmer(x) ∧ ¬ParticipatedIn(x, finalheatfreerelay)) ↔ ¬Recieved(x, medal)))"
},
{
"input": "Translate into first-order logic: A game is played with three stages: red stage, yellow stage, and green stage.",
"output": "∃x (Player(x))"
},
{
"input": "Translate into first-order logic: Each player begins at the red stage.",
"output": "∀x (Player(x) → StartRed(x))"
},
{
"input": "Translate into first-order logic: All players must reach the yellow stage before they can reach the green stage.",
"output": "∀x (Player(x) → YellowToGreen(x))"
},
{
"input": "Translate into first-order logic: The yellow stage comes after the red stage.",
"output": "∀x (Player(x) → RedToYellow(x))"
},
{
"input": "Translate into first-order logic: All players must proceed one stage at a time.",
"output": "∀x (Player(x) → ¬RedToGreen(x))"
},
{
"input": "Translate into first-order logic: A game is played with three stages: red stage, yellow stage, and green stage.",
"output": "∃x (Player(x))"
},
{
"input": "Translate into first-order logic: Each player begins at the red stage.",
"output": "∀x (Player(x) → StartRed(x))"
},
{
"input": "Translate into first-order logic: All players must reach the yellow stage before they can reach the green stage.",
"output": "∀x (Player(x) → YellowToGreen(x))"
},
{
"input": "Translate into first-order logic: The yellow stage comes after the red stage.",
"output": "∀x (Player(x) → RedToYellow(x))"
},
{
"input": "Translate into first-order logic: All players must proceed one stage at a time.",
"output": "∀x (Player(x) → ¬RedToGreen(x))"
},
{
"input": "Translate into first-order logic: A game is played with three stages: red stage, yellow stage, and green stage.",
"output": "∃x (Player(x))"
},
{
"input": "Translate into first-order logic: Each player begins at the red stage.",
"output": "∀x (Player(x) → StartRed(x))"
},
{
"input": "Translate into first-order logic: All players must reach the yellow stage before they can reach the green stage.",
"output": "∀x (Player(x) → YellowToGreen(x))"
},
{
"input": "Translate into first-order logic: The yellow stage comes after the red stage.",
"output": "∀x (Player(x) → RedToYellow(x))"
},
{
"input": "Translate into first-order logic: All players must proceed one stage at a time.",
"output": "∀x (Player(x) → ¬RedToGreen(x))"
},
{
"input": "Translate into first-order logic: People either value physical touch as an especially important love language or value words of affirmation as an especially important love language.",
"output": "∀x (Physical(x) ∨ Words(x))"
},
{
"input": "Translate into first-order logic: If a person values physical touch as an especially important love language, then they are good with pets.",
"output": "∀x (Physical(x) → GoodWithPets(x))"
},
{
"input": "Translate into first-order logic: No people that are good with pets are scared of animals.",
"output": "∀x (GoodWithPets(x) → ¬ScaredOfAnimals(x))"
},
{
"input": "Translate into first-order logic: People are either scared of animals or love animals.",
"output": "∀x (ScaredOfAnimals(x) ∨ LoveAnimals(x))"
},
{
"input": "Translate into first-order logic: Adam is either a person who values physical touch as an especially important love language or a person who loves animals.",
"output": "Physical(adam) ⊕ LoveAnimals(adam)"
},
{
"input": "Translate into first-order logic: People either value physical touch as an especially important love language or value words of affirmation as an especially important love language.",
"output": "∀x (Physical(x) ∨ Words(x))"
},
{
"input": "Translate into first-order logic: If a person values physical touch as an especially important love language, then they are good with pets.",
"output": "∀x (Physical(x) → GoodWithPets(x))"
},
{
"input": "Translate into first-order logic: No people that are good with pets are scared of animals.",
"output": "∀x (GoodWithPets(x) → ¬ScaredOfAnimals(x))"
},
{
"input": "Translate into first-order logic: People are either scared of animals or love animals.",
"output": "∀x (ScaredOfAnimals(x) ∨ LoveAnimals(x))"
},
{
"input": "Translate into first-order logic: Adam is either a person who values physical touch as an especially important love language or a person who loves animals.",
"output": "Physical(adam) ⊕ LoveAnimals(adam)"
},
{
"input": "Translate into first-order logic: People either value physical touch as an especially important love language or value words of affirmation as an especially important love language.",
"output": "∀x (Physical(x) ∨ Words(x))"
},
{
"input": "Translate into first-order logic: If a person values physical touch as an especially important love language, then they are good with pets.",
"output": "∀x (Physical(x) → GoodWithPets(x))"
},
{
"input": "Translate into first-order logic: No people that are good with pets are scared of animals.",
"output": "∀x (GoodWithPets(x) → ¬ScaredOfAnimals(x))"
},
{
"input": "Translate into first-order logic: People are either scared of animals or love animals.",
"output": "∀x (ScaredOfAnimals(x) ∨ LoveAnimals(x))"
},
{
"input": "Translate into first-order logic: Adam is either a person who values physical touch as an especially important love language or a person who loves animals.",
"output": "Physical(adam) ⊕ LoveAnimals(adam)"
},
{
"input": "Translate into first-order logic: People either value physical touch as an especially important love language or value words of affirmation as an especially important love language.",
"output": "∀x (Physical(x) ∨ Words(x))"
},
{
"input": "Translate into first-order logic: If a person values physical touch as an especially important love language, then they are good with pets.",
"output": "∀x (Physical(x) → GoodWithPets(x))"
},
{
"input": "Translate into first-order logic: No people that are good with pets are scared of animals.",
"output": "∀x (GoodWithPets(x) → ¬ScaredOfAnimals(x))"
},
{
"input": "Translate into first-order logic: People are either scared of animals or love animals.",
"output": "∀x (ScaredOfAnimals(x) ∨ LoveAnimals(x))"
},
{
"input": "Translate into first-order logic: Adam is either a person who values physical touch as an especially important love language or a person who loves animals.",
"output": "Physical(adam) ⊕ LoveAnimals(adam)"
},
{
"input": "Translate into first-order logic: People either value physical touch as an especially important love language or value words of affirmation as an especially important love language.",
"output": "∀x (Physical(x) ∨ Words(x))"
},
{
"input": "Translate into first-order logic: If a person values physical touch as an especially important love language, then they are good with pets.",
"output": "∀x (Physical(x) → GoodWithPets(x))"
},
{
"input": "Translate into first-order logic: No people that are good with pets are scared of animals.",
"output": "∀x (GoodWithPets(x) → ¬ScaredOfAnimals(x))"
},
{
"input": "Translate into first-order logic: People are either scared of animals or love animals.",
"output": "∀x (ScaredOfAnimals(x) ∨ LoveAnimals(x))"
},
{
"input": "Translate into first-order logic: Adam is either a person who values physical touch as an especially important love language or a person who loves animals.",
"output": "Physical(adam) ⊕ LoveAnimals(adam)"
},
{
"input": "Translate into first-order logic: All birds have wings.",
"output": "∀x (Bird(x) → Winged(x))"
},
{
"input": "Translate into first-order logic: No animal with wings is a reptile.",
"output": "∀x (Winged(x) → ¬Reptile(x))"
},
{
"input": "Translate into first-order logic: Some animals that fly are birds.",
"output": "∃x (Fly(x) ∧ Bird(x))"
},
{
"input": "Translate into first-order logic: If something is an iguana, then it is a reptile.",
"output": "∀x (Iguana(x) → Reptile(x))"
},
{
"input": "Translate into first-order logic: John is neither an iguana nor a bird.",
"output": "¬Iguana(john) ⊕ Bird(john)"
},
{
"input": "Translate into first-order logic: All birds have wings.",
"output": "∀x (Bird(x) → Winged(x))"
},
{
"input": "Translate into first-order logic: No animal with wings is a reptile.",
"output": "∀x (Winged(x) → ¬Reptile(x))"
},
{
"input": "Translate into first-order logic: Some animals that fly are birds.",
"output": "∃x (Fly(x) ∧ Bird(x))"
},
{
"input": "Translate into first-order logic: If something is an iguana, then it is a reptile.",
"output": "∀x (Iguana(x) → Reptile(x))"
},
{
"input": "Translate into first-order logic: John is neither an iguana nor a bird.",
"output": "¬Iguana(john) ⊕ Bird(john)"
},
{
"input": "Translate into first-order logic: All birds have wings.",
"output": "∀x (Bird(x) → Winged(x))"
},
{
"input": "Translate into first-order logic: No animal with wings is a reptile.",
"output": "∀x (Winged(x) → ¬Reptile(x))"
},
{
"input": "Translate into first-order logic: Some animals that fly are birds.",
"output": "∃x (Fly(x) ∧ Bird(x))"
},
{
"input": "Translate into first-order logic: If something is an iguana, then it is a reptile.",
"output": "∀x (Iguana(x) → Reptile(x))"
},
{
"input": "Translate into first-order logic: John is neither an iguana nor a bird.",
"output": "¬Iguana(john) ⊕ Bird(john)"
},
{
"input": "Translate into first-order logic: EndGame is a movie released in 2006.",
"output": "Movie(endGame) ∧ Released(endGame, year2006)"
},
{
"input": "Translate into first-order logic: EndGame was set in Washington.",
"output": "Set(endGame, washington)"
},
{
"input": "Translate into first-order logic: EndGame was filmed outside of Washington.",
"output": "FilmedOutside(endGame, washington)"
},
{
"input": "Translate into first-order logic: Some movies are filmed in New York.",
"output": "∃x (FilmedIn(x, newYork))"
},
{
"input": "Translate into first-order logic: Andy Chang directed EndGame.",
"output": "Directed(andyChang, endGame)"
},
{
"input": "Translate into first-order logic: Andy Chang is from Hong Kong.",
"output": "From(andyChang, hongKong)"
},
{
"input": "Translate into first-order logic: EndGame is a movie released in 2006.",
"output": "Movie(endGame) ∧ Released(endGame, year2006)"
},
{
"input": "Translate into first-order logic: EndGame was set in Washington.",
"output": "Set(endGame, washington)"
},
{
"input": "Translate into first-order logic: EndGame was filmed outside of Washington.",
"output": "FilmedOutside(endGame, washington)"
},
{
"input": "Translate into first-order logic: Some movies are filmed in New York.",
"output": "∃x (FilmedIn(x, newYork))"
},
{
"input": "Translate into first-order logic: Andy Chang directed EndGame.",
"output": "Directed(andyChang, endGame)"
},
{
"input": "Translate into first-order logic: Andy Chang is from Hong Kong.",
"output": "From(andyChang, hongKong)"
},
{
"input": "Translate into first-order logic: EndGame is a movie released in 2006.",
"output": "Movie(endGame) ∧ Released(endGame, year2006)"
},
{
"input": "Translate into first-order logic: EndGame was set in Washington.",
"output": "Set(endGame, washington)"
},
{
"input": "Translate into first-order logic: EndGame was filmed outside of Washington.",
"output": "FilmedOutside(endGame, washington)"
},
{
"input": "Translate into first-order logic: Some movies are filmed in New York.",
"output": "∃x (FilmedIn(x, newYork))"
},
{
"input": "Translate into first-order logic: Andy Chang directed EndGame.",
"output": "Directed(andyChang, endGame)"
},
{
"input": "Translate into first-order logic: Andy Chang is from Hong Kong.",
"output": "From(andyChang, hongKong)"
},
{
"input": "Translate into first-order logic: Six, seven and eight are real numbers.",
"output": "RealNum(six) ∧ RealNum(seven) ∧ RealNum(eight)"
},
{
"input": "Translate into first-order logic: If a real number equals another real number adding one, the first number is larger.",
"output": "∀x ∀y (RealNum(x) ∧ RealNum(y) ∧ EqualAddOne(x, y) → Larger(x, y))"
},
{
"input": "Translate into first-order logic: If the number x is larger than number y, then y is not larger than x.",
"output": "∀x ∀y (Larger(x, y) ↔ ¬Larger(y, x))"
},
{
"input": "Translate into first-order logic: Seven equals six plus one.",
"output": "EqualAddOne(seven, six)"
},
{
"input": "Translate into first-order logic: Eight equals seven plus one.",
"output": "EqualAddOne(eight, seven)"
},
{
"input": "Translate into first-order logic: Two is positive.",
"output": "Positive(two)"
},
{
"input": "Translate into first-order logic: If a number is positive, then the double of it is also positive.",
"output": "∀x ∀y ((Positive(x) ∧ EqualDouble(y, x)) → Positive(y))"
},
{
"input": "Translate into first-order logic: Eight is the double of four.",
"output": "EqualDouble(eight, four)"
},
{
"input": "Translate into first-order logic: Four is the double of two.",
"output": "EqualDouble(four, two)"
},
{
"input": "Translate into first-order logic: Six, seven and eight are real numbers.",
"output": "RealNum(six) ∧ RealNum(seven) ∧ RealNum(eight)"
},
{
"input": "Translate into first-order logic: If a real number equals another real number adding one, the first number is larger.",
"output": "∀x ∀y (RealNum(x) ∧ RealNum(y) ∧ EqualAddOne(x, y) → Larger(x, y))"
},
{
"input": "Translate into first-order logic: If the number x is larger than number y, then y is not larger than x.",
"output": "∀x ∀y (Larger(x, y) ↔ ¬Larger(y, x))"
},
{
"input": "Translate into first-order logic: Seven equals six plus one.",
"output": "EqualAddOne(seven, six)"
},
{
"input": "Translate into first-order logic: Eight equals seven plus one.",
"output": "EqualAddOne(eight, seven)"
},
{
"input": "Translate into first-order logic: Two is positive.",
"output": "Positive(two)"
},
{
"input": "Translate into first-order logic: If a number is positive, then the double of it is also positive.",
"output": "∀x ∀y ((Positive(x) ∧ EqualDouble(y, x)) → Positive(y))"
},
{
"input": "Translate into first-order logic: Eight is the double of four.",
"output": "EqualDouble(eight, four)"
},
{
"input": "Translate into first-order logic: Four is the double of two.",
"output": "EqualDouble(four, two)"
},
{
"input": "Translate into first-order logic: Six, seven and eight are real numbers.",
"output": "RealNum(six) ∧ RealNum(seven) ∧ RealNum(eight)"
},
{
"input": "Translate into first-order logic: If a real number equals another real number adding one, the first number is larger.",
"output": "∀x ∀y (RealNum(x) ∧ RealNum(y) ∧ EqualAddOne(x, y) → Larger(x, y))"
},
{
"input": "Translate into first-order logic: If the number x is larger than number y, then y is not larger than x.",
"output": "∀x ∀y (Larger(x, y) ↔ ¬Larger(y, x))"
},
{
"input": "Translate into first-order logic: Seven equals six plus one.",
"output": "EqualAddOne(seven, six)"
},
{
"input": "Translate into first-order logic: Eight equals seven plus one.",
"output": "EqualAddOne(eight, seven)"
},
{
"input": "Translate into first-order logic: Two is positive.",
"output": "Positive(two)"
},
{
"input": "Translate into first-order logic: If a number is positive, then the double of it is also positive.",
"output": "∀x ∀y ((Positive(x) ∧ EqualDouble(y, x)) → Positive(y))"
},
{
"input": "Translate into first-order logic: Eight is the double of four.",
"output": "EqualDouble(eight, four)"
},
{
"input": "Translate into first-order logic: Four is the double of two.",
"output": "EqualDouble(four, two)"
},
{
"input": "Translate into first-order logic: A dog never tells the truth.",
"output": "∀x (Dog(x) → NeverTellsTruth(x))"
},
{
"input": "Translate into first-order logic: Some poker players are dogs.",
"output": "∃x (PokerPlayer(x) ∧ Dog(x))"
},
{
"input": "Translate into first-order logic: All Asians are human.",
"output": "∀x ( Asian(x)→  Human(x))"
},
{
"input": "Translate into first-order logic: All Chinese are Asian.",
"output": "∀x ( Chinese(x)→  Asian(x))"
},
{
"input": "Translate into first-order logic: A man is either Chinese or British.",
"output": "∀x ( Chinese(x) ∨  British(x))"
},
{
"input": "Translate into first-order logic: All British are European.",
"output": "∀x ( British(x)→  European(x))"
},
{
"input": "Translate into first-order logic: All Spanish are European.",
"output": "∀x ( Spanish(x)→  European(x))"
},
{
"input": "Translate into first-order logic: No Indian is European.",
"output": "∀x ( Indian(x)→ ¬ European(x))"
},
{
"input": "Translate into first-order logic: Jessee is either both an Indian and a human, or neither an Indian nor a human.",
"output": "( Indian(jesse) ∧ Human(jesse)) ⊕ (¬ Indian(jesse) ∧ ¬ Human(jesse))"
},
{
"input": "Translate into first-order logic: All Asians are human.",
"output": "∀x ( Asian(x)→  Human(x))"
},
{
"input": "Translate into first-order logic: All Chinese are Asian.",
"output": "∀x ( Chinese(x)→  Asian(x))"
},
{
"input": "Translate into first-order logic: A man is either Chinese or British.",
"output": "∀x ( Chinese(x) ∨  British(x))"
},
{
"input": "Translate into first-order logic: All British are European.",
"output": "∀x ( British(x)→  European(x))"
},
{
"input": "Translate into first-order logic: All Spanish are European.",
"output": "∀x ( Spanish(x)→  European(x))"
},
{
"input": "Translate into first-order logic: No Indian is European.",
"output": "∀x ( Indian(x)→ ¬ European(x))"
},
{
"input": "Translate into first-order logic: Jessee is either both an Indian and a human, or neither an Indian nor a human.",
"output": "( Indian(jesse) ∧ Human(jesse)) ⊕ (¬ Indian(jesse) ∧ ¬ Human(jesse))"
},
{
"input": "Translate into first-order logic: All Asians are human.",
"output": "∀x ( Asian(x)→  Human(x))"
},
{
"input": "Translate into first-order logic: All Chinese are Asian.",
"output": "∀x ( Chinese(x)→  Asian(x))"
},
{
"input": "Translate into first-order logic: A man is either Chinese or British.",
"output": "∀x ( Chinese(x) ∨  British(x))"
},
{
"input": "Translate into first-order logic: All British are European.",
"output": "∀x ( British(x)→  European(x))"
},
{
"input": "Translate into first-order logic: All Spanish are European.",
"output": "∀x ( Spanish(x)→  European(x))"
},
{
"input": "Translate into first-order logic: No Indian is European.",
"output": "∀x ( Indian(x)→ ¬ European(x))"
},
{
"input": "Translate into first-order logic: Jessee is either both an Indian and a human, or neither an Indian nor a human.",
"output": "( Indian(jesse) ∧ Human(jesse)) ⊕ (¬ Indian(jesse) ∧ ¬ Human(jesse))"
},
{
"input": "Translate into first-order logic: No people who never admit a mistake are good teachers.",
"output": "∀x (NeverAdmitMistakes(x) → ¬GoodTeacher(x))"
},
{
"input": "Translate into first-order logic: Some well-informed people are people who never admit a mistake.",
"output": "∃x (WellInformed(x) ∧ NeverAdmitMistakes(x))"
},
{
"input": "Translate into first-order logic: Philatelic literature is divided into the following categories: Stamp catalogues, Periodicals, Auction catalogues, Books, Bibliographies, and Background Material",
"output": "∀x (PhilatelicLit(x) → (Stamp(x) ∨ Periodical(x) ∨ Auction(x) ∨ Book(x) ∨ Bibliography(x) ∨ Background(x)))"
},
{
"input": "Translate into first-order logic: Mort is not a Stamp catalogue.",
"output": "¬Stamp(mort)"
},
{
"input": "Translate into first-order logic: Mort is not a periodical, auction catalogue, bibliography, or background material.",
"output": "¬(Periodical(mort) ∨ Auction(mort) ∨ Bibliography(mort) ∨ Background(mort))"
},
{
"input": "Translate into first-order logic: Mort is a piece of Philatelic literature.",
"output": "PhilatelicLit(mort)"
},
{
"input": "Translate into first-order logic: Philatelic literature is divided into the following categories: Stamp catalogues, Periodicals, Auction catalogues, Books, Bibliographies, and Background Material",
"output": "∀x (PhilatelicLit(x) → (Stamp(x) ∨ Periodical(x) ∨ Auction(x) ∨ Book(x) ∨ Bibliography(x) ∨ Background(x)))"
},
{
"input": "Translate into first-order logic: Mort is not a Stamp catalogue.",
"output": "¬Stamp(mort)"
},
{
"input": "Translate into first-order logic: Mort is not a periodical, auction catalogue, bibliography, or background material.",
"output": "¬(Periodical(mort) ∨ Auction(mort) ∨ Bibliography(mort) ∨ Background(mort))"
},
{
"input": "Translate into first-order logic: Mort is a piece of Philatelic literature.",
"output": "PhilatelicLit(mort)"
},
{
"input": "Translate into first-order logic: Philatelic literature is divided into the following categories: Stamp catalogues, Periodicals, Auction catalogues, Books, Bibliographies, and Background Material",
"output": "∀x (PhilatelicLit(x) → (Stamp(x) ∨ Periodical(x) ∨ Auction(x) ∨ Book(x) ∨ Bibliography(x) ∨ Background(x)))"
},
{
"input": "Translate into first-order logic: Mort is not a Stamp catalogue.",
"output": "¬Stamp(mort)"
},
{
"input": "Translate into first-order logic: Mort is not a periodical, auction catalogue, bibliography, or background material.",
"output": "¬(Periodical(mort) ∨ Auction(mort) ∨ Bibliography(mort) ∨ Background(mort))"
},
{
"input": "Translate into first-order logic: Mort is a piece of Philatelic literature.",
"output": "PhilatelicLit(mort)"
},
{
"input": "Translate into first-order logic: Adventures of Rusty is a drama film and children's film.",
"output": "DramaFilm(adventuresofrusty) ∧ ChildrensFilm(adventuresofrusty)"
},
{
"input": "Translate into first-order logic: Columbia Pictures produced Adventures of Rusty",
"output": "Produced(columbiapictures, adventuresofrusty)"
},
{
"input": "Translate into first-order logic: Tintin was produced by Paramount.",
"output": "Produced(paramount, tintin)"
},
{
"input": "Translate into first-order logic: Tintin is an adventure film.",
"output": "AdventureFilm(tintin)"
},
{
"input": "Translate into first-order logic: Adventures of Rusty is a drama film and children's film.",
"output": "DramaFilm(adventuresofrusty) ∧ ChildrensFilm(adventuresofrusty)"
},
{
"input": "Translate into first-order logic: Columbia Pictures produced Adventures of Rusty",
"output": "Produced(columbiapictures, adventuresofrusty)"
},
{
"input": "Translate into first-order logic: Tintin was produced by Paramount.",
"output": "Produced(paramount, tintin)"
},
{
"input": "Translate into first-order logic: Tintin is an adventure film.",
"output": "AdventureFilm(tintin)"
},
{
"input": "Translate into first-order logic: Adventures of Rusty is a drama film and children's film.",
"output": "DramaFilm(adventuresofrusty) ∧ ChildrensFilm(adventuresofrusty)"
},
{
"input": "Translate into first-order logic: Columbia Pictures produced Adventures of Rusty",
"output": "Produced(columbiapictures, adventuresofrusty)"
},
{
"input": "Translate into first-order logic: Tintin was produced by Paramount.",
"output": "Produced(paramount, tintin)"
},
{
"input": "Translate into first-order logic: Tintin is an adventure film.",
"output": "AdventureFilm(tintin)"
},
{
"input": "Translate into first-order logic: Adventures of Rusty is a drama film and children's film.",
"output": "DramaFilm(adventuresofrusty) ∧ ChildrensFilm(adventuresofrusty)"
},
{
"input": "Translate into first-order logic: Columbia Pictures produced Adventures of Rusty",
"output": "Produced(columbiapictures, adventuresofrusty)"
},
{
"input": "Translate into first-order logic: Tintin was produced by Paramount.",
"output": "Produced(paramount, tintin)"
},
{
"input": "Translate into first-order logic: Tintin is an adventure film.",
"output": "AdventureFilm(tintin)"
},
{
"input": "Translate into first-order logic: Deng Xiaoping served as the paramount leader of the People's Republic of China (PRC).",
"output": "ParamountLeaderOf(dengxiaoping, prc)"
},
{
"input": "Translate into first-order logic: Deng Xiaoping was praised for his reaffirmation of the reform program in his Southern Tour of 1992 as well as the reversion of Hong Kong to Chinese control in 1997 and the return of Macau in 1999.",
"output": "PraisedFor(dengxiaoping, reaffirmationofreformprogram) ∧ PraisedFor(dengxiaoping, reversionofhongkong) ∧ PraisedFor(dengxiaoping, returnofmacau)"
},
{
"input": "Translate into first-order logic: As the party's Secretary-General under Mao and Vice Premier in he 1950s, Deng Xiaoping presided over the Anti-Rightist Campaign launched by Mao.",
"output": "PartysSecretaryGeneral(dengxiaoping) ∧ Under(dengxiaoping, mao) ∧ VicePremier(dengxiaoping) ∧ PresidedOver(dengxiaoping, antirightistcampaign) ∧ LaunchedBy(antirightistcampaign, mao)"
},
{
"input": "Translate into first-order logic: Deng Xiaoping became instrumental in China's economic reconstruction following the disastrous Great Leap Forward (1958–1960).",
"output": "InstrumentalIn(dengxiaoping, chinaseconomicreconstruction) ∧ Following(chinaseconomicreconstruction, greatleapforward) ∧ Disastrous(greatleapforward)"
},
{
"input": "Translate into first-order logic: Mao Zedong died in 1976.",
"output": "DiedIn(mao, y1976)"
},
{
"input": "Translate into first-order logic: After Mao Zedong's death, Deng Xiaoping gradually rose to supreme power.",
"output": "GraduallyRoseTo(dengxiaoping, supremepower)"
},
{
"input": "Translate into first-order logic: Deng Xiaoping served as the paramount leader of the People's Republic of China (PRC).",
"output": "ParamountLeaderOf(dengxiaoping, prc)"
},
{
"input": "Translate into first-order logic: Deng Xiaoping was praised for his reaffirmation of the reform program in his Southern Tour of 1992 as well as the reversion of Hong Kong to Chinese control in 1997 and the return of Macau in 1999.",
"output": "PraisedFor(dengxiaoping, reaffirmationofreformprogram) ∧ PraisedFor(dengxiaoping, reversionofhongkong) ∧ PraisedFor(dengxiaoping, returnofmacau)"
},
{
"input": "Translate into first-order logic: As the party's Secretary-General under Mao and Vice Premier in he 1950s, Deng Xiaoping presided over the Anti-Rightist Campaign launched by Mao.",
"output": "PartysSecretaryGeneral(dengxiaoping) ∧ Under(dengxiaoping, mao) ∧ VicePremier(dengxiaoping) ∧ PresidedOver(dengxiaoping, antirightistcampaign) ∧ LaunchedBy(antirightistcampaign, mao)"
},
{
"input": "Translate into first-order logic: Deng Xiaoping became instrumental in China's economic reconstruction following the disastrous Great Leap Forward (1958–1960).",
"output": "InstrumentalIn(dengxiaoping, chinaseconomicreconstruction) ∧ Following(chinaseconomicreconstruction, greatleapforward) ∧ Disastrous(greatleapforward)"
},
{
"input": "Translate into first-order logic: Mao Zedong died in 1976.",
"output": "DiedIn(mao, y1976)"
},
{
"input": "Translate into first-order logic: After Mao Zedong's death, Deng Xiaoping gradually rose to supreme power.",
"output": "GraduallyRoseTo(dengxiaoping, supremepower)"
},
{
"input": "Translate into first-order logic: Deng Xiaoping served as the paramount leader of the People's Republic of China (PRC).",
"output": "ParamountLeaderOf(dengxiaoping, prc)"
},
{
"input": "Translate into first-order logic: Deng Xiaoping was praised for his reaffirmation of the reform program in his Southern Tour of 1992 as well as the reversion of Hong Kong to Chinese control in 1997 and the return of Macau in 1999.",
"output": "PraisedFor(dengxiaoping, reaffirmationofreformprogram) ∧ PraisedFor(dengxiaoping, reversionofhongkong) ∧ PraisedFor(dengxiaoping, returnofmacau)"
},
{
"input": "Translate into first-order logic: As the party's Secretary-General under Mao and Vice Premier in he 1950s, Deng Xiaoping presided over the Anti-Rightist Campaign launched by Mao.",
"output": "PartysSecretaryGeneral(dengxiaoping) ∧ Under(dengxiaoping, mao) ∧ VicePremier(dengxiaoping) ∧ PresidedOver(dengxiaoping, antirightistcampaign) ∧ LaunchedBy(antirightistcampaign, mao)"
},
{
"input": "Translate into first-order logic: Deng Xiaoping became instrumental in China's economic reconstruction following the disastrous Great Leap Forward (1958–1960).",
"output": "InstrumentalIn(dengxiaoping, chinaseconomicreconstruction) ∧ Following(chinaseconomicreconstruction, greatleapforward) ∧ Disastrous(greatleapforward)"
},
{
"input": "Translate into first-order logic: Mao Zedong died in 1976.",
"output": "DiedIn(mao, y1976)"
},
{
"input": "Translate into first-order logic: After Mao Zedong's death, Deng Xiaoping gradually rose to supreme power.",
"output": "GraduallyRoseTo(dengxiaoping, supremepower)"
},
{
"input": "Translate into first-order logic: All imaginative processes are produced in human brains.",
"output": "∀x (ImaginativeProcess(x) → ProducedInHumanBrains(x))"
},
{
"input": "Translate into first-order logic: All science-fiction is from an imaginative process.",
"output": " ∀x (Science-fiction(x) → ImaginativeProcess(x)) "
},
{
"input": "Translate into first-order logic: Either science-fiction or fact.",
"output": " ∀x (Science-fiction(x) ∨ Fact(x))"
},
{
"input": "Translate into first-order logic: No facts are proven to be false.",
"output": " ∀x (Fact(x) → ¬ProvedToBeFalse(x)) "
},
{
"input": "Translate into first-order logic: Dune is a science-fiction or proven to be false.",
"output": " Science-fiction(dune) ∨ ProvedToBeFalse(dune)"
},
{
"input": "Translate into first-order logic: All imaginative processes are produced in human brains.",
"output": "∀x (ImaginativeProcess(x) → ProducedInHumanBrains(x))"
},
{
"input": "Translate into first-order logic: All science-fiction is from an imaginative process.",
"output": " ∀x (Science-fiction(x) → ImaginativeProcess(x)) "
},
{
"input": "Translate into first-order logic: Either science-fiction or fact.",
"output": " ∀x (Science-fiction(x) ∨ Fact(x))"
},
{
"input": "Translate into first-order logic: No facts are proven to be false.",
"output": " ∀x (Fact(x) → ¬ProvedToBeFalse(x)) "
},
{
"input": "Translate into first-order logic: Dune is a science-fiction or proven to be false.",
"output": " Science-fiction(dune) ∨ ProvedToBeFalse(dune)"
},
{
"input": "Translate into first-order logic: All imaginative processes are produced in human brains.",
"output": "∀x (ImaginativeProcess(x) → ProducedInHumanBrains(x))"
},
{
"input": "Translate into first-order logic: All science-fiction is from an imaginative process.",
"output": " ∀x (Science-fiction(x) → ImaginativeProcess(x)) "
},
{
"input": "Translate into first-order logic: Either science-fiction or fact.",
"output": " ∀x (Science-fiction(x) ∨ Fact(x))"
},
{
"input": "Translate into first-order logic: No facts are proven to be false.",
"output": " ∀x (Fact(x) → ¬ProvedToBeFalse(x)) "
},
{
"input": "Translate into first-order logic: Dune is a science-fiction or proven to be false.",
"output": " Science-fiction(dune) ∨ ProvedToBeFalse(dune)"
},
{
"input": "Translate into first-order logic: All imaginative processes are produced in human brains.",
"output": "∀x (ImaginativeProcess(x) → ProducedInHumanBrains(x))"
},
{
"input": "Translate into first-order logic: All science-fiction is from an imaginative process.",
"output": " ∀x (Science-fiction(x) → ImaginativeProcess(x)) "
},
{
"input": "Translate into first-order logic: Either science-fiction or fact.",
"output": " ∀x (Science-fiction(x) ∨ Fact(x))"
},
{
"input": "Translate into first-order logic: No facts are proven to be false.",
"output": " ∀x (Fact(x) → ¬ProvedToBeFalse(x)) "
},
{
"input": "Translate into first-order logic: Dune is a science-fiction or proven to be false.",
"output": " Science-fiction(dune) ∨ ProvedToBeFalse(dune)"
},
{
"input": "Translate into first-order logic: All imaginative processes are produced in human brains.",
"output": "∀x (ImaginativeProcess(x) → ProducedInHumanBrains(x))"
},
{
"input": "Translate into first-order logic: All science-fiction is from an imaginative process.",
"output": " ∀x (Science-fiction(x) → ImaginativeProcess(x)) "
},
{
"input": "Translate into first-order logic: Either science-fiction or fact.",
"output": " ∀x (Science-fiction(x) ∨ Fact(x))"
},
{
"input": "Translate into first-order logic: No facts are proven to be false.",
"output": " ∀x (Fact(x) → ¬ProvedToBeFalse(x)) "
},
{
"input": "Translate into first-order logic: Dune is a science-fiction or proven to be false.",
"output": " Science-fiction(dune) ∨ ProvedToBeFalse(dune)"
},
{
"input": "Translate into first-order logic: All imaginative processes are produced in human brains.",
"output": "∀x (ImaginativeProcess(x) → ProducedInHumanBrains(x))"
},
{
"input": "Translate into first-order logic: All science-fiction is from an imaginative process.",
"output": " ∀x (Science-fiction(x) → ImaginativeProcess(x)) "
},
{
"input": "Translate into first-order logic: Either science-fiction or fact.",
"output": " ∀x (Science-fiction(x) ∨ Fact(x))"
},
{
"input": "Translate into first-order logic: No facts are proven to be false.",
"output": " ∀x (Fact(x) → ¬ProvedToBeFalse(x)) "
},
{
"input": "Translate into first-order logic: Dune is a science-fiction or proven to be false.",
"output": " Science-fiction(dune) ∨ ProvedToBeFalse(dune)"
},
{
"input": "Translate into first-order logic: All imaginative processes are produced in human brains.",
"output": "∀x (ImaginativeProcess(x) → ProducedInHumanBrains(x))"
},
{
"input": "Translate into first-order logic: All science-fiction is from an imaginative process.",
"output": " ∀x (Science-fiction(x) → ImaginativeProcess(x)) "
},
{
"input": "Translate into first-order logic: Either science-fiction or fact.",
"output": " ∀x (Science-fiction(x) ∨ Fact(x))"
},
{
"input": "Translate into first-order logic: No facts are proven to be false.",
"output": " ∀x (Fact(x) → ¬ProvedToBeFalse(x)) "
},
{
"input": "Translate into first-order logic: Dune is a science-fiction or proven to be false.",
"output": " Science-fiction(dune) ∨ ProvedToBeFalse(dune)"
},
{
"input": "Translate into first-order logic: All imaginative processes are produced in human brains.",
"output": "∀x (ImaginativeProcess(x) → ProducedInHumanBrains(x))"
},
{
"input": "Translate into first-order logic: All science-fiction is from an imaginative process.",
"output": " ∀x (Science-fiction(x) → ImaginativeProcess(x)) "
},
{
"input": "Translate into first-order logic: Either science-fiction or fact.",
"output": " ∀x (Science-fiction(x) ∨ Fact(x))"
},
{
"input": "Translate into first-order logic: No facts are proven to be false.",
"output": " ∀x (Fact(x) → ¬ProvedToBeFalse(x)) "
},
{
"input": "Translate into first-order logic: Dune is a science-fiction or proven to be false.",
"output": " Science-fiction(dune) ∨ ProvedToBeFalse(dune)"
},
{
"input": "Translate into first-order logic: All imaginative processes are produced in human brains.",
"output": "∀x (ImaginativeProcess(x) → ProducedInHumanBrains(x))"
},
{
"input": "Translate into first-order logic: All science-fiction is from an imaginative process.",
"output": " ∀x (Science-fiction(x) → ImaginativeProcess(x)) "
},
{
"input": "Translate into first-order logic: Either science-fiction or fact.",
"output": " ∀x (Science-fiction(x) ∨ Fact(x))"
},
{
"input": "Translate into first-order logic: No facts are proven to be false.",
"output": " ∀x (Fact(x) → ¬ProvedToBeFalse(x)) "
},
{
"input": "Translate into first-order logic: Dune is a science-fiction or proven to be false.",
"output": " Science-fiction(dune) ∨ ProvedToBeFalse(dune)"
},
{
"input": "Translate into first-order logic: All imaginative processes are produced in human brains.",
"output": "∀x (ImaginativeProcess(x) → ProducedInHumanBrains(x))"
},
{
"input": "Translate into first-order logic: All science-fiction is from an imaginative process.",
"output": " ∀x (Science-fiction(x) → ImaginativeProcess(x)) "
},
{
"input": "Translate into first-order logic: Either science-fiction or fact.",
"output": " ∀x (Science-fiction(x) ∨ Fact(x))"
},
{
"input": "Translate into first-order logic: No facts are proven to be false.",
"output": " ∀x (Fact(x) → ¬ProvedToBeFalse(x)) "
},
{
"input": "Translate into first-order logic: Dune is a science-fiction or proven to be false.",
"output": " Science-fiction(dune) ∨ ProvedToBeFalse(dune)"
},
{
"input": "Translate into first-order logic: An American superhero comes from either DC universe or Marvel universe.",
"output": "∀x (Superhero(x) ∧ American(x) → (ComeFrom(x, dc universe) ⊕ ComeFrom(x, marvel universe))) "
},
{
"input": "Translate into first-order logic: Captain America is a superhero.",
"output": " Superhero(captain america) "
},
{
"input": "Translate into first-order logic: Captain America is an American.",
"output": " American(captain america) "
},
{
"input": "Translate into first-order logic: Captain America does not come from DC universe.",
"output": " ¬ComeFrom(captain america, dc universe) "
},
{
"input": "Translate into first-order logic: If a superhero is American, he speaks English.",
"output": " ∀x (Superhero(x) ∧ American(x) → Speak(x, english)) "
},
{
"input": "Translate into first-order logic: A superhero speaks English or Spanish.",
"output": " ∀x (Superhero(x) → (Speak(x, english) ∨ Speak(x, spanish)))"
},
{
"input": "Translate into first-order logic: An American superhero comes from either DC universe or Marvel universe.",
"output": "∀x (Superhero(x) ∧ American(x) → (ComeFrom(x, dc universe) ⊕ ComeFrom(x, marvel universe))) "
},
{
"input": "Translate into first-order logic: Captain America is a superhero.",
"output": " Superhero(captain america) "
},
{
"input": "Translate into first-order logic: Captain America is an American.",
"output": " American(captain america) "
},
{
"input": "Translate into first-order logic: Captain America does not come from DC universe.",
"output": " ¬ComeFrom(captain america, dc universe) "
},
{
"input": "Translate into first-order logic: If a superhero is American, he speaks English.",
"output": " ∀x (Superhero(x) ∧ American(x) → Speak(x, english)) "
},
{
"input": "Translate into first-order logic: A superhero speaks English or Spanish.",
"output": " ∀x (Superhero(x) → (Speak(x, english) ∨ Speak(x, spanish)))"
},
{
"input": "Translate into first-order logic: An American superhero comes from either DC universe or Marvel universe.",
"output": "∀x (Superhero(x) ∧ American(x) → (ComeFrom(x, dc universe) ⊕ ComeFrom(x, marvel universe))) "
},
{
"input": "Translate into first-order logic: Captain America is a superhero.",
"output": " Superhero(captain america) "
},
{
"input": "Translate into first-order logic: Captain America is an American.",
"output": " American(captain america) "
},
{
"input": "Translate into first-order logic: Captain America does not come from DC universe.",
"output": " ¬ComeFrom(captain america, dc universe) "
},
{
"input": "Translate into first-order logic: If a superhero is American, he speaks English.",
"output": " ∀x (Superhero(x) ∧ American(x) → Speak(x, english)) "
},
{
"input": "Translate into first-order logic: A superhero speaks English or Spanish.",
"output": " ∀x (Superhero(x) → (Speak(x, english) ∨ Speak(x, spanish)))"
},
{
"input": "Translate into first-order logic: Robert Zimmer was born in Germany.",
"output": "BornInGermany(robertZimmer)"
},
{
"input": "Translate into first-order logic: Robert Zimmer is an essayist.",
"output": "IsEssayist(robertZimmer)"
},
{
"input": "Translate into first-order logic: Robert Zimmer was born in 1953.",
"output": "BornIn(robertZimmer, year1953)"
},
{
"input": "Translate into first-order logic: Every essayist is a writer.",
"output": "∀x (IsEssayist(x) → IsWriter(x))"
},
{
"input": "Translate into first-order logic: Every person born in Germany is German.",
"output": "∀x (BornInGermany(x) → IsGerman(x))"
},
{
"input": "Translate into first-order logic: Robert Zimmer was born in Germany.",
"output": "BornInGermany(robertZimmer)"
},
{
"input": "Translate into first-order logic: Robert Zimmer is an essayist.",
"output": "IsEssayist(robertZimmer)"
},
{
"input": "Translate into first-order logic: Robert Zimmer was born in 1953.",
"output": "BornIn(robertZimmer, year1953)"
},
{
"input": "Translate into first-order logic: Every essayist is a writer.",
"output": "∀x (IsEssayist(x) → IsWriter(x))"
},
{
"input": "Translate into first-order logic: Every person born in Germany is German.",
"output": "∀x (BornInGermany(x) → IsGerman(x))"
},
{
"input": "Translate into first-order logic: Robert Zimmer was born in Germany.",
"output": "BornInGermany(robertZimmer)"
},
{
"input": "Translate into first-order logic: Robert Zimmer is an essayist.",
"output": "IsEssayist(robertZimmer)"
},
{
"input": "Translate into first-order logic: Robert Zimmer was born in 1953.",
"output": "BornIn(robertZimmer, year1953)"
},
{
"input": "Translate into first-order logic: Every essayist is a writer.",
"output": "∀x (IsEssayist(x) → IsWriter(x))"
},
{
"input": "Translate into first-order logic: Every person born in Germany is German.",
"output": "∀x (BornInGermany(x) → IsGerman(x))"
},
{
"input": "Translate into first-order logic: All people who repay their loans on time have a high credit score.",
"output": "∀x (Repay(x) → HighCreditScore(x))"
},
{
"input": "Translate into first-order logic: Some people with high credit scores and high salaries are approved for mortgages.",
"output": "∃x ((HighCreditScore(x) ∧ HighSalary(x)) → Mortgage(x))"
},
{
"input": "Translate into first-order logic: John has a high salary.",
"output": "HighSalary(john)"
},
{
"input": "Translate into first-order logic: All students are members of the university.",
"output": "∀x (Student(x) → MemberOfUniversity(x))"
},
{
"input": "Translate into first-order logic: All graduate students are students.",
"output": "∀x (GraduateStudent(x) → Student(x))"
},
{
"input": "Translate into first-order logic: All PhD students are graduate students.",
"output": "∀x (PhDStudent(x) → GraduateStudent(x))"
},
{
"input": "Translate into first-order logic: Some PhD students have high IQs.",
"output": "∃x (PhDStudent(x) ∧ HighIQ(x))"
},
{
"input": "Translate into first-order logic: If John is not a PhD student, then he is not a member of the university.",
"output": "¬PhDStudent(john) → ¬MemberOfUniversity(john)"
},
{
"input": "Translate into first-order logic: If John has a high IQ, then he is a PhD student or a graduate student.",
"output": "HighIQ(john) → PhDStudent(john) ⊕ GraduateStudent(john)"
},
{
"input": "Translate into first-order logic: All students are members of the university.",
"output": "∀x (Student(x) → MemberOfUniversity(x))"
},
{
"input": "Translate into first-order logic: All graduate students are students.",
"output": "∀x (GraduateStudent(x) → Student(x))"
},
{
"input": "Translate into first-order logic: All PhD students are graduate students.",
"output": "∀x (PhDStudent(x) → GraduateStudent(x))"
},
{
"input": "Translate into first-order logic: Some PhD students have high IQs.",
"output": "∃x (PhDStudent(x) ∧ HighIQ(x))"
},
{
"input": "Translate into first-order logic: If John is not a PhD student, then he is not a member of the university.",
"output": "¬PhDStudent(john) → ¬MemberOfUniversity(john)"
},
{
"input": "Translate into first-order logic: If John has a high IQ, then he is a PhD student or a graduate student.",
"output": "HighIQ(john) → PhDStudent(john) ⊕ GraduateStudent(john)"
},
{
"input": "Translate into first-order logic: All students are members of the university.",
"output": "∀x (Student(x) → MemberOfUniversity(x))"
},
{
"input": "Translate into first-order logic: All graduate students are students.",
"output": "∀x (GraduateStudent(x) → Student(x))"
},
{
"input": "Translate into first-order logic: All PhD students are graduate students.",
"output": "∀x (PhDStudent(x) → GraduateStudent(x))"
},
{
"input": "Translate into first-order logic: Some PhD students have high IQs.",
"output": "∃x (PhDStudent(x) ∧ HighIQ(x))"
},
{
"input": "Translate into first-order logic: If John is not a PhD student, then he is not a member of the university.",
"output": "¬PhDStudent(john) → ¬MemberOfUniversity(john)"
},
{
"input": "Translate into first-order logic: If John has a high IQ, then he is a PhD student or a graduate student.",
"output": "HighIQ(john) → PhDStudent(john) ⊕ GraduateStudent(john)"
},
{
"input": "Translate into first-order logic: Belgium, France and Germany are European countries.",
"output": "EuropeanCountry(belgium) ∨ EuropeanCountry(france) ∨ EuropeanCountry(germany)"
},
{
"input": "Translate into first-order logic: Paris is the capital of France.",
"output": "CapitalOf(paris, france)"
},
{
"input": "Translate into first-order logic: The Eiffel Tower is one of the main tourist attractions located in Paris.",
"output": "TouristAttraction(eiffelTower) ∧ LocatedIn(eiffelTower, paris)"
},
{
"input": "Translate into first-order logic: Some people who live in Belgium speak French.",
"output": "∃x (LiveIn(x, belgium) → Speak(x, french))"
},
{
"input": "Translate into first-order logic: If John goes to Europe, he will see some tourist attractions.",
"output": "∃x (GoTo(john, europe) → (See(john, x) ∧ TouristAttraction(x)))"
},
{
"input": "Translate into first-order logic: John speaks French.",
"output": "Speak(john, french)"
},
{
"input": "Translate into first-order logic: Belgium, France and Germany are European countries.",
"output": "EuropeanCountry(belgium) ∨ EuropeanCountry(france) ∨ EuropeanCountry(germany)"
},
{
"input": "Translate into first-order logic: Paris is the capital of France.",
"output": "CapitalOf(paris, france)"
},
{
"input": "Translate into first-order logic: The Eiffel Tower is one of the main tourist attractions located in Paris.",
"output": "TouristAttraction(eiffelTower) ∧ LocatedIn(eiffelTower, paris)"
},
{
"input": "Translate into first-order logic: Some people who live in Belgium speak French.",
"output": "∃x (LiveIn(x, belgium) → Speak(x, french))"
},
{
"input": "Translate into first-order logic: If John goes to Europe, he will see some tourist attractions.",
"output": "∃x (GoTo(john, europe) → (See(john, x) ∧ TouristAttraction(x)))"
},
{
"input": "Translate into first-order logic: John speaks French.",
"output": "Speak(john, french)"
},
{
"input": "Translate into first-order logic: Belgium, France and Germany are European countries.",
"output": "EuropeanCountry(belgium) ∨ EuropeanCountry(france) ∨ EuropeanCountry(germany)"
},
{
"input": "Translate into first-order logic: Paris is the capital of France.",
"output": "CapitalOf(paris, france)"
},
{
"input": "Translate into first-order logic: The Eiffel Tower is one of the main tourist attractions located in Paris.",
"output": "TouristAttraction(eiffelTower) ∧ LocatedIn(eiffelTower, paris)"
},
{
"input": "Translate into first-order logic: Some people who live in Belgium speak French.",
"output": "∃x (LiveIn(x, belgium) → Speak(x, french))"
},
{
"input": "Translate into first-order logic: If John goes to Europe, he will see some tourist attractions.",
"output": "∃x (GoTo(john, europe) → (See(john, x) ∧ TouristAttraction(x)))"
},
{
"input": "Translate into first-order logic: John speaks French.",
"output": "Speak(john, french)"
},
{
"input": "Translate into first-order logic: All sports cars are loud.",
"output": "∀x (SportsCar(x) → LoudCar(x))"
},
{
"input": "Translate into first-order logic: No loud cars are electric.",
"output": "∀x (LoudCar(x) → ¬ElectricCar(x))"
},
{
"input": "Translate into first-order logic: If a car is a Ferrari, then it is a sports car.",
"output": "∀x (Ferrari(x) → SportsCar(x))"
},
{
"input": "Translate into first-order logic: All cars made in Maranello are Ferrari",
"output": "∀x (MadeInMaranello(x) → Ferrari(x))"
},
{
"input": "Translate into first-order logic: If Prius is neither a sports car nor a loud car, then Prius is a Maranello-made car or a loud car.",
"output": "∀x (¬SportsCar(prius) ∨ ¬LoudCar(prius) → MadeInMaranello(prius) ∨ LoudCar(prius))"
},
{
"input": "Translate into first-order logic: All sports cars are loud.",
"output": "∀x (SportsCar(x) → LoudCar(x))"
},
{
"input": "Translate into first-order logic: No loud cars are electric.",
"output": "∀x (LoudCar(x) → ¬ElectricCar(x))"
},
{
"input": "Translate into first-order logic: If a car is a Ferrari, then it is a sports car.",
"output": "∀x (Ferrari(x) → SportsCar(x))"
},
{
"input": "Translate into first-order logic: All cars made in Maranello are Ferrari",
"output": "∀x (MadeInMaranello(x) → Ferrari(x))"
},
{
"input": "Translate into first-order logic: If Prius is neither a sports car nor a loud car, then Prius is a Maranello-made car or a loud car.",
"output": "∀x (¬SportsCar(prius) ∨ ¬LoudCar(prius) → MadeInMaranello(prius) ∨ LoudCar(prius))"
},
{
"input": "Translate into first-order logic: All sports cars are loud.",
"output": "∀x (SportsCar(x) → LoudCar(x))"
},
{
"input": "Translate into first-order logic: No loud cars are electric.",
"output": "∀x (LoudCar(x) → ¬ElectricCar(x))"
},
{
"input": "Translate into first-order logic: If a car is a Ferrari, then it is a sports car.",
"output": "∀x (Ferrari(x) → SportsCar(x))"
},
{
"input": "Translate into first-order logic: All cars made in Maranello are Ferrari",
"output": "∀x (MadeInMaranello(x) → Ferrari(x))"
},
{
"input": "Translate into first-order logic: If Prius is neither a sports car nor a loud car, then Prius is a Maranello-made car or a loud car.",
"output": "∀x (¬SportsCar(prius) ∨ ¬LoudCar(prius) → MadeInMaranello(prius) ∨ LoudCar(prius))"
},
{
"input": "Translate into first-order logic: All sports cars are loud.",
"output": "∀x (SportsCar(x) → LoudCar(x))"
},
{
"input": "Translate into first-order logic: No loud cars are electric.",
"output": "∀x (LoudCar(x) → ¬ElectricCar(x))"
},
{
"input": "Translate into first-order logic: If a car is a Ferrari, then it is a sports car.",
"output": "∀x (Ferrari(x) → SportsCar(x))"
},
{
"input": "Translate into first-order logic: All cars made in Maranello are Ferrari",
"output": "∀x (MadeInMaranello(x) → Ferrari(x))"
},
{
"input": "Translate into first-order logic: If Prius is neither a sports car nor a loud car, then Prius is a Maranello-made car or a loud car.",
"output": "∀x (¬SportsCar(prius) ∨ ¬LoudCar(prius) → MadeInMaranello(prius) ∨ LoudCar(prius))"
},
{
"input": "Translate into first-order logic: If something is a plant, then it is not a cute animal.",
"output": "∀x (Plant(x) → ¬CuteAnimal(x))"
},
{
"input": "Translate into first-order logic: All flowers are plants.",
"output": "∀x (Flower(x) → Plant(x))"
},
{
"input": "Translate into first-order logic: Every kitten is a cute animal.",
"output": "∀x (Kitten(x) → CuteAnimal(x))"
},
{
"input": "Translate into first-order logic: If something is grown in a garden, then it is a flower.",
"output": "∀x (GrownInGarden(x) → Flower(x))"
},
{
"input": "Translate into first-order logic: Piper is a kitten or a cute animal.",
"output": "Kitten(piper) ∨ CuteAnimal(piper)"
},
{
"input": "Translate into first-order logic: If something is a plant, then it is not a cute animal.",
"output": "∀x (Plant(x) → ¬CuteAnimal(x))"
},
{
"input": "Translate into first-order logic: All flowers are plants.",
"output": "∀x (Flower(x) → Plant(x))"
},
{
"input": "Translate into first-order logic: Every kitten is a cute animal.",
"output": "∀x (Kitten(x) → CuteAnimal(x))"
},
{
"input": "Translate into first-order logic: If something is grown in a garden, then it is a flower.",
"output": "∀x (GrownInGarden(x) → Flower(x))"
},
{
"input": "Translate into first-order logic: Piper is a kitten or a cute animal.",
"output": "Kitten(piper) ∨ CuteAnimal(piper)"
},
{
"input": "Translate into first-order logic: If something is a plant, then it is not a cute animal.",
"output": "∀x (Plant(x) → ¬CuteAnimal(x))"
},
{
"input": "Translate into first-order logic: All flowers are plants.",
"output": "∀x (Flower(x) → Plant(x))"
},
{
"input": "Translate into first-order logic: Every kitten is a cute animal.",
"output": "∀x (Kitten(x) → CuteAnimal(x))"
},
{
"input": "Translate into first-order logic: If something is grown in a garden, then it is a flower.",
"output": "∀x (GrownInGarden(x) → Flower(x))"
},
{
"input": "Translate into first-order logic: Piper is a kitten or a cute animal.",
"output": "Kitten(piper) ∨ CuteAnimal(piper)"
},
{
"input": "Translate into first-order logic: Guam has participated in the Winter Olympics.",
"output": "ParticipatedIn(guam, winterolympics)"
},
{
"input": "Translate into first-order logic: In 1988, the Winter Olympics were held in Calgary.",
"output": "Year(y1988) → BeHeld(winterolympics, calgary)"
},
{
"input": "Translate into first-order logic: Guam sent an athlete to the Calgary Winter Olympics.",
"output": "BeHeld(winterolympics, calgary) → SendAthletes(guam)"
},
{
"input": "Translate into first-order logic: If Guan sent an athlete to the Calgary Winter Olympics, then it participated in the Calgary Winter Olympics.",
"output": "SendAthletes(guam) → ParticipatedIn(guam, winterolympics)"
},
{
"input": "Translate into first-order logic: Judd Bankert is the only athlete from Guam who has ever competed in the Winter Olympics.",
"output": "BeFrom(bankert, guam) ∧ ParticipatedIn(bankert, winterolympics)"
},
{
"input": "Translate into first-order logic: Guam has participated in the Winter Olympics.",
"output": "ParticipatedIn(guam, winterolympics)"
},
{
"input": "Translate into first-order logic: In 1988, the Winter Olympics were held in Calgary.",
"output": "Year(y1988) → BeHeld(winterolympics, calgary)"
},
{
"input": "Translate into first-order logic: Guam sent an athlete to the Calgary Winter Olympics.",
"output": "BeHeld(winterolympics, calgary) → SendAthletes(guam)"
},
{
"input": "Translate into first-order logic: If Guan sent an athlete to the Calgary Winter Olympics, then it participated in the Calgary Winter Olympics.",
"output": "SendAthletes(guam) → ParticipatedIn(guam, winterolympics)"
},
{
"input": "Translate into first-order logic: Judd Bankert is the only athlete from Guam who has ever competed in the Winter Olympics.",
"output": "BeFrom(bankert, guam) ∧ ParticipatedIn(bankert, winterolympics)"
},
{
"input": "Translate into first-order logic: Michael O'Donnell is a British physician, journalist, author and broadcaster.",
"output": "British(michael) ∧ Physician(michael) ∧ Journalist(michael) ∧ Author(michael) ∧ Broadcaster(michael)"
},
{
"input": "Translate into first-order logic: One of the word-setters of My Word! was Michael O'Donnell.",
"output": "WordSetter(michael)"
},
{
"input": "Translate into first-order logic: The magazine World Medicine was edited by Michael O'Donnell.",
"output": "Magazine(worldmedicine) ∧ EditedBy(worldmedicine, michael)"
},
{
"input": "Translate into first-order logic: Michael O'Donnell was born in Yorkshire as the son of a general practitioner.",
"output": "∃x (BornIn(michael, yorkshire) ∧ Son(michael, x) ∧ GeneralPractitioner(x))"
},
{
"input": "Translate into first-order logic: Michael O'Donnell is a British physician, journalist, author and broadcaster.",
"output": "British(michael) ∧ Physician(michael) ∧ Journalist(michael) ∧ Author(michael) ∧ Broadcaster(michael)"
},
{
"input": "Translate into first-order logic: One of the word-setters of My Word! was Michael O'Donnell.",
"output": "WordSetter(michael)"
},
{
"input": "Translate into first-order logic: The magazine World Medicine was edited by Michael O'Donnell.",
"output": "Magazine(worldmedicine) ∧ EditedBy(worldmedicine, michael)"
},
{
"input": "Translate into first-order logic: Michael O'Donnell was born in Yorkshire as the son of a general practitioner.",
"output": "∃x (BornIn(michael, yorkshire) ∧ Son(michael, x) ∧ GeneralPractitioner(x))"
},
{
"input": "Translate into first-order logic: Michael O'Donnell is a British physician, journalist, author and broadcaster.",
"output": "British(michael) ∧ Physician(michael) ∧ Journalist(michael) ∧ Author(michael) ∧ Broadcaster(michael)"
},
{
"input": "Translate into first-order logic: One of the word-setters of My Word! was Michael O'Donnell.",
"output": "WordSetter(michael)"
},
{
"input": "Translate into first-order logic: The magazine World Medicine was edited by Michael O'Donnell.",
"output": "Magazine(worldmedicine) ∧ EditedBy(worldmedicine, michael)"
},
{
"input": "Translate into first-order logic: Michael O'Donnell was born in Yorkshire as the son of a general practitioner.",
"output": "∃x (BornIn(michael, yorkshire) ∧ Son(michael, x) ∧ GeneralPractitioner(x))"
},
{
"input": "Translate into first-order logic: Michael O'Donnell is a British physician, journalist, author and broadcaster.",
"output": "British(michael) ∧ Physician(michael) ∧ Journalist(michael) ∧ Author(michael) ∧ Broadcaster(michael)"
},
{
"input": "Translate into first-order logic: One of the word-setters of My Word! was Michael O'Donnell.",
"output": "WordSetter(michael)"
},
{
"input": "Translate into first-order logic: The magazine World Medicine was edited by Michael O'Donnell.",
"output": "Magazine(worldmedicine) ∧ EditedBy(worldmedicine, michael)"
},
{
"input": "Translate into first-order logic: Michael O'Donnell was born in Yorkshire as the son of a general practitioner.",
"output": "∃x (BornIn(michael, yorkshire) ∧ Son(michael, x) ∧ GeneralPractitioner(x))"
},
{
"input": "Translate into first-order logic: Michael O'Donnell is a British physician, journalist, author and broadcaster.",
"output": "British(michael) ∧ Physician(michael) ∧ Journalist(michael) ∧ Author(michael) ∧ Broadcaster(michael)"
},
{
"input": "Translate into first-order logic: One of the word-setters of My Word! was Michael O'Donnell.",
"output": "WordSetter(michael)"
},
{
"input": "Translate into first-order logic: The magazine World Medicine was edited by Michael O'Donnell.",
"output": "Magazine(worldmedicine) ∧ EditedBy(worldmedicine, michael)"
},
{
"input": "Translate into first-order logic: Michael O'Donnell was born in Yorkshire as the son of a general practitioner.",
"output": "∃x (BornIn(michael, yorkshire) ∧ Son(michael, x) ∧ GeneralPractitioner(x))"
},
{
"input": "Translate into first-order logic: No homework is fun.",
"output": "∀x (Homework(x) → ¬IsFun(x))"
},
{
"input": "Translate into first-order logic: Some reading is homework.",
"output": "∃x (IsReading(x) ∧ Homework(x))"
},
{
"input": "Translate into first-order logic: If violence is good, it is justified.",
"output": "∀x ((Violence(x) ∧ Good(x)) → Justified(x))"
},
{
"input": "Translate into first-order logic: If something is justified, it is lawful.",
"output": "∀x (Justified(x) → Lawful(x))"
},
{
"input": "Translate into first-order logic: All people who have a horse ranch regularly ride horses for pleasure and sport.",
"output": "∀x (Ranch(x) → RegularlyRide(x))"
},
{
"input": "Translate into first-order logic: All people who have a lot of disposable income have a horse ranch.",
"output": "∀x (DisposableIncome(x) → Ranch(x))"
},
{
"input": "Translate into first-order logic: If people compete in horse dressage shows, then they have a lot of disposable income.",
"output": "∀x (Compete(x) → DisposableIncome(x))"
},
{
"input": "Translate into first-order logic: If people compete in horse dressage shows, then they have invested in high-quality equestrian gear and equipment.",
"output": "∀x (Compete(x) → Invested(x))"
},
{
"input": "Translate into first-order logic: If people regularly ride horses for pleasure and sport, then they do not live in cramped residential buildings.",
"output": "∀x (RegularlyRide(x) → ¬Cramped(x))"
},
{
"input": "Translate into first-order logic: Manny either has a horse ranch and lives in cramped residential buildings, or he neither has a horse ranch nor lives in cramped residential buildings.",
"output": "(Ranch(manny) ∧ Cramped(manny)) ⊕ (¬Ranch(manny) ∧ ¬Cramped(manny))"
},
{
"input": "Translate into first-order logic: All people who have a horse ranch regularly ride horses for pleasure and sport.",
"output": "∀x (Ranch(x) → RegularlyRide(x))"
},
{
"input": "Translate into first-order logic: All people who have a lot of disposable income have a horse ranch.",
"output": "∀x (DisposableIncome(x) → Ranch(x))"
},
{
"input": "Translate into first-order logic: If people compete in horse dressage shows, then they have a lot of disposable income.",
"output": "∀x (Compete(x) → DisposableIncome(x))"
},
{
"input": "Translate into first-order logic: If people compete in horse dressage shows, then they have invested in high-quality equestrian gear and equipment.",
"output": "∀x (Compete(x) → Invested(x))"
},
{
"input": "Translate into first-order logic: If people regularly ride horses for pleasure and sport, then they do not live in cramped residential buildings.",
"output": "∀x (RegularlyRide(x) → ¬Cramped(x))"
},
{
"input": "Translate into first-order logic: Manny either has a horse ranch and lives in cramped residential buildings, or he neither has a horse ranch nor lives in cramped residential buildings.",
"output": "(Ranch(manny) ∧ Cramped(manny)) ⊕ (¬Ranch(manny) ∧ ¬Cramped(manny))"
},
{
"input": "Translate into first-order logic: All people who have a horse ranch regularly ride horses for pleasure and sport.",
"output": "∀x (Ranch(x) → RegularlyRide(x))"
},
{
"input": "Translate into first-order logic: All people who have a lot of disposable income have a horse ranch.",
"output": "∀x (DisposableIncome(x) → Ranch(x))"
},
{
"input": "Translate into first-order logic: If people compete in horse dressage shows, then they have a lot of disposable income.",
"output": "∀x (Compete(x) → DisposableIncome(x))"
},
{
"input": "Translate into first-order logic: If people compete in horse dressage shows, then they have invested in high-quality equestrian gear and equipment.",
"output": "∀x (Compete(x) → Invested(x))"
},
{
"input": "Translate into first-order logic: If people regularly ride horses for pleasure and sport, then they do not live in cramped residential buildings.",
"output": "∀x (RegularlyRide(x) → ¬Cramped(x))"
},
{
"input": "Translate into first-order logic: Manny either has a horse ranch and lives in cramped residential buildings, or he neither has a horse ranch nor lives in cramped residential buildings.",
"output": "(Ranch(manny) ∧ Cramped(manny)) ⊕ (¬Ranch(manny) ∧ ¬Cramped(manny))"
},
{
"input": "Translate into first-order logic: A roundel is a rounded artillery fortification.",
"output": "∀x (Roundel(x) → Rounded(x) ∧ ArtilleryFortification(x))"
},
{
"input": "Translate into first-order logic: A roundel is not higher than adjacent walls.",
"output": "∀x ∀y (Roundel(x) ∧ AdjacentWall(y) → ¬Higher(x, y))"
},
{
"input": "Translate into first-order logic: Cannons can be deployed on artillery fortifications.",
"output": "∀x (ArtilleryFortification(x) → DeployCannons(x))"
},
{
"input": "Translate into first-order logic: Roundels are the oldest artillery fortifications.",
"output": "∀x ∀y (Roundel(x) ∧ ArtilleryFortification(x) ∧ ArtilleryFortification(y) → Older(x, y))"
},
{
"input": "Translate into first-order logic: Battery towers are an artillery fortification.",
"output": "∀x (BatteryTower(x) → ArtilleryFortification(x))"
},
{
"input": "Translate into first-order logic: A roundel is a rounded artillery fortification.",
"output": "∀x (Roundel(x) → Rounded(x) ∧ ArtilleryFortification(x))"
},
{
"input": "Translate into first-order logic: A roundel is not higher than adjacent walls.",
"output": "∀x ∀y (Roundel(x) ∧ AdjacentWall(y) → ¬Higher(x, y))"
},
{
"input": "Translate into first-order logic: Cannons can be deployed on artillery fortifications.",
"output": "∀x (ArtilleryFortification(x) → DeployCannons(x))"
},
{
"input": "Translate into first-order logic: Roundels are the oldest artillery fortifications.",
"output": "∀x ∀y (Roundel(x) ∧ ArtilleryFortification(x) ∧ ArtilleryFortification(y) → Older(x, y))"
},
{
"input": "Translate into first-order logic: Battery towers are an artillery fortification.",
"output": "∀x (BatteryTower(x) → ArtilleryFortification(x))"
},
{
"input": "Translate into first-order logic: A roundel is a rounded artillery fortification.",
"output": "∀x (Roundel(x) → Rounded(x) ∧ ArtilleryFortification(x))"
},
{
"input": "Translate into first-order logic: A roundel is not higher than adjacent walls.",
"output": "∀x ∀y (Roundel(x) ∧ AdjacentWall(y) → ¬Higher(x, y))"
},
{
"input": "Translate into first-order logic: Cannons can be deployed on artillery fortifications.",
"output": "∀x (ArtilleryFortification(x) → DeployCannons(x))"
},
{
"input": "Translate into first-order logic: Roundels are the oldest artillery fortifications.",
"output": "∀x ∀y (Roundel(x) ∧ ArtilleryFortification(x) ∧ ArtilleryFortification(y) → Older(x, y))"
},
{
"input": "Translate into first-order logic: Battery towers are an artillery fortification.",
"output": "∀x (BatteryTower(x) → ArtilleryFortification(x))"
},
{
"input": "Translate into first-order logic: A roundel is a rounded artillery fortification.",
"output": "∀x (Roundel(x) → Rounded(x) ∧ ArtilleryFortification(x))"
},
{
"input": "Translate into first-order logic: A roundel is not higher than adjacent walls.",
"output": "∀x ∀y (Roundel(x) ∧ AdjacentWall(y) → ¬Higher(x, y))"
},
{
"input": "Translate into first-order logic: Cannons can be deployed on artillery fortifications.",
"output": "∀x (ArtilleryFortification(x) → DeployCannons(x))"
},
{
"input": "Translate into first-order logic: Roundels are the oldest artillery fortifications.",
"output": "∀x ∀y (Roundel(x) ∧ ArtilleryFortification(x) ∧ ArtilleryFortification(y) → Older(x, y))"
},
{
"input": "Translate into first-order logic: Battery towers are an artillery fortification.",
"output": "∀x (BatteryTower(x) → ArtilleryFortification(x))"
},
{
"input": "Translate into first-order logic: All tissues are soft.",
"output": "∀x (Tissue(x) → Soft(x))"
},
{
"input": "Translate into first-order logic: Some papers are tissues.",
"output": "∃x (Paper(x) ∧ Tissue(x))"
},
{
"input": "Translate into first-order logic: All volunteers receive intangible benefits for their work.",
"output": "∀x (Volunteer(x) → GetIntangibleBenefits(x))"
},
{
"input": "Translate into first-order logic: Volunteers work regularly or on an as-needed basis.",
"output": "∀x (Volunteer(x) → WorkRegularly(x) ∨ WorkAsNeeded(x))"
},
{
"input": "Translate into first-order logic: Some volunteers are trained.",
"output": "∃x (Volunteer(x) → Trained(x))"
},
{
"input": "Translate into first-order logic: Volunteers work in groups or individually.",
"output": "∀x (Volunteer(x) → (WorkInGroup(x) ∨ WorkIndividually(x)))"
},
{
"input": "Translate into first-order logic: Environmental volunteers contribute toward environmental management or conservation.",
"output": "∀x (Volunteer(x) ∧ Environmental(x) → (ContributeTo(x, environmentalmanagement) ∨ ContributeTo(x, environmentalconservation)))"
},
{
"input": "Translate into first-order logic: Participating in natural disaster response is an example of volunteers working in groups on an as-needed basis.",
"output": "∃x (Volunteer(x) ∧ ContributeTo(x, naturaldisasterresponse) → WorkInGroup(x) ∧ WorkAsNeeded(x))"
},
{
"input": "Translate into first-order logic: All volunteers receive intangible benefits for their work.",
"output": "∀x (Volunteer(x) → GetIntangibleBenefits(x))"
},
{
"input": "Translate into first-order logic: Volunteers work regularly or on an as-needed basis.",
"output": "∀x (Volunteer(x) → WorkRegularly(x) ∨ WorkAsNeeded(x))"
},
{
"input": "Translate into first-order logic: Some volunteers are trained.",
"output": "∃x (Volunteer(x) → Trained(x))"
},
{
"input": "Translate into first-order logic: Volunteers work in groups or individually.",
"output": "∀x (Volunteer(x) → (WorkInGroup(x) ∨ WorkIndividually(x)))"
},
{
"input": "Translate into first-order logic: Environmental volunteers contribute toward environmental management or conservation.",
"output": "∀x (Volunteer(x) ∧ Environmental(x) → (ContributeTo(x, environmentalmanagement) ∨ ContributeTo(x, environmentalconservation)))"
},
{
"input": "Translate into first-order logic: Participating in natural disaster response is an example of volunteers working in groups on an as-needed basis.",
"output": "∃x (Volunteer(x) ∧ ContributeTo(x, naturaldisasterresponse) → WorkInGroup(x) ∧ WorkAsNeeded(x))"
},
{
"input": "Translate into first-order logic: All volunteers receive intangible benefits for their work.",
"output": "∀x (Volunteer(x) → GetIntangibleBenefits(x))"
},
{
"input": "Translate into first-order logic: Volunteers work regularly or on an as-needed basis.",
"output": "∀x (Volunteer(x) → WorkRegularly(x) ∨ WorkAsNeeded(x))"
},
{
"input": "Translate into first-order logic: Some volunteers are trained.",
"output": "∃x (Volunteer(x) → Trained(x))"
},
{
"input": "Translate into first-order logic: Volunteers work in groups or individually.",
"output": "∀x (Volunteer(x) → (WorkInGroup(x) ∨ WorkIndividually(x)))"
},
{
"input": "Translate into first-order logic: Environmental volunteers contribute toward environmental management or conservation.",
"output": "∀x (Volunteer(x) ∧ Environmental(x) → (ContributeTo(x, environmentalmanagement) ∨ ContributeTo(x, environmentalconservation)))"
},
{
"input": "Translate into first-order logic: Participating in natural disaster response is an example of volunteers working in groups on an as-needed basis.",
"output": "∃x (Volunteer(x) ∧ ContributeTo(x, naturaldisasterresponse) → WorkInGroup(x) ∧ WorkAsNeeded(x))"
},
{
"input": "Translate into first-order logic: All people who are very consistent and enjoy sticking to their regular routines do not like surprises.",
"output": "∀x (Consistent(x) → NoSurprises(x))"
},
{
"input": "Translate into first-order logic: If people wear flannel shirts every day, then they are very consistent and enjoy sticking to their regular routines.",
"output": "∀x (Flannel(x) → Consistent(x))"
},
{
"input": "Translate into first-order logic: If people do not like shopping for clothes and other materialistic goods, then they wear flannel shirts every day.",
"output": "∀x (NoShopping(x) → Flannel(x))"
},
{
"input": "Translate into first-order logic: All old people living in stable homes do not like surprises.",
"output": "∀x (Old(x) → NoSurprises(x))"
},
{
"input": "Translate into first-order logic: If people have very high energy and are impulsive, then they like surprises.",
"output": "∀x (Impulsive(x) → ¬NoSurprises(x))"
},
{
"input": "Translate into first-order logic: If Mike is not a person who wears flannel shirts every day and has very high energy and is impulsive, then Mike either is very consistent and enjoys sticking to his regular routines or does not like surprises.",
"output": "¬(NoSurprises(mike) ∧ Impulsive(mike)) → Consistent(mike) ⊕ NoSurprises(mike)"
},
{
"input": "Translate into first-order logic: All people who are very consistent and enjoy sticking to their regular routines do not like surprises.",
"output": "∀x (Consistent(x) → NoSurprises(x))"
},
{
"input": "Translate into first-order logic: If people wear flannel shirts every day, then they are very consistent and enjoy sticking to their regular routines.",
"output": "∀x (Flannel(x) → Consistent(x))"
},
{
"input": "Translate into first-order logic: If people do not like shopping for clothes and other materialistic goods, then they wear flannel shirts every day.",
"output": "∀x (NoShopping(x) → Flannel(x))"
},
{
"input": "Translate into first-order logic: All old people living in stable homes do not like surprises.",
"output": "∀x (Old(x) → NoSurprises(x))"
},
{
"input": "Translate into first-order logic: If people have very high energy and are impulsive, then they like surprises.",
"output": "∀x (Impulsive(x) → ¬NoSurprises(x))"
},
{
"input": "Translate into first-order logic: If Mike is not a person who wears flannel shirts every day and has very high energy and is impulsive, then Mike either is very consistent and enjoys sticking to his regular routines or does not like surprises.",
"output": "¬(NoSurprises(mike) ∧ Impulsive(mike)) → Consistent(mike) ⊕ NoSurprises(mike)"
},
{
"input": "Translate into first-order logic: All people who are very consistent and enjoy sticking to their regular routines do not like surprises.",
"output": "∀x (Consistent(x) → NoSurprises(x))"
},
{
"input": "Translate into first-order logic: If people wear flannel shirts every day, then they are very consistent and enjoy sticking to their regular routines.",
"output": "∀x (Flannel(x) → Consistent(x))"
},
{
"input": "Translate into first-order logic: If people do not like shopping for clothes and other materialistic goods, then they wear flannel shirts every day.",
"output": "∀x (NoShopping(x) → Flannel(x))"
},
{
"input": "Translate into first-order logic: All old people living in stable homes do not like surprises.",
"output": "∀x (Old(x) → NoSurprises(x))"
},
{
"input": "Translate into first-order logic: If people have very high energy and are impulsive, then they like surprises.",
"output": "∀x (Impulsive(x) → ¬NoSurprises(x))"
},
{
"input": "Translate into first-order logic: If Mike is not a person who wears flannel shirts every day and has very high energy and is impulsive, then Mike either is very consistent and enjoys sticking to his regular routines or does not like surprises.",
"output": "¬(NoSurprises(mike) ∧ Impulsive(mike)) → Consistent(mike) ⊕ NoSurprises(mike)"
},
{
"input": "Translate into first-order logic: Adam owns cars.",
"output": "∃x (Owns(adam, x))"
},
{
"input": "Translate into first-order logic: Adam has a favorite car.",
"output": "∃x (Favorite(adam, x))"
},
{
"input": "Translate into first-order logic: Among the cars he owns, Adam's favorite car is European.",
"output": "∀x ((Owns(adam, x) ∧ Favorite(adam, x)) → European(x))"
},
{
"input": "Translate into first-order logic: Adam broke his favorite car.",
"output": "∀x ((Owns(adam, x) ∧ Favorite(adam, x)) → Broke(adam, x))"
},
{
"input": "Translate into first-order logic: Adam owns cars.",
"output": "∃x (Owns(adam, x))"
},
{
"input": "Translate into first-order logic: Adam has a favorite car.",
"output": "∃x (Favorite(adam, x))"
},
{
"input": "Translate into first-order logic: Among the cars he owns, Adam's favorite car is European.",
"output": "∀x ((Owns(adam, x) ∧ Favorite(adam, x)) → European(x))"
},
{
"input": "Translate into first-order logic: Adam broke his favorite car.",
"output": "∀x ((Owns(adam, x) ∧ Favorite(adam, x)) → Broke(adam, x))"
},
{
"input": "Translate into first-order logic: No buildings in New Haven are higher than 400 meters.",
"output": "∀x (NewHaven(x) → ¬High(x))"
},
{
"input": "Translate into first-order logic: All buildings managed by Yale Housing are in New Haven.",
"output": "∀x (YaleHousing(x) → NewHaven(x))"
},
{
"input": "Translate into first-order logic: All buildings in Manhattan are higher than 400 meters.",
"output": "∀x (Manhattan(x) → High(x))"
},
{
"input": "Translate into first-order logic: All buildings owned by Bloomberg are in Manhattan.",
"output": "∀x (Bloomberg(x) → Manhattan(x))"
},
{
"input": "Translate into first-order logic: All buildings with the Bloomberg logo are buildings owned by Bloomberg.",
"output": "∀x (BloombergLogo(x) → Bloomberg(x))"
},
{
"input": "Translate into first-order logic: Tower A is neither in New Haven nor in Manhattan.",
"output": "¬(NewHaven(towera) ⊕ Manhattan(towera))"
},
{
"input": "Translate into first-order logic: Tower B is a building with the Bloomberg logo and in Manhattan.",
"output": "BloombergLogo(towerb) ∧ Manhattan(towerb)"
},
{
"input": "Translate into first-order logic: No buildings in New Haven are higher than 400 meters.",
"output": "∀x (NewHaven(x) → ¬High(x))"
},
{
"input": "Translate into first-order logic: All buildings managed by Yale Housing are in New Haven.",
"output": "∀x (YaleHousing(x) → NewHaven(x))"
},
{
"input": "Translate into first-order logic: All buildings in Manhattan are higher than 400 meters.",
"output": "∀x (Manhattan(x) → High(x))"
},
{
"input": "Translate into first-order logic: All buildings owned by Bloomberg are in Manhattan.",
"output": "∀x (Bloomberg(x) → Manhattan(x))"
},
{
"input": "Translate into first-order logic: All buildings with the Bloomberg logo are buildings owned by Bloomberg.",
"output": "∀x (BloombergLogo(x) → Bloomberg(x))"
},
{
"input": "Translate into first-order logic: Tower A is neither in New Haven nor in Manhattan.",
"output": "¬(NewHaven(towera) ⊕ Manhattan(towera))"
},
{
"input": "Translate into first-order logic: Tower B is a building with the Bloomberg logo and in Manhattan.",
"output": "BloombergLogo(towerb) ∧ Manhattan(towerb)"
},
{
"input": "Translate into first-order logic: No buildings in New Haven are higher than 400 meters.",
"output": "∀x (NewHaven(x) → ¬High(x))"
},
{
"input": "Translate into first-order logic: All buildings managed by Yale Housing are in New Haven.",
"output": "∀x (YaleHousing(x) → NewHaven(x))"
},
{
"input": "Translate into first-order logic: All buildings in Manhattan are higher than 400 meters.",
"output": "∀x (Manhattan(x) → High(x))"
},
{
"input": "Translate into first-order logic: All buildings owned by Bloomberg are in Manhattan.",
"output": "∀x (Bloomberg(x) → Manhattan(x))"
},
{
"input": "Translate into first-order logic: All buildings with the Bloomberg logo are buildings owned by Bloomberg.",
"output": "∀x (BloombergLogo(x) → Bloomberg(x))"
},
{
"input": "Translate into first-order logic: Tower A is neither in New Haven nor in Manhattan.",
"output": "¬(NewHaven(towera) ⊕ Manhattan(towera))"
},
{
"input": "Translate into first-order logic: Tower B is a building with the Bloomberg logo and in Manhattan.",
"output": "BloombergLogo(towerb) ∧ Manhattan(towerb)"
},
{
"input": "Translate into first-order logic: No buildings in New Haven are higher than 400 meters.",
"output": "∀x (NewHaven(x) → ¬High(x))"
},
{
"input": "Translate into first-order logic: All buildings managed by Yale Housing are in New Haven.",
"output": "∀x (YaleHousing(x) → NewHaven(x))"
},
{
"input": "Translate into first-order logic: All buildings in Manhattan are higher than 400 meters.",
"output": "∀x (Manhattan(x) → High(x))"
},
{
"input": "Translate into first-order logic: All buildings owned by Bloomberg are in Manhattan.",
"output": "∀x (Bloomberg(x) → Manhattan(x))"
},
{
"input": "Translate into first-order logic: All buildings with the Bloomberg logo are buildings owned by Bloomberg.",
"output": "∀x (BloombergLogo(x) → Bloomberg(x))"
},
{
"input": "Translate into first-order logic: Tower A is neither in New Haven nor in Manhattan.",
"output": "¬(NewHaven(towera) ⊕ Manhattan(towera))"
},
{
"input": "Translate into first-order logic: Tower B is a building with the Bloomberg logo and in Manhattan.",
"output": "BloombergLogo(towerb) ∧ Manhattan(towerb)"
},
{
"input": "Translate into first-order logic: No fish are birds.",
"output": "∀x (Fish(x) → ¬Bird(x))"
},
{
"input": "Translate into first-order logic: Everything that is an osprey is a bird.",
"output": "∀x (Osprey(x) → Bird(x))"
},
{
"input": "Translate into first-order logic: If something is a carp, then it is a fish.",
"output": "∀x (Carp(x) → Fish(x))"
},
{
"input": "Translate into first-order logic: All goldfish are carp.",
"output": "∀x (Goldfish(x) → Carp(x))"
},
{
"input": "Translate into first-order logic: If Bubbles is either an osprey or a goldfish, then Bubbles is not a fish.",
"output": "Osprey(bubbles) ⊕ Carp(bubbles) → ¬Fish(bubbles)"
},
{
"input": "Translate into first-order logic: No fish are birds.",
"output": "∀x (Fish(x) → ¬Bird(x))"
},
{
"input": "Translate into first-order logic: Everything that is an osprey is a bird.",
"output": "∀x (Osprey(x) → Bird(x))"
},
{
"input": "Translate into first-order logic: If something is a carp, then it is a fish.",
"output": "∀x (Carp(x) → Fish(x))"
},
{
"input": "Translate into first-order logic: All goldfish are carp.",
"output": "∀x (Goldfish(x) → Carp(x))"
},
{
"input": "Translate into first-order logic: If Bubbles is either an osprey or a goldfish, then Bubbles is not a fish.",
"output": "Osprey(bubbles) ⊕ Carp(bubbles) → ¬Fish(bubbles)"
},
{
"input": "Translate into first-order logic: No fish are birds.",
"output": "∀x (Fish(x) → ¬Bird(x))"
},
{
"input": "Translate into first-order logic: Everything that is an osprey is a bird.",
"output": "∀x (Osprey(x) → Bird(x))"
},
{
"input": "Translate into first-order logic: If something is a carp, then it is a fish.",
"output": "∀x (Carp(x) → Fish(x))"
},
{
"input": "Translate into first-order logic: All goldfish are carp.",
"output": "∀x (Goldfish(x) → Carp(x))"
},
{
"input": "Translate into first-order logic: If Bubbles is either an osprey or a goldfish, then Bubbles is not a fish.",
"output": "Osprey(bubbles) ⊕ Carp(bubbles) → ¬Fish(bubbles)"
},
{
"input": "Translate into first-order logic: Mr. and Mrs. Smith make a travel plan, they want to go to a city in California or Florida, and where neither of them has ever been.",
"output": "∀x (WantToGo(x) → (California(x) ∨ Florida(x)) ∧ (NeverGo(x)))"
},
{
"input": "Translate into first-order logic: Cities in California that they are interested in are San Francisco, Los Angeles, and San Diego.",
"output": "∀x (((SanFrancisco(x) ∨ LosAngeles(x) ∨ SanDiego(x)) ∧ California(x)) → WantToGo(x))"
},
{
"input": "Translate into first-order logic: Cities in Florida that they are interested in are Orlando and Miami.",
"output": "∀x ((Orlando(x) ∨ Miami(x)) ∧ Florida(x)) → WantToGo(x))"
},
{
"input": "Translate into first-order logic: Mr. Smith has been to two cities in California.",
"output": "CaliforniaCityVisited(mr.smith, two)"
},
{
"input": "Translate into first-order logic: Mrs. Smith has been to one city in Florida.",
"output": "FloridaCityVisited(mrs.smith, one)"
},
{
"input": "Translate into first-order logic: Mr. and Mrs. Smith make a travel plan, they want to go to a city in California or Florida, and where neither of them has ever been.",
"output": "∀x (WantToGo(x) → (California(x) ∨ Florida(x)) ∧ (NeverGo(x)))"
},
{
"input": "Translate into first-order logic: Cities in California that they are interested in are San Francisco, Los Angeles, and San Diego.",
"output": "∀x (((SanFrancisco(x) ∨ LosAngeles(x) ∨ SanDiego(x)) ∧ California(x)) → WantToGo(x))"
},
{
"input": "Translate into first-order logic: Cities in Florida that they are interested in are Orlando and Miami.",
"output": "∀x ((Orlando(x) ∨ Miami(x)) ∧ Florida(x)) → WantToGo(x))"
},
{
"input": "Translate into first-order logic: Mr. Smith has been to two cities in California.",
"output": "CaliforniaCityVisited(mr.smith, two)"
},
{
"input": "Translate into first-order logic: Mrs. Smith has been to one city in Florida.",
"output": "FloridaCityVisited(mrs.smith, one)"
},
{
"input": "Translate into first-order logic: Mr. and Mrs. Smith make a travel plan, they want to go to a city in California or Florida, and where neither of them has ever been.",
"output": "∀x (WantToGo(x) → (California(x) ∨ Florida(x)) ∧ (NeverGo(x)))"
},
{
"input": "Translate into first-order logic: Cities in California that they are interested in are San Francisco, Los Angeles, and San Diego.",
"output": "∀x (((SanFrancisco(x) ∨ LosAngeles(x) ∨ SanDiego(x)) ∧ California(x)) → WantToGo(x))"
},
{
"input": "Translate into first-order logic: Cities in Florida that they are interested in are Orlando and Miami.",
"output": "∀x ((Orlando(x) ∨ Miami(x)) ∧ Florida(x)) → WantToGo(x))"
},
{
"input": "Translate into first-order logic: Mr. Smith has been to two cities in California.",
"output": "CaliforniaCityVisited(mr.smith, two)"
},
{
"input": "Translate into first-order logic: Mrs. Smith has been to one city in Florida.",
"output": "FloridaCityVisited(mrs.smith, one)"
},
{
"input": "Translate into first-order logic: Everything is either big or small.",
"output": "∀x (Big(x) ⊕ Small(x))"
},
{
"input": "Translate into first-order logic: All big things are heavy.",
"output": "∀x (Big(x) → Heavy(x))"
},
{
"input": "Translate into first-order logic: All small things are light.",
"output": "∀x (Small(x) → Light(x))"
},
{
"input": "Translate into first-order logic: All heavy things are still.",
"output": "∀x (Heavy(x) → Still(x))"
},
{
"input": "Translate into first-order logic: All light things are unstable.",
"output": "∀x (Light(x) → Unstable(x))"
},
{
"input": "Translate into first-order logic: All unstable things are changing.",
"output": "∀x (Unstable(x) → Changing(x))"
},
{
"input": "Translate into first-order logic: All unstable things are kinetic.",
"output": "∀x (Unstable(x) → Kinetic(x))"
},
{
"input": "Translate into first-order logic: A bird is not both heavy and still.",
"output": "¬(Heavy(bird) ∧ Still(bird))"
},
{
"input": "Translate into first-order logic: Everything is either big or small.",
"output": "∀x (Big(x) ⊕ Small(x))"
},
{
"input": "Translate into first-order logic: All big things are heavy.",
"output": "∀x (Big(x) → Heavy(x))"
},
{
"input": "Translate into first-order logic: All small things are light.",
"output": "∀x (Small(x) → Light(x))"
},
{
"input": "Translate into first-order logic: All heavy things are still.",
"output": "∀x (Heavy(x) → Still(x))"
},
{
"input": "Translate into first-order logic: All light things are unstable.",
"output": "∀x (Light(x) → Unstable(x))"
},
{
"input": "Translate into first-order logic: All unstable things are changing.",
"output": "∀x (Unstable(x) → Changing(x))"
},
{
"input": "Translate into first-order logic: All unstable things are kinetic.",
"output": "∀x (Unstable(x) → Kinetic(x))"
},
{
"input": "Translate into first-order logic: A bird is not both heavy and still.",
"output": "¬(Heavy(bird) ∧ Still(bird))"
},
{
"input": "Translate into first-order logic: Everything is either big or small.",
"output": "∀x (Big(x) ⊕ Small(x))"
},
{
"input": "Translate into first-order logic: All big things are heavy.",
"output": "∀x (Big(x) → Heavy(x))"
},
{
"input": "Translate into first-order logic: All small things are light.",
"output": "∀x (Small(x) → Light(x))"
},
{
"input": "Translate into first-order logic: All heavy things are still.",
"output": "∀x (Heavy(x) → Still(x))"
},
{
"input": "Translate into first-order logic: All light things are unstable.",
"output": "∀x (Light(x) → Unstable(x))"
},
{
"input": "Translate into first-order logic: All unstable things are changing.",
"output": "∀x (Unstable(x) → Changing(x))"
},
{
"input": "Translate into first-order logic: All unstable things are kinetic.",
"output": "∀x (Unstable(x) → Kinetic(x))"
},
{
"input": "Translate into first-order logic: A bird is not both heavy and still.",
"output": "¬(Heavy(bird) ∧ Still(bird))"
},
{
"input": "Translate into first-order logic: Everything is either big or small.",
"output": "∀x (Big(x) ⊕ Small(x))"
},
{
"input": "Translate into first-order logic: All big things are heavy.",
"output": "∀x (Big(x) → Heavy(x))"
},
{
"input": "Translate into first-order logic: All small things are light.",
"output": "∀x (Small(x) → Light(x))"
},
{
"input": "Translate into first-order logic: All heavy things are still.",
"output": "∀x (Heavy(x) → Still(x))"
},
{
"input": "Translate into first-order logic: All light things are unstable.",
"output": "∀x (Light(x) → Unstable(x))"
},
{
"input": "Translate into first-order logic: All unstable things are changing.",
"output": "∀x (Unstable(x) → Changing(x))"
},
{
"input": "Translate into first-order logic: All unstable things are kinetic.",
"output": "∀x (Unstable(x) → Kinetic(x))"
},
{
"input": "Translate into first-order logic: A bird is not both heavy and still.",
"output": "¬(Heavy(bird) ∧ Still(bird))"
},
{
"input": "Translate into first-order logic: Everything is either big or small.",
"output": "∀x (Big(x) ⊕ Small(x))"
},
{
"input": "Translate into first-order logic: All big things are heavy.",
"output": "∀x (Big(x) → Heavy(x))"
},
{
"input": "Translate into first-order logic: All small things are light.",
"output": "∀x (Small(x) → Light(x))"
},
{
"input": "Translate into first-order logic: All heavy things are still.",
"output": "∀x (Heavy(x) → Still(x))"
},
{
"input": "Translate into first-order logic: All light things are unstable.",
"output": "∀x (Light(x) → Unstable(x))"
},
{
"input": "Translate into first-order logic: All unstable things are changing.",
"output": "∀x (Unstable(x) → Changing(x))"
},
{
"input": "Translate into first-order logic: All unstable things are kinetic.",
"output": "∀x (Unstable(x) → Kinetic(x))"
},
{
"input": "Translate into first-order logic: A bird is not both heavy and still.",
"output": "¬(Heavy(bird) ∧ Still(bird))"
},
{
"input": "Translate into first-order logic: Everything is either big or small.",
"output": "∀x (Big(x) ⊕ Small(x))"
},
{
"input": "Translate into first-order logic: All big things are heavy.",
"output": "∀x (Big(x) → Heavy(x))"
},
{
"input": "Translate into first-order logic: All small things are light.",
"output": "∀x (Small(x) → Light(x))"
},
{
"input": "Translate into first-order logic: All heavy things are still.",
"output": "∀x (Heavy(x) → Still(x))"
},
{
"input": "Translate into first-order logic: All light things are unstable.",
"output": "∀x (Light(x) → Unstable(x))"
},
{
"input": "Translate into first-order logic: All unstable things are changing.",
"output": "∀x (Unstable(x) → Changing(x))"
},
{
"input": "Translate into first-order logic: All unstable things are kinetic.",
"output": "∀x (Unstable(x) → Kinetic(x))"
},
{
"input": "Translate into first-order logic: A bird is not both heavy and still.",
"output": "¬(Heavy(bird) ∧ Still(bird))"
},
{
"input": "Translate into first-order logic: DI Ray is a police procedural television series.",
"output": "TelevisionSeries(diRay)"
},
{
"input": "Translate into first-order logic: DI Ray was created and written by Maya Sondhi.",
"output": "Create(maya, diRay) ∧ Write(maya, diRay)"
},
{
"input": "Translate into first-order logic: DI Ray was produced by Jed Mercurio.",
"output": "Produce(jed, diRay)"
},
{
"input": "Translate into first-order logic: Maya Sondhi and Jed Mercurio are both British.",
"output": "British(maya) ∧ British(jed) "
},
{
"input": "Translate into first-order logic: DI Ray is a police procedural television series.",
"output": "TelevisionSeries(diRay)"
},
{
"input": "Translate into first-order logic: DI Ray was created and written by Maya Sondhi.",
"output": "Create(maya, diRay) ∧ Write(maya, diRay)"
},
{
"input": "Translate into first-order logic: DI Ray was produced by Jed Mercurio.",
"output": "Produce(jed, diRay)"
},
{
"input": "Translate into first-order logic: Maya Sondhi and Jed Mercurio are both British.",
"output": "British(maya) ∧ British(jed) "
},
{
"input": "Translate into first-order logic: All men are human.",
"output": "∀x (Man(x) → Human(x))"
},
{
"input": "Translate into first-order logic: All gentlemen are men.",
"output": "∀x (Gentleman(x) → Man(x))"
},
{
"input": "Translate into first-order logic: All lawyers are gentlemen.",
"output": "∀x (Lawyer(x) → Gentleman(x))"
},
{
"input": "Translate into first-order logic: All women are human.",
"output": "∀x (Woman(x) → Human(x))"
},
{
"input": "Translate into first-order logic: No sheep are human.",
"output": "∀x (Sheep(x) → ¬Human(x))"
},
{
"input": "Translate into first-order logic: If Mike is not both a human and a sheep, then Mike is either a man or a human.",
"output": "(¬Human(mike) ∨ ¬Sheep(mike)) → Man(mike) ⊕ Human(mike)"
},
{
"input": "Translate into first-order logic: All men are human.",
"output": "∀x (Man(x) → Human(x))"
},
{
"input": "Translate into first-order logic: All gentlemen are men.",
"output": "∀x (Gentleman(x) → Man(x))"
},
{
"input": "Translate into first-order logic: All lawyers are gentlemen.",
"output": "∀x (Lawyer(x) → Gentleman(x))"
},
{
"input": "Translate into first-order logic: All women are human.",
"output": "∀x (Woman(x) → Human(x))"
},
{
"input": "Translate into first-order logic: No sheep are human.",
"output": "∀x (Sheep(x) → ¬Human(x))"
},
{
"input": "Translate into first-order logic: If Mike is not both a human and a sheep, then Mike is either a man or a human.",
"output": "(¬Human(mike) ∨ ¬Sheep(mike)) → Man(mike) ⊕ Human(mike)"
},
{
"input": "Translate into first-order logic: All men are human.",
"output": "∀x (Man(x) → Human(x))"
},
{
"input": "Translate into first-order logic: All gentlemen are men.",
"output": "∀x (Gentleman(x) → Man(x))"
},
{
"input": "Translate into first-order logic: All lawyers are gentlemen.",
"output": "∀x (Lawyer(x) → Gentleman(x))"
},
{
"input": "Translate into first-order logic: All women are human.",
"output": "∀x (Woman(x) → Human(x))"
},
{
"input": "Translate into first-order logic: No sheep are human.",
"output": "∀x (Sheep(x) → ¬Human(x))"
},
{
"input": "Translate into first-order logic: If Mike is not both a human and a sheep, then Mike is either a man or a human.",
"output": "(¬Human(mike) ∨ ¬Sheep(mike)) → Man(mike) ⊕ Human(mike)"
},
{
"input": "Translate into first-order logic: Some defenders are centerback.",
"output": "∃x (Defender(x) ∧ Centerback(x))"
},
{
"input": "Translate into first-order logic: All defenders are soccer players.",
"output": "∀x (Defender(x) → SoccerPlayer(x))"
},
{
"input": "Translate into first-order logic: No soccer players are professional basketball players.",
"output": "¬(∃x (SoccerPlayer(x) ∧ ProfessionalBasketballPlayer(x)))"
},
{
"input": "Translate into first-order logic: All NBA players are professional basketball players.",
"output": "∀x (NBAPlayer(x) → ProfessionalBasketballPlayer(x))"
},
{
"input": "Translate into first-order logic: Stephen Curry is an NBA player.",
"output": "NBAPlayer(stephencurry)"
},
{
"input": "Translate into first-order logic: Some defenders are centerback.",
"output": "∃x (Defender(x) ∧ Centerback(x))"
},
{
"input": "Translate into first-order logic: All defenders are soccer players.",
"output": "∀x (Defender(x) → SoccerPlayer(x))"
},
{
"input": "Translate into first-order logic: No soccer players are professional basketball players.",
"output": "¬(∃x (SoccerPlayer(x) ∧ ProfessionalBasketballPlayer(x)))"
},
{
"input": "Translate into first-order logic: All NBA players are professional basketball players.",
"output": "∀x (NBAPlayer(x) → ProfessionalBasketballPlayer(x))"
},
{
"input": "Translate into first-order logic: Stephen Curry is an NBA player.",
"output": "NBAPlayer(stephencurry)"
},
{
"input": "Translate into first-order logic: Some defenders are centerback.",
"output": "∃x (Defender(x) ∧ Centerback(x))"
},
{
"input": "Translate into first-order logic: All defenders are soccer players.",
"output": "∀x (Defender(x) → SoccerPlayer(x))"
},
{
"input": "Translate into first-order logic: No soccer players are professional basketball players.",
"output": "¬(∃x (SoccerPlayer(x) ∧ ProfessionalBasketballPlayer(x)))"
},
{
"input": "Translate into first-order logic: All NBA players are professional basketball players.",
"output": "∀x (NBAPlayer(x) → ProfessionalBasketballPlayer(x))"
},
{
"input": "Translate into first-order logic: Stephen Curry is an NBA player.",
"output": "NBAPlayer(stephencurry)"
},
{
"input": "Translate into first-order logic: If a person doesn't have enough money to buy a product, then that person can't buy it.",
"output": "∀x ∀y (Person(x) ∧ Product(y) ∧ ¬HaveEnoughMoneyFor(x, y) → ¬Buy(x, y))"
},
{
"input": "Translate into first-order logic: Monitors are products.",
"output": "∀x (Monitor(x) → Product(x))"
},
{
"input": "Translate into first-order logic: 4k monitors are more expensive than 1080 monitors and 2k monitors.",
"output": "∀x ∀y ∀z (Monitor(x) ∧ Monitor(y) ∧ Monitor(z) ∧ FourK(x) ∧ OneOEightO(y) ∧ TwoK(z) → MoreExpensive(x, y) ∧ MoreExpensive(x, z))"
},
{
"input": "Translate into first-order logic: John is a person.",
"output": "Person(john)"
},
{
"input": "Translate into first-order logic: John doesn't have enough money to buy a 2k monitor.",
"output": "∀x (Monitor(x) ∧ TwoK(x) → ¬HaveEnoughMoneyFor(john, x))"
},
{
"input": "Translate into first-order logic: If a person doesn't have enough money to buy a product, then that person can't buy it.",
"output": "∀x ∀y (Person(x) ∧ Product(y) ∧ ¬HaveEnoughMoneyFor(x, y) → ¬Buy(x, y))"
},
{
"input": "Translate into first-order logic: Monitors are products.",
"output": "∀x (Monitor(x) → Product(x))"
},
{
"input": "Translate into first-order logic: 4k monitors are more expensive than 1080 monitors and 2k monitors.",
"output": "∀x ∀y ∀z (Monitor(x) ∧ Monitor(y) ∧ Monitor(z) ∧ FourK(x) ∧ OneOEightO(y) ∧ TwoK(z) → MoreExpensive(x, y) ∧ MoreExpensive(x, z))"
},
{
"input": "Translate into first-order logic: John is a person.",
"output": "Person(john)"
},
{
"input": "Translate into first-order logic: John doesn't have enough money to buy a 2k monitor.",
"output": "∀x (Monitor(x) ∧ TwoK(x) → ¬HaveEnoughMoneyFor(john, x))"
},
{
"input": "Translate into first-order logic: All artificial satellites are important scientific achievements.",
"output": "∀x (ArtificialSatellite(x) → ImportantScientificAchievement(x))"
},
{
"input": "Translate into first-order logic: Some artificial satellites are not U.S. inventions.",
"output": "∃x (ArtificialSatellite(x) ∧ ¬USInvention(x))"
},
{
"input": "Translate into first-order logic: Some cats are not pets.",
"output": "∃x (Cat(x) ∧ ¬Pet(x))"
},
{
"input": "Translate into first-order logic: All cats are mammals.",
"output": "∀x (Cat(x) → Mammal(x))"
},
{
"input": "Translate into first-order logic: If people visit a coffee shop at least three times a week, then they are addicted to coffee or other caffeinated drinks.",
"output": "∀x (CoffeeShop(x) → CaffeineAddict(x))"
},
{
"input": "Translate into first-order logic: People either visit a coffee shop at least three times a week or order takeout at least once a day.",
"output": "∀x (CoffeeShop(x) ∨ Takeout(x))"
},
{
"input": "Translate into first-order logic: If people make a lot of their own food at home using recipes and online guides, then they order takeout at least once a day.",
"output": "∀x (MakeFood(x) → Takeout(x))"
},
{
"input": "Translate into first-order logic: If people own at least one coffeemaker and one blender in their home, then they do not order takeout at least once a day.",
"output": "∀x (KitchenAppliance(x) → ¬Takeout(x))"
},
{
"input": "Translate into first-order logic: All people who lead very busy lives that include 12-hour work hours make a lot of their own food at home using recipes and online guides.",
"output": "∀x (Busy(x) → MakeFood(x))"
},
{
"input": "Translate into first-order logic: Sam is either both addicted to coffee or other caffeinated drinks or leads very busy lives that include 12-hour work hours, or she is neither addicted to coffee and other caffeinated drinks nor leads very busy lives that include 12-hour work hours",
"output": "(CaffeineAddict(sam) ∧ Busy(sam)) ⊕ (¬CaffeineAddict(sam) ∧ ¬Busy(sam))"
},
{
"input": "Translate into first-order logic: If people visit a coffee shop at least three times a week, then they are addicted to coffee or other caffeinated drinks.",
"output": "∀x (CoffeeShop(x) → CaffeineAddict(x))"
},
{
"input": "Translate into first-order logic: People either visit a coffee shop at least three times a week or order takeout at least once a day.",
"output": "∀x (CoffeeShop(x) ∨ Takeout(x))"
},
{
"input": "Translate into first-order logic: If people make a lot of their own food at home using recipes and online guides, then they order takeout at least once a day.",
"output": "∀x (MakeFood(x) → Takeout(x))"
},
{
"input": "Translate into first-order logic: If people own at least one coffeemaker and one blender in their home, then they do not order takeout at least once a day.",
"output": "∀x (KitchenAppliance(x) → ¬Takeout(x))"
},
{
"input": "Translate into first-order logic: All people who lead very busy lives that include 12-hour work hours make a lot of their own food at home using recipes and online guides.",
"output": "∀x (Busy(x) → MakeFood(x))"
},
{
"input": "Translate into first-order logic: Sam is either both addicted to coffee or other caffeinated drinks or leads very busy lives that include 12-hour work hours, or she is neither addicted to coffee and other caffeinated drinks nor leads very busy lives that include 12-hour work hours",
"output": "(CaffeineAddict(sam) ∧ Busy(sam)) ⊕ (¬CaffeineAddict(sam) ∧ ¬Busy(sam))"
},
{
"input": "Translate into first-order logic: If people visit a coffee shop at least three times a week, then they are addicted to coffee or other caffeinated drinks.",
"output": "∀x (CoffeeShop(x) → CaffeineAddict(x))"
},
{
"input": "Translate into first-order logic: People either visit a coffee shop at least three times a week or order takeout at least once a day.",
"output": "∀x (CoffeeShop(x) ∨ Takeout(x))"
},
{
"input": "Translate into first-order logic: If people make a lot of their own food at home using recipes and online guides, then they order takeout at least once a day.",
"output": "∀x (MakeFood(x) → Takeout(x))"
},
{
"input": "Translate into first-order logic: If people own at least one coffeemaker and one blender in their home, then they do not order takeout at least once a day.",
"output": "∀x (KitchenAppliance(x) → ¬Takeout(x))"
},
{
"input": "Translate into first-order logic: All people who lead very busy lives that include 12-hour work hours make a lot of their own food at home using recipes and online guides.",
"output": "∀x (Busy(x) → MakeFood(x))"
},
{
"input": "Translate into first-order logic: Sam is either both addicted to coffee or other caffeinated drinks or leads very busy lives that include 12-hour work hours, or she is neither addicted to coffee and other caffeinated drinks nor leads very busy lives that include 12-hour work hours",
"output": "(CaffeineAddict(sam) ∧ Busy(sam)) ⊕ (¬CaffeineAddict(sam) ∧ ¬Busy(sam))"
},
{
"input": "Translate into first-order logic: No professional basketball players are soccer players.",
"output": "¬(∃x (SoccerPlayer(x) ∧ ProfessionalBasketballPlayer(x)))"
},
{
"input": "Translate into first-order logic: All NBA players are professional basketball players.",
"output": "∀x (NBAPlayer(x) → ProfessionalBasketballPlayer(x))"
},
{
"input": "Translate into first-order logic: All defenders are soccer players.",
"output": "∀x (Defender(x) → SoccerPlayer(x))"
},
{
"input": "Translate into first-order logic: All centerbacks are defenders.",
"output": "∀x (Centerback(x) → Defender(x))"
},
{
"input": "Translate into first-order logic: Roger Federer is not an NBA player or a defender.",
"output": "¬(NBAPlayer(rogerfederer) ⊕ Defender(rogerfederer))"
},
{
"input": "Translate into first-order logic: No professional basketball players are soccer players.",
"output": "¬(∃x (SoccerPlayer(x) ∧ ProfessionalBasketballPlayer(x)))"
},
{
"input": "Translate into first-order logic: All NBA players are professional basketball players.",
"output": "∀x (NBAPlayer(x) → ProfessionalBasketballPlayer(x))"
},
{
"input": "Translate into first-order logic: All defenders are soccer players.",
"output": "∀x (Defender(x) → SoccerPlayer(x))"
},
{
"input": "Translate into first-order logic: All centerbacks are defenders.",
"output": "∀x (Centerback(x) → Defender(x))"
},
{
"input": "Translate into first-order logic: Roger Federer is not an NBA player or a defender.",
"output": "¬(NBAPlayer(rogerfederer) ⊕ Defender(rogerfederer))"
},
{
"input": "Translate into first-order logic: No professional basketball players are soccer players.",
"output": "¬(∃x (SoccerPlayer(x) ∧ ProfessionalBasketballPlayer(x)))"
},
{
"input": "Translate into first-order logic: All NBA players are professional basketball players.",
"output": "∀x (NBAPlayer(x) → ProfessionalBasketballPlayer(x))"
},
{
"input": "Translate into first-order logic: All defenders are soccer players.",
"output": "∀x (Defender(x) → SoccerPlayer(x))"
},
{
"input": "Translate into first-order logic: All centerbacks are defenders.",
"output": "∀x (Centerback(x) → Defender(x))"
},
{
"input": "Translate into first-order logic: Roger Federer is not an NBA player or a defender.",
"output": "¬(NBAPlayer(rogerfederer) ⊕ Defender(rogerfederer))"
},
{
"input": "Translate into first-order logic: Some teachers working at a pool are not nice.",
"output": "∃x (TeacherWorkingAtPool(x) ∧ ¬Nice(x))"
},
{
"input": "Translate into first-order logic: All teachers working at pools are pool managers.",
"output": "∀x (TeacherWorkingAtPool(x) → PoolManager(x))"
},
{
"input": "Translate into first-order logic: All pool managers are lifeguards.",
"output": "∀x (PoolManager(x) → Lifeguard(x))"
},
{
"input": "Translate into first-order logic: If someone is a lifeguard, then they work at a pool.",
"output": "∀x (Lifeguard(x) → WorkAtPool(x))"
},
{
"input": "Translate into first-order logic: Mary does not work at a pool.",
"output": "¬WorkAtPool(mary))"
},
{
"input": "Translate into first-order logic: Some teachers working at a pool are not nice.",
"output": "∃x (TeacherWorkingAtPool(x) ∧ ¬Nice(x))"
},
{
"input": "Translate into first-order logic: All teachers working at pools are pool managers.",
"output": "∀x (TeacherWorkingAtPool(x) → PoolManager(x))"
},
{
"input": "Translate into first-order logic: All pool managers are lifeguards.",
"output": "∀x (PoolManager(x) → Lifeguard(x))"
},
{
"input": "Translate into first-order logic: If someone is a lifeguard, then they work at a pool.",
"output": "∀x (Lifeguard(x) → WorkAtPool(x))"
},
{
"input": "Translate into first-order logic: Mary does not work at a pool.",
"output": "¬WorkAtPool(mary))"
},
{
"input": "Translate into first-order logic: Some teachers working at a pool are not nice.",
"output": "∃x (TeacherWorkingAtPool(x) ∧ ¬Nice(x))"
},
{
"input": "Translate into first-order logic: All teachers working at pools are pool managers.",
"output": "∀x (TeacherWorkingAtPool(x) → PoolManager(x))"
},
{
"input": "Translate into first-order logic: All pool managers are lifeguards.",
"output": "∀x (PoolManager(x) → Lifeguard(x))"
},
{
"input": "Translate into first-order logic: If someone is a lifeguard, then they work at a pool.",
"output": "∀x (Lifeguard(x) → WorkAtPool(x))"
},
{
"input": "Translate into first-order logic: Mary does not work at a pool.",
"output": "¬WorkAtPool(mary))"
},
{
"input": "Translate into first-order logic: Not all art pieces require talent.",
"output": "∃x (ArtPiece(x) ∧ ¬RequiresTalent(x))"
},
{
"input": "Translate into first-order logic: Everything that requires talent requires practice.",
"output": "∀x (RequiresTalent(x) → RequiresPractice(x))"
},
{
"input": "Translate into first-order logic: Bernarda Bryson Shahn was a painter and lithographer.",
"output": "Painter(bernardaBrysonShahn) ∧ Lithographer(bernardaBrysonShahn) "
},
{
"input": "Translate into first-order logic: Bernarda Bryson Shahn was born in Athens, Ohio.",
"output": "BornIn(bernardaBrysonShahn, athensOhio)"
},
{
"input": "Translate into first-order logic: Bernarda Bryson Shahn was married to Ben Shahn.",
"output": "MarriedTo(bernardaBrysonShahn, benShahn)"
},
{
"input": "Translate into first-order logic: People born in Athens, Ohio are Americans.",
"output": "∀x (BornIn(x, athensOhio) → American(x))"
},
{
"input": "Translate into first-order logic: Bernarda Bryson Shahn was a painter and lithographer.",
"output": "Painter(bernardaBrysonShahn) ∧ Lithographer(bernardaBrysonShahn) "
},
{
"input": "Translate into first-order logic: Bernarda Bryson Shahn was born in Athens, Ohio.",
"output": "BornIn(bernardaBrysonShahn, athensOhio)"
},
{
"input": "Translate into first-order logic: Bernarda Bryson Shahn was married to Ben Shahn.",
"output": "MarriedTo(bernardaBrysonShahn, benShahn)"
},
{
"input": "Translate into first-order logic: People born in Athens, Ohio are Americans.",
"output": "∀x (BornIn(x, athensOhio) → American(x))"
},
{
"input": "Translate into first-order logic: Bernarda Bryson Shahn was a painter and lithographer.",
"output": "Painter(bernardaBrysonShahn) ∧ Lithographer(bernardaBrysonShahn) "
},
{
"input": "Translate into first-order logic: Bernarda Bryson Shahn was born in Athens, Ohio.",
"output": "BornIn(bernardaBrysonShahn, athensOhio)"
},
{
"input": "Translate into first-order logic: Bernarda Bryson Shahn was married to Ben Shahn.",
"output": "MarriedTo(bernardaBrysonShahn, benShahn)"
},
{
"input": "Translate into first-order logic: People born in Athens, Ohio are Americans.",
"output": "∀x (BornIn(x, athensOhio) → American(x))"
},
{
"input": "Translate into first-order logic: If people upgrade to the newest iPhone model every year, then they are not saving money for a down payment on a new house.",
"output": "∀x (Iphone(x) → ¬House(x))"
},
{
"input": "Translate into first-order logic: If people enjoy reading about tech specs and keeping up to date on the latest technology, then they upgrade to the newest iPhone model every year.",
"output": "∀x (Tech(x) → Iphone(x))"
},
{
"input": "Translate into first-order logic: People either are saving money for a down payment on a new house or they live in apartments in big metropolitan cities.",
"output": "∀x (House(x) ∨ Apartment(x))"
},
{
"input": "Translate into first-order logic: If people live with at least one roommate then they do not own at least one pet.",
"output": "∀x (Roommate(x) → ¬Pet(x))"
},
{
"input": "Translate into first-order logic: All people who own at least one pet live with at least one roommate.",
"output": "∀x (Apartment(x) → Roommate(x))"
},
{
"input": "Translate into first-order logic: If Emma does not both own at least one pet and live in apartments in big metropolitan cities, then Emma either owns at least one pet and lives in an apartment in big metropolitan cities, or she neither owns a pet nor lives in an apartment in big metropolitan cities.",
"output": "¬(Pet(emma) ∧ Apartment(emma)) → ((Pet(emma) ∧ Apartment(emma)) ∨ (¬Pet(emma) ∧ ¬Apartment(emma)))"
},
{
"input": "Translate into first-order logic: If people upgrade to the newest iPhone model every year, then they are not saving money for a down payment on a new house.",
"output": "∀x (Iphone(x) → ¬House(x))"
},
{
"input": "Translate into first-order logic: If people enjoy reading about tech specs and keeping up to date on the latest technology, then they upgrade to the newest iPhone model every year.",
"output": "∀x (Tech(x) → Iphone(x))"
},
{
"input": "Translate into first-order logic: People either are saving money for a down payment on a new house or they live in apartments in big metropolitan cities.",
"output": "∀x (House(x) ∨ Apartment(x))"
},
{
"input": "Translate into first-order logic: If people live with at least one roommate then they do not own at least one pet.",
"output": "∀x (Roommate(x) → ¬Pet(x))"
},
{
"input": "Translate into first-order logic: All people who own at least one pet live with at least one roommate.",
"output": "∀x (Apartment(x) → Roommate(x))"
},
{
"input": "Translate into first-order logic: If Emma does not both own at least one pet and live in apartments in big metropolitan cities, then Emma either owns at least one pet and lives in an apartment in big metropolitan cities, or she neither owns a pet nor lives in an apartment in big metropolitan cities.",
"output": "¬(Pet(emma) ∧ Apartment(emma)) → ((Pet(emma) ∧ Apartment(emma)) ∨ (¬Pet(emma) ∧ ¬Apartment(emma)))"
},
{
"input": "Translate into first-order logic: If you are on the payroll, then you are being paid by the school.",
"output": "∀x (OnPayroll(x) → PaidBySchool(x))"
},
{
"input": "Translate into first-order logic: If someone has a job at a school, then they are on the payroll.",
"output": "∀x (JobAtSchool(x) → OnPayroll(x))"
},
{
"input": "Translate into first-order logic: All faculty members have a job at a school.",
"output": "∀x (FacultyMember(x) → JobAtSchool(x))"
},
{
"input": "Translate into first-order logic: One can either be a faculty member or a teacher.",
"output": "∀x (FacultyMember(x) ∨ Teacher(x))"
},
{
"input": "Translate into first-order logic: Every teacher has students.",
"output": "∀x (Teacher(x) → HasStudents(x))"
},
{
"input": "Translate into first-order logic: If Nancy is a teacher, then they are on the payroll.",
"output": "Teacher(nancy) → OnPayroll(nancy)"
},
{
"input": "Translate into first-order logic: If Nancy is not a teacher, then they are not paid by the school.",
"output": "¬Teacher(nancy) → ¬OnPayroll(nancy)"
},
{
"input": "Translate into first-order logic: If you are on the payroll, then you are being paid by the school.",
"output": "∀x (OnPayroll(x) → PaidBySchool(x))"
},
{
"input": "Translate into first-order logic: If someone has a job at a school, then they are on the payroll.",
"output": "∀x (JobAtSchool(x) → OnPayroll(x))"
},
{
"input": "Translate into first-order logic: All faculty members have a job at a school.",
"output": "∀x (FacultyMember(x) → JobAtSchool(x))"
},
{
"input": "Translate into first-order logic: One can either be a faculty member or a teacher.",
"output": "∀x (FacultyMember(x) ∨ Teacher(x))"
},
{
"input": "Translate into first-order logic: Every teacher has students.",
"output": "∀x (Teacher(x) → HasStudents(x))"
},
{
"input": "Translate into first-order logic: If Nancy is a teacher, then they are on the payroll.",
"output": "Teacher(nancy) → OnPayroll(nancy)"
},
{
"input": "Translate into first-order logic: If Nancy is not a teacher, then they are not paid by the school.",
"output": "¬Teacher(nancy) → ¬OnPayroll(nancy)"
},
{
"input": "Translate into first-order logic: If you are on the payroll, then you are being paid by the school.",
"output": "∀x (OnPayroll(x) → PaidBySchool(x))"
},
{
"input": "Translate into first-order logic: If someone has a job at a school, then they are on the payroll.",
"output": "∀x (JobAtSchool(x) → OnPayroll(x))"
},
{
"input": "Translate into first-order logic: All faculty members have a job at a school.",
"output": "∀x (FacultyMember(x) → JobAtSchool(x))"
},
{
"input": "Translate into first-order logic: One can either be a faculty member or a teacher.",
"output": "∀x (FacultyMember(x) ∨ Teacher(x))"
},
{
"input": "Translate into first-order logic: Every teacher has students.",
"output": "∀x (Teacher(x) → HasStudents(x))"
},
{
"input": "Translate into first-order logic: If Nancy is a teacher, then they are on the payroll.",
"output": "Teacher(nancy) → OnPayroll(nancy)"
},
{
"input": "Translate into first-order logic: If Nancy is not a teacher, then they are not paid by the school.",
"output": "¬Teacher(nancy) → ¬OnPayroll(nancy)"
},
{
"input": "Translate into first-order logic: Kangaroo is an animal.",
"output": "∀x (Kangaroo(x) → Animal(x))"
},
{
"input": "Translate into first-order logic: No Kangaroos live in Germany.",
"output": "∀x (Kangaroo(x) → ¬LiveIn(x, germany))"
},
{
"input": "Translate into first-order logic: If Jane saves enough money for the summer, she will fly to Germany.",
"output": "EnoughMoney(jane) → FlyTo(jane, germany)"
},
{
"input": "Translate into first-order logic: If Jane flies to Germany, she will go to the Berlin Zoo.",
"output": "FlyTo(jane, germany) → GoTo(jane, berlinzoo) "
},
{
"input": "Translate into first-order logic: If someone goes to the Berlin Zoo, they will see some of the animals that live in Germany.",
"output": "∀x ∃y (GoTo(x, berlinzoo) ∧ Animal(y) → MaySee(y, x, berlinzoo))"
},
{
"input": "Translate into first-order logic: If a class has prerequisites the student must take the prerequisites to take the class.",
"output": "∀x ∀y ((Prereq(x, y) ∧ Taken(x)) ↔ CanTake(y))"
},
{
"input": "Translate into first-order logic: If a class has no prerequisites, then the student can take the class",
"output": "∀x ∀y (¬Prereq(x, y) → CanTake(y))"
},
{
"input": "Translate into first-order logic: CPSC 201 and CPSC 223 are prerequisites for CPSC 323.",
"output": "Prereq(cpsc201, cpsc323) ∧ Prereq(cpsc223, cpsc323)"
},
{
"input": "Translate into first-order logic: Intro Microeconomics is the only prerequisite for Intermediate Microeconomics.",
"output": "(Prereq(intromicro, intermediatemicro) ∧ Taken(intromicro)) → CanTake(intermediatemicro)"
},
{
"input": "Translate into first-order logic: Intro Geology has no prerequisites.",
"output": "∀x (¬Prereq(x, introgeology))"
},
{
"input": "Translate into first-order logic: If a class has prerequisites the student must take the prerequisites to take the class.",
"output": "∀x ∀y ((Prereq(x, y) ∧ Taken(x)) ↔ CanTake(y))"
},
{
"input": "Translate into first-order logic: If a class has no prerequisites, then the student can take the class",
"output": "∀x ∀y (¬Prereq(x, y) → CanTake(y))"
},
{
"input": "Translate into first-order logic: CPSC 201 and CPSC 223 are prerequisites for CPSC 323.",
"output": "Prereq(cpsc201, cpsc323) ∧ Prereq(cpsc223, cpsc323)"
},
{
"input": "Translate into first-order logic: Intro Microeconomics is the only prerequisite for Intermediate Microeconomics.",
"output": "(Prereq(intromicro, intermediatemicro) ∧ Taken(intromicro)) → CanTake(intermediatemicro)"
},
{
"input": "Translate into first-order logic: Intro Geology has no prerequisites.",
"output": "∀x (¬Prereq(x, introgeology))"
},
{
"input": "Translate into first-order logic: If a class has prerequisites the student must take the prerequisites to take the class.",
"output": "∀x ∀y ((Prereq(x, y) ∧ Taken(x)) ↔ CanTake(y))"
},
{
"input": "Translate into first-order logic: If a class has no prerequisites, then the student can take the class",
"output": "∀x ∀y (¬Prereq(x, y) → CanTake(y))"
},
{
"input": "Translate into first-order logic: CPSC 201 and CPSC 223 are prerequisites for CPSC 323.",
"output": "Prereq(cpsc201, cpsc323) ∧ Prereq(cpsc223, cpsc323)"
},
{
"input": "Translate into first-order logic: Intro Microeconomics is the only prerequisite for Intermediate Microeconomics.",
"output": "(Prereq(intromicro, intermediatemicro) ∧ Taken(intromicro)) → CanTake(intermediatemicro)"
},
{
"input": "Translate into first-order logic: Intro Geology has no prerequisites.",
"output": "∀x (¬Prereq(x, introgeology))"
},
{
"input": "Translate into first-order logic: If a class has prerequisites the student must take the prerequisites to take the class.",
"output": "∀x ∀y ((Prereq(x, y) ∧ Taken(x)) ↔ CanTake(y))"
},
{
"input": "Translate into first-order logic: If a class has no prerequisites, then the student can take the class",
"output": "∀x ∀y (¬Prereq(x, y) → CanTake(y))"
},
{
"input": "Translate into first-order logic: CPSC 201 and CPSC 223 are prerequisites for CPSC 323.",
"output": "Prereq(cpsc201, cpsc323) ∧ Prereq(cpsc223, cpsc323)"
},
{
"input": "Translate into first-order logic: Intro Microeconomics is the only prerequisite for Intermediate Microeconomics.",
"output": "(Prereq(intromicro, intermediatemicro) ∧ Taken(intromicro)) → CanTake(intermediatemicro)"
},
{
"input": "Translate into first-order logic: Intro Geology has no prerequisites.",
"output": "∀x (¬Prereq(x, introgeology))"
},
{
"input": "Translate into first-order logic: A heptalogy, is a compound literary or narrative work that is made up of seven distinct works.",
"output": "∀x (SevenDistinctWorks(x) → Heptalogy(x))"
},
{
"input": "Translate into first-order logic: The Harry Potter series consists of 7 distinct works.",
"output": "SevenDistinctWorks(harryPotter)"
},
{
"input": "Translate into first-order logic: The Chronicles of Narnia consists of 7 distinct works.",
"output": "SevenDistinctWorks(chroniclesofNarnia)"
},
{
"input": "Translate into first-order logic: A heptalogy, is a compound literary or narrative work that is made up of seven distinct works.",
"output": "∀x (SevenDistinctWorks(x) → Heptalogy(x))"
},
{
"input": "Translate into first-order logic: The Harry Potter series consists of 7 distinct works.",
"output": "SevenDistinctWorks(harryPotter)"
},
{
"input": "Translate into first-order logic: The Chronicles of Narnia consists of 7 distinct works.",
"output": "SevenDistinctWorks(chroniclesofNarnia)"
},
{
"input": "Translate into first-order logic: A heptalogy, is a compound literary or narrative work that is made up of seven distinct works.",
"output": "∀x (SevenDistinctWorks(x) → Heptalogy(x))"
},
{
"input": "Translate into first-order logic: The Harry Potter series consists of 7 distinct works.",
"output": "SevenDistinctWorks(harryPotter)"
},
{
"input": "Translate into first-order logic: The Chronicles of Narnia consists of 7 distinct works.",
"output": "SevenDistinctWorks(chroniclesofNarnia)"
},
{
"input": "Translate into first-order logic: All people who attend Renaissance fairs regularly enjoy dressing up in old-fashioned and historical period clothing.",
"output": "∀x (RenaissanceFair(x) → DressingUp(x))"
},
{
"input": "Translate into first-order logic: If people are fascinated by the history of the Renaissance and other past eras, then they attend Renaissance fairs regularly.",
"output": "∀x (HistoryRenaissance(x) → RenaissanceFair(x))"
},
{
"input": "Translate into first-order logic: People are either fascinated by the history of the Renaissance and other past eras, or are not nostalgic academics who enjoy learning.",
"output": "∀x (HistoryRenaissance(x) ∨ NotAcademics(x))"
},
{
"input": "Translate into first-order logic: If people are focused on the future and industry professions, then they are not nostalgic academics who enjoy learning.",
"output": "∀x (Industry(x) → NotAcademics(x))"
},
{
"input": "Translate into first-order logic: If people are historical professors who are passionate about their job and subject, then they are nostalgic academics who enjoy learning.",
"output": "∀x (HistoryProf(x) → ¬NotAcademics(x))"
},
{
"input": "Translate into first-order logic: If Clyde is not focused on the future and industry professions, then he is neither focused on the future and industry professions nor enjoys dressing up in old-fashioned and historical period clothing.",
"output": "¬Industry(clyde) → ¬(Industry(clyde) ∨ DressingUp(clyde))"
},
{
"input": "Translate into first-order logic: All people who attend Renaissance fairs regularly enjoy dressing up in old-fashioned and historical period clothing.",
"output": "∀x (RenaissanceFair(x) → DressingUp(x))"
},
{
"input": "Translate into first-order logic: If people are fascinated by the history of the Renaissance and other past eras, then they attend Renaissance fairs regularly.",
"output": "∀x (HistoryRenaissance(x) → RenaissanceFair(x))"
},
{
"input": "Translate into first-order logic: People are either fascinated by the history of the Renaissance and other past eras, or are not nostalgic academics who enjoy learning.",
"output": "∀x (HistoryRenaissance(x) ∨ NotAcademics(x))"
},
{
"input": "Translate into first-order logic: If people are focused on the future and industry professions, then they are not nostalgic academics who enjoy learning.",
"output": "∀x (Industry(x) → NotAcademics(x))"
},
{
"input": "Translate into first-order logic: If people are historical professors who are passionate about their job and subject, then they are nostalgic academics who enjoy learning.",
"output": "∀x (HistoryProf(x) → ¬NotAcademics(x))"
},
{
"input": "Translate into first-order logic: If Clyde is not focused on the future and industry professions, then he is neither focused on the future and industry professions nor enjoys dressing up in old-fashioned and historical period clothing.",
"output": "¬Industry(clyde) → ¬(Industry(clyde) ∨ DressingUp(clyde))"
},
{
"input": "Translate into first-order logic: All people who attend Renaissance fairs regularly enjoy dressing up in old-fashioned and historical period clothing.",
"output": "∀x (RenaissanceFair(x) → DressingUp(x))"
},
{
"input": "Translate into first-order logic: If people are fascinated by the history of the Renaissance and other past eras, then they attend Renaissance fairs regularly.",
"output": "∀x (HistoryRenaissance(x) → RenaissanceFair(x))"
},
{
"input": "Translate into first-order logic: People are either fascinated by the history of the Renaissance and other past eras, or are not nostalgic academics who enjoy learning.",
"output": "∀x (HistoryRenaissance(x) ∨ NotAcademics(x))"
},
{
"input": "Translate into first-order logic: If people are focused on the future and industry professions, then they are not nostalgic academics who enjoy learning.",
"output": "∀x (Industry(x) → NotAcademics(x))"
},
{
"input": "Translate into first-order logic: If people are historical professors who are passionate about their job and subject, then they are nostalgic academics who enjoy learning.",
"output": "∀x (HistoryProf(x) → ¬NotAcademics(x))"
},
{
"input": "Translate into first-order logic: If Clyde is not focused on the future and industry professions, then he is neither focused on the future and industry professions nor enjoys dressing up in old-fashioned and historical period clothing.",
"output": "¬Industry(clyde) → ¬(Industry(clyde) ∨ DressingUp(clyde))"
},
{
"input": "Translate into first-order logic: No sports cars are vehicles intended to be driven at moderate speeds.",
"output": "∀x (SportsCar(x) → ¬IntendedToBeDrivenAtModerateSpeeds(x))"
},
{
"input": "Translate into first-order logic: All automobiles designed for family use are vehicles intended to be driven at moderate speeds.",
"output": "∀x (ForFamilyUse(x) → IntendedToBeDrivenAtModerateSpeeds(x))"
},
{
"input": "Translate into first-order logic: If people work well in teams in their workplace, then they get along with all their colleagues at their work.",
"output": "∀x (WorkTeams(x) → Colleagues(x))"
},
{
"input": "Translate into first-order logic: If people come to work every day with a positive attitude, then they work well in teams in their workplace.",
"output": "∀x (PositiveAttitude(x) → WorkTeams(x))"
},
{
"input": "Translate into first-order logic: People either come into work every day with a positive attitude or are always tired every morning.",
"output": "∀x (PositiveAttitude(x) ⊕ Tired(x)) ∧ (∀x (Tired(x) → BossPromotions(x)))"
},
{
"input": "Translate into first-order logic: If people get many promotions from their boss at work, then they receive negative feedback from teams at work.",
"output": "∀x (BossPromotions(x) → ¬NegativeFeedback(x))"
},
{
"input": "Translate into first-order logic: Kat is either both a person who works well in teams in their workplace and is always tired every morning, or she neither works well in teams in their workplace nor is always tired every morning.",
"output": "(WorkTeams(kat) ∧ Tired(kat)) ∨ ¬WorkTeams(kat) ∧ ¬Tired(kat))"
},
{
"input": "Translate into first-order logic: If people work well in teams in their workplace, then they get along with all their colleagues at their work.",
"output": "∀x (WorkTeams(x) → Colleagues(x))"
},
{
"input": "Translate into first-order logic: If people come to work every day with a positive attitude, then they work well in teams in their workplace.",
"output": "∀x (PositiveAttitude(x) → WorkTeams(x))"
},
{
"input": "Translate into first-order logic: People either come into work every day with a positive attitude or are always tired every morning.",
"output": "∀x (PositiveAttitude(x) ⊕ Tired(x)) ∧ (∀x (Tired(x) → BossPromotions(x)))"
},
{
"input": "Translate into first-order logic: If people get many promotions from their boss at work, then they receive negative feedback from teams at work.",
"output": "∀x (BossPromotions(x) → ¬NegativeFeedback(x))"
},
{
"input": "Translate into first-order logic: Kat is either both a person who works well in teams in their workplace and is always tired every morning, or she neither works well in teams in their workplace nor is always tired every morning.",
"output": "(WorkTeams(kat) ∧ Tired(kat)) ∨ ¬WorkTeams(kat) ∧ ¬Tired(kat))"
},
{
"input": "Translate into first-order logic: If people work well in teams in their workplace, then they get along with all their colleagues at their work.",
"output": "∀x (WorkTeams(x) → Colleagues(x))"
},
{
"input": "Translate into first-order logic: If people come to work every day with a positive attitude, then they work well in teams in their workplace.",
"output": "∀x (PositiveAttitude(x) → WorkTeams(x))"
},
{
"input": "Translate into first-order logic: People either come into work every day with a positive attitude or are always tired every morning.",
"output": "∀x (PositiveAttitude(x) ⊕ Tired(x)) ∧ (∀x (Tired(x) → BossPromotions(x)))"
},
{
"input": "Translate into first-order logic: If people get many promotions from their boss at work, then they receive negative feedback from teams at work.",
"output": "∀x (BossPromotions(x) → ¬NegativeFeedback(x))"
},
{
"input": "Translate into first-order logic: Kat is either both a person who works well in teams in their workplace and is always tired every morning, or she neither works well in teams in their workplace nor is always tired every morning.",
"output": "(WorkTeams(kat) ∧ Tired(kat)) ∨ ¬WorkTeams(kat) ∧ ¬Tired(kat))"
},
{
"input": "Translate into first-order logic: Drishti is open-source.",
"output": "OpenSource(drishti)"
},
{
"input": "Translate into first-order logic: Open-source software is free to modify.",
"output": "∀x (OpenSource(x) → ModifyFree(x))"
},
{
"input": "Translate into first-order logic: There are five grades including A+, A, B+, B, and C in English.",
"output": "Grade(a+) ∨ Grade(a) ∨ Grade(b+) ∨ Grade(b) ∨ Grade(c)"
},
{
"input": "Translate into first-order logic: If a student gets A+ in English, then his score is greater than 95.",
"output": "∀x (GetGrade(x, a+) → GreaterThan95(x))"
},
{
"input": "Translate into first-order logic: If a student gets A in English, then his score is in the range of 90-95.",
"output": "∀x (GetGrade(x, a) → Range90to95(x))"
},
{
"input": "Translate into first-order logic: Zhang got an A in English.",
"output": "GetGrade(zhang, a)"
},
{
"input": "Translate into first-order logic: Wang's English score is better than Zhang's.",
"output": "Better(wang, zhang)"
},
{
"input": "Translate into first-order logic: Wu's English score is lower than 90.",
"output": "LowerThan90(wu)"
},
{
"input": "Translate into first-order logic: There are five grades including A+, A, B+, B, and C in English.",
"output": "Grade(a+) ∨ Grade(a) ∨ Grade(b+) ∨ Grade(b) ∨ Grade(c)"
},
{
"input": "Translate into first-order logic: If a student gets A+ in English, then his score is greater than 95.",
"output": "∀x (GetGrade(x, a+) → GreaterThan95(x))"
},
{
"input": "Translate into first-order logic: If a student gets A in English, then his score is in the range of 90-95.",
"output": "∀x (GetGrade(x, a) → Range90to95(x))"
},
{
"input": "Translate into first-order logic: Zhang got an A in English.",
"output": "GetGrade(zhang, a)"
},
{
"input": "Translate into first-order logic: Wang's English score is better than Zhang's.",
"output": "Better(wang, zhang)"
},
{
"input": "Translate into first-order logic: Wu's English score is lower than 90.",
"output": "LowerThan90(wu)"
},
{
"input": "Translate into first-order logic: There are five grades including A+, A, B+, B, and C in English.",
"output": "Grade(a+) ∨ Grade(a) ∨ Grade(b+) ∨ Grade(b) ∨ Grade(c)"
},
{
"input": "Translate into first-order logic: If a student gets A+ in English, then his score is greater than 95.",
"output": "∀x (GetGrade(x, a+) → GreaterThan95(x))"
},
{
"input": "Translate into first-order logic: If a student gets A in English, then his score is in the range of 90-95.",
"output": "∀x (GetGrade(x, a) → Range90to95(x))"
},
{
"input": "Translate into first-order logic: Zhang got an A in English.",
"output": "GetGrade(zhang, a)"
},
{
"input": "Translate into first-order logic: Wang's English score is better than Zhang's.",
"output": "Better(wang, zhang)"
},
{
"input": "Translate into first-order logic: Wu's English score is lower than 90.",
"output": "LowerThan90(wu)"
},
{
"input": "Translate into first-order logic: Olivia doesn't prefer warm temperature during the day.",
"output": "∀x (Day(x) → ¬PrefersWarmAt(olivia, x))"
},
{
"input": "Translate into first-order logic: When Olivia sleeps, she prefers cool temperature.",
"output": "∀x (SleepingDuring(olivia, x) → PrefersCoolAt(olivia, x))"
},
{
"input": "Translate into first-order logic: Olivia sleeps during the night.",
"output": "∀x (SleepingDuring(olivia, x) → Night(x))"
},
{
"input": "Translate into first-order logic: Olivia works during the day.",
"output": "∀x (WorkingDuring(olivia, x) → Day(x))"
},
{
"input": "Translate into first-order logic: Olivia either works or sleeps.",
"output": "∀x (WorkingDuring(olivia, x) ∨ SleepingDuring(olivia, x))"
},
{
"input": "Translate into first-order logic: The time is either the day or the night.",
"output": "∀x (Day(x) ∨ Night(x))"
},
{
"input": "Translate into first-order logic: Olivia either prefers warm temperature or prefers cool temperature.",
"output": "∀x (PrefersWarmAt(olivia, x) ∨ PrefersCoolAt(olivia, x))"
},
{
"input": "Translate into first-order logic: Taylor Swift gives a commencement speech in New York University in 2022.",
"output": "Speech(taylorSwift, nyc)"
},
{
"input": "Translate into first-order logic: Both Columbia University and New York University are located in Manhattan.",
"output": "Manhattan(columbiaUniversity) ∧ Manhattan(nyc)"
},
{
"input": "Translate into first-order logic: Taylor Swift has received three Grammy Album of the Year Awards.",
"output": "HaveAlbum(taylorSwift)"
},
{
"input": "Translate into first-order logic: Columbia University is one of the Ivy League schools.",
"output": "IvyLeague(columbiaUniversity)"
},
{
"input": "Translate into first-order logic: Taylor Swift gives a commencement speech in New York University in 2022.",
"output": "Speech(taylorSwift, nyc)"
},
{
"input": "Translate into first-order logic: Both Columbia University and New York University are located in Manhattan.",
"output": "Manhattan(columbiaUniversity) ∧ Manhattan(nyc)"
},
{
"input": "Translate into first-order logic: Taylor Swift has received three Grammy Album of the Year Awards.",
"output": "HaveAlbum(taylorSwift)"
},
{
"input": "Translate into first-order logic: Columbia University is one of the Ivy League schools.",
"output": "IvyLeague(columbiaUniversity)"
},
{
"input": "Translate into first-order logic: Customers either choose Plan A or Plan B.",
"output": "∀x (PlanA(x) ∨ PlanB(x))"
},
{
"input": "Translate into first-order logic: All who choose Plan B are rewarded with a $30 gift card.",
"output": "∀x (PlanB(x) → Award(x))"
},
{
"input": "Translate into first-order logic: There are no customers who do not choose any plans.",
"output": "∀x (¬NoPlan(x))"
},
{
"input": "Translate into first-order logic: No customers rewarded a $30 gift card are older than 80.",
"output": "∀x (Award(x) → ¬OlderThan80(x))"
},
{
"input": "Translate into first-order logic: Customers are either older than 80 or are currently studying at school.",
"output": "∀x (OlderThan80(x) ∨ StudyAtSchool(x))"
},
{
"input": "Translate into first-order logic: James is not a customer who is currently studying at school.",
"output": "¬StudyAtSchool(james)"
},
{
"input": "Translate into first-order logic: Customers either choose Plan A or Plan B.",
"output": "∀x (PlanA(x) ∨ PlanB(x))"
},
{
"input": "Translate into first-order logic: All who choose Plan B are rewarded with a $30 gift card.",
"output": "∀x (PlanB(x) → Award(x))"
},
{
"input": "Translate into first-order logic: There are no customers who do not choose any plans.",
"output": "∀x (¬NoPlan(x))"
},
{
"input": "Translate into first-order logic: No customers rewarded a $30 gift card are older than 80.",
"output": "∀x (Award(x) → ¬OlderThan80(x))"
},
{
"input": "Translate into first-order logic: Customers are either older than 80 or are currently studying at school.",
"output": "∀x (OlderThan80(x) ∨ StudyAtSchool(x))"
},
{
"input": "Translate into first-order logic: James is not a customer who is currently studying at school.",
"output": "¬StudyAtSchool(james)"
},
{
"input": "Translate into first-order logic: Customers either choose Plan A or Plan B.",
"output": "∀x (PlanA(x) ∨ PlanB(x))"
},
{
"input": "Translate into first-order logic: All who choose Plan B are rewarded with a $30 gift card.",
"output": "∀x (PlanB(x) → Award(x))"
},
{
"input": "Translate into first-order logic: There are no customers who do not choose any plans.",
"output": "∀x (¬NoPlan(x))"
},
{
"input": "Translate into first-order logic: No customers rewarded a $30 gift card are older than 80.",
"output": "∀x (Award(x) → ¬OlderThan80(x))"
},
{
"input": "Translate into first-order logic: Customers are either older than 80 or are currently studying at school.",
"output": "∀x (OlderThan80(x) ∨ StudyAtSchool(x))"
},
{
"input": "Translate into first-order logic: James is not a customer who is currently studying at school.",
"output": "¬StudyAtSchool(james)"
},
{
"input": "Translate into first-order logic: Detroit City is a horse.",
"output": "Horse(detroitcity)"
},
{
"input": "Translate into first-order logic: Some horses are racehorses.",
"output": "∃x (Horse(x) ∧ Racehorse(x))"
},
{
"input": "Translate into first-order logic: If a horse falls during a race, then it dies.",
"output": "∀x (Horse(x) ∧ Racing(x) ∧ Falls(x) → Dead(x))"
},
{
"input": "Translate into first-order logic: Detroit City fell during a race.",
"output": "Racing(detroitcity) ∧ Falls(detroitcity)"
},
{
"input": "Translate into first-order logic: A horse is a racehorse if it is in a race.",
"output": "∀x (Horse(x) ∧ Racing(x) → Racehorse(x))"
},
{
"input": "Translate into first-order logic: Detroit City is a horse.",
"output": "Horse(detroitcity)"
},
{
"input": "Translate into first-order logic: Some horses are racehorses.",
"output": "∃x (Horse(x) ∧ Racehorse(x))"
},
{
"input": "Translate into first-order logic: If a horse falls during a race, then it dies.",
"output": "∀x (Horse(x) ∧ Racing(x) ∧ Falls(x) → Dead(x))"
},
{
"input": "Translate into first-order logic: Detroit City fell during a race.",
"output": "Racing(detroitcity) ∧ Falls(detroitcity)"
},
{
"input": "Translate into first-order logic: A horse is a racehorse if it is in a race.",
"output": "∀x (Horse(x) ∧ Racing(x) → Racehorse(x))"
},
{
"input": "Translate into first-order logic: Detroit City is a horse.",
"output": "Horse(detroitcity)"
},
{
"input": "Translate into first-order logic: Some horses are racehorses.",
"output": "∃x (Horse(x) ∧ Racehorse(x))"
},
{
"input": "Translate into first-order logic: If a horse falls during a race, then it dies.",
"output": "∀x (Horse(x) ∧ Racing(x) ∧ Falls(x) → Dead(x))"
},
{
"input": "Translate into first-order logic: Detroit City fell during a race.",
"output": "Racing(detroitcity) ∧ Falls(detroitcity)"
},
{
"input": "Translate into first-order logic: A horse is a racehorse if it is in a race.",
"output": "∀x (Horse(x) ∧ Racing(x) → Racehorse(x))"
},
{
"input": "Translate into first-order logic: Frederick Monhoff was an architect, artist, and illustrator.",
"output": "Architect(monhoff) ∧ Artist(monhoff) ∧ Illustrator(monhoff)"
},
{
"input": "Translate into first-order logic: Frederick Monhoff was an American.",
"output": "American(monhoff)"
},
{
"input": "Translate into first-order logic: An artist is good at painting or music.",
"output": "∀x (Artist(x) → GoodAt(x, painting) ∨ GoodAt(x, music))"
},
{
"input": "Translate into first-order logic: All Americans speak English.",
"output": "∀x (American(x) → Speak(x, english))"
},
{
"input": "Translate into first-order logic: Frederick Monhoff was an architect, artist, and illustrator.",
"output": "Architect(monhoff) ∧ Artist(monhoff) ∧ Illustrator(monhoff)"
},
{
"input": "Translate into first-order logic: Frederick Monhoff was an American.",
"output": "American(monhoff)"
},
{
"input": "Translate into first-order logic: An artist is good at painting or music.",
"output": "∀x (Artist(x) → GoodAt(x, painting) ∨ GoodAt(x, music))"
},
{
"input": "Translate into first-order logic: All Americans speak English.",
"output": "∀x (American(x) → Speak(x, english))"
},
{
"input": "Translate into first-order logic: Miroslav Fiedler was a Czech mathematician.",
"output": "Czech(miroslavfiedler) ∧ Mathematician(miroslavfiedler)"
},
{
"input": "Translate into first-order logic: Miroslav Fiedler is known for his contributions to linear algebra and graph theory.",
"output": "KnownFor(miroslavfiedler, contributionsToLinearAlgebraAndGraphTheory)"
},
{
"input": "Translate into first-order logic: Miroslav Fiedler is honored by the Fiedler eigenvalue.",
"output": "HonoredBy(miroslavfiedler, fiedlerEigenvalue)"
},
{
"input": "Translate into first-order logic: Fiedler eigenvalue is the second smallest eigenvalue of the graph Laplacian.",
"output": "TheSecondSmallestEigenvalueOf(fiedlerEigenvalue, theGraphLaplacian)"
},
{
"input": "Translate into first-order logic: Miroslav Fiedler was a Czech mathematician.",
"output": "Czech(miroslavfiedler) ∧ Mathematician(miroslavfiedler)"
},
{
"input": "Translate into first-order logic: Miroslav Fiedler is known for his contributions to linear algebra and graph theory.",
"output": "KnownFor(miroslavfiedler, contributionsToLinearAlgebraAndGraphTheory)"
},
{
"input": "Translate into first-order logic: Miroslav Fiedler is honored by the Fiedler eigenvalue.",
"output": "HonoredBy(miroslavfiedler, fiedlerEigenvalue)"
},
{
"input": "Translate into first-order logic: Fiedler eigenvalue is the second smallest eigenvalue of the graph Laplacian.",
"output": "TheSecondSmallestEigenvalueOf(fiedlerEigenvalue, theGraphLaplacian)"
},
{
"input": "Translate into first-order logic: Miroslav Fiedler was a Czech mathematician.",
"output": "Czech(miroslavfiedler) ∧ Mathematician(miroslavfiedler)"
},
{
"input": "Translate into first-order logic: Miroslav Fiedler is known for his contributions to linear algebra and graph theory.",
"output": "KnownFor(miroslavfiedler, contributionsToLinearAlgebraAndGraphTheory)"
},
{
"input": "Translate into first-order logic: Miroslav Fiedler is honored by the Fiedler eigenvalue.",
"output": "HonoredBy(miroslavfiedler, fiedlerEigenvalue)"
},
{
"input": "Translate into first-order logic: Fiedler eigenvalue is the second smallest eigenvalue of the graph Laplacian.",
"output": "TheSecondSmallestEigenvalueOf(fiedlerEigenvalue, theGraphLaplacian)"
},
{
"input": "Translate into first-order logic: A laptop is a computer.",
"output": "∀x (Laptop(x) → Computer(x))"
},
{
"input": "Translate into first-order logic: You can play games on a computer.",
"output": "∀x (Computer(x) → CanPlayGames(x))"
},
{
"input": "Translate into first-order logic: A phone is not a computer.",
"output": "∀x (Phone(x) → ¬Computer(x))"
},
{
"input": "Translate into first-order logic: A laptop is a computer.",
"output": "∀x (Laptop(x) → Computer(x))"
},
{
"input": "Translate into first-order logic: You can play games on a computer.",
"output": "∀x (Computer(x) → CanPlayGames(x))"
},
{
"input": "Translate into first-order logic: A phone is not a computer.",
"output": "∀x (Phone(x) → ¬Computer(x))"
},
{
"input": "Translate into first-order logic: Walter Folger Brown was an American politician and lawyer, and served as the postmaster general.",
"output": "AmericanPolitician(walterbrown) ∧ Lawyer(walterbrown) ∧ ServedAs(walterbrown, postamastergeneral)"
},
{
"input": "Translate into first-order logic: Walter Folger Brown graduated from Harvard University with a Bachelors of Arts.",
"output": "Graduated(walterbrown, harvard) ∧ GraduatedWith(walterbrown, bachelorsofart)"
},
{
"input": "Translate into first-order logic: While they were both in Toledo, Walter Folger Brown's father practiced law with Walter Folger Brown.",
"output": "In(walterbrown, toledo) ∧ In(walterbrownfather, toledo) ∧ PracticedLawTogether(walterbrownfather, walterbrown)"
},
{
"input": "Translate into first-order logic: Katherin Hafer married Walter Folger Brown.",
"output": "Married(ketherinhafer, walterbrown)"
},
{
"input": "Translate into first-order logic: Walter Folger Brown was an American politician and lawyer, and served as the postmaster general.",
"output": "AmericanPolitician(walterbrown) ∧ Lawyer(walterbrown) ∧ ServedAs(walterbrown, postamastergeneral)"
},
{
"input": "Translate into first-order logic: Walter Folger Brown graduated from Harvard University with a Bachelors of Arts.",
"output": "Graduated(walterbrown, harvard) ∧ GraduatedWith(walterbrown, bachelorsofart)"
},
{
"input": "Translate into first-order logic: While they were both in Toledo, Walter Folger Brown's father practiced law with Walter Folger Brown.",
"output": "In(walterbrown, toledo) ∧ In(walterbrownfather, toledo) ∧ PracticedLawTogether(walterbrownfather, walterbrown)"
},
{
"input": "Translate into first-order logic: Katherin Hafer married Walter Folger Brown.",
"output": "Married(ketherinhafer, walterbrown)"
},
{
"input": "Translate into first-order logic: Walter Folger Brown was an American politician and lawyer, and served as the postmaster general.",
"output": "AmericanPolitician(walterbrown) ∧ Lawyer(walterbrown) ∧ ServedAs(walterbrown, postamastergeneral)"
},
{
"input": "Translate into first-order logic: Walter Folger Brown graduated from Harvard University with a Bachelors of Arts.",
"output": "Graduated(walterbrown, harvard) ∧ GraduatedWith(walterbrown, bachelorsofart)"
},
{
"input": "Translate into first-order logic: While they were both in Toledo, Walter Folger Brown's father practiced law with Walter Folger Brown.",
"output": "In(walterbrown, toledo) ∧ In(walterbrownfather, toledo) ∧ PracticedLawTogether(walterbrownfather, walterbrown)"
},
{
"input": "Translate into first-order logic: Katherin Hafer married Walter Folger Brown.",
"output": "Married(ketherinhafer, walterbrown)"
},
{
"input": "Translate into first-order logic: All products shipped from China are made in China.",
"output": "∀x (ShipChina(x) → MadeInChina(x))"
},
{
"input": "Translate into first-order logic: All products sold in JD are shipped from China.",
"output": "∀x (SoldJD(x) → ShipChina(x))"
},
{
"input": "Translate into first-order logic: All products commonly used in China are sold in JD.",
"output": "∀x (CommonlyUsedChina(x) → SoldJD(x))"
},
{
"input": "Translate into first-order logic: All products favored by young people are commonly used in China.",
"output": "∀x (FavoredByYoungPeople(x) → CommonlyUsedChina(x))"
},
{
"input": "Translate into first-order logic: MacBook is not made in China and is not commonly used in China.",
"output": "¬(MadeInChina(macbook) ∧ CommonlyUsedChina(macbook))"
},
{
"input": "Translate into first-order logic: All products shipped from China are made in China.",
"output": "∀x (ShipChina(x) → MadeInChina(x))"
},
{
"input": "Translate into first-order logic: All products sold in JD are shipped from China.",
"output": "∀x (SoldJD(x) → ShipChina(x))"
},
{
"input": "Translate into first-order logic: All products commonly used in China are sold in JD.",
"output": "∀x (CommonlyUsedChina(x) → SoldJD(x))"
},
{
"input": "Translate into first-order logic: All products favored by young people are commonly used in China.",
"output": "∀x (FavoredByYoungPeople(x) → CommonlyUsedChina(x))"
},
{
"input": "Translate into first-order logic: MacBook is not made in China and is not commonly used in China.",
"output": "¬(MadeInChina(macbook) ∧ CommonlyUsedChina(macbook))"
},
{
"input": "Translate into first-order logic: All products shipped from China are made in China.",
"output": "∀x (ShipChina(x) → MadeInChina(x))"
},
{
"input": "Translate into first-order logic: All products sold in JD are shipped from China.",
"output": "∀x (SoldJD(x) → ShipChina(x))"
},
{
"input": "Translate into first-order logic: All products commonly used in China are sold in JD.",
"output": "∀x (CommonlyUsedChina(x) → SoldJD(x))"
},
{
"input": "Translate into first-order logic: All products favored by young people are commonly used in China.",
"output": "∀x (FavoredByYoungPeople(x) → CommonlyUsedChina(x))"
},
{
"input": "Translate into first-order logic: MacBook is not made in China and is not commonly used in China.",
"output": "¬(MadeInChina(macbook) ∧ CommonlyUsedChina(macbook))"
},
{
"input": "Translate into first-order logic: All products shipped from China are made in China.",
"output": "∀x (ShipChina(x) → MadeInChina(x))"
},
{
"input": "Translate into first-order logic: All products sold in JD are shipped from China.",
"output": "∀x (SoldJD(x) → ShipChina(x))"
},
{
"input": "Translate into first-order logic: All products commonly used in China are sold in JD.",
"output": "∀x (CommonlyUsedChina(x) → SoldJD(x))"
},
{
"input": "Translate into first-order logic: All products favored by young people are commonly used in China.",
"output": "∀x (FavoredByYoungPeople(x) → CommonlyUsedChina(x))"
},
{
"input": "Translate into first-order logic: MacBook is not made in China and is not commonly used in China.",
"output": "¬(MadeInChina(macbook) ∧ CommonlyUsedChina(macbook))"
},
{
"input": "Translate into first-order logic: All products shipped from China are made in China.",
"output": "∀x (ShipChina(x) → MadeInChina(x))"
},
{
"input": "Translate into first-order logic: All products sold in JD are shipped from China.",
"output": "∀x (SoldJD(x) → ShipChina(x))"
},
{
"input": "Translate into first-order logic: All products commonly used in China are sold in JD.",
"output": "∀x (CommonlyUsedChina(x) → SoldJD(x))"
},
{
"input": "Translate into first-order logic: All products favored by young people are commonly used in China.",
"output": "∀x (FavoredByYoungPeople(x) → CommonlyUsedChina(x))"
},
{
"input": "Translate into first-order logic: MacBook is not made in China and is not commonly used in China.",
"output": "¬(MadeInChina(macbook) ∧ CommonlyUsedChina(macbook))"
},
{
"input": "Translate into first-order logic: Oxford Circus is a road junction connecting Oxford Street and Regent Street.",
"output": "OxfordStreet(oxfordCircus) ∧ RegentStreet(oxfordCircus)"
},
{
"input": "Translate into first-order logic: Oxford Street is in London.",
"output": "∀x (OxfordStreet(x) → London(x))"
},
{
"input": "Translate into first-order logic: John Nash designed the construction on Regent Street.",
"output": "∃x (RegentStreet(x) ∧ Design(johnNash, x))"
},
{
"input": "Translate into first-order logic: John Nash designed Oxford Circus.",
"output": "Design(johnNash, oxfordCircus)"
},
{
"input": "Translate into first-order logic: John Nash is an architect in British.",
"output": "British(johnNash) ∧ Architect(johnNash)"
},
{
"input": "Translate into first-order logic: Oxford Circus is the entrance to Oxford Circus tube station which is a part of the Central line in 1900.",
"output": "CentralLine(oxfordCircus)"
},
{
"input": "Translate into first-order logic: Oxford Circus is a road junction connecting Oxford Street and Regent Street.",
"output": "OxfordStreet(oxfordCircus) ∧ RegentStreet(oxfordCircus)"
},
{
"input": "Translate into first-order logic: Oxford Street is in London.",
"output": "∀x (OxfordStreet(x) → London(x))"
},
{
"input": "Translate into first-order logic: John Nash designed the construction on Regent Street.",
"output": "∃x (RegentStreet(x) ∧ Design(johnNash, x))"
},
{
"input": "Translate into first-order logic: John Nash designed Oxford Circus.",
"output": "Design(johnNash, oxfordCircus)"
},
{
"input": "Translate into first-order logic: John Nash is an architect in British.",
"output": "British(johnNash) ∧ Architect(johnNash)"
},
{
"input": "Translate into first-order logic: Oxford Circus is the entrance to Oxford Circus tube station which is a part of the Central line in 1900.",
"output": "CentralLine(oxfordCircus)"
},
{
"input": "Translate into first-order logic: Oxford Circus is a road junction connecting Oxford Street and Regent Street.",
"output": "OxfordStreet(oxfordCircus) ∧ RegentStreet(oxfordCircus)"
},
{
"input": "Translate into first-order logic: Oxford Street is in London.",
"output": "∀x (OxfordStreet(x) → London(x))"
},
{
"input": "Translate into first-order logic: John Nash designed the construction on Regent Street.",
"output": "∃x (RegentStreet(x) ∧ Design(johnNash, x))"
},
{
"input": "Translate into first-order logic: John Nash designed Oxford Circus.",
"output": "Design(johnNash, oxfordCircus)"
},
{
"input": "Translate into first-order logic: John Nash is an architect in British.",
"output": "British(johnNash) ∧ Architect(johnNash)"
},
{
"input": "Translate into first-order logic: Oxford Circus is the entrance to Oxford Circus tube station which is a part of the Central line in 1900.",
"output": "CentralLine(oxfordCircus)"
},
{
"input": "Translate into first-order logic: Oxford Circus is a road junction connecting Oxford Street and Regent Street.",
"output": "OxfordStreet(oxfordCircus) ∧ RegentStreet(oxfordCircus)"
},
{
"input": "Translate into first-order logic: Oxford Street is in London.",
"output": "∀x (OxfordStreet(x) → London(x))"
},
{
"input": "Translate into first-order logic: John Nash designed the construction on Regent Street.",
"output": "∃x (RegentStreet(x) ∧ Design(johnNash, x))"
},
{
"input": "Translate into first-order logic: John Nash designed Oxford Circus.",
"output": "Design(johnNash, oxfordCircus)"
},
{
"input": "Translate into first-order logic: John Nash is an architect in British.",
"output": "British(johnNash) ∧ Architect(johnNash)"
},
{
"input": "Translate into first-order logic: Oxford Circus is the entrance to Oxford Circus tube station which is a part of the Central line in 1900.",
"output": "CentralLine(oxfordCircus)"
},
{
"input": "Translate into first-order logic: An animal is either a cat or a dog.",
"output": "∀x (Cat(x) ⊕ Dog(x))"
},
{
"input": "Translate into first-order logic: All dogs bark.",
"output": "∀x (Dog(x) → Bark(x))"
},
{
"input": "Translate into first-order logic: Ghosts do not exist.",
"output": "∀x (¬Ghost(x))"
},
{
"input": "Translate into first-order logic: If something barks, then it is not alive.",
"output": "∀x (Bark(x) → ¬Alive(x))"
},
{
"input": "Translate into first-order logic: A thing is either alive or dead.",
"output": "∀x (Alive(x) ⊕ Dead(x))"
},
{
"input": "Translate into first-order logic: Jojo is not dead.",
"output": "¬Dead(jojo)"
},
{
"input": "Translate into first-order logic: An animal is either a cat or a dog.",
"output": "∀x (Cat(x) ⊕ Dog(x))"
},
{
"input": "Translate into first-order logic: All dogs bark.",
"output": "∀x (Dog(x) → Bark(x))"
},
{
"input": "Translate into first-order logic: Ghosts do not exist.",
"output": "∀x (¬Ghost(x))"
},
{
"input": "Translate into first-order logic: If something barks, then it is not alive.",
"output": "∀x (Bark(x) → ¬Alive(x))"
},
{
"input": "Translate into first-order logic: A thing is either alive or dead.",
"output": "∀x (Alive(x) ⊕ Dead(x))"
},
{
"input": "Translate into first-order logic: Jojo is not dead.",
"output": "¬Dead(jojo)"
},
{
"input": "Translate into first-order logic: An animal is either a cat or a dog.",
"output": "∀x (Cat(x) ⊕ Dog(x))"
},
{
"input": "Translate into first-order logic: All dogs bark.",
"output": "∀x (Dog(x) → Bark(x))"
},
{
"input": "Translate into first-order logic: Ghosts do not exist.",
"output": "∀x (¬Ghost(x))"
},
{
"input": "Translate into first-order logic: If something barks, then it is not alive.",
"output": "∀x (Bark(x) → ¬Alive(x))"
},
{
"input": "Translate into first-order logic: A thing is either alive or dead.",
"output": "∀x (Alive(x) ⊕ Dead(x))"
},
{
"input": "Translate into first-order logic: Jojo is not dead.",
"output": "¬Dead(jojo)"
},
{
"input": "Translate into first-order logic: All animals that are tigers are cats.",
"output": "∀x (Tiger(x) → Cat(x))"
},
{
"input": "Translate into first-order logic: No cats are dogs.",
"output": "∀x (Cat(x) → ¬Dog(x))"
},
{
"input": "Translate into first-order logic: All Bengal tigers are tigers.",
"output": "∀x (BengalTiger(x) → Tiger(x))"
},
{
"input": "Translate into first-order logic: Everything that is a husky is a dog.",
"output": "∀x (Husky(x) → Dog(x))"
},
{
"input": "Translate into first-order logic: Fido is either a Bengal tiger or a cat.",
"output": "BengalTiger(fido) ∨ Cat(fido)"
},
{
"input": "Translate into first-order logic: All animals that are tigers are cats.",
"output": "∀x (Tiger(x) → Cat(x))"
},
{
"input": "Translate into first-order logic: No cats are dogs.",
"output": "∀x (Cat(x) → ¬Dog(x))"
},
{
"input": "Translate into first-order logic: All Bengal tigers are tigers.",
"output": "∀x (BengalTiger(x) → Tiger(x))"
},
{
"input": "Translate into first-order logic: Everything that is a husky is a dog.",
"output": "∀x (Husky(x) → Dog(x))"
},
{
"input": "Translate into first-order logic: Fido is either a Bengal tiger or a cat.",
"output": "BengalTiger(fido) ∨ Cat(fido)"
},
{
"input": "Translate into first-order logic: All animals that are tigers are cats.",
"output": "∀x (Tiger(x) → Cat(x))"
},
{
"input": "Translate into first-order logic: No cats are dogs.",
"output": "∀x (Cat(x) → ¬Dog(x))"
},
{
"input": "Translate into first-order logic: All Bengal tigers are tigers.",
"output": "∀x (BengalTiger(x) → Tiger(x))"
},
{
"input": "Translate into first-order logic: Everything that is a husky is a dog.",
"output": "∀x (Husky(x) → Dog(x))"
},
{
"input": "Translate into first-order logic: Fido is either a Bengal tiger or a cat.",
"output": "BengalTiger(fido) ∨ Cat(fido)"
},
{
"input": "Translate into first-order logic: All animals that are tigers are cats.",
"output": "∀x (Tiger(x) → Cat(x))"
},
{
"input": "Translate into first-order logic: No cats are dogs.",
"output": "∀x (Cat(x) → ¬Dog(x))"
},
{
"input": "Translate into first-order logic: All Bengal tigers are tigers.",
"output": "∀x (BengalTiger(x) → Tiger(x))"
},
{
"input": "Translate into first-order logic: Everything that is a husky is a dog.",
"output": "∀x (Husky(x) → Dog(x))"
},
{
"input": "Translate into first-order logic: Fido is either a Bengal tiger or a cat.",
"output": "BengalTiger(fido) ∨ Cat(fido)"
},
{
"input": "Translate into first-order logic: If a city hold a Summer Olympics, and the city is a US city, then the Summer Olympics will be in the US.",
"output": "∀x ∀y (SummerOlympicsCity(x, y) ∧ CityInCountry(y, us) → SummerOlympicsCountry(x, us))"
},
{
"input": "Translate into first-order logic: If a city is in a state which is in US, the city is a US city.",
"output": "∀x ∀y (CityInState(x, y) ∧ StateInCountry(y, us) → CityInCountry(x, us))"
},
{
"input": "Translate into first-order logic: If a city in a state, and a Summer Olympics is in this city, then the Summer Olympics is in this state.",
"output": "∀x ∀y ∀z (CityInState(x, y) ∧ SummerOlympicsCity(z, x) → SummerOlympicsState(z, y))"
},
{
"input": "Translate into first-order logic: The 2028 Summer Olympics is scheduled to take place in Los Angeles(LA).",
"output": "SummerOlympicsCity(y2028, la)"
},
{
"input": "Translate into first-order logic: LA is a city in California(CA).",
"output": "CityInState(la, ca)"
},
{
"input": "Translate into first-order logic: Atlanta is a US city.",
"output": "CityInCountry(atlanta, us)"
},
{
"input": "Translate into first-order logic: Atlanta is in Georgia(CA).",
"output": "StateInCountry(ca, us)"
},
{
"input": "Translate into first-order logic: CA is a state in the United States.",
"output": "CityInState(atlanta, ga)"
},
{
"input": "Translate into first-order logic: Boxing, modern pentathlon, and weightlifting will be removed from The 2028 Summer Olympics.",
"output": "¬InSummerOlympics(y2028, boxing) ∧ ¬InSummerOlympics(y2028, modern_pentathlon) ∧ ¬InSummerOlympics(y2028, weightlifting)"
},
{
"input": "Translate into first-order logic: Atlanta in the United States hold the 1996 Summer Olympics.",
"output": "SummerOlympicsCity(y1996, atlanta)"
},
{
"input": "Translate into first-order logic: If a city hold a Summer Olympics, and the city is a US city, then the Summer Olympics will be in the US.",
"output": "∀x ∀y (SummerOlympicsCity(x, y) ∧ CityInCountry(y, us) → SummerOlympicsCountry(x, us))"
},
{
"input": "Translate into first-order logic: If a city is in a state which is in US, the city is a US city.",
"output": "∀x ∀y (CityInState(x, y) ∧ StateInCountry(y, us) → CityInCountry(x, us))"
},
{
"input": "Translate into first-order logic: If a city in a state, and a Summer Olympics is in this city, then the Summer Olympics is in this state.",
"output": "∀x ∀y ∀z (CityInState(x, y) ∧ SummerOlympicsCity(z, x) → SummerOlympicsState(z, y))"
},
{
"input": "Translate into first-order logic: The 2028 Summer Olympics is scheduled to take place in Los Angeles(LA).",
"output": "SummerOlympicsCity(y2028, la)"
},
{
"input": "Translate into first-order logic: LA is a city in California(CA).",
"output": "CityInState(la, ca)"
},
{
"input": "Translate into first-order logic: Atlanta is a US city.",
"output": "CityInCountry(atlanta, us)"
},
{
"input": "Translate into first-order logic: Atlanta is in Georgia(CA).",
"output": "StateInCountry(ca, us)"
},
{
"input": "Translate into first-order logic: CA is a state in the United States.",
"output": "CityInState(atlanta, ga)"
},
{
"input": "Translate into first-order logic: Boxing, modern pentathlon, and weightlifting will be removed from The 2028 Summer Olympics.",
"output": "¬InSummerOlympics(y2028, boxing) ∧ ¬InSummerOlympics(y2028, modern_pentathlon) ∧ ¬InSummerOlympics(y2028, weightlifting)"
},
{
"input": "Translate into first-order logic: Atlanta in the United States hold the 1996 Summer Olympics.",
"output": "SummerOlympicsCity(y1996, atlanta)"
},
{
"input": "Translate into first-order logic: If a city hold a Summer Olympics, and the city is a US city, then the Summer Olympics will be in the US.",
"output": "∀x ∀y (SummerOlympicsCity(x, y) ∧ CityInCountry(y, us) → SummerOlympicsCountry(x, us))"
},
{
"input": "Translate into first-order logic: If a city is in a state which is in US, the city is a US city.",
"output": "∀x ∀y (CityInState(x, y) ∧ StateInCountry(y, us) → CityInCountry(x, us))"
},
{
"input": "Translate into first-order logic: If a city in a state, and a Summer Olympics is in this city, then the Summer Olympics is in this state.",
"output": "∀x ∀y ∀z (CityInState(x, y) ∧ SummerOlympicsCity(z, x) → SummerOlympicsState(z, y))"
},
{
"input": "Translate into first-order logic: The 2028 Summer Olympics is scheduled to take place in Los Angeles(LA).",
"output": "SummerOlympicsCity(y2028, la)"
},
{
"input": "Translate into first-order logic: LA is a city in California(CA).",
"output": "CityInState(la, ca)"
},
{
"input": "Translate into first-order logic: Atlanta is a US city.",
"output": "CityInCountry(atlanta, us)"
},
{
"input": "Translate into first-order logic: Atlanta is in Georgia(CA).",
"output": "StateInCountry(ca, us)"
},
{
"input": "Translate into first-order logic: CA is a state in the United States.",
"output": "CityInState(atlanta, ga)"
},
{
"input": "Translate into first-order logic: Boxing, modern pentathlon, and weightlifting will be removed from The 2028 Summer Olympics.",
"output": "¬InSummerOlympics(y2028, boxing) ∧ ¬InSummerOlympics(y2028, modern_pentathlon) ∧ ¬InSummerOlympics(y2028, weightlifting)"
},
{
"input": "Translate into first-order logic: Atlanta in the United States hold the 1996 Summer Olympics.",
"output": "SummerOlympicsCity(y1996, atlanta)"
},
{
"input": "Translate into first-order logic: The taiga vole is a large vole found in northwestern North America.",
"output": "Vole(taigaVole) ∧ Find(taigaVole, northAmerica)"
},
{
"input": "Translate into first-order logic: Cats like playing with all voles.",
"output": "∀x (Vole(x) → CatLikePlayingWith(x))"
},
{
"input": "Translate into first-order logic: The taiga vole lives in the boreal taiga zone.",
"output": "Live(taigaVole, borealTaigaZone)"
},
{
"input": "Translate into first-order logic: The boreal taiga zone in North America is a cold place to live in.",
"output": "∀x (Find(x, northAmerica) ∧ Live(x, borealTaigaZone) → LiveInColdPlace(x))"
},
{
"input": "Translate into first-order logic: Taiga vole is typically much larger than most other North American voles, especially those from the genus Microtus.",
"output": "Larger(taigaVole, microtusVole)"
},
{
"input": "Translate into first-order logic: The taiga vole is a large vole found in northwestern North America.",
"output": "Vole(taigaVole) ∧ Find(taigaVole, northAmerica)"
},
{
"input": "Translate into first-order logic: Cats like playing with all voles.",
"output": "∀x (Vole(x) → CatLikePlayingWith(x))"
},
{
"input": "Translate into first-order logic: The taiga vole lives in the boreal taiga zone.",
"output": "Live(taigaVole, borealTaigaZone)"
},
{
"input": "Translate into first-order logic: The boreal taiga zone in North America is a cold place to live in.",
"output": "∀x (Find(x, northAmerica) ∧ Live(x, borealTaigaZone) → LiveInColdPlace(x))"
},
{
"input": "Translate into first-order logic: Taiga vole is typically much larger than most other North American voles, especially those from the genus Microtus.",
"output": "Larger(taigaVole, microtusVole)"
},
{
"input": "Translate into first-order logic: Either in women or in men.",
"output": "∀x (Women(x) ∨ Men(x)) "
},
{
"input": "Translate into first-order logic: No men have breast cancer.",
"output": " ∀x (Men(x) → ¬BreastCancer(x))"
},
{
"input": "Translate into first-order logic: Either breast cancer or non-breast cancer.",
"output": " ∀x (BreastCancer (x) ∨ Non-BreastCancer(x)) "
},
{
"input": "Translate into first-order logic: No type of cancer is without a tumor.",
"output": " ∀x (ATypeOfCancer(x) → ¬WithoutTumor (x)) "
},
{
"input": "Translate into first-order logic: All non-breast cancers are a type of cancer.",
"output": " ∀x (Non-BreastCancer(x) → ATypeOfCancer(x)) "
},
{
"input": "Translate into first-order logic: If adenocarcinoma is a type of cancer or without a tumor, then adenocarcinoma is in women or without a tumor.",
"output": " ATypeOfCancer(adenocarcinoma) ∨ WithoutTumor(adenocarcinoma) → women(adenocarcinoma) ∨ WithoutTumor(adenocarcinoma)"
},
{
"input": "Translate into first-order logic: Either in women or in men.",
"output": "∀x (Women(x) ∨ Men(x)) "
},
{
"input": "Translate into first-order logic: No men have breast cancer.",
"output": " ∀x (Men(x) → ¬BreastCancer(x))"
},
{
"input": "Translate into first-order logic: Either breast cancer or non-breast cancer.",
"output": " ∀x (BreastCancer (x) ∨ Non-BreastCancer(x)) "
},
{
"input": "Translate into first-order logic: No type of cancer is without a tumor.",
"output": " ∀x (ATypeOfCancer(x) → ¬WithoutTumor (x)) "
},
{
"input": "Translate into first-order logic: All non-breast cancers are a type of cancer.",
"output": " ∀x (Non-BreastCancer(x) → ATypeOfCancer(x)) "
},
{
"input": "Translate into first-order logic: If adenocarcinoma is a type of cancer or without a tumor, then adenocarcinoma is in women or without a tumor.",
"output": " ATypeOfCancer(adenocarcinoma) ∨ WithoutTumor(adenocarcinoma) → women(adenocarcinoma) ∨ WithoutTumor(adenocarcinoma)"
},
{
"input": "Translate into first-order logic: Either in women or in men.",
"output": "∀x (Women(x) ∨ Men(x)) "
},
{
"input": "Translate into first-order logic: No men have breast cancer.",
"output": " ∀x (Men(x) → ¬BreastCancer(x))"
},
{
"input": "Translate into first-order logic: Either breast cancer or non-breast cancer.",
"output": " ∀x (BreastCancer (x) ∨ Non-BreastCancer(x)) "
},
{
"input": "Translate into first-order logic: No type of cancer is without a tumor.",
"output": " ∀x (ATypeOfCancer(x) → ¬WithoutTumor (x)) "
},
{
"input": "Translate into first-order logic: All non-breast cancers are a type of cancer.",
"output": " ∀x (Non-BreastCancer(x) → ATypeOfCancer(x)) "
},
{
"input": "Translate into first-order logic: If adenocarcinoma is a type of cancer or without a tumor, then adenocarcinoma is in women or without a tumor.",
"output": " ATypeOfCancer(adenocarcinoma) ∨ WithoutTumor(adenocarcinoma) → women(adenocarcinoma) ∨ WithoutTumor(adenocarcinoma)"
},
{
"input": "Translate into first-order logic: Some monitors equipped in the lab are produced by the company named AOC.",
"output": "∃x (Lab(x) ∧ AOC(x))"
},
{
"input": "Translate into first-order logic: All monitors equipped in the lab are cheaper than their original prices.",
"output": "∀x (Lab(x) → Cheaper(x))"
},
{
"input": "Translate into first-order logic: If the monitor is cheaper than its original prices, then its resolution is 1080p.",
"output": "∀x (Cheaper(x) → A1080p(x))"
},
{
"input": "Translate into first-order logic: If a monitor is with a resolution of 1080p, then it does not support the type-c port.",
"output": "∀x (A1080p(x) → ¬TypeC(x))"
},
{
"input": "Translate into first-order logic: LG34 is equipped in the lab.",
"output": "Lab(lg-34)"
},
{
"input": "Translate into first-order logic: Some monitors equipped in the lab are produced by the company named AOC.",
"output": "∃x (Lab(x) ∧ AOC(x))"
},
{
"input": "Translate into first-order logic: All monitors equipped in the lab are cheaper than their original prices.",
"output": "∀x (Lab(x) → Cheaper(x))"
},
{
"input": "Translate into first-order logic: If the monitor is cheaper than its original prices, then its resolution is 1080p.",
"output": "∀x (Cheaper(x) → A1080p(x))"
},
{
"input": "Translate into first-order logic: If a monitor is with a resolution of 1080p, then it does not support the type-c port.",
"output": "∀x (A1080p(x) → ¬TypeC(x))"
},
{
"input": "Translate into first-order logic: LG34 is equipped in the lab.",
"output": "Lab(lg-34)"
},
{
"input": "Translate into first-order logic: Some monitors equipped in the lab are produced by the company named AOC.",
"output": "∃x (Lab(x) ∧ AOC(x))"
},
{
"input": "Translate into first-order logic: All monitors equipped in the lab are cheaper than their original prices.",
"output": "∀x (Lab(x) → Cheaper(x))"
},
{
"input": "Translate into first-order logic: If the monitor is cheaper than its original prices, then its resolution is 1080p.",
"output": "∀x (Cheaper(x) → A1080p(x))"
},
{
"input": "Translate into first-order logic: If a monitor is with a resolution of 1080p, then it does not support the type-c port.",
"output": "∀x (A1080p(x) → ¬TypeC(x))"
},
{
"input": "Translate into first-order logic: LG34 is equipped in the lab.",
"output": "Lab(lg-34)"
},
{
"input": "Translate into first-order logic: All fruits sold in Boston are shipped from Columbia.",
"output": "∀x (SoldBoston(x) → ShippedFromColumbia(x))"
},
{
"input": "Translate into first-order logic: Some fruits sold in New Haven are shipped from Mexico.",
"output": "∃x (SoldNewHaven(x) ∧ ShippedFromMexico(x))"
},
{
"input": "Translate into first-order logic: No fruits shipped from Columbia are fruits sold in New York.",
"output": "∀x (ShippedFromColumbia(x) → ¬SoldNewYork(x))"
},
{
"input": "Translate into first-order logic: Avocadoe are a kind of fruit sold in New York or New York.",
"output": "SoldNewYork(avocado) ∨ SoldBoston(avocado)"
},
{
"input": "Translate into first-order logic: Avocadoe are either shipped from Columbia and sold in New Haven, or neither shipped from Columbia nor sold in New Haven.",
"output": "¬(ShippedFromColumbia(avocado) ⊕ SoldNewHaven(avocado))"
},
{
"input": "Translate into first-order logic: All fruits sold in Boston are shipped from Columbia.",
"output": "∀x (SoldBoston(x) → ShippedFromColumbia(x))"
},
{
"input": "Translate into first-order logic: Some fruits sold in New Haven are shipped from Mexico.",
"output": "∃x (SoldNewHaven(x) ∧ ShippedFromMexico(x))"
},
{
"input": "Translate into first-order logic: No fruits shipped from Columbia are fruits sold in New York.",
"output": "∀x (ShippedFromColumbia(x) → ¬SoldNewYork(x))"
},
{
"input": "Translate into first-order logic: Avocadoe are a kind of fruit sold in New York or New York.",
"output": "SoldNewYork(avocado) ∨ SoldBoston(avocado)"
},
{
"input": "Translate into first-order logic: Avocadoe are either shipped from Columbia and sold in New Haven, or neither shipped from Columbia nor sold in New Haven.",
"output": "¬(ShippedFromColumbia(avocado) ⊕ SoldNewHaven(avocado))"
},
{
"input": "Translate into first-order logic: All fruits sold in Boston are shipped from Columbia.",
"output": "∀x (SoldBoston(x) → ShippedFromColumbia(x))"
},
{
"input": "Translate into first-order logic: Some fruits sold in New Haven are shipped from Mexico.",
"output": "∃x (SoldNewHaven(x) ∧ ShippedFromMexico(x))"
},
{
"input": "Translate into first-order logic: No fruits shipped from Columbia are fruits sold in New York.",
"output": "∀x (ShippedFromColumbia(x) → ¬SoldNewYork(x))"
},
{
"input": "Translate into first-order logic: Avocadoe are a kind of fruit sold in New York or New York.",
"output": "SoldNewYork(avocado) ∨ SoldBoston(avocado)"
},
{
"input": "Translate into first-order logic: Avocadoe are either shipped from Columbia and sold in New Haven, or neither shipped from Columbia nor sold in New Haven.",
"output": "¬(ShippedFromColumbia(avocado) ⊕ SoldNewHaven(avocado))"
},
{
"input": "Translate into first-order logic: All fruits sold in Boston are shipped from Columbia.",
"output": "∀x (SoldBoston(x) → ShippedFromColumbia(x))"
},
{
"input": "Translate into first-order logic: Some fruits sold in New Haven are shipped from Mexico.",
"output": "∃x (SoldNewHaven(x) ∧ ShippedFromMexico(x))"
},
{
"input": "Translate into first-order logic: No fruits shipped from Columbia are fruits sold in New York.",
"output": "∀x (ShippedFromColumbia(x) → ¬SoldNewYork(x))"
},
{
"input": "Translate into first-order logic: Avocadoe are a kind of fruit sold in New York or New York.",
"output": "SoldNewYork(avocado) ∨ SoldBoston(avocado)"
},
{
"input": "Translate into first-order logic: Avocadoe are either shipped from Columbia and sold in New Haven, or neither shipped from Columbia nor sold in New Haven.",
"output": "¬(ShippedFromColumbia(avocado) ⊕ SoldNewHaven(avocado))"
},
{
"input": "Translate into first-order logic: Some monitors equipped in the library are produced by AOC.",
"output": "∃x (Library(x) ∧ AOC(x))"
},
{
"input": "Translate into first-order logic: All monitors equipped in the library are cheaper than 800 dollars.",
"output": "∀x (Library(x) → Cheap(x))"
},
{
"input": "Translate into first-order logic: All monitors cheaper than 800 dollars are with a resolution of 1080p.",
"output": "∀x (Cheap(x) → A1080p(x))"
},
{
"input": "Translate into first-order logic: If a monitor has a resolution of 1080p, then it does not support the type-c port.",
"output": "∀x (A1080p(x) → ¬TypeC(x))"
},
{
"input": "Translate into first-order logic: A-2017 supports the type-c port.",
"output": "TypeC(a-2017)"
},
{
"input": "Translate into first-order logic: Some monitors equipped in the library are produced by AOC.",
"output": "∃x (Library(x) ∧ AOC(x))"
},
{
"input": "Translate into first-order logic: All monitors equipped in the library are cheaper than 800 dollars.",
"output": "∀x (Library(x) → Cheap(x))"
},
{
"input": "Translate into first-order logic: All monitors cheaper than 800 dollars are with a resolution of 1080p.",
"output": "∀x (Cheap(x) → A1080p(x))"
},
{
"input": "Translate into first-order logic: If a monitor has a resolution of 1080p, then it does not support the type-c port.",
"output": "∀x (A1080p(x) → ¬TypeC(x))"
},
{
"input": "Translate into first-order logic: A-2017 supports the type-c port.",
"output": "TypeC(a-2017)"
},
{
"input": "Translate into first-order logic: Some monitors equipped in the library are produced by AOC.",
"output": "∃x (Library(x) ∧ AOC(x))"
},
{
"input": "Translate into first-order logic: All monitors equipped in the library are cheaper than 800 dollars.",
"output": "∀x (Library(x) → Cheap(x))"
},
{
"input": "Translate into first-order logic: All monitors cheaper than 800 dollars are with a resolution of 1080p.",
"output": "∀x (Cheap(x) → A1080p(x))"
},
{
"input": "Translate into first-order logic: If a monitor has a resolution of 1080p, then it does not support the type-c port.",
"output": "∀x (A1080p(x) → ¬TypeC(x))"
},
{
"input": "Translate into first-order logic: A-2017 supports the type-c port.",
"output": "TypeC(a-2017)"
},
{
"input": "Translate into first-order logic: Sūduva Marijampolė holds the Lithuanian Supercup.",
"output": "Hold(suduva, thelithuaniansupercup)"
},
{
"input": "Translate into first-order logic: Sūduva Marijampolė is a soccer team.",
"output": "SoccerTeam(suduva)"
},
{
"input": "Translate into first-order logic: Ainderby Quernhow is a village and civil parish in the Hambleton District.",
"output": "∀x (AinderbyQuernhow(x) → Village(x) ∧ CivilParish(x) ∧ Hambleton(x))"
},
{
"input": "Translate into first-order logic: Hambleton District is in North Yorkshire.",
"output": "∀x (Hambleton(x) → NorthYorkshire(x))"
},
{
"input": "Translate into first-order logic: North Yorkshire is in England.",
"output": "∀x (NorthYorkshire(x) → England(x))"
},
{
"input": "Translate into first-order logic: Ainderby Quernhow is a village and civil parish in the Hambleton District.",
"output": "∀x (AinderbyQuernhow(x) → Village(x) ∧ CivilParish(x) ∧ Hambleton(x))"
},
{
"input": "Translate into first-order logic: Hambleton District is in North Yorkshire.",
"output": "∀x (Hambleton(x) → NorthYorkshire(x))"
},
{
"input": "Translate into first-order logic: North Yorkshire is in England.",
"output": "∀x (NorthYorkshire(x) → England(x))"
},
{
"input": "Translate into first-order logic: Douglas Adams is an author who created the book collection called The Salmon of Doubt.",
"output": "Author(douglasAdams) ∧ Book(theSalmonOfDoubt)"
},
{
"input": "Translate into first-order logic: The Salmon of Doubt is about life experiences and technology.",
"output": "AboutLifeExperience(theSalmonOfDoubt) ∧ AboutTechnology(theSalmonOfDoubt)"
},
{
"input": "Translate into first-order logic: All authors are writers.",
"output": "∀x (Author(x) → Writer(x))"
},
{
"input": "Translate into first-order logic: Writers create innovative ideas.",
"output": "∀x (Writer(x) → CreateInnovativeIdea(x))"
},
{
"input": "Translate into first-order logic: Some books that contain innovative ideas are about technology.",
"output": "∃x (ContainInnovativeIdea(x) ∧ AboutTechnology(x))"
},
{
"input": "Translate into first-order logic: Douglas Adams is an author who created the book collection called The Salmon of Doubt.",
"output": "Author(douglasAdams) ∧ Book(theSalmonOfDoubt)"
},
{
"input": "Translate into first-order logic: The Salmon of Doubt is about life experiences and technology.",
"output": "AboutLifeExperience(theSalmonOfDoubt) ∧ AboutTechnology(theSalmonOfDoubt)"
},
{
"input": "Translate into first-order logic: All authors are writers.",
"output": "∀x (Author(x) → Writer(x))"
},
{
"input": "Translate into first-order logic: Writers create innovative ideas.",
"output": "∀x (Writer(x) → CreateInnovativeIdea(x))"
},
{
"input": "Translate into first-order logic: Some books that contain innovative ideas are about technology.",
"output": "∃x (ContainInnovativeIdea(x) ∧ AboutTechnology(x))"
},
{
"input": "Translate into first-order logic: Douglas Adams is an author who created the book collection called The Salmon of Doubt.",
"output": "Author(douglasAdams) ∧ Book(theSalmonOfDoubt)"
},
{
"input": "Translate into first-order logic: The Salmon of Doubt is about life experiences and technology.",
"output": "AboutLifeExperience(theSalmonOfDoubt) ∧ AboutTechnology(theSalmonOfDoubt)"
},
{
"input": "Translate into first-order logic: All authors are writers.",
"output": "∀x (Author(x) → Writer(x))"
},
{
"input": "Translate into first-order logic: Writers create innovative ideas.",
"output": "∀x (Writer(x) → CreateInnovativeIdea(x))"
},
{
"input": "Translate into first-order logic: Some books that contain innovative ideas are about technology.",
"output": "∃x (ContainInnovativeIdea(x) ∧ AboutTechnology(x))"
},
{
"input": "Translate into first-order logic: No disposable products can help slow down global warming.",
"output": "∀x (DisposableProducts(x) → ¬HelpSlowDownGlobalWarming(x))"
},
{
"input": "Translate into first-order logic: All eco-friendly brands can help slow down global warming.",
"output": " ∀x (Eco-friendlyBrand(x) → HelpSlowDownGlobalWarming(x))"
},
{
"input": "Translate into first-order logic: All sustainable fashion brands are eco-friendly brands.",
"output": " ∀x (SustainableFashionBrand(x) → Eco-friendlyBrand(x))"
},
{
"input": "Translate into first-order logic: All fast fashion products are disposable products.",
"output": " ∀x (FastFashionProducts(x) → DisposableProducts(x)) "
},
{
"input": "Translate into first-order logic: If Reformation is not helping slow down global warming, then Reformation is an eco-friendly brand or a sustainable fashion brand.",
"output": " ¬HelpSlowDownGlobalWarming(reformation) → Eco-friendlyBrand(reformation) ∨ SustainableFashionBrand(reformation)"
},
{
"input": "Translate into first-order logic: No disposable products can help slow down global warming.",
"output": "∀x (DisposableProducts(x) → ¬HelpSlowDownGlobalWarming(x))"
},
{
"input": "Translate into first-order logic: All eco-friendly brands can help slow down global warming.",
"output": " ∀x (Eco-friendlyBrand(x) → HelpSlowDownGlobalWarming(x))"
},
{
"input": "Translate into first-order logic: All sustainable fashion brands are eco-friendly brands.",
"output": " ∀x (SustainableFashionBrand(x) → Eco-friendlyBrand(x))"
},
{
"input": "Translate into first-order logic: All fast fashion products are disposable products.",
"output": " ∀x (FastFashionProducts(x) → DisposableProducts(x)) "
},
{
"input": "Translate into first-order logic: If Reformation is not helping slow down global warming, then Reformation is an eco-friendly brand or a sustainable fashion brand.",
"output": " ¬HelpSlowDownGlobalWarming(reformation) → Eco-friendlyBrand(reformation) ∨ SustainableFashionBrand(reformation)"
},
{
"input": "Translate into first-order logic: No disposable products can help slow down global warming.",
"output": "∀x (DisposableProducts(x) → ¬HelpSlowDownGlobalWarming(x))"
},
{
"input": "Translate into first-order logic: All eco-friendly brands can help slow down global warming.",
"output": " ∀x (Eco-friendlyBrand(x) → HelpSlowDownGlobalWarming(x))"
},
{
"input": "Translate into first-order logic: All sustainable fashion brands are eco-friendly brands.",
"output": " ∀x (SustainableFashionBrand(x) → Eco-friendlyBrand(x))"
},
{
"input": "Translate into first-order logic: All fast fashion products are disposable products.",
"output": " ∀x (FastFashionProducts(x) → DisposableProducts(x)) "
},
{
"input": "Translate into first-order logic: If Reformation is not helping slow down global warming, then Reformation is an eco-friendly brand or a sustainable fashion brand.",
"output": " ¬HelpSlowDownGlobalWarming(reformation) → Eco-friendlyBrand(reformation) ∨ SustainableFashionBrand(reformation)"
},
{
"input": "Translate into first-order logic: No disposable products can help slow down global warming.",
"output": "∀x (DisposableProducts(x) → ¬HelpSlowDownGlobalWarming(x))"
},
{
"input": "Translate into first-order logic: All eco-friendly brands can help slow down global warming.",
"output": " ∀x (Eco-friendlyBrand(x) → HelpSlowDownGlobalWarming(x))"
},
{
"input": "Translate into first-order logic: All sustainable fashion brands are eco-friendly brands.",
"output": " ∀x (SustainableFashionBrand(x) → Eco-friendlyBrand(x))"
},
{
"input": "Translate into first-order logic: All fast fashion products are disposable products.",
"output": " ∀x (FastFashionProducts(x) → DisposableProducts(x)) "
},
{
"input": "Translate into first-order logic: If Reformation is not helping slow down global warming, then Reformation is an eco-friendly brand or a sustainable fashion brand.",
"output": " ¬HelpSlowDownGlobalWarming(reformation) → Eco-friendlyBrand(reformation) ∨ SustainableFashionBrand(reformation)"
},
{
"input": "Translate into first-order logic: No disposable products can help slow down global warming.",
"output": "∀x (DisposableProducts(x) → ¬HelpSlowDownGlobalWarming(x))"
},
{
"input": "Translate into first-order logic: All eco-friendly brands can help slow down global warming.",
"output": " ∀x (Eco-friendlyBrand(x) → HelpSlowDownGlobalWarming(x))"
},
{
"input": "Translate into first-order logic: All sustainable fashion brands are eco-friendly brands.",
"output": " ∀x (SustainableFashionBrand(x) → Eco-friendlyBrand(x))"
},
{
"input": "Translate into first-order logic: All fast fashion products are disposable products.",
"output": " ∀x (FastFashionProducts(x) → DisposableProducts(x)) "
},
{
"input": "Translate into first-order logic: If Reformation is not helping slow down global warming, then Reformation is an eco-friendly brand or a sustainable fashion brand.",
"output": " ¬HelpSlowDownGlobalWarming(reformation) → Eco-friendlyBrand(reformation) ∨ SustainableFashionBrand(reformation)"
},
{
"input": "Translate into first-order logic: No disposable products can help slow down global warming.",
"output": "∀x (DisposableProducts(x) → ¬HelpSlowDownGlobalWarming(x))"
},
{
"input": "Translate into first-order logic: All eco-friendly brands can help slow down global warming.",
"output": " ∀x (Eco-friendlyBrand(x) → HelpSlowDownGlobalWarming(x))"
},
{
"input": "Translate into first-order logic: All sustainable fashion brands are eco-friendly brands.",
"output": " ∀x (SustainableFashionBrand(x) → Eco-friendlyBrand(x))"
},
{
"input": "Translate into first-order logic: All fast fashion products are disposable products.",
"output": " ∀x (FastFashionProducts(x) → DisposableProducts(x)) "
},
{
"input": "Translate into first-order logic: If Reformation is not helping slow down global warming, then Reformation is an eco-friendly brand or a sustainable fashion brand.",
"output": " ¬HelpSlowDownGlobalWarming(reformation) → Eco-friendlyBrand(reformation) ∨ SustainableFashionBrand(reformation)"
},
{
"input": "Translate into first-order logic: Roy Richardson was a cricketer for Sint Maartener, a consituent country.",
"output": "Cricketeer(royrichardson) ∧ PlayedFor(royrichardson, sintmaartener) ∧ ConstituentCountry(sintmaartener)"
},
{
"input": "Translate into first-order logic: Roy Richardson was a right handed batsman and medium pace bowler.",
"output": "RightHanded(royrichardson) ∧ Batsman(royrichardson) ∧ MediumPaceBowler(royrichardson)"
},
{
"input": "Translate into first-order logic: Roy Richardson was old when he debuted in cricket.",
"output": "Old(royrichardson) ∧ DebutedIn(royrichardson, cricket)"
},
{
"input": "Translate into first-order logic: Sherville Huggins dismissed Roy Richardson.",
"output": "Dismissed(shervillehuggins, royrichardson)"
},
{
"input": "Translate into first-order logic: Roy Richardson was a cricketer for Sint Maartener, a consituent country.",
"output": "Cricketeer(royrichardson) ∧ PlayedFor(royrichardson, sintmaartener) ∧ ConstituentCountry(sintmaartener)"
},
{
"input": "Translate into first-order logic: Roy Richardson was a right handed batsman and medium pace bowler.",
"output": "RightHanded(royrichardson) ∧ Batsman(royrichardson) ∧ MediumPaceBowler(royrichardson)"
},
{
"input": "Translate into first-order logic: Roy Richardson was old when he debuted in cricket.",
"output": "Old(royrichardson) ∧ DebutedIn(royrichardson, cricket)"
},
{
"input": "Translate into first-order logic: Sherville Huggins dismissed Roy Richardson.",
"output": "Dismissed(shervillehuggins, royrichardson)"
},
{
"input": "Translate into first-order logic: To get a job at Google, you need to have a lot of work experience or a good education.",
"output": "∀x (Employed(x, google) → WorkExp(x) ∨ GoodEduc(x))"
},
{
"input": "Translate into first-order logic: All Yale graduates who submitted their resumes to Google got jobs there.",
"output": "∀x ((Yale(x) ∧ CV(x, google)) → Employed(x, google))"
},
{
"input": "Translate into first-order logic: John has a lot of work experience.",
"output": "WorkExp(john)"
},
{
"input": "Translate into first-order logic: John submitted his resume to Google and got a job there.",
"output": "CV(john, google) ∧ Employed(john, google)"
},
{
"input": "Translate into first-order logic: No students are doctors.",
"output": "∀x (Student(x) → ¬Doctor(x))"
},
{
"input": "Translate into first-order logic: All people taking classes are students.",
"output": "∀x (TakingClass(x) → Student(x))"
},
{
"input": "Translate into first-order logic: All graduate students are people taking classes.",
"output": "∀x (GraduateStudent(x) → TakingClass(x))"
},
{
"input": "Translate into first-order logic: All PhD students are graduate students.",
"output": "∀x (PhDStudent(x) → GraduateStudent(x))"
},
{
"input": "Translate into first-order logic: If Joe is a graduate student or a doctor (but not both), then Joe is not a graduate student and a student.",
"output": "GraduateStudent(joe) ⊕  Doctor(joe) → ¬(GraduateStudent(joe) ^ Student(joe))"
},
{
"input": "Translate into first-order logic: No students are doctors.",
"output": "∀x (Student(x) → ¬Doctor(x))"
},
{
"input": "Translate into first-order logic: All people taking classes are students.",
"output": "∀x (TakingClass(x) → Student(x))"
},
{
"input": "Translate into first-order logic: All graduate students are people taking classes.",
"output": "∀x (GraduateStudent(x) → TakingClass(x))"
},
{
"input": "Translate into first-order logic: All PhD students are graduate students.",
"output": "∀x (PhDStudent(x) → GraduateStudent(x))"
},
{
"input": "Translate into first-order logic: If Joe is a graduate student or a doctor (but not both), then Joe is not a graduate student and a student.",
"output": "GraduateStudent(joe) ⊕  Doctor(joe) → ¬(GraduateStudent(joe) ^ Student(joe))"
},
{
"input": "Translate into first-order logic: No students are doctors.",
"output": "∀x (Student(x) → ¬Doctor(x))"
},
{
"input": "Translate into first-order logic: All people taking classes are students.",
"output": "∀x (TakingClass(x) → Student(x))"
},
{
"input": "Translate into first-order logic: All graduate students are people taking classes.",
"output": "∀x (GraduateStudent(x) → TakingClass(x))"
},
{
"input": "Translate into first-order logic: All PhD students are graduate students.",
"output": "∀x (PhDStudent(x) → GraduateStudent(x))"
},
{
"input": "Translate into first-order logic: If Joe is a graduate student or a doctor (but not both), then Joe is not a graduate student and a student.",
"output": "GraduateStudent(joe) ⊕  Doctor(joe) → ¬(GraduateStudent(joe) ^ Student(joe))"
},
{
"input": "Translate into first-order logic: Hugh Vanstone is one of the world's leading lighting designers.",
"output": "WorldLeadingLightningDesigner(hughVanstone)"
},
{
"input": "Translate into first-order logic: Hugh Vanstone is from the UK.",
"output": "FromUK(hughVanstone)"
},
{
"input": "Translate into first-order logic: Hugh Vanstone has lit more than 160 productions.",
"output": "LitOver160Productions(hughVanstone)"
},
{
"input": "Translate into first-order logic: Hugh Vanstone attended school where he is from.",
"output": "AttendedSchoolWhereFrom(hughVanstone)"
},
{
"input": "Translate into first-order logic: Hugh Vanstone is one of the world's leading lighting designers.",
"output": "WorldLeadingLightningDesigner(hughVanstone)"
},
{
"input": "Translate into first-order logic: Hugh Vanstone is from the UK.",
"output": "FromUK(hughVanstone)"
},
{
"input": "Translate into first-order logic: Hugh Vanstone has lit more than 160 productions.",
"output": "LitOver160Productions(hughVanstone)"
},
{
"input": "Translate into first-order logic: Hugh Vanstone attended school where he is from.",
"output": "AttendedSchoolWhereFrom(hughVanstone)"
},
{
"input": "Translate into first-order logic: Hugh Vanstone is one of the world's leading lighting designers.",
"output": "WorldLeadingLightningDesigner(hughVanstone)"
},
{
"input": "Translate into first-order logic: Hugh Vanstone is from the UK.",
"output": "FromUK(hughVanstone)"
},
{
"input": "Translate into first-order logic: Hugh Vanstone has lit more than 160 productions.",
"output": "LitOver160Productions(hughVanstone)"
},
{
"input": "Translate into first-order logic: Hugh Vanstone attended school where he is from.",
"output": "AttendedSchoolWhereFrom(hughVanstone)"
},
{
"input": "Translate into first-order logic: No man can run faster than Bolt.",
"output": "∀x (Man(x) → ¬FasterThanBolt(x))"
},
{
"input": "Translate into first-order logic: Superman is not a man.",
"output": "¬Man(superman) "
},
{
"input": "Translate into first-order logic: Donald Ervin Knuth is an American computer scientist, mathematician, and Professor Emeritus at Stanford University.",
"output": "AmericanComputerScientist(donaldErvinKnuth) ∧ Mathematician(donaldErvinKnuth) ∧ ProfessorStanford(donaldErvinKnuth)"
},
{
"input": "Translate into first-order logic: Knuth has been called the \"father of the analysis of algorithms\".",
"output": "BeCalled(donaldErvinKnuth, fatherOfTheAnalysisOfAlgorithms)"
},
{
"input": "Translate into first-order logic: Donald Ervin Knuth is an American computer scientist, mathematician, and Professor Emeritus at Stanford University.",
"output": "AmericanComputerScientist(donaldErvinKnuth) ∧ Mathematician(donaldErvinKnuth) ∧ ProfessorStanford(donaldErvinKnuth)"
},
{
"input": "Translate into first-order logic: Knuth has been called the \"father of the analysis of algorithms\".",
"output": "BeCalled(donaldErvinKnuth, fatherOfTheAnalysisOfAlgorithms)"
},
{
"input": "Translate into first-order logic: Donald Ervin Knuth is an American computer scientist, mathematician, and Professor Emeritus at Stanford University.",
"output": "AmericanComputerScientist(donaldErvinKnuth) ∧ Mathematician(donaldErvinKnuth) ∧ ProfessorStanford(donaldErvinKnuth)"
},
{
"input": "Translate into first-order logic: Knuth has been called the \"father of the analysis of algorithms\".",
"output": "BeCalled(donaldErvinKnuth, fatherOfTheAnalysisOfAlgorithms)"
},
{
"input": "Translate into first-order logic: Neocrepidodera Corpulentas are flea beetles or moths.",
"output": "FleaBeetle(neocrepidoderacorpulenta) ∨ Moth(neocrepidoderacorpulenta)"
},
{
"input": "Translate into first-order logic: The species Neocrepidodera Corpulenta is in the Chrysomelidae family.",
"output": "Species(neocrepidoderacorpulenta) ∧ Family(chrysomelidae) ∧ In(neocrepidoderacorpulenta, chrysomelidae)"
},
{
"input": "Translate into first-order logic: There are no moths within the Chrysomelidae family.",
"output": "∀x (In(x, chrysomelidae) ∧ Family(chrysomelidae) → ¬Moth(x))"
},
{
"input": "Translate into first-order logic: Neocrepidodera Corpulentas are flea beetles or moths.",
"output": "FleaBeetle(neocrepidoderacorpulenta) ∨ Moth(neocrepidoderacorpulenta)"
},
{
"input": "Translate into first-order logic: The species Neocrepidodera Corpulenta is in the Chrysomelidae family.",
"output": "Species(neocrepidoderacorpulenta) ∧ Family(chrysomelidae) ∧ In(neocrepidoderacorpulenta, chrysomelidae)"
},
{
"input": "Translate into first-order logic: There are no moths within the Chrysomelidae family.",
"output": "∀x (In(x, chrysomelidae) ∧ Family(chrysomelidae) → ¬Moth(x))"
},
{
"input": "Translate into first-order logic: Carrozzeria Colli is a Milanese coachbuilder company that was established by Giuseppe Colli in 1931.",
"output": "MilaneseCoachbuilderCompany(carrozzeriacolli) ∧ EstablishedBy(carrozzeriacolli, giuseppecolli) ∧ EstablishedIn(carrozzeriacolli, y1901)"
},
{
"input": "Translate into first-order logic: Carrozzeria Colli is a company that specialized in using aluminum.",
"output": "SpecializedIn(carrozzeriacolli, usingaluminum)"
},
{
"input": "Translate into first-order logic: The first automobiles built by Carrozzeria Colli were racing cars.",
"output": "∀x (FirstAutomobilesBy(x, carrozzeriacolli) → Racingcar(x))"
},
{
"input": "Translate into first-order logic: Some racing cars built by Carrozzeria Colli used Fiat 1100 mechanicals and chasis.",
"output": "∃x (RacingCar(x) ∧ BuiltBy(x, carrozzeriacolli) ∧ Used(x, fiat110mechanicals) ∧ Used(x, chasis))"
},
{
"input": "Translate into first-order logic: Carrozzeria Colli worked for airforces.",
"output": "∃x (Airforce(x) ∧ WorkedFor(carrozzeriacolli, x))"
},
{
"input": "Translate into first-order logic: Carrozzeria Colli made car bodies.",
"output": "Made(carrozzeriacolli, carbodies)"
},
{
"input": "Translate into first-order logic: Carrozzeria Colli is a Milanese coachbuilder company that was established by Giuseppe Colli in 1931.",
"output": "MilaneseCoachbuilderCompany(carrozzeriacolli) ∧ EstablishedBy(carrozzeriacolli, giuseppecolli) ∧ EstablishedIn(carrozzeriacolli, y1901)"
},
{
"input": "Translate into first-order logic: Carrozzeria Colli is a company that specialized in using aluminum.",
"output": "SpecializedIn(carrozzeriacolli, usingaluminum)"
},
{
"input": "Translate into first-order logic: The first automobiles built by Carrozzeria Colli were racing cars.",
"output": "∀x (FirstAutomobilesBy(x, carrozzeriacolli) → Racingcar(x))"
},
{
"input": "Translate into first-order logic: Some racing cars built by Carrozzeria Colli used Fiat 1100 mechanicals and chasis.",
"output": "∃x (RacingCar(x) ∧ BuiltBy(x, carrozzeriacolli) ∧ Used(x, fiat110mechanicals) ∧ Used(x, chasis))"
},
{
"input": "Translate into first-order logic: Carrozzeria Colli worked for airforces.",
"output": "∃x (Airforce(x) ∧ WorkedFor(carrozzeriacolli, x))"
},
{
"input": "Translate into first-order logic: Carrozzeria Colli made car bodies.",
"output": "Made(carrozzeriacolli, carbodies)"
},
{
"input": "Translate into first-order logic: Carrozzeria Colli is a Milanese coachbuilder company that was established by Giuseppe Colli in 1931.",
"output": "MilaneseCoachbuilderCompany(carrozzeriacolli) ∧ EstablishedBy(carrozzeriacolli, giuseppecolli) ∧ EstablishedIn(carrozzeriacolli, y1901)"
},
{
"input": "Translate into first-order logic: Carrozzeria Colli is a company that specialized in using aluminum.",
"output": "SpecializedIn(carrozzeriacolli, usingaluminum)"
},
{
"input": "Translate into first-order logic: The first automobiles built by Carrozzeria Colli were racing cars.",
"output": "∀x (FirstAutomobilesBy(x, carrozzeriacolli) → Racingcar(x))"
},
{
"input": "Translate into first-order logic: Some racing cars built by Carrozzeria Colli used Fiat 1100 mechanicals and chasis.",
"output": "∃x (RacingCar(x) ∧ BuiltBy(x, carrozzeriacolli) ∧ Used(x, fiat110mechanicals) ∧ Used(x, chasis))"
},
{
"input": "Translate into first-order logic: Carrozzeria Colli worked for airforces.",
"output": "∃x (Airforce(x) ∧ WorkedFor(carrozzeriacolli, x))"
},
{
"input": "Translate into first-order logic: Carrozzeria Colli made car bodies.",
"output": "Made(carrozzeriacolli, carbodies)"
},
{
"input": "Translate into first-order logic: Carrozzeria Colli is a Milanese coachbuilder company that was established by Giuseppe Colli in 1931.",
"output": "MilaneseCoachbuilderCompany(carrozzeriacolli) ∧ EstablishedBy(carrozzeriacolli, giuseppecolli) ∧ EstablishedIn(carrozzeriacolli, y1901)"
},
{
"input": "Translate into first-order logic: Carrozzeria Colli is a company that specialized in using aluminum.",
"output": "SpecializedIn(carrozzeriacolli, usingaluminum)"
},
{
"input": "Translate into first-order logic: The first automobiles built by Carrozzeria Colli were racing cars.",
"output": "∀x (FirstAutomobilesBy(x, carrozzeriacolli) → Racingcar(x))"
},
{
"input": "Translate into first-order logic: Some racing cars built by Carrozzeria Colli used Fiat 1100 mechanicals and chasis.",
"output": "∃x (RacingCar(x) ∧ BuiltBy(x, carrozzeriacolli) ∧ Used(x, fiat110mechanicals) ∧ Used(x, chasis))"
},
{
"input": "Translate into first-order logic: Carrozzeria Colli worked for airforces.",
"output": "∃x (Airforce(x) ∧ WorkedFor(carrozzeriacolli, x))"
},
{
"input": "Translate into first-order logic: Carrozzeria Colli made car bodies.",
"output": "Made(carrozzeriacolli, carbodies)"
},
{
"input": "Translate into first-order logic: Carrozzeria Colli is a Milanese coachbuilder company that was established by Giuseppe Colli in 1931.",
"output": "MilaneseCoachbuilderCompany(carrozzeriacolli) ∧ EstablishedBy(carrozzeriacolli, giuseppecolli) ∧ EstablishedIn(carrozzeriacolli, y1901)"
},
{
"input": "Translate into first-order logic: Carrozzeria Colli is a company that specialized in using aluminum.",
"output": "SpecializedIn(carrozzeriacolli, usingaluminum)"
},
{
"input": "Translate into first-order logic: The first automobiles built by Carrozzeria Colli were racing cars.",
"output": "∀x (FirstAutomobilesBy(x, carrozzeriacolli) → Racingcar(x))"
},
{
"input": "Translate into first-order logic: Some racing cars built by Carrozzeria Colli used Fiat 1100 mechanicals and chasis.",
"output": "∃x (RacingCar(x) ∧ BuiltBy(x, carrozzeriacolli) ∧ Used(x, fiat110mechanicals) ∧ Used(x, chasis))"
},
{
"input": "Translate into first-order logic: Carrozzeria Colli worked for airforces.",
"output": "∃x (Airforce(x) ∧ WorkedFor(carrozzeriacolli, x))"
},
{
"input": "Translate into first-order logic: Carrozzeria Colli made car bodies.",
"output": "Made(carrozzeriacolli, carbodies)"
},
{
"input": "Translate into first-order logic: John will go to the cinema if and only if Jack goes to the cinema today.",
"output": "GoToTheCinema(john, today) ↔ GoToTheCinema(jack, today)"
},
{
"input": "Translate into first-order logic: Jack will go to the cinema if and only if Iron Man is on and the weather is not bad today.",
"output": "GoToTheCinema(jack, today) ↔ (Movie(ironman) ∧ ¬BadWeather(today))"
},
{
"input": "Translate into first-order logic: Some days in March have bad weather.",
"output": "∃x (Month(march) → BadWeather(x))"
},
{
"input": "Translate into first-order logic: Iron man is on.",
"output": "Movie(ironman)"
},
{
"input": "Translate into first-order logic: It's March now.",
"output": "Month(march)"
},
{
"input": "Translate into first-order logic: John will go to the cinema if and only if Jack goes to the cinema today.",
"output": "GoToTheCinema(john, today) ↔ GoToTheCinema(jack, today)"
},
{
"input": "Translate into first-order logic: Jack will go to the cinema if and only if Iron Man is on and the weather is not bad today.",
"output": "GoToTheCinema(jack, today) ↔ (Movie(ironman) ∧ ¬BadWeather(today))"
},
{
"input": "Translate into first-order logic: Some days in March have bad weather.",
"output": "∃x (Month(march) → BadWeather(x))"
},
{
"input": "Translate into first-order logic: Iron man is on.",
"output": "Movie(ironman)"
},
{
"input": "Translate into first-order logic: It's March now.",
"output": "Month(march)"
},
{
"input": "Translate into first-order logic: Quiksilver sells sportswear, clothing, footwear, and accessories.",
"output": "∀x (QuiksilverSells(x) → Sportswear(x) ∨ Clothing(x) ∨ Footwear(x) ∨ Accessory(x))"
},
{
"input": "Translate into first-order logic: Flannels are a type of clothing.",
"output": "Clothing(flannel)"
},
{
"input": "Translate into first-order logic: Joe owns an item fron Quiksilver.",
"output": "∃x (QuiksilverSells(x) → JoeOwns(x))"
},
{
"input": "Translate into first-order logic: Quiksilver sells sportswear, clothing, footwear, and accessories.",
"output": "∀x (QuiksilverSells(x) → Sportswear(x) ∨ Clothing(x) ∨ Footwear(x) ∨ Accessory(x))"
},
{
"input": "Translate into first-order logic: Flannels are a type of clothing.",
"output": "Clothing(flannel)"
},
{
"input": "Translate into first-order logic: Joe owns an item fron Quiksilver.",
"output": "∃x (QuiksilverSells(x) → JoeOwns(x))"
},
{
"input": "Translate into first-order logic: Quiksilver sells sportswear, clothing, footwear, and accessories.",
"output": "∀x (QuiksilverSells(x) → Sportswear(x) ∨ Clothing(x) ∨ Footwear(x) ∨ Accessory(x))"
},
{
"input": "Translate into first-order logic: Flannels are a type of clothing.",
"output": "Clothing(flannel)"
},
{
"input": "Translate into first-order logic: Joe owns an item fron Quiksilver.",
"output": "∃x (QuiksilverSells(x) → JoeOwns(x))"
},
{
"input": "Translate into first-order logic: No video games released by Nintendo support the PS4 platform.",
"output": "∀x (Nintendo(x) → ¬SupportPS4(x))"
},
{
"input": "Translate into first-order logic: All video games in the Pokemon series are released by Nintendo.",
"output": "∀x (Pokemon(x) → Nintendo(x))"
},
{
"input": "Translate into first-order logic: All video games in the FIFA series support the PS4 platform.",
"output": "∀x (FIFA(x) → SupportPS4(x))"
},
{
"input": "Translate into first-order logic: All video games supporting users to simulate playing soccer games online are in the FIFA series.",
"output": "∀x (SoccerOnline(x) → FIFA(x))"
},
{
"input": "Translate into first-order logic: The video game named “Be Lionel” is in the Pokemon series or supports users to simulate playing football games online.",
"output": "Pokemon(belionel) ⊕ SoccerOnline(belionel)"
},
{
"input": "Translate into first-order logic: No video games released by Nintendo support the PS4 platform.",
"output": "∀x (Nintendo(x) → ¬SupportPS4(x))"
},
{
"input": "Translate into first-order logic: All video games in the Pokemon series are released by Nintendo.",
"output": "∀x (Pokemon(x) → Nintendo(x))"
},
{
"input": "Translate into first-order logic: All video games in the FIFA series support the PS4 platform.",
"output": "∀x (FIFA(x) → SupportPS4(x))"
},
{
"input": "Translate into first-order logic: All video games supporting users to simulate playing soccer games online are in the FIFA series.",
"output": "∀x (SoccerOnline(x) → FIFA(x))"
},
{
"input": "Translate into first-order logic: The video game named “Be Lionel” is in the Pokemon series or supports users to simulate playing football games online.",
"output": "Pokemon(belionel) ⊕ SoccerOnline(belionel)"
},
{
"input": "Translate into first-order logic: No video games released by Nintendo support the PS4 platform.",
"output": "∀x (Nintendo(x) → ¬SupportPS4(x))"
},
{
"input": "Translate into first-order logic: All video games in the Pokemon series are released by Nintendo.",
"output": "∀x (Pokemon(x) → Nintendo(x))"
},
{
"input": "Translate into first-order logic: All video games in the FIFA series support the PS4 platform.",
"output": "∀x (FIFA(x) → SupportPS4(x))"
},
{
"input": "Translate into first-order logic: All video games supporting users to simulate playing soccer games online are in the FIFA series.",
"output": "∀x (SoccerOnline(x) → FIFA(x))"
},
{
"input": "Translate into first-order logic: The video game named “Be Lionel” is in the Pokemon series or supports users to simulate playing football games online.",
"output": "Pokemon(belionel) ⊕ SoccerOnline(belionel)"
},
{
"input": "Translate into first-order logic: No video games released by Nintendo support the PS4 platform.",
"output": "∀x (Nintendo(x) → ¬SupportPS4(x))"
},
{
"input": "Translate into first-order logic: All video games in the Pokemon series are released by Nintendo.",
"output": "∀x (Pokemon(x) → Nintendo(x))"
},
{
"input": "Translate into first-order logic: All video games in the FIFA series support the PS4 platform.",
"output": "∀x (FIFA(x) → SupportPS4(x))"
},
{
"input": "Translate into first-order logic: All video games supporting users to simulate playing soccer games online are in the FIFA series.",
"output": "∀x (SoccerOnline(x) → FIFA(x))"
},
{
"input": "Translate into first-order logic: The video game named “Be Lionel” is in the Pokemon series or supports users to simulate playing football games online.",
"output": "Pokemon(belionel) ⊕ SoccerOnline(belionel)"
},
{
"input": "Translate into first-order logic: No payment cards issued by Russian banks can be used with ApplePay.",
"output": "∀x (RussianBank(x) → ¬ApplePay(x))"
},
{
"input": "Translate into first-order logic: All MIR payment cards are issued by Russian banks.",
"output": "∀x (Mir(x) → RussianBank(x))"
},
{
"input": "Translate into first-order logic: Some international payment cards can be used with ApplePay.",
"output": "∃x (International(x) → ApplePay(x))"
},
{
"input": "Translate into first-order logic: Social payments in Russia can only be transferred to MIR payment cards.",
"output": "∀x (SocialRussia(x) → Mir(x))"
},
{
"input": "Translate into first-order logic: Bank of America payment cards can be used with ApplePay.",
"output": "ApplePay(boapaymentcards)"
},
{
"input": "Translate into first-order logic: No payment cards issued by Russian banks can be used with ApplePay.",
"output": "∀x (RussianBank(x) → ¬ApplePay(x))"
},
{
"input": "Translate into first-order logic: All MIR payment cards are issued by Russian banks.",
"output": "∀x (Mir(x) → RussianBank(x))"
},
{
"input": "Translate into first-order logic: Some international payment cards can be used with ApplePay.",
"output": "∃x (International(x) → ApplePay(x))"
},
{
"input": "Translate into first-order logic: Social payments in Russia can only be transferred to MIR payment cards.",
"output": "∀x (SocialRussia(x) → Mir(x))"
},
{
"input": "Translate into first-order logic: Bank of America payment cards can be used with ApplePay.",
"output": "ApplePay(boapaymentcards)"
},
{
"input": "Translate into first-order logic: No payment cards issued by Russian banks can be used with ApplePay.",
"output": "∀x (RussianBank(x) → ¬ApplePay(x))"
},
{
"input": "Translate into first-order logic: All MIR payment cards are issued by Russian banks.",
"output": "∀x (Mir(x) → RussianBank(x))"
},
{
"input": "Translate into first-order logic: Some international payment cards can be used with ApplePay.",
"output": "∃x (International(x) → ApplePay(x))"
},
{
"input": "Translate into first-order logic: Social payments in Russia can only be transferred to MIR payment cards.",
"output": "∀x (SocialRussia(x) → Mir(x))"
},
{
"input": "Translate into first-order logic: Bank of America payment cards can be used with ApplePay.",
"output": "ApplePay(boapaymentcards)"
},
{
"input": "Translate into first-order logic: The Lumina APV is produced by Chevrolet.",
"output": "Chevrolet(luminaAPV)"
},
{
"input": "Translate into first-order logic: The Astro is a van produced by Chevrolet.",
"output": "Chevrolet(astro) ∧ Van(astro)"
},
{
"input": "Translate into first-order logic: Cars produced by Chevrolet are either cars or vans.",
"output": "∀x (Chevrolet(x) → Car(x) ⊕ Van(x))"
},
{
"input": "Translate into first-order logic: The Lumina APV is produced by Chevrolet.",
"output": "Chevrolet(luminaAPV)"
},
{
"input": "Translate into first-order logic: The Astro is a van produced by Chevrolet.",
"output": "Chevrolet(astro) ∧ Van(astro)"
},
{
"input": "Translate into first-order logic: Cars produced by Chevrolet are either cars or vans.",
"output": "∀x (Chevrolet(x) → Car(x) ⊕ Van(x))"
},
{
"input": "Translate into first-order logic: The Lumina APV is produced by Chevrolet.",
"output": "Chevrolet(luminaAPV)"
},
{
"input": "Translate into first-order logic: The Astro is a van produced by Chevrolet.",
"output": "Chevrolet(astro) ∧ Van(astro)"
},
{
"input": "Translate into first-order logic: Cars produced by Chevrolet are either cars or vans.",
"output": "∀x (Chevrolet(x) → Car(x) ⊕ Van(x))"
},
{
"input": "Translate into first-order logic: The Lumina APV is produced by Chevrolet.",
"output": "Chevrolet(luminaAPV)"
},
{
"input": "Translate into first-order logic: The Astro is a van produced by Chevrolet.",
"output": "Chevrolet(astro) ∧ Van(astro)"
},
{
"input": "Translate into first-order logic: Cars produced by Chevrolet are either cars or vans.",
"output": "∀x (Chevrolet(x) → Car(x) ⊕ Van(x))"
},
{
"input": "Translate into first-order logic: Everyone who works in person is a commuter.",
"output": "∀x (InPerson(x) → Commuter(x))"
},
{
"input": "Translate into first-order logic: People either work in person or work from home.",
"output": "∀x (InPerson(x) ⊕ FromHome(x))"
},
{
"input": "Translate into first-order logic: Everyone who works from home has a relaxed schedule.",
"output": "∀x (FromHome(x) → Relaxed(x))"
},
{
"input": "Translate into first-order logic: George is either a commuter or has a home office setup.",
"output": "Commuter(george) ⊕ HomeOffice(george)"
},
{
"input": "Translate into first-order logic: If George is either a person who works from home or has a home office setup, then George is not a person who works from home and a commuter.",
"output": "FromHome(george) ⊕ HomeOffice(george) → ¬(FromHome(george) ∧ Commuter(george))"
},
{
"input": "Translate into first-order logic: Everyone who works in person is a commuter.",
"output": "∀x (InPerson(x) → Commuter(x))"
},
{
"input": "Translate into first-order logic: People either work in person or work from home.",
"output": "∀x (InPerson(x) ⊕ FromHome(x))"
},
{
"input": "Translate into first-order logic: Everyone who works from home has a relaxed schedule.",
"output": "∀x (FromHome(x) → Relaxed(x))"
},
{
"input": "Translate into first-order logic: George is either a commuter or has a home office setup.",
"output": "Commuter(george) ⊕ HomeOffice(george)"
},
{
"input": "Translate into first-order logic: If George is either a person who works from home or has a home office setup, then George is not a person who works from home and a commuter.",
"output": "FromHome(george) ⊕ HomeOffice(george) → ¬(FromHome(george) ∧ Commuter(george))"
},
{
"input": "Translate into first-order logic: Everyone who works in person is a commuter.",
"output": "∀x (InPerson(x) → Commuter(x))"
},
{
"input": "Translate into first-order logic: People either work in person or work from home.",
"output": "∀x (InPerson(x) ⊕ FromHome(x))"
},
{
"input": "Translate into first-order logic: Everyone who works from home has a relaxed schedule.",
"output": "∀x (FromHome(x) → Relaxed(x))"
},
{
"input": "Translate into first-order logic: George is either a commuter or has a home office setup.",
"output": "Commuter(george) ⊕ HomeOffice(george)"
},
{
"input": "Translate into first-order logic: If George is either a person who works from home or has a home office setup, then George is not a person who works from home and a commuter.",
"output": "FromHome(george) ⊕ HomeOffice(george) → ¬(FromHome(george) ∧ Commuter(george))"
},
{
"input": "Translate into first-order logic: Jason Kramer is an American music supervisor.",
"output": "MusicSupervisor(jasonKramer) ∧ American(jasonKramer)"
},
{
"input": "Translate into first-order logic: Some American radio personalities are also music supervisors.",
"output": "∃x (American(x) ∧ MusicSupervisor(x) ∧ RadioPersonality(x))"
},
{
"input": "Translate into first-order logic: Anyone who hosts a show on a public radio station is a radio personality.",
"output": "∀x (HostShowOnPublicRadioStation(x) → RadioPersonality(x))"
},
{
"input": "Translate into first-order logic: Joe Rogan is a radio personality.",
"output": "RadioPersonality(joeRogan)"
},
{
"input": "Translate into first-order logic: Jason Kramer hosted a show on a public radio station.",
"output": "HostShowOnPublicRadioStation(jasonKramer)"
},
{
"input": "Translate into first-order logic: Jason Kramer is an American music supervisor.",
"output": "MusicSupervisor(jasonKramer) ∧ American(jasonKramer)"
},
{
"input": "Translate into first-order logic: Some American radio personalities are also music supervisors.",
"output": "∃x (American(x) ∧ MusicSupervisor(x) ∧ RadioPersonality(x))"
},
{
"input": "Translate into first-order logic: Anyone who hosts a show on a public radio station is a radio personality.",
"output": "∀x (HostShowOnPublicRadioStation(x) → RadioPersonality(x))"
},
{
"input": "Translate into first-order logic: Joe Rogan is a radio personality.",
"output": "RadioPersonality(joeRogan)"
},
{
"input": "Translate into first-order logic: Jason Kramer hosted a show on a public radio station.",
"output": "HostShowOnPublicRadioStation(jasonKramer)"
},
{
"input": "Translate into first-order logic: Jason Kramer is an American music supervisor.",
"output": "MusicSupervisor(jasonKramer) ∧ American(jasonKramer)"
},
{
"input": "Translate into first-order logic: Some American radio personalities are also music supervisors.",
"output": "∃x (American(x) ∧ MusicSupervisor(x) ∧ RadioPersonality(x))"
},
{
"input": "Translate into first-order logic: Anyone who hosts a show on a public radio station is a radio personality.",
"output": "∀x (HostShowOnPublicRadioStation(x) → RadioPersonality(x))"
},
{
"input": "Translate into first-order logic: Joe Rogan is a radio personality.",
"output": "RadioPersonality(joeRogan)"
},
{
"input": "Translate into first-order logic: Jason Kramer hosted a show on a public radio station.",
"output": "HostShowOnPublicRadioStation(jasonKramer)"
},
{
"input": "Translate into first-order logic: No coffee sold in Walmart is produced in France.",
"output": "∀x (Walmart(x) → ¬France(x))"
},
{
"input": "Translate into first-order logic: All coffee supplied by the company is sold in Walmart.",
"output": "∀x (Company(x) → Walmart(x))"
},
{
"input": "Translate into first-order logic: All coffee produced in Columbia is produced in France.",
"output": "∀x (Columbia(x) → France(x))"
},
{
"input": "Translate into first-order logic: All coffee favored by local residents is coffee produced in Columbia.",
"output": "∀x (Favored(x) → Columbia(x))"
},
{
"input": "Translate into first-order logic: All coffee with high prices is favored by local residents.",
"output": "∀x (HighPrice(x) → Favored(x))"
},
{
"input": "Translate into first-order logic: Civet Coffee is not produced in Columbia and is cheap.",
"output": "¬(Columbia(civetcoffee) ∧ HighPrice(civetcoffee))"
},
{
"input": "Translate into first-order logic: Jamaica Blue is sold in Walmart or favored by local residents.",
"output": "Walmart(jamaicablue) ∨ Favored(jamaicablue)"
},
{
"input": "Translate into first-order logic: No coffee sold in Walmart is produced in France.",
"output": "∀x (Walmart(x) → ¬France(x))"
},
{
"input": "Translate into first-order logic: All coffee supplied by the company is sold in Walmart.",
"output": "∀x (Company(x) → Walmart(x))"
},
{
"input": "Translate into first-order logic: All coffee produced in Columbia is produced in France.",
"output": "∀x (Columbia(x) → France(x))"
},
{
"input": "Translate into first-order logic: All coffee favored by local residents is coffee produced in Columbia.",
"output": "∀x (Favored(x) → Columbia(x))"
},
{
"input": "Translate into first-order logic: All coffee with high prices is favored by local residents.",
"output": "∀x (HighPrice(x) → Favored(x))"
},
{
"input": "Translate into first-order logic: Civet Coffee is not produced in Columbia and is cheap.",
"output": "¬(Columbia(civetcoffee) ∧ HighPrice(civetcoffee))"
},
{
"input": "Translate into first-order logic: Jamaica Blue is sold in Walmart or favored by local residents.",
"output": "Walmart(jamaicablue) ∨ Favored(jamaicablue)"
},
{
"input": "Translate into first-order logic: No coffee sold in Walmart is produced in France.",
"output": "∀x (Walmart(x) → ¬France(x))"
},
{
"input": "Translate into first-order logic: All coffee supplied by the company is sold in Walmart.",
"output": "∀x (Company(x) → Walmart(x))"
},
{
"input": "Translate into first-order logic: All coffee produced in Columbia is produced in France.",
"output": "∀x (Columbia(x) → France(x))"
},
{
"input": "Translate into first-order logic: All coffee favored by local residents is coffee produced in Columbia.",
"output": "∀x (Favored(x) → Columbia(x))"
},
{
"input": "Translate into first-order logic: All coffee with high prices is favored by local residents.",
"output": "∀x (HighPrice(x) → Favored(x))"
},
{
"input": "Translate into first-order logic: Civet Coffee is not produced in Columbia and is cheap.",
"output": "¬(Columbia(civetcoffee) ∧ HighPrice(civetcoffee))"
},
{
"input": "Translate into first-order logic: Jamaica Blue is sold in Walmart or favored by local residents.",
"output": "Walmart(jamaicablue) ∨ Favored(jamaicablue)"
},
{
"input": "Translate into first-order logic: No coffee sold in Walmart is produced in France.",
"output": "∀x (Walmart(x) → ¬France(x))"
},
{
"input": "Translate into first-order logic: All coffee supplied by the company is sold in Walmart.",
"output": "∀x (Company(x) → Walmart(x))"
},
{
"input": "Translate into first-order logic: All coffee produced in Columbia is produced in France.",
"output": "∀x (Columbia(x) → France(x))"
},
{
"input": "Translate into first-order logic: All coffee favored by local residents is coffee produced in Columbia.",
"output": "∀x (Favored(x) → Columbia(x))"
},
{
"input": "Translate into first-order logic: All coffee with high prices is favored by local residents.",
"output": "∀x (HighPrice(x) → Favored(x))"
},
{
"input": "Translate into first-order logic: Civet Coffee is not produced in Columbia and is cheap.",
"output": "¬(Columbia(civetcoffee) ∧ HighPrice(civetcoffee))"
},
{
"input": "Translate into first-order logic: Jamaica Blue is sold in Walmart or favored by local residents.",
"output": "Walmart(jamaicablue) ∨ Favored(jamaicablue)"
},
{
"input": "Translate into first-order logic: There are two places named Galicia: either in Spain or in Poland.",
"output": "∀x (Galicia(x) → Spain(x) ⊕ Poland(x))"
},
{
"input": "Translate into first-order logic: Spain is in Europe.",
"output": "∀x (Spain(x) → Europe(x))"
},
{
"input": "Translate into first-order logic: Poland is in Europe.",
"output": "∀x (Poland(x) → Europe(x))"
},
{
"input": "Translate into first-order logic: Rochelle lives in Europe.",
"output": "∀x (RochelleLive(x) → Europe(x))"
},
{
"input": "Translate into first-order logic: Dominique does not live in Europe.",
"output": "∀x (DominiqueLive(x) → ¬Europe(x))"
},
{
"input": "Translate into first-order logic: Alfonso lives in Galicia.",
"output": "∀x (AlfonsoLive(x) → Galicia(x))"
},
{
"input": "Translate into first-order logic: There are two places named Galicia: either in Spain or in Poland.",
"output": "∀x (Galicia(x) → Spain(x) ⊕ Poland(x))"
},
{
"input": "Translate into first-order logic: Spain is in Europe.",
"output": "∀x (Spain(x) → Europe(x))"
},
{
"input": "Translate into first-order logic: Poland is in Europe.",
"output": "∀x (Poland(x) → Europe(x))"
},
{
"input": "Translate into first-order logic: Rochelle lives in Europe.",
"output": "∀x (RochelleLive(x) → Europe(x))"
},
{
"input": "Translate into first-order logic: Dominique does not live in Europe.",
"output": "∀x (DominiqueLive(x) → ¬Europe(x))"
},
{
"input": "Translate into first-order logic: Alfonso lives in Galicia.",
"output": "∀x (AlfonsoLive(x) → Galicia(x))"
},
{
"input": "Translate into first-order logic: There are two places named Galicia: either in Spain or in Poland.",
"output": "∀x (Galicia(x) → Spain(x) ⊕ Poland(x))"
},
{
"input": "Translate into first-order logic: Spain is in Europe.",
"output": "∀x (Spain(x) → Europe(x))"
},
{
"input": "Translate into first-order logic: Poland is in Europe.",
"output": "∀x (Poland(x) → Europe(x))"
},
{
"input": "Translate into first-order logic: Rochelle lives in Europe.",
"output": "∀x (RochelleLive(x) → Europe(x))"
},
{
"input": "Translate into first-order logic: Dominique does not live in Europe.",
"output": "∀x (DominiqueLive(x) → ¬Europe(x))"
},
{
"input": "Translate into first-order logic: Alfonso lives in Galicia.",
"output": "∀x (AlfonsoLive(x) → Galicia(x))"
},
{
"input": "Translate into first-order logic: Ralph Hammerthaler was born in Wasserburg am Inn.",
"output": "BornIn(ralphHammerthaler, wasserburgAmInn)"
},
{
"input": "Translate into first-order logic: Wasserburg am Inn is in Germany.",
"output": "LocatedIn(wasserbAmInn, germany)"
},
{
"input": "Translate into first-order logic: Germany is in Europe.",
"output": "LocatedIn(germany, europe)"
},
{
"input": "Translate into first-order logic: Ralph Hammerthaler is a German writer.",
"output": "Writer(ralphHammerthaler)"
},
{
"input": "Translate into first-order logic: Ralph Hammerthaler was born in 1965.",
"output": "BornIn1965(ralphHammerthaler)"
},
{
"input": "Translate into first-order logic: Ralph Hammerthaler was born in Wasserburg am Inn.",
"output": "BornIn(ralphHammerthaler, wasserburgAmInn)"
},
{
"input": "Translate into first-order logic: Wasserburg am Inn is in Germany.",
"output": "LocatedIn(wasserbAmInn, germany)"
},
{
"input": "Translate into first-order logic: Germany is in Europe.",
"output": "LocatedIn(germany, europe)"
},
{
"input": "Translate into first-order logic: Ralph Hammerthaler is a German writer.",
"output": "Writer(ralphHammerthaler)"
},
{
"input": "Translate into first-order logic: Ralph Hammerthaler was born in 1965.",
"output": "BornIn1965(ralphHammerthaler)"
},
{
"input": "Translate into first-order logic: All books written by Tomas have sold more than 1 million copies.",
"output": "∀x (WrittenByTomas(x) → SoldOneMillion(x))"
},
{
"input": "Translate into first-order logic: Some books that have won Hugo Awards are written by Tomas.",
"output": "∃x (WinningHugoAward(x) ∧ WrittenByTomas(x))"
},
{
"input": "Translate into first-order logic: All books about the future are inspired by Shakespeare.",
"output": "∀x (AboutFuture(x) → InspiredFromShakespeare(x))"
},
{
"input": "Translate into first-order logic: 2001 is a book either inspired from Shakespeare or it has sold more than 1 million copies.",
"output": "InspiredFromShakespeare(y2001) ⊕ SoldOneMillion(y2001) "
},
{
"input": "Translate into first-order logic: 2001 is a book that has either sold more than 1 million copies or it was written by Tomas.",
"output": "SoldOneMillion(y2001) ⊕ WrittenByTomas(y2001)"
},
{
"input": "Translate into first-order logic: All books written by Tomas have sold more than 1 million copies.",
"output": "∀x (WrittenByTomas(x) → SoldOneMillion(x))"
},
{
"input": "Translate into first-order logic: Some books that have won Hugo Awards are written by Tomas.",
"output": "∃x (WinningHugoAward(x) ∧ WrittenByTomas(x))"
},
{
"input": "Translate into first-order logic: All books about the future are inspired by Shakespeare.",
"output": "∀x (AboutFuture(x) → InspiredFromShakespeare(x))"
},
{
"input": "Translate into first-order logic: 2001 is a book either inspired from Shakespeare or it has sold more than 1 million copies.",
"output": "InspiredFromShakespeare(y2001) ⊕ SoldOneMillion(y2001) "
},
{
"input": "Translate into first-order logic: 2001 is a book that has either sold more than 1 million copies or it was written by Tomas.",
"output": "SoldOneMillion(y2001) ⊕ WrittenByTomas(y2001)"
},
{
"input": "Translate into first-order logic: All books written by Tomas have sold more than 1 million copies.",
"output": "∀x (WrittenByTomas(x) → SoldOneMillion(x))"
},
{
"input": "Translate into first-order logic: Some books that have won Hugo Awards are written by Tomas.",
"output": "∃x (WinningHugoAward(x) ∧ WrittenByTomas(x))"
},
{
"input": "Translate into first-order logic: All books about the future are inspired by Shakespeare.",
"output": "∀x (AboutFuture(x) → InspiredFromShakespeare(x))"
},
{
"input": "Translate into first-order logic: 2001 is a book either inspired from Shakespeare or it has sold more than 1 million copies.",
"output": "InspiredFromShakespeare(y2001) ⊕ SoldOneMillion(y2001) "
},
{
"input": "Translate into first-order logic: 2001 is a book that has either sold more than 1 million copies or it was written by Tomas.",
"output": "SoldOneMillion(y2001) ⊕ WrittenByTomas(y2001)"
},
{
"input": "Translate into first-order logic: No grass is food.",
"output": "∀x (Grass(x) → ¬Food(x))"
},
{
"input": "Translate into first-order logic: All meadows are grass.",
"output": "∀x (Meadow(x) → Grass(x))"
},
{
"input": "Translate into first-order logic: All edible things are food.",
"output": "∀x (Edible(x) → Food(x))"
},
{
"input": "Translate into first-order logic: All fruits are edible.",
"output": "∀x (Fruit(x) → Edible(x))"
},
{
"input": "Translate into first-order logic: All lemons are fruit.",
"output": "∀x (Lemon(x) → Fruit(x))"
},
{
"input": "Translate into first-order logic: Grapes are not edible and lemons.",
"output": "¬(Edible(grape) ∧ Lemon(grape))"
},
{
"input": "Translate into first-order logic: Bananas are grass or fruit.",
"output": "Grass(banana) ∨ Fruit(banana)"
},
{
"input": "Translate into first-order logic: No grass is food.",
"output": "∀x (Grass(x) → ¬Food(x))"
},
{
"input": "Translate into first-order logic: All meadows are grass.",
"output": "∀x (Meadow(x) → Grass(x))"
},
{
"input": "Translate into first-order logic: All edible things are food.",
"output": "∀x (Edible(x) → Food(x))"
},
{
"input": "Translate into first-order logic: All fruits are edible.",
"output": "∀x (Fruit(x) → Edible(x))"
},
{
"input": "Translate into first-order logic: All lemons are fruit.",
"output": "∀x (Lemon(x) → Fruit(x))"
},
{
"input": "Translate into first-order logic: Grapes are not edible and lemons.",
"output": "¬(Edible(grape) ∧ Lemon(grape))"
},
{
"input": "Translate into first-order logic: Bananas are grass or fruit.",
"output": "Grass(banana) ∨ Fruit(banana)"
},
{
"input": "Translate into first-order logic: No grass is food.",
"output": "∀x (Grass(x) → ¬Food(x))"
},
{
"input": "Translate into first-order logic: All meadows are grass.",
"output": "∀x (Meadow(x) → Grass(x))"
},
{
"input": "Translate into first-order logic: All edible things are food.",
"output": "∀x (Edible(x) → Food(x))"
},
{
"input": "Translate into first-order logic: All fruits are edible.",
"output": "∀x (Fruit(x) → Edible(x))"
},
{
"input": "Translate into first-order logic: All lemons are fruit.",
"output": "∀x (Lemon(x) → Fruit(x))"
},
{
"input": "Translate into first-order logic: Grapes are not edible and lemons.",
"output": "¬(Edible(grape) ∧ Lemon(grape))"
},
{
"input": "Translate into first-order logic: Bananas are grass or fruit.",
"output": "Grass(banana) ∨ Fruit(banana)"
},
{
"input": "Translate into first-order logic: No grass is food.",
"output": "∀x (Grass(x) → ¬Food(x))"
},
{
"input": "Translate into first-order logic: All meadows are grass.",
"output": "∀x (Meadow(x) → Grass(x))"
},
{
"input": "Translate into first-order logic: All edible things are food.",
"output": "∀x (Edible(x) → Food(x))"
},
{
"input": "Translate into first-order logic: All fruits are edible.",
"output": "∀x (Fruit(x) → Edible(x))"
},
{
"input": "Translate into first-order logic: All lemons are fruit.",
"output": "∀x (Lemon(x) → Fruit(x))"
},
{
"input": "Translate into first-order logic: Grapes are not edible and lemons.",
"output": "¬(Edible(grape) ∧ Lemon(grape))"
},
{
"input": "Translate into first-order logic: Bananas are grass or fruit.",
"output": "Grass(banana) ∨ Fruit(banana)"
},
{
"input": "Translate into first-order logic: The Golden State Warriors are a team from San Francisco.",
"output": "Team(goldenstatewarriors) ∧ From(goldenstatewarriors, sanfrancisco)"
},
{
"input": "Translate into first-order logic: The Golden State Warriors won the NBA finals.",
"output": "Won(goldenstatewarriors, nbafinals)"
},
{
"input": "Translate into first-order logic: All teams attending the NBA finals have more than thirty years of history.",
"output": "∀x (team(x) ∧ Attending(x, nbafinals) → HasMoreThan(x, thirtyyearsofhistory))"
},
{
"input": "Translate into first-order logic: Boston Celtics are a team that lost the NBA finals.",
"output": "Team(bostonceltics) ∧ Lost(bostonceltics, nbafinals)"
},
{
"input": "Translate into first-order logic: If a team wins the NBA finals, then they will have more income.",
"output": "∀x (Team(x) ∧ Won(x, nbafinals) → MoreIncome(x))"
},
{
"input": "Translate into first-order logic: If a team wins or loses at the NBA finals, then they are attending the finals.",
"output": "∀x (Won(x, nbafinals) ∨ Lost(x, nbafinals) → Attending(x, nbafinals))"
},
{
"input": "Translate into first-order logic: The Golden State Warriors are a team from San Francisco.",
"output": "Team(goldenstatewarriors) ∧ From(goldenstatewarriors, sanfrancisco)"
},
{
"input": "Translate into first-order logic: The Golden State Warriors won the NBA finals.",
"output": "Won(goldenstatewarriors, nbafinals)"
},
{
"input": "Translate into first-order logic: All teams attending the NBA finals have more than thirty years of history.",
"output": "∀x (team(x) ∧ Attending(x, nbafinals) → HasMoreThan(x, thirtyyearsofhistory))"
},
{
"input": "Translate into first-order logic: Boston Celtics are a team that lost the NBA finals.",
"output": "Team(bostonceltics) ∧ Lost(bostonceltics, nbafinals)"
},
{
"input": "Translate into first-order logic: If a team wins the NBA finals, then they will have more income.",
"output": "∀x (Team(x) ∧ Won(x, nbafinals) → MoreIncome(x))"
},
{
"input": "Translate into first-order logic: If a team wins or loses at the NBA finals, then they are attending the finals.",
"output": "∀x (Won(x, nbafinals) ∨ Lost(x, nbafinals) → Attending(x, nbafinals))"
},
{
"input": "Translate into first-order logic: The Golden State Warriors are a team from San Francisco.",
"output": "Team(goldenstatewarriors) ∧ From(goldenstatewarriors, sanfrancisco)"
},
{
"input": "Translate into first-order logic: The Golden State Warriors won the NBA finals.",
"output": "Won(goldenstatewarriors, nbafinals)"
},
{
"input": "Translate into first-order logic: All teams attending the NBA finals have more than thirty years of history.",
"output": "∀x (team(x) ∧ Attending(x, nbafinals) → HasMoreThan(x, thirtyyearsofhistory))"
},
{
"input": "Translate into first-order logic: Boston Celtics are a team that lost the NBA finals.",
"output": "Team(bostonceltics) ∧ Lost(bostonceltics, nbafinals)"
},
{
"input": "Translate into first-order logic: If a team wins the NBA finals, then they will have more income.",
"output": "∀x (Team(x) ∧ Won(x, nbafinals) → MoreIncome(x))"
},
{
"input": "Translate into first-order logic: If a team wins or loses at the NBA finals, then they are attending the finals.",
"output": "∀x (Won(x, nbafinals) ∨ Lost(x, nbafinals) → Attending(x, nbafinals))"
},
{
"input": "Translate into first-order logic: Maya will play violin if and only if she never injures her fingers.",
"output": "CanInjureFingures(maya) → ¬WillPlayViolin(maya)"
},
{
"input": "Translate into first-order logic: Volleyball players can injure their ankle, fingers, or shoulder.",
"output": "∀x (VolleyballPlayer(x) → CanInjureFingures(x))"
},
{
"input": "Translate into first-order logic: Maya is a volleyball player.",
"output": "VolleyballPlayer(maya)"
},
{
"input": "Translate into first-order logic: All devices belonging to the company are connected to Google Home.",
"output": "∀x (InCompany(x) → GoogleHome(x))"
},
{
"input": "Translate into first-order logic: All devices with the company logo belong to the company.",
"output": "∀x (CompanyLogo(x) → InCompany(x))"
},
{
"input": "Translate into first-order logic: A device is either with the company logo or belongs to employees.",
"output": "∀x (CompanyLogo(x) ∨ Employee(x))"
},
{
"input": "Translate into first-order logic: All devices belonging to employees are available to connect to the company's wifi.",
"output": "∀x (Employee(x) → Wifi(x))"
},
{
"input": "Translate into first-order logic: All devices connected to Google Home are controlled by managers.",
"output": "∀x (GoogleHome(x) → ControlledByManager(x))"
},
{
"input": "Translate into first-order logic: All devices that connect to the company's wifi are easy to operate.",
"output": "∀x (Wifi(x) → EasyToOperate(x))"
},
{
"input": "Translate into first-order logic: All devices that are easy to operate are produced after 2020.",
"output": "∀x (EasyToOperate(x) → ProducedAfter2020(x))"
},
{
"input": "Translate into first-order logic: IPod1 is produced before 2020.",
"output": "¬ProducedAfter2020(iPod1)"
},
{
"input": "Translate into first-order logic: All devices belonging to the company are connected to Google Home.",
"output": "∀x (InCompany(x) → GoogleHome(x))"
},
{
"input": "Translate into first-order logic: All devices with the company logo belong to the company.",
"output": "∀x (CompanyLogo(x) → InCompany(x))"
},
{
"input": "Translate into first-order logic: A device is either with the company logo or belongs to employees.",
"output": "∀x (CompanyLogo(x) ∨ Employee(x))"
},
{
"input": "Translate into first-order logic: All devices belonging to employees are available to connect to the company's wifi.",
"output": "∀x (Employee(x) → Wifi(x))"
},
{
"input": "Translate into first-order logic: All devices connected to Google Home are controlled by managers.",
"output": "∀x (GoogleHome(x) → ControlledByManager(x))"
},
{
"input": "Translate into first-order logic: All devices that connect to the company's wifi are easy to operate.",
"output": "∀x (Wifi(x) → EasyToOperate(x))"
},
{
"input": "Translate into first-order logic: All devices that are easy to operate are produced after 2020.",
"output": "∀x (EasyToOperate(x) → ProducedAfter2020(x))"
},
{
"input": "Translate into first-order logic: IPod1 is produced before 2020.",
"output": "¬ProducedAfter2020(iPod1)"
},
{
"input": "Translate into first-order logic: All devices belonging to the company are connected to Google Home.",
"output": "∀x (InCompany(x) → GoogleHome(x))"
},
{
"input": "Translate into first-order logic: All devices with the company logo belong to the company.",
"output": "∀x (CompanyLogo(x) → InCompany(x))"
},
{
"input": "Translate into first-order logic: A device is either with the company logo or belongs to employees.",
"output": "∀x (CompanyLogo(x) ∨ Employee(x))"
},
{
"input": "Translate into first-order logic: All devices belonging to employees are available to connect to the company's wifi.",
"output": "∀x (Employee(x) → Wifi(x))"
},
{
"input": "Translate into first-order logic: All devices connected to Google Home are controlled by managers.",
"output": "∀x (GoogleHome(x) → ControlledByManager(x))"
},
{
"input": "Translate into first-order logic: All devices that connect to the company's wifi are easy to operate.",
"output": "∀x (Wifi(x) → EasyToOperate(x))"
},
{
"input": "Translate into first-order logic: All devices that are easy to operate are produced after 2020.",
"output": "∀x (EasyToOperate(x) → ProducedAfter2020(x))"
},
{
"input": "Translate into first-order logic: IPod1 is produced before 2020.",
"output": "¬ProducedAfter2020(iPod1)"
},
{
"input": "Translate into first-order logic: All devices belonging to the company are connected to Google Home.",
"output": "∀x (InCompany(x) → GoogleHome(x))"
},
{
"input": "Translate into first-order logic: All devices with the company logo belong to the company.",
"output": "∀x (CompanyLogo(x) → InCompany(x))"
},
{
"input": "Translate into first-order logic: A device is either with the company logo or belongs to employees.",
"output": "∀x (CompanyLogo(x) ∨ Employee(x))"
},
{
"input": "Translate into first-order logic: All devices belonging to employees are available to connect to the company's wifi.",
"output": "∀x (Employee(x) → Wifi(x))"
},
{
"input": "Translate into first-order logic: All devices connected to Google Home are controlled by managers.",
"output": "∀x (GoogleHome(x) → ControlledByManager(x))"
},
{
"input": "Translate into first-order logic: All devices that connect to the company's wifi are easy to operate.",
"output": "∀x (Wifi(x) → EasyToOperate(x))"
},
{
"input": "Translate into first-order logic: All devices that are easy to operate are produced after 2020.",
"output": "∀x (EasyToOperate(x) → ProducedAfter2020(x))"
},
{
"input": "Translate into first-order logic: IPod1 is produced before 2020.",
"output": "¬ProducedAfter2020(iPod1)"
},
{
"input": "Translate into first-order logic: All CD players are delicate mechanisms.",
"output": "∀x (CDPlayer(x) → DelicateMechanism(x))"
},
{
"input": "Translate into first-order logic: No delicate mechanisms are suitable toys for children.",
"output": "∀x (DelicateMechanism(x) → ¬SuitableToyForChildren(x))"
},
{
"input": "Translate into first-order logic: All mammals are living beings.",
"output": "∀x (Mammal(x) → LivingBeing(x)) "
},
{
"input": "Translate into first-order logic: All elephants are mammals.",
"output": "∀x (Elephant(x) → Mammal(x))"
},
{
"input": "Translate into first-order logic: All baby elephants are elephants.",
"output": "∀x (BabyElephant(x) → Elephant(x))"
},
{
"input": "Translate into first-order logic: Some baby elephants are sleepy.",
"output": "∃x (BabyElephant(x) ∧ Sleepy(x))"
},
{
"input": "Translate into first-order logic: If Jumbo is a living being, then Jumbo is not an elephant or a mammal.",
"output": "LivingBeing(jumbo) → ¬(Elephant(jumbo) ∨ Mammal(jumbo))"
},
{
"input": "Translate into first-order logic: If Jumbo is sleepy, then Jumbo is a baby elephant or an elephant.",
"output": "Sleepy(jumbo) → BabyElephant(jumbo) ∨ Mammal(jumbo)"
},
{
"input": "Translate into first-order logic: All mammals are living beings.",
"output": "∀x (Mammal(x) → LivingBeing(x)) "
},
{
"input": "Translate into first-order logic: All elephants are mammals.",
"output": "∀x (Elephant(x) → Mammal(x))"
},
{
"input": "Translate into first-order logic: All baby elephants are elephants.",
"output": "∀x (BabyElephant(x) → Elephant(x))"
},
{
"input": "Translate into first-order logic: Some baby elephants are sleepy.",
"output": "∃x (BabyElephant(x) ∧ Sleepy(x))"
},
{
"input": "Translate into first-order logic: If Jumbo is a living being, then Jumbo is not an elephant or a mammal.",
"output": "LivingBeing(jumbo) → ¬(Elephant(jumbo) ∨ Mammal(jumbo))"
},
{
"input": "Translate into first-order logic: If Jumbo is sleepy, then Jumbo is a baby elephant or an elephant.",
"output": "Sleepy(jumbo) → BabyElephant(jumbo) ∨ Mammal(jumbo)"
},
{
"input": "Translate into first-order logic: All mammals are living beings.",
"output": "∀x (Mammal(x) → LivingBeing(x)) "
},
{
"input": "Translate into first-order logic: All elephants are mammals.",
"output": "∀x (Elephant(x) → Mammal(x))"
},
{
"input": "Translate into first-order logic: All baby elephants are elephants.",
"output": "∀x (BabyElephant(x) → Elephant(x))"
},
{
"input": "Translate into first-order logic: Some baby elephants are sleepy.",
"output": "∃x (BabyElephant(x) ∧ Sleepy(x))"
},
{
"input": "Translate into first-order logic: If Jumbo is a living being, then Jumbo is not an elephant or a mammal.",
"output": "LivingBeing(jumbo) → ¬(Elephant(jumbo) ∨ Mammal(jumbo))"
},
{
"input": "Translate into first-order logic: If Jumbo is sleepy, then Jumbo is a baby elephant or an elephant.",
"output": "Sleepy(jumbo) → BabyElephant(jumbo) ∨ Mammal(jumbo)"
},
{
"input": "Translate into first-order logic: All mammals are living beings.",
"output": "∀x (Mammal(x) → LivingBeing(x)) "
},
{
"input": "Translate into first-order logic: All elephants are mammals.",
"output": "∀x (Elephant(x) → Mammal(x))"
},
{
"input": "Translate into first-order logic: All baby elephants are elephants.",
"output": "∀x (BabyElephant(x) → Elephant(x))"
},
{
"input": "Translate into first-order logic: Some baby elephants are sleepy.",
"output": "∃x (BabyElephant(x) ∧ Sleepy(x))"
},
{
"input": "Translate into first-order logic: If Jumbo is a living being, then Jumbo is not an elephant or a mammal.",
"output": "LivingBeing(jumbo) → ¬(Elephant(jumbo) ∨ Mammal(jumbo))"
},
{
"input": "Translate into first-order logic: If Jumbo is sleepy, then Jumbo is a baby elephant or an elephant.",
"output": "Sleepy(jumbo) → BabyElephant(jumbo) ∨ Mammal(jumbo)"
},
{
"input": "Translate into first-order logic: All mammals are living beings.",
"output": "∀x (Mammal(x) → LivingBeing(x)) "
},
{
"input": "Translate into first-order logic: All elephants are mammals.",
"output": "∀x (Elephant(x) → Mammal(x))"
},
{
"input": "Translate into first-order logic: All baby elephants are elephants.",
"output": "∀x (BabyElephant(x) → Elephant(x))"
},
{
"input": "Translate into first-order logic: Some baby elephants are sleepy.",
"output": "∃x (BabyElephant(x) ∧ Sleepy(x))"
},
{
"input": "Translate into first-order logic: If Jumbo is a living being, then Jumbo is not an elephant or a mammal.",
"output": "LivingBeing(jumbo) → ¬(Elephant(jumbo) ∨ Mammal(jumbo))"
},
{
"input": "Translate into first-order logic: If Jumbo is sleepy, then Jumbo is a baby elephant or an elephant.",
"output": "Sleepy(jumbo) → BabyElephant(jumbo) ∨ Mammal(jumbo)"
},
{
"input": "Translate into first-order logic: No faculty does homework.",
"output": "∀x (Faculty(x) → ¬DoesHomework(x))"
},
{
"input": "Translate into first-order logic: All students do homework.",
"output": "∀x (Student(x) → DoesHomework(x))"
},
{
"input": "Translate into first-order logic: All kids are students.",
"output": "∀x (Kid(x) → Student(x))"
},
{
"input": "Translate into first-order logic: If someone works at a school, then they are faculty.",
"output": "∀x (WorkAtSchool(x) → Faculty(x))"
},
{
"input": "Translate into first-order logic: If Jill works at a school or is a teacher, then Jill works at a school.",
"output": "WorkAtSchool(jill) ∨ DoesHomework(jill) → WorkAtSchool(jill)"
},
{
"input": "Translate into first-order logic: No faculty does homework.",
"output": "∀x (Faculty(x) → ¬DoesHomework(x))"
},
{
"input": "Translate into first-order logic: All students do homework.",
"output": "∀x (Student(x) → DoesHomework(x))"
},
{
"input": "Translate into first-order logic: All kids are students.",
"output": "∀x (Kid(x) → Student(x))"
},
{
"input": "Translate into first-order logic: If someone works at a school, then they are faculty.",
"output": "∀x (WorkAtSchool(x) → Faculty(x))"
},
{
"input": "Translate into first-order logic: If Jill works at a school or is a teacher, then Jill works at a school.",
"output": "WorkAtSchool(jill) ∨ DoesHomework(jill) → WorkAtSchool(jill)"
},
{
"input": "Translate into first-order logic: No faculty does homework.",
"output": "∀x (Faculty(x) → ¬DoesHomework(x))"
},
{
"input": "Translate into first-order logic: All students do homework.",
"output": "∀x (Student(x) → DoesHomework(x))"
},
{
"input": "Translate into first-order logic: All kids are students.",
"output": "∀x (Kid(x) → Student(x))"
},
{
"input": "Translate into first-order logic: If someone works at a school, then they are faculty.",
"output": "∀x (WorkAtSchool(x) → Faculty(x))"
},
{
"input": "Translate into first-order logic: If Jill works at a school or is a teacher, then Jill works at a school.",
"output": "WorkAtSchool(jill) ∨ DoesHomework(jill) → WorkAtSchool(jill)"
},
{
"input": "Translate into first-order logic: Either Max listens to classical music or Max listens to rap.",
"output": "∀x (MaxListensToClassicalMusic(x) ∨ MaxListensToRap(x))"
},
{
"input": "Translate into first-order logic: All the songs that Max listens to that are classical music are from the 12th century.",
"output": "∀x (MaxListensToClassicalMusic(x) → SongsFrom12thCentury(x))"
},
{
"input": "Translate into first-order logic: If the song Max listens to is rap, then the song is from Kanye West.",
"output": "∀x (MaxListensToRap(x) → SongsFromKanyeWest(x))"
},
{
"input": "Translate into first-order logic: If a songs is from Kanye West, then the song is full of lyrics.",
"output": "∀x (SongsFromKanyeWest(x) → SongsFullOfLyrics(x))"
},
{
"input": "Translate into first-order logic: All songs that are full of lyrics need to be written with words",
"output": "∀x (SongsFullOfLyrics(x) → NeedToBeWrittenWithWords(x))"
},
{
"input": "Translate into first-order logic: If “As it was” by Harry Styles is classical music that Max listens to or  from the 12th century, then “As it was” by Harry Styles is either classical music that Max listens to, or the songs are from 12th century.",
"output": "MaxListensToClassicalMusic(asItWasByHarryStyles) ∨ SongsFrom12thCentury(asItWasByHarryStyles) → MaxListensToClassicalMusic(asItWasByHarryStyles) ⊕ SongsFrom12thCentury(asItWasByHarryStyles)"
},
{
"input": "Translate into first-order logic: Either Max listens to classical music or Max listens to rap.",
"output": "∀x (MaxListensToClassicalMusic(x) ∨ MaxListensToRap(x))"
},
{
"input": "Translate into first-order logic: All the songs that Max listens to that are classical music are from the 12th century.",
"output": "∀x (MaxListensToClassicalMusic(x) → SongsFrom12thCentury(x))"
},
{
"input": "Translate into first-order logic: If the song Max listens to is rap, then the song is from Kanye West.",
"output": "∀x (MaxListensToRap(x) → SongsFromKanyeWest(x))"
},
{
"input": "Translate into first-order logic: If a songs is from Kanye West, then the song is full of lyrics.",
"output": "∀x (SongsFromKanyeWest(x) → SongsFullOfLyrics(x))"
},
{
"input": "Translate into first-order logic: All songs that are full of lyrics need to be written with words",
"output": "∀x (SongsFullOfLyrics(x) → NeedToBeWrittenWithWords(x))"
},
{
"input": "Translate into first-order logic: If “As it was” by Harry Styles is classical music that Max listens to or  from the 12th century, then “As it was” by Harry Styles is either classical music that Max listens to, or the songs are from 12th century.",
"output": "MaxListensToClassicalMusic(asItWasByHarryStyles) ∨ SongsFrom12thCentury(asItWasByHarryStyles) → MaxListensToClassicalMusic(asItWasByHarryStyles) ⊕ SongsFrom12thCentury(asItWasByHarryStyles)"
},
{
"input": "Translate into first-order logic: Either Max listens to classical music or Max listens to rap.",
"output": "∀x (MaxListensToClassicalMusic(x) ∨ MaxListensToRap(x))"
},
{
"input": "Translate into first-order logic: All the songs that Max listens to that are classical music are from the 12th century.",
"output": "∀x (MaxListensToClassicalMusic(x) → SongsFrom12thCentury(x))"
},
{
"input": "Translate into first-order logic: If the song Max listens to is rap, then the song is from Kanye West.",
"output": "∀x (MaxListensToRap(x) → SongsFromKanyeWest(x))"
},
{
"input": "Translate into first-order logic: If a songs is from Kanye West, then the song is full of lyrics.",
"output": "∀x (SongsFromKanyeWest(x) → SongsFullOfLyrics(x))"
},
{
"input": "Translate into first-order logic: All songs that are full of lyrics need to be written with words",
"output": "∀x (SongsFullOfLyrics(x) → NeedToBeWrittenWithWords(x))"
},
{
"input": "Translate into first-order logic: If “As it was” by Harry Styles is classical music that Max listens to or  from the 12th century, then “As it was” by Harry Styles is either classical music that Max listens to, or the songs are from 12th century.",
"output": "MaxListensToClassicalMusic(asItWasByHarryStyles) ∨ SongsFrom12thCentury(asItWasByHarryStyles) → MaxListensToClassicalMusic(asItWasByHarryStyles) ⊕ SongsFrom12thCentury(asItWasByHarryStyles)"
},
{
"input": "Translate into first-order logic: \"Your Woman\" is a song by British one-man band White Town.",
"output": "Produce(whiteTown, yourWoman)"
},
{
"input": "Translate into first-order logic: \"Your Woman\" song peaked at No. 1 on the UK Singles Chart.",
"output": "Peak(yourWoman, uKSinglesChart)"
},
{
"input": "Translate into first-order logic: If a song peaked at No.1 at a cetain place, then it was extremely popular.",
"output": "∀x ∀y (Peak(x, y) → Popular(x))"
},
{
"input": "Translate into first-order logic: \"Your Woman\" also peaked No. 1 in Iceland, Israel and Spain.",
"output": "Peak(yourWoman, iceland) ∧ Peak(yourWoman, isarel) ∧ Peak(yourWoman, spain)"
},
{
"input": "Translate into first-order logic: \"Your Woman\" is a song by British one-man band White Town.",
"output": "Produce(whiteTown, yourWoman)"
},
{
"input": "Translate into first-order logic: \"Your Woman\" song peaked at No. 1 on the UK Singles Chart.",
"output": "Peak(yourWoman, uKSinglesChart)"
},
{
"input": "Translate into first-order logic: If a song peaked at No.1 at a cetain place, then it was extremely popular.",
"output": "∀x ∀y (Peak(x, y) → Popular(x))"
},
{
"input": "Translate into first-order logic: \"Your Woman\" also peaked No. 1 in Iceland, Israel and Spain.",
"output": "Peak(yourWoman, iceland) ∧ Peak(yourWoman, isarel) ∧ Peak(yourWoman, spain)"
},
{
"input": "Translate into first-order logic: \"Your Woman\" is a song by British one-man band White Town.",
"output": "Produce(whiteTown, yourWoman)"
},
{
"input": "Translate into first-order logic: \"Your Woman\" song peaked at No. 1 on the UK Singles Chart.",
"output": "Peak(yourWoman, uKSinglesChart)"
},
{
"input": "Translate into first-order logic: If a song peaked at No.1 at a cetain place, then it was extremely popular.",
"output": "∀x ∀y (Peak(x, y) → Popular(x))"
},
{
"input": "Translate into first-order logic: \"Your Woman\" also peaked No. 1 in Iceland, Israel and Spain.",
"output": "Peak(yourWoman, iceland) ∧ Peak(yourWoman, isarel) ∧ Peak(yourWoman, spain)"
},
{
"input": "Translate into first-order logic: All people who limp often and regularly have long-term medical issues with underlying causes.",
"output": "∀x (Limp(x) → Medical(x))"
},
{
"input": "Translate into first-order logic: If people have long-term medical issues with underlying causes, then they are not often spry and energetic.",
"output": "∀x (Medical(x) → ¬Spry(x))"
},
{
"input": "Translate into first-order logic: People either stay indoors and rest a lot at home or people are often tired and disinterested in their activities.",
"output": "∀x (Spry(x) ⊕ Tired(x)) ∧ (∀x (Tired(x) → Indoors(x)))"
},
{
"input": "Translate into first-order logic: If people stay indoors and rest a lot at home, then they do not visit the gym at least once a day.",
"output": "∀x (Indoors(x) → ¬Gym(x))"
},
{
"input": "Translate into first-order logic: If Mark either limps often and regularly or is often spry and energetic, then Mark limps often and regularly or is often tired and disinterested in his activities.",
"output": "(Limp(Mark) ⊕ Spry(Mark)) → Limp(Mark) ∨ Tired(Mark)"
},
{
"input": "Translate into first-order logic: All people who limp often and regularly have long-term medical issues with underlying causes.",
"output": "∀x (Limp(x) → Medical(x))"
},
{
"input": "Translate into first-order logic: If people have long-term medical issues with underlying causes, then they are not often spry and energetic.",
"output": "∀x (Medical(x) → ¬Spry(x))"
},
{
"input": "Translate into first-order logic: People either stay indoors and rest a lot at home or people are often tired and disinterested in their activities.",
"output": "∀x (Spry(x) ⊕ Tired(x)) ∧ (∀x (Tired(x) → Indoors(x)))"
},
{
"input": "Translate into first-order logic: If people stay indoors and rest a lot at home, then they do not visit the gym at least once a day.",
"output": "∀x (Indoors(x) → ¬Gym(x))"
},
{
"input": "Translate into first-order logic: If Mark either limps often and regularly or is often spry and energetic, then Mark limps often and regularly or is often tired and disinterested in his activities.",
"output": "(Limp(Mark) ⊕ Spry(Mark)) → Limp(Mark) ∨ Tired(Mark)"
},
{
"input": "Translate into first-order logic: All people who limp often and regularly have long-term medical issues with underlying causes.",
"output": "∀x (Limp(x) → Medical(x))"
},
{
"input": "Translate into first-order logic: If people have long-term medical issues with underlying causes, then they are not often spry and energetic.",
"output": "∀x (Medical(x) → ¬Spry(x))"
},
{
"input": "Translate into first-order logic: People either stay indoors and rest a lot at home or people are often tired and disinterested in their activities.",
"output": "∀x (Spry(x) ⊕ Tired(x)) ∧ (∀x (Tired(x) → Indoors(x)))"
},
{
"input": "Translate into first-order logic: If people stay indoors and rest a lot at home, then they do not visit the gym at least once a day.",
"output": "∀x (Indoors(x) → ¬Gym(x))"
},
{
"input": "Translate into first-order logic: If Mark either limps often and regularly or is often spry and energetic, then Mark limps often and regularly or is often tired and disinterested in his activities.",
"output": "(Limp(Mark) ⊕ Spry(Mark)) → Limp(Mark) ∨ Tired(Mark)"
},
{
"input": "Translate into first-order logic: If two soccer teams score the same number of goals in one UCL final during the regular time, they need to play for the extra time.",
"output": "∀x ∀y (SoccerTeam(x) ∧ SoccerTeam(y) ∧ SameScore(x, y) ∧ During(regularTime) → PlayExtra(x, y))"
},
{
"input": "Translate into first-order logic: If two soccer teams score the same number of goals in one UCL final during both the regular time and extra time, they need to play the penalty shoot-out.",
"output": "∀x ∀y (SoccerTeam(x) ∧ SoccerTeam(y) ∧ SameScore(x, y) ∧ During(regularTime) ∧ During(extraTime) → PlayPenalty(x, y))"
},
{
"input": "Translate into first-order logic: Real Madrid and Atlético Madrid both scored one goal in 2016 UCL final during the regular time.",
"output": "SoccerTeam(realMadrid) ∧ SoccerTeam(atleticoMadrid) ∧ SameScore(realMadrid, atleticoMadrid) ∧ During(regularTime)"
},
{
"input": "Translate into first-order logic: Real Madrid and Atlético Madrid both scored zero goals in 2016 UCL final during the extra time.",
"output": "SoccerTeam(realMadrid) ∧ SoccerTeam(atleticoMadrid) ∧ SameScore(realMadrid, atleticoMadrid) ∧ During(extraTime)"
},
{
"input": "Translate into first-order logic: If two soccer teams score the same number of goals in one UCL final during the regular time, they need to play for the extra time.",
"output": "∀x ∀y (SoccerTeam(x) ∧ SoccerTeam(y) ∧ SameScore(x, y) ∧ During(regularTime) → PlayExtra(x, y))"
},
{
"input": "Translate into first-order logic: If two soccer teams score the same number of goals in one UCL final during both the regular time and extra time, they need to play the penalty shoot-out.",
"output": "∀x ∀y (SoccerTeam(x) ∧ SoccerTeam(y) ∧ SameScore(x, y) ∧ During(regularTime) ∧ During(extraTime) → PlayPenalty(x, y))"
},
{
"input": "Translate into first-order logic: Real Madrid and Atlético Madrid both scored one goal in 2016 UCL final during the regular time.",
"output": "SoccerTeam(realMadrid) ∧ SoccerTeam(atleticoMadrid) ∧ SameScore(realMadrid, atleticoMadrid) ∧ During(regularTime)"
},
{
"input": "Translate into first-order logic: Real Madrid and Atlético Madrid both scored zero goals in 2016 UCL final during the extra time.",
"output": "SoccerTeam(realMadrid) ∧ SoccerTeam(atleticoMadrid) ∧ SameScore(realMadrid, atleticoMadrid) ∧ During(extraTime)"
},
{
"input": "Translate into first-order logic: System 7 is a UK-based electronic dance music band.",
"output": "BasedOn(system7, uk) ∧ ElectronicDanceMusicBand(system7)"
},
{
"input": "Translate into first-order logic: Steve Hillage and Miquette Giraudy formed System 7.",
"output": "Formed(stevehillage, system7) ∧ Formed(miquettegiraudy, system7)"
},
{
"input": "Translate into first-order logic: Steve Hillage and Miquette Giraudy are former members of the band Gong.",
"output": "FormerMemberOf(stevehillage, gong) ∧ FormerMemberOf(miquettegiraudy, gong)"
},
{
"input": "Translate into first-order logic: Electric dance music bands are bands.",
"output": "∀x (ElectronicDanceMusicBand(x) → Band(x))"
},
{
"input": "Translate into first-order logic: System 7 has released several club singles.",
"output": "∃x (ClubSingle(x) ∧ Released(system7, x))"
},
{
"input": "Translate into first-order logic: Club singles are not singles.",
"output": "∀x (ClubSingle(x) → ¬Single(x))"
},
{
"input": "Translate into first-order logic: System 7 is a UK-based electronic dance music band.",
"output": "BasedOn(system7, uk) ∧ ElectronicDanceMusicBand(system7)"
},
{
"input": "Translate into first-order logic: Steve Hillage and Miquette Giraudy formed System 7.",
"output": "Formed(stevehillage, system7) ∧ Formed(miquettegiraudy, system7)"
},
{
"input": "Translate into first-order logic: Steve Hillage and Miquette Giraudy are former members of the band Gong.",
"output": "FormerMemberOf(stevehillage, gong) ∧ FormerMemberOf(miquettegiraudy, gong)"
},
{
"input": "Translate into first-order logic: Electric dance music bands are bands.",
"output": "∀x (ElectronicDanceMusicBand(x) → Band(x))"
},
{
"input": "Translate into first-order logic: System 7 has released several club singles.",
"output": "∃x (ClubSingle(x) ∧ Released(system7, x))"
},
{
"input": "Translate into first-order logic: Club singles are not singles.",
"output": "∀x (ClubSingle(x) → ¬Single(x))"
},
{
"input": "Translate into first-order logic: System 7 is a UK-based electronic dance music band.",
"output": "BasedOn(system7, uk) ∧ ElectronicDanceMusicBand(system7)"
},
{
"input": "Translate into first-order logic: Steve Hillage and Miquette Giraudy formed System 7.",
"output": "Formed(stevehillage, system7) ∧ Formed(miquettegiraudy, system7)"
},
{
"input": "Translate into first-order logic: Steve Hillage and Miquette Giraudy are former members of the band Gong.",
"output": "FormerMemberOf(stevehillage, gong) ∧ FormerMemberOf(miquettegiraudy, gong)"
},
{
"input": "Translate into first-order logic: Electric dance music bands are bands.",
"output": "∀x (ElectronicDanceMusicBand(x) → Band(x))"
},
{
"input": "Translate into first-order logic: System 7 has released several club singles.",
"output": "∃x (ClubSingle(x) ∧ Released(system7, x))"
},
{
"input": "Translate into first-order logic: Club singles are not singles.",
"output": "∀x (ClubSingle(x) → ¬Single(x))"
},
{
"input": "Translate into first-order logic: A summarization model is always faithful if it uses content from the input documents.",
"output": "∀x (Model(x) ∧ Summarization(x) ∧ OnlyUseInputDocument(x) → Faithful(x))"
},
{
"input": "Translate into first-order logic: Extractive models are a kind of summarization models.",
"output": "∀x (Model(x) ∧ Extractive(x) → Summarization(x))"
},
{
"input": "Translate into first-order logic: Extractive model can only use content from the input documents.",
"output": "∀x (Model(x) ∧ Extractive(x) → OnlyUseInputDocument(x))"
},
{
"input": "Translate into first-order logic: A summarization model is always faithful if it uses content from the input documents.",
"output": "∀x (Model(x) ∧ Summarization(x) ∧ OnlyUseInputDocument(x) → Faithful(x))"
},
{
"input": "Translate into first-order logic: Extractive models are a kind of summarization models.",
"output": "∀x (Model(x) ∧ Extractive(x) → Summarization(x))"
},
{
"input": "Translate into first-order logic: Extractive model can only use content from the input documents.",
"output": "∀x (Model(x) ∧ Extractive(x) → OnlyUseInputDocument(x))"
},
{
"input": "Translate into first-order logic: If people practice coding questions, then they are not studying to go to medical school to become a doctor.",
"output": "∀x Coding(x) → ¬StudyingToBeDoctor(x)"
},
{
"input": "Translate into first-order logic: If people want to work in the software engineering industry, then they practice coding questions.",
"output": "∀x Industry(x) → Coding(x)"
},
{
"input": "Translate into first-order logic: If people enjoy healthcare fields and want to help people with medical issues, then they are studying to go to medical school to become a doctor.",
"output": "∀x Healthcare(x) → StudyingToBeDoctor(x)"
},
{
"input": "Translate into first-order logic: If people grew up with parents who worked as doctors, then they enjoy healthcare fields and want to help people with medical issues.",
"output": "∀x ParentDoctors(x) → Healthcare(x)"
},
{
"input": "Translate into first-order logic: If people study hard, then they grew up with parents who worked as doctors.",
"output": "∀x Study(x) → ParentDoctors(x)"
},
{
"input": "Translate into first-order logic: If Robin neither enjoys healthcare fields and wants to help people with medical issues nor grew up with parents who worked as doctors, then Robin is either a person who studies hard or grew up with parents who worked as doctors.",
"output": "¬(Healthcare(Robin) ∨ ParentDoctors(Robin)) → (Study(Robin) ∨ ParentDoctors(Robin)) "
},
{
"input": "Translate into first-order logic: If people practice coding questions, then they are not studying to go to medical school to become a doctor.",
"output": "∀x Coding(x) → ¬StudyingToBeDoctor(x)"
},
{
"input": "Translate into first-order logic: If people want to work in the software engineering industry, then they practice coding questions.",
"output": "∀x Industry(x) → Coding(x)"
},
{
"input": "Translate into first-order logic: If people enjoy healthcare fields and want to help people with medical issues, then they are studying to go to medical school to become a doctor.",
"output": "∀x Healthcare(x) → StudyingToBeDoctor(x)"
},
{
"input": "Translate into first-order logic: If people grew up with parents who worked as doctors, then they enjoy healthcare fields and want to help people with medical issues.",
"output": "∀x ParentDoctors(x) → Healthcare(x)"
},
{
"input": "Translate into first-order logic: If people study hard, then they grew up with parents who worked as doctors.",
"output": "∀x Study(x) → ParentDoctors(x)"
},
{
"input": "Translate into first-order logic: If Robin neither enjoys healthcare fields and wants to help people with medical issues nor grew up with parents who worked as doctors, then Robin is either a person who studies hard or grew up with parents who worked as doctors.",
"output": "¬(Healthcare(Robin) ∨ ParentDoctors(Robin)) → (Study(Robin) ∨ ParentDoctors(Robin)) "
},
{
"input": "Translate into first-order logic: If people practice coding questions, then they are not studying to go to medical school to become a doctor.",
"output": "∀x Coding(x) → ¬StudyingToBeDoctor(x)"
},
{
"input": "Translate into first-order logic: If people want to work in the software engineering industry, then they practice coding questions.",
"output": "∀x Industry(x) → Coding(x)"
},
{
"input": "Translate into first-order logic: If people enjoy healthcare fields and want to help people with medical issues, then they are studying to go to medical school to become a doctor.",
"output": "∀x Healthcare(x) → StudyingToBeDoctor(x)"
},
{
"input": "Translate into first-order logic: If people grew up with parents who worked as doctors, then they enjoy healthcare fields and want to help people with medical issues.",
"output": "∀x ParentDoctors(x) → Healthcare(x)"
},
{
"input": "Translate into first-order logic: If people study hard, then they grew up with parents who worked as doctors.",
"output": "∀x Study(x) → ParentDoctors(x)"
},
{
"input": "Translate into first-order logic: If Robin neither enjoys healthcare fields and wants to help people with medical issues nor grew up with parents who worked as doctors, then Robin is either a person who studies hard or grew up with parents who worked as doctors.",
"output": "¬(Healthcare(Robin) ∨ ParentDoctors(Robin)) → (Study(Robin) ∨ ParentDoctors(Robin)) "
},
{
"input": "Translate into first-order logic: If people go to the spa at least once a week, then they are not people who are miserly and need to save a large portion of their income.",
"output": "∀x Spa(x) → ¬Miserly(x)"
},
{
"input": "Translate into first-order logic: People are either miserly and need to save a large portion of their income, or people that frivolously spend a lot of money every time they go out.",
"output": "∀x Miserly(x) ∨ Frivolous(x)"
},
{
"input": "Translate into first-order logic: If people frivolously spend a lot of money every time they go out, then they value quality manufacturing and luxury items.",
"output": "∀x Frivolous(x) → Luxury(x)"
},
{
"input": "Translate into first-order logic: If people value quality manufacturing and luxury items, then they enjoy shopping for materialistic items in their free time.",
"output": "∀x Luxury(x) → Shopping(x)"
},
{
"input": "Translate into first-order logic: If Jess is not miserly and needs to save a large portion of their income, then Jess does not value quality manufacturing and luxury items.",
"output": "¬Miserly(Jess) → ¬Luxury(Jess)"
},
{
"input": "Translate into first-order logic: If Jess either values quality manufacturing and luxury items or, if he does not, then he is miserly and needs to save a large portion of his income, then Jess frivolously spends a lot of money every time he goes out.",
"output": "Luxury(Jess) ⊕ Miserly(Jess)) →  Luxury(Jess)"
},
{
"input": "Translate into first-order logic: If people go to the spa at least once a week, then they are not people who are miserly and need to save a large portion of their income.",
"output": "∀x Spa(x) → ¬Miserly(x)"
},
{
"input": "Translate into first-order logic: People are either miserly and need to save a large portion of their income, or people that frivolously spend a lot of money every time they go out.",
"output": "∀x Miserly(x) ∨ Frivolous(x)"
},
{
"input": "Translate into first-order logic: If people frivolously spend a lot of money every time they go out, then they value quality manufacturing and luxury items.",
"output": "∀x Frivolous(x) → Luxury(x)"
},
{
"input": "Translate into first-order logic: If people value quality manufacturing and luxury items, then they enjoy shopping for materialistic items in their free time.",
"output": "∀x Luxury(x) → Shopping(x)"
},
{
"input": "Translate into first-order logic: If Jess is not miserly and needs to save a large portion of their income, then Jess does not value quality manufacturing and luxury items.",
"output": "¬Miserly(Jess) → ¬Luxury(Jess)"
},
{
"input": "Translate into first-order logic: If Jess either values quality manufacturing and luxury items or, if he does not, then he is miserly and needs to save a large portion of his income, then Jess frivolously spends a lot of money every time he goes out.",
"output": "Luxury(Jess) ⊕ Miserly(Jess)) →  Luxury(Jess)"
},
{
"input": "Translate into first-order logic: If people go to the spa at least once a week, then they are not people who are miserly and need to save a large portion of their income.",
"output": "∀x Spa(x) → ¬Miserly(x)"
},
{
"input": "Translate into first-order logic: People are either miserly and need to save a large portion of their income, or people that frivolously spend a lot of money every time they go out.",
"output": "∀x Miserly(x) ∨ Frivolous(x)"
},
{
"input": "Translate into first-order logic: If people frivolously spend a lot of money every time they go out, then they value quality manufacturing and luxury items.",
"output": "∀x Frivolous(x) → Luxury(x)"
},
{
"input": "Translate into first-order logic: If people value quality manufacturing and luxury items, then they enjoy shopping for materialistic items in their free time.",
"output": "∀x Luxury(x) → Shopping(x)"
},
{
"input": "Translate into first-order logic: If Jess is not miserly and needs to save a large portion of their income, then Jess does not value quality manufacturing and luxury items.",
"output": "¬Miserly(Jess) → ¬Luxury(Jess)"
},
{
"input": "Translate into first-order logic: If Jess either values quality manufacturing and luxury items or, if he does not, then he is miserly and needs to save a large portion of his income, then Jess frivolously spends a lot of money every time he goes out.",
"output": "Luxury(Jess) ⊕ Miserly(Jess)) →  Luxury(Jess)"
},
{
"input": "Translate into first-order logic: The indie pop band Phoenix has released 6 albums.",
"output": "AlbumsReleased(phoenix, l6)"
},
{
"input": "Translate into first-order logic: Phoenix's album \"Wolfgang Amadeus Phoenix\" sold over 500,000 copies.",
"output": "Album(wolfgangamadeusphoenix) ∧ IsAlbumOf(wolfgangamadeusphoenix, phoenix) ∧ SoldOver(wolfgangamadeusphoenix, l500000)"
},
{
"input": "Translate into first-order logic: A certified gold album or single is one which sold over half a million copies.",
"output": "∀x ((Album(x) ∨ Single(x)) ∧ SoldOver(x, l500000) → CertifiedGold(x))"
},
{
"input": "Translate into first-order logic: \"1901\" is a single from Phoenix's album \"Wolfgang Amadeus Phoenix.\"",
"output": "Single(l1901) ∧ From(l1901, wolfgangamadeusphoenix) ∧ By(l1901, phoenix)"
},
{
"input": "Translate into first-order logic: Over 400,000 copies of \"1901\" have been sold.",
"output": "SoldOver(l1901, l400000)"
},
{
"input": "Translate into first-order logic: The indie pop band Phoenix has released 6 albums.",
"output": "AlbumsReleased(phoenix, l6)"
},
{
"input": "Translate into first-order logic: Phoenix's album \"Wolfgang Amadeus Phoenix\" sold over 500,000 copies.",
"output": "Album(wolfgangamadeusphoenix) ∧ IsAlbumOf(wolfgangamadeusphoenix, phoenix) ∧ SoldOver(wolfgangamadeusphoenix, l500000)"
},
{
"input": "Translate into first-order logic: A certified gold album or single is one which sold over half a million copies.",
"output": "∀x ((Album(x) ∨ Single(x)) ∧ SoldOver(x, l500000) → CertifiedGold(x))"
},
{
"input": "Translate into first-order logic: \"1901\" is a single from Phoenix's album \"Wolfgang Amadeus Phoenix.\"",
"output": "Single(l1901) ∧ From(l1901, wolfgangamadeusphoenix) ∧ By(l1901, phoenix)"
},
{
"input": "Translate into first-order logic: Over 400,000 copies of \"1901\" have been sold.",
"output": "SoldOver(l1901, l400000)"
},
{
"input": "Translate into first-order logic: Peter Parker is a either a superhero or a civilian.",
"output": "Superhero(peter) ⊕ Civilian(peter)"
},
{
"input": "Translate into first-order logic: The Hulk is a destroyer.",
"output": "Destroyer(hulk)"
},
{
"input": "Translate into first-order logic: The Hulk wakes up when he is angry.",
"output": "Angry(hulk) → Wake(hulk)"
},
{
"input": "Translate into first-order logic: If the Hulk wakes up, then he will break a bridge.",
"output": "Wake(hulk) → BreakBridge(hulk)"
},
{
"input": "Translate into first-order logic: Thor is a god.",
"output": "God(thor)"
},
{
"input": "Translate into first-order logic: Thor will break a bridge when he is happy.",
"output": "Happy(thor) → BreakBridge(thor)"
},
{
"input": "Translate into first-order logic: A god is not a destroyer and a destroyer is not a god.",
"output": "∀x (God(x) ↔ ¬Destroyer(x))"
},
{
"input": "Translate into first-order logic: Peter Parker wears a uniform when he is a superhero.",
"output": "Superhero(peter) → WearUniform(peter)"
},
{
"input": "Translate into first-order logic: Peter Parker is not a civilian if and only if a destroyer is breaking a bridge.",
"output": "∀x (¬Civilian(peter) ↔ (Destroyer(x) ∧ BreakBridge(x)))"
},
{
"input": "Translate into first-order logic: If Thor is happy, the Hulk is angry.",
"output": "Happy(thor) → Angry(hulk)"
},
{
"input": "Translate into first-order logic: Peter Parker is a either a superhero or a civilian.",
"output": "Superhero(peter) ⊕ Civilian(peter)"
},
{
"input": "Translate into first-order logic: The Hulk is a destroyer.",
"output": "Destroyer(hulk)"
},
{
"input": "Translate into first-order logic: The Hulk wakes up when he is angry.",
"output": "Angry(hulk) → Wake(hulk)"
},
{
"input": "Translate into first-order logic: If the Hulk wakes up, then he will break a bridge.",
"output": "Wake(hulk) → BreakBridge(hulk)"
},
{
"input": "Translate into first-order logic: Thor is a god.",
"output": "God(thor)"
},
{
"input": "Translate into first-order logic: Thor will break a bridge when he is happy.",
"output": "Happy(thor) → BreakBridge(thor)"
},
{
"input": "Translate into first-order logic: A god is not a destroyer and a destroyer is not a god.",
"output": "∀x (God(x) ↔ ¬Destroyer(x))"
},
{
"input": "Translate into first-order logic: Peter Parker wears a uniform when he is a superhero.",
"output": "Superhero(peter) → WearUniform(peter)"
},
{
"input": "Translate into first-order logic: Peter Parker is not a civilian if and only if a destroyer is breaking a bridge.",
"output": "∀x (¬Civilian(peter) ↔ (Destroyer(x) ∧ BreakBridge(x)))"
},
{
"input": "Translate into first-order logic: If Thor is happy, the Hulk is angry.",
"output": "Happy(thor) → Angry(hulk)"
},
{
"input": "Translate into first-order logic: Peter Parker is a either a superhero or a civilian.",
"output": "Superhero(peter) ⊕ Civilian(peter)"
},
{
"input": "Translate into first-order logic: The Hulk is a destroyer.",
"output": "Destroyer(hulk)"
},
{
"input": "Translate into first-order logic: The Hulk wakes up when he is angry.",
"output": "Angry(hulk) → Wake(hulk)"
},
{
"input": "Translate into first-order logic: If the Hulk wakes up, then he will break a bridge.",
"output": "Wake(hulk) → BreakBridge(hulk)"
},
{
"input": "Translate into first-order logic: Thor is a god.",
"output": "God(thor)"
},
{
"input": "Translate into first-order logic: Thor will break a bridge when he is happy.",
"output": "Happy(thor) → BreakBridge(thor)"
},
{
"input": "Translate into first-order logic: A god is not a destroyer and a destroyer is not a god.",
"output": "∀x (God(x) ↔ ¬Destroyer(x))"
},
{
"input": "Translate into first-order logic: Peter Parker wears a uniform when he is a superhero.",
"output": "Superhero(peter) → WearUniform(peter)"
},
{
"input": "Translate into first-order logic: Peter Parker is not a civilian if and only if a destroyer is breaking a bridge.",
"output": "∀x (¬Civilian(peter) ↔ (Destroyer(x) ∧ BreakBridge(x)))"
},
{
"input": "Translate into first-order logic: If Thor is happy, the Hulk is angry.",
"output": "Happy(thor) → Angry(hulk)"
},
{
"input": "Translate into first-order logic: Diethylcarbamazine is a medication discovered in the year 1947.",
"output": "∀x (Diethylcarbamazine(x) ∧ Medication(x) ∧ DiscoveredIn(x, year1947))"
},
{
"input": "Translate into first-order logic: Diethylcarbamazine can be used to treat river blindness.",
"output": "∀x ∀y (Diethylcarbamazine(x) ∧ RiverBlindness(y) → Treats(x, y))"
},
{
"input": "Translate into first-order logic: The only preferred treatment for river blindness is ivermectin.",
"output": "∀x ∀y (RiverBlindness(y) ∧ PreferredTreatment(x, y) → Ivermectin(x))"
},
{
"input": "Translate into first-order logic: Diethylcarbamazine is not ivermectin.",
"output": "∀x (Diethylcarbamazine(x) → ¬Ivermectin(x))"
},
{
"input": "Translate into first-order logic: Diethylcarbamazine is a medication discovered in the year 1947.",
"output": "∀x (Diethylcarbamazine(x) ∧ Medication(x) ∧ DiscoveredIn(x, year1947))"
},
{
"input": "Translate into first-order logic: Diethylcarbamazine can be used to treat river blindness.",
"output": "∀x ∀y (Diethylcarbamazine(x) ∧ RiverBlindness(y) → Treats(x, y))"
},
{
"input": "Translate into first-order logic: The only preferred treatment for river blindness is ivermectin.",
"output": "∀x ∀y (RiverBlindness(y) ∧ PreferredTreatment(x, y) → Ivermectin(x))"
},
{
"input": "Translate into first-order logic: Diethylcarbamazine is not ivermectin.",
"output": "∀x (Diethylcarbamazine(x) → ¬Ivermectin(x))"
},
{
"input": "Translate into first-order logic: Diethylcarbamazine is a medication discovered in the year 1947.",
"output": "∀x (Diethylcarbamazine(x) ∧ Medication(x) ∧ DiscoveredIn(x, year1947))"
},
{
"input": "Translate into first-order logic: Diethylcarbamazine can be used to treat river blindness.",
"output": "∀x ∀y (Diethylcarbamazine(x) ∧ RiverBlindness(y) → Treats(x, y))"
},
{
"input": "Translate into first-order logic: The only preferred treatment for river blindness is ivermectin.",
"output": "∀x ∀y (RiverBlindness(y) ∧ PreferredTreatment(x, y) → Ivermectin(x))"
},
{
"input": "Translate into first-order logic: Diethylcarbamazine is not ivermectin.",
"output": "∀x (Diethylcarbamazine(x) → ¬Ivermectin(x))"
},
{
"input": "Translate into first-order logic: All univariate analyses use a generalized linear model.",
"output": "∀x (UnivariateAnalysis(x) → UsesGeneralizedLinearModel(x)) "
},
{
"input": "Translate into first-order logic: All multivoxel (pattern) analyses are implementing machine learning algorithms.",
"output": " ∀x (MultivoxelPatternAnalysis(x) → ImplementingMachineLearningAlgorithms(x))"
},
{
"input": "Translate into first-order logic: All implementing machine learning algorithms are to learn and classify multivariate data.",
"output": " ∀x (ImplementingMachineLearningAlgorithms(x) → LearnAndClassifyMultivariateData(x)) "
},
{
"input": "Translate into first-order logic: The Latent Dirichlet allocation model uses a generalized linear model or a univariate analysis.",
"output": " UsesGeneralizedLinearModel(latentDirichletAllocationModel) ∨ UnivariateAnalysis(latentDirichletAllocationModel)"
},
{
"input": "Translate into first-order logic: If the Latent Dirichlet allocation model does not learn and classify multivariate data, then the Latent Dirichlet allocation model uses a generalized linear model and a multivoxel (pattern) analysis.",
"output": " ¬LearnAndClassifyMultivariateData(latentDirichletAllocationModel) → UsesGeneralizedLinearModel(latentDirichletAllocationModel) ∧ MultivoxelPatternAnalysis(latentDirichletAllocationModel)"
},
{
"input": "Translate into first-order logic: All univariate analyses use a generalized linear model.",
"output": "∀x (UnivariateAnalysis(x) → UsesGeneralizedLinearModel(x)) "
},
{
"input": "Translate into first-order logic: All multivoxel (pattern) analyses are implementing machine learning algorithms.",
"output": " ∀x (MultivoxelPatternAnalysis(x) → ImplementingMachineLearningAlgorithms(x))"
},
{
"input": "Translate into first-order logic: All implementing machine learning algorithms are to learn and classify multivariate data.",
"output": " ∀x (ImplementingMachineLearningAlgorithms(x) → LearnAndClassifyMultivariateData(x)) "
},
{
"input": "Translate into first-order logic: The Latent Dirichlet allocation model uses a generalized linear model or a univariate analysis.",
"output": " UsesGeneralizedLinearModel(latentDirichletAllocationModel) ∨ UnivariateAnalysis(latentDirichletAllocationModel)"
},
{
"input": "Translate into first-order logic: If the Latent Dirichlet allocation model does not learn and classify multivariate data, then the Latent Dirichlet allocation model uses a generalized linear model and a multivoxel (pattern) analysis.",
"output": " ¬LearnAndClassifyMultivariateData(latentDirichletAllocationModel) → UsesGeneralizedLinearModel(latentDirichletAllocationModel) ∧ MultivoxelPatternAnalysis(latentDirichletAllocationModel)"
},
{
"input": "Translate into first-order logic: All univariate analyses use a generalized linear model.",
"output": "∀x (UnivariateAnalysis(x) → UsesGeneralizedLinearModel(x)) "
},
{
"input": "Translate into first-order logic: All multivoxel (pattern) analyses are implementing machine learning algorithms.",
"output": " ∀x (MultivoxelPatternAnalysis(x) → ImplementingMachineLearningAlgorithms(x))"
},
{
"input": "Translate into first-order logic: All implementing machine learning algorithms are to learn and classify multivariate data.",
"output": " ∀x (ImplementingMachineLearningAlgorithms(x) → LearnAndClassifyMultivariateData(x)) "
},
{
"input": "Translate into first-order logic: The Latent Dirichlet allocation model uses a generalized linear model or a univariate analysis.",
"output": " UsesGeneralizedLinearModel(latentDirichletAllocationModel) ∨ UnivariateAnalysis(latentDirichletAllocationModel)"
},
{
"input": "Translate into first-order logic: If the Latent Dirichlet allocation model does not learn and classify multivariate data, then the Latent Dirichlet allocation model uses a generalized linear model and a multivoxel (pattern) analysis.",
"output": " ¬LearnAndClassifyMultivariateData(latentDirichletAllocationModel) → UsesGeneralizedLinearModel(latentDirichletAllocationModel) ∧ MultivoxelPatternAnalysis(latentDirichletAllocationModel)"
},
{
"input": "Translate into first-order logic: If something requires a medical diagnosis, then lab tests or imaging is required.",
"output": "∀x (RequiresAMedicalDiagnosis(x) → LabTestsOrImagingRequired(x)) "
},
{
"input": "Translate into first-order logic: All rare diseases require a medical diagnosis.",
"output": "∀x (RareDiseases(x) → RequiresAMedicalDiagnosis(x))"
},
{
"input": "Translate into first-order logic: If something is mild, then no lab tests or imaging is required.",
"output": "∀x (Mild(x) → ¬LabTestsOrImagingRequired(x)) "
},
{
"input": "Translate into first-order logic: All blood cancers are rare diseases.",
"output": "∀x (BloodCancer(x) → RareDiseases(x))"
},
{
"input": "Translate into first-order logic: All Leukemia is blood cancer.",
"output": "∀x (Leukemia(x) → BloodCancer(x))"
},
{
"input": "Translate into first-order logic: If bladder cancer is either both blood cancer and Leukemia or neither blood cancer nor Leukemia, then bladder cancer is Leukemia.",
"output": "¬(BloodCancer(bladderCancer) ⊕ Leukemia(bladderCancer)) → Leukemia(bladderCancer)"
},
{
"input": "Translate into first-order logic: If something requires a medical diagnosis, then lab tests or imaging is required.",
"output": "∀x (RequiresAMedicalDiagnosis(x) → LabTestsOrImagingRequired(x)) "
},
{
"input": "Translate into first-order logic: All rare diseases require a medical diagnosis.",
"output": "∀x (RareDiseases(x) → RequiresAMedicalDiagnosis(x))"
},
{
"input": "Translate into first-order logic: If something is mild, then no lab tests or imaging is required.",
"output": "∀x (Mild(x) → ¬LabTestsOrImagingRequired(x)) "
},
{
"input": "Translate into first-order logic: All blood cancers are rare diseases.",
"output": "∀x (BloodCancer(x) → RareDiseases(x))"
},
{
"input": "Translate into first-order logic: All Leukemia is blood cancer.",
"output": "∀x (Leukemia(x) → BloodCancer(x))"
},
{
"input": "Translate into first-order logic: If bladder cancer is either both blood cancer and Leukemia or neither blood cancer nor Leukemia, then bladder cancer is Leukemia.",
"output": "¬(BloodCancer(bladderCancer) ⊕ Leukemia(bladderCancer)) → Leukemia(bladderCancer)"
},
{
"input": "Translate into first-order logic: If something requires a medical diagnosis, then lab tests or imaging is required.",
"output": "∀x (RequiresAMedicalDiagnosis(x) → LabTestsOrImagingRequired(x)) "
},
{
"input": "Translate into first-order logic: All rare diseases require a medical diagnosis.",
"output": "∀x (RareDiseases(x) → RequiresAMedicalDiagnosis(x))"
},
{
"input": "Translate into first-order logic: If something is mild, then no lab tests or imaging is required.",
"output": "∀x (Mild(x) → ¬LabTestsOrImagingRequired(x)) "
},
{
"input": "Translate into first-order logic: All blood cancers are rare diseases.",
"output": "∀x (BloodCancer(x) → RareDiseases(x))"
},
{
"input": "Translate into first-order logic: All Leukemia is blood cancer.",
"output": "∀x (Leukemia(x) → BloodCancer(x))"
},
{
"input": "Translate into first-order logic: If bladder cancer is either both blood cancer and Leukemia or neither blood cancer nor Leukemia, then bladder cancer is Leukemia.",
"output": "¬(BloodCancer(bladderCancer) ⊕ Leukemia(bladderCancer)) → Leukemia(bladderCancer)"
},
{
"input": "Translate into first-order logic: No precious metals aren't scarce.",
"output": "∀x (PreciousMetals(x) → ¬NotScarce(x))"
},
{
"input": "Translate into first-order logic: All non-rare earth metals are not scarce.",
"output": " ∀x (Non-rareEarthMetals(x) → NotScarce(x)) "
},
{
"input": "Translate into first-order logic: Either non-rare earth metals or rare earth metals.",
"output": " ∀x (Non-rareEarthMetals(x) ∨ RareEarthMetals(x)) "
},
{
"input": "Translate into first-order logic: All rare earth metals can be used for batteries.",
"output": " ∀x (RareEarthMetals(x) → BeUsedForBatteries(x)) "
},
{
"input": "Translate into first-order logic: All rare earth metals are essential for electric vehicles.",
"output": " ∀x (RareEarthMetals(x) → EssentialForElectricVehicles(x))"
},
{
"input": "Translate into first-order logic: Lithium is neither a non-rare earth metal nor essential for electric vehicles.",
"output": " ¬Non-rareEarthMetals(lithium) ⊕ ¬EssentialForElectricVehicles(lithium)"
},
{
"input": "Translate into first-order logic: No precious metals aren't scarce.",
"output": "∀x (PreciousMetals(x) → ¬NotScarce(x))"
},
{
"input": "Translate into first-order logic: All non-rare earth metals are not scarce.",
"output": " ∀x (Non-rareEarthMetals(x) → NotScarce(x)) "
},
{
"input": "Translate into first-order logic: Either non-rare earth metals or rare earth metals.",
"output": " ∀x (Non-rareEarthMetals(x) ∨ RareEarthMetals(x)) "
},
{
"input": "Translate into first-order logic: All rare earth metals can be used for batteries.",
"output": " ∀x (RareEarthMetals(x) → BeUsedForBatteries(x)) "
},
{
"input": "Translate into first-order logic: All rare earth metals are essential for electric vehicles.",
"output": " ∀x (RareEarthMetals(x) → EssentialForElectricVehicles(x))"
},
{
"input": "Translate into first-order logic: Lithium is neither a non-rare earth metal nor essential for electric vehicles.",
"output": " ¬Non-rareEarthMetals(lithium) ⊕ ¬EssentialForElectricVehicles(lithium)"
},
{
"input": "Translate into first-order logic: No precious metals aren't scarce.",
"output": "∀x (PreciousMetals(x) → ¬NotScarce(x))"
},
{
"input": "Translate into first-order logic: All non-rare earth metals are not scarce.",
"output": " ∀x (Non-rareEarthMetals(x) → NotScarce(x)) "
},
{
"input": "Translate into first-order logic: Either non-rare earth metals or rare earth metals.",
"output": " ∀x (Non-rareEarthMetals(x) ∨ RareEarthMetals(x)) "
},
{
"input": "Translate into first-order logic: All rare earth metals can be used for batteries.",
"output": " ∀x (RareEarthMetals(x) → BeUsedForBatteries(x)) "
},
{
"input": "Translate into first-order logic: All rare earth metals are essential for electric vehicles.",
"output": " ∀x (RareEarthMetals(x) → EssentialForElectricVehicles(x))"
},
{
"input": "Translate into first-order logic: Lithium is neither a non-rare earth metal nor essential for electric vehicles.",
"output": " ¬Non-rareEarthMetals(lithium) ⊕ ¬EssentialForElectricVehicles(lithium)"
},
{
"input": "Translate into first-order logic: If people own at least one pet, then they do not have tidy houses.",
"output": "∀x (OwnPet(x) → ¬TidyHouse(x))"
},
{
"input": "Translate into first-order logic: If people grew up with childhood pets, then they own at least one pet.",
"output": "∀x (ChildhoodPet(x) → OwnPet(x))"
},
{
"input": "Translate into first-order logic: If people hire a maid or cleaning service, then they have tidy houses.",
"output": "∀x (HireCleaning(x) → TidyHouse(x))"
},
{
"input": "Translate into first-order logic: If people live in the suburbs, then they have tidy houses.",
"output": "∀x (Suburbs(x) → ChildhoodPet(x))"
},
{
"input": "Translate into first-order logic: Jack either does not hire a maid or cleaning service or, if he does, then he does not own at least one pet.",
"output": "¬(HireCleaning(jack) ⊕ OwnPet(jack))"
},
{
"input": "Translate into first-order logic: If people own at least one pet, then they do not have tidy houses.",
"output": "∀x (OwnPet(x) → ¬TidyHouse(x))"
},
{
"input": "Translate into first-order logic: If people grew up with childhood pets, then they own at least one pet.",
"output": "∀x (ChildhoodPet(x) → OwnPet(x))"
},
{
"input": "Translate into first-order logic: If people hire a maid or cleaning service, then they have tidy houses.",
"output": "∀x (HireCleaning(x) → TidyHouse(x))"
},
{
"input": "Translate into first-order logic: If people live in the suburbs, then they have tidy houses.",
"output": "∀x (Suburbs(x) → ChildhoodPet(x))"
},
{
"input": "Translate into first-order logic: Jack either does not hire a maid or cleaning service or, if he does, then he does not own at least one pet.",
"output": "¬(HireCleaning(jack) ⊕ OwnPet(jack))"
},
{
"input": "Translate into first-order logic: If people own at least one pet, then they do not have tidy houses.",
"output": "∀x (OwnPet(x) → ¬TidyHouse(x))"
},
{
"input": "Translate into first-order logic: If people grew up with childhood pets, then they own at least one pet.",
"output": "∀x (ChildhoodPet(x) → OwnPet(x))"
},
{
"input": "Translate into first-order logic: If people hire a maid or cleaning service, then they have tidy houses.",
"output": "∀x (HireCleaning(x) → TidyHouse(x))"
},
{
"input": "Translate into first-order logic: If people live in the suburbs, then they have tidy houses.",
"output": "∀x (Suburbs(x) → ChildhoodPet(x))"
},
{
"input": "Translate into first-order logic: Jack either does not hire a maid or cleaning service or, if he does, then he does not own at least one pet.",
"output": "¬(HireCleaning(jack) ⊕ OwnPet(jack))"
},
{
"input": "Translate into first-order logic: If people own at least one pet, then they do not have tidy houses.",
"output": "∀x (OwnPet(x) → ¬TidyHouse(x))"
},
{
"input": "Translate into first-order logic: If people grew up with childhood pets, then they own at least one pet.",
"output": "∀x (ChildhoodPet(x) → OwnPet(x))"
},
{
"input": "Translate into first-order logic: If people hire a maid or cleaning service, then they have tidy houses.",
"output": "∀x (HireCleaning(x) → TidyHouse(x))"
},
{
"input": "Translate into first-order logic: If people live in the suburbs, then they have tidy houses.",
"output": "∀x (Suburbs(x) → ChildhoodPet(x))"
},
{
"input": "Translate into first-order logic: Jack either does not hire a maid or cleaning service or, if he does, then he does not own at least one pet.",
"output": "¬(HireCleaning(jack) ⊕ OwnPet(jack))"
},
{
"input": "Translate into first-order logic: If people own at least one pet, then they do not have tidy houses.",
"output": "∀x (OwnPet(x) → ¬TidyHouse(x))"
},
{
"input": "Translate into first-order logic: If people grew up with childhood pets, then they own at least one pet.",
"output": "∀x (ChildhoodPet(x) → OwnPet(x))"
},
{
"input": "Translate into first-order logic: If people hire a maid or cleaning service, then they have tidy houses.",
"output": "∀x (HireCleaning(x) → TidyHouse(x))"
},
{
"input": "Translate into first-order logic: If people live in the suburbs, then they have tidy houses.",
"output": "∀x (Suburbs(x) → ChildhoodPet(x))"
},
{
"input": "Translate into first-order logic: Jack either does not hire a maid or cleaning service or, if he does, then he does not own at least one pet.",
"output": "¬(HireCleaning(jack) ⊕ OwnPet(jack))"
},
{
"input": "Translate into first-order logic: A bottle is either standing upright or toppled over.",
"output": "Upright(bottle) ⊕ ToppledOver(bottle)"
},
{
"input": "Translate into first-order logic: The bottle is not upright.",
"output": "¬Upright(bottle)"
},
{
"input": "Translate into first-order logic: If people eat cereal and milk every day for breakfast, then they have very busy morning schedules every day.",
"output": "∀x (Cereal(x) → BusyMorning(x))"
},
{
"input": "Translate into first-order logic: All young children below the age of ten eat cereal and milk every day for breakfast.",
"output": "∀x (YoungChildren(x) → BusyMorning(x))"
},
{
"input": "Translate into first-order logic: People are either young children below the age of ten or have a lot of commitments they voluntarily signed up for.",
"output": "∀x (YoungChildren(x) ⊕ Committments(x))"
},
{
"input": "Translate into first-order logic: If people have a lot of commitments they voluntarily signed up for, then they are hardworking individuals with high ambitions and goals for the future.",
"output": "∀x (Committments(x) → Hardworking(x))"
},
{
"input": "Translate into first-order logic: If people are hardworking individuals with high ambitions and goals for the future, then they are not good at staying organized and motivated.",
"output": "∀x (Hardworking(x) → ¬Organized(x))"
},
{
"input": "Translate into first-order logic: John either is both a hardworking individual with high ambitions and goals for the future and has busy morning schedules every day, or he is neither a hardworking individual with high ambitions and goals for the future nor does he have a busy morning schedule every day.",
"output": "(Hardworking(john) ∧ BusyMorning(john)) ⊕ (¬Hardworking(john) ∧ ¬BusyMorning(john))"
},
{
"input": "Translate into first-order logic: If people eat cereal and milk every day for breakfast, then they have very busy morning schedules every day.",
"output": "∀x (Cereal(x) → BusyMorning(x))"
},
{
"input": "Translate into first-order logic: All young children below the age of ten eat cereal and milk every day for breakfast.",
"output": "∀x (YoungChildren(x) → BusyMorning(x))"
},
{
"input": "Translate into first-order logic: People are either young children below the age of ten or have a lot of commitments they voluntarily signed up for.",
"output": "∀x (YoungChildren(x) ⊕ Committments(x))"
},
{
"input": "Translate into first-order logic: If people have a lot of commitments they voluntarily signed up for, then they are hardworking individuals with high ambitions and goals for the future.",
"output": "∀x (Committments(x) → Hardworking(x))"
},
{
"input": "Translate into first-order logic: If people are hardworking individuals with high ambitions and goals for the future, then they are not good at staying organized and motivated.",
"output": "∀x (Hardworking(x) → ¬Organized(x))"
},
{
"input": "Translate into first-order logic: John either is both a hardworking individual with high ambitions and goals for the future and has busy morning schedules every day, or he is neither a hardworking individual with high ambitions and goals for the future nor does he have a busy morning schedule every day.",
"output": "(Hardworking(john) ∧ BusyMorning(john)) ⊕ (¬Hardworking(john) ∧ ¬BusyMorning(john))"
},
{
"input": "Translate into first-order logic: If people eat cereal and milk every day for breakfast, then they have very busy morning schedules every day.",
"output": "∀x (Cereal(x) → BusyMorning(x))"
},
{
"input": "Translate into first-order logic: All young children below the age of ten eat cereal and milk every day for breakfast.",
"output": "∀x (YoungChildren(x) → BusyMorning(x))"
},
{
"input": "Translate into first-order logic: People are either young children below the age of ten or have a lot of commitments they voluntarily signed up for.",
"output": "∀x (YoungChildren(x) ⊕ Committments(x))"
},
{
"input": "Translate into first-order logic: If people have a lot of commitments they voluntarily signed up for, then they are hardworking individuals with high ambitions and goals for the future.",
"output": "∀x (Committments(x) → Hardworking(x))"
},
{
"input": "Translate into first-order logic: If people are hardworking individuals with high ambitions and goals for the future, then they are not good at staying organized and motivated.",
"output": "∀x (Hardworking(x) → ¬Organized(x))"
},
{
"input": "Translate into first-order logic: John either is both a hardworking individual with high ambitions and goals for the future and has busy morning schedules every day, or he is neither a hardworking individual with high ambitions and goals for the future nor does he have a busy morning schedule every day.",
"output": "(Hardworking(john) ∧ BusyMorning(john)) ⊕ (¬Hardworking(john) ∧ ¬BusyMorning(john))"
},
{
"input": "Translate into first-order logic: Ableton has an office in Germany.",
"output": "OfficeIn(ableton, germany)"
},
{
"input": "Translate into first-order logic: Ableton has an office in the USA.",
"output": "OfficeIn(ableton, usa)"
},
{
"input": "Translate into first-order logic: USA and Germany are different countries.",
"output": "¬SameCountry(germany, usa)"
},
{
"input": "Translate into first-order logic: Any company that has offices in different countries is a multinational company.",
"output": "∀x ∀y ∀z (OfficeIn(x, y) ∧ OfficeIn(x, z) ∧ ¬SameCountry(y, z) → IsMultinationalCompany(x))"
},
{
"input": "Translate into first-order logic: Ableton makes music software.",
"output": "MakesMusicSoftware(ableton)"
},
{
"input": "Translate into first-order logic: Ableton has an office in Germany.",
"output": "OfficeIn(ableton, germany)"
},
{
"input": "Translate into first-order logic: Ableton has an office in the USA.",
"output": "OfficeIn(ableton, usa)"
},
{
"input": "Translate into first-order logic: USA and Germany are different countries.",
"output": "¬SameCountry(germany, usa)"
},
{
"input": "Translate into first-order logic: Any company that has offices in different countries is a multinational company.",
"output": "∀x ∀y ∀z (OfficeIn(x, y) ∧ OfficeIn(x, z) ∧ ¬SameCountry(y, z) → IsMultinationalCompany(x))"
},
{
"input": "Translate into first-order logic: Ableton makes music software.",
"output": "MakesMusicSoftware(ableton)"
},
{
"input": "Translate into first-order logic: Ableton has an office in Germany.",
"output": "OfficeIn(ableton, germany)"
},
{
"input": "Translate into first-order logic: Ableton has an office in the USA.",
"output": "OfficeIn(ableton, usa)"
},
{
"input": "Translate into first-order logic: USA and Germany are different countries.",
"output": "¬SameCountry(germany, usa)"
},
{
"input": "Translate into first-order logic: Any company that has offices in different countries is a multinational company.",
"output": "∀x ∀y ∀z (OfficeIn(x, y) ∧ OfficeIn(x, z) ∧ ¬SameCountry(y, z) → IsMultinationalCompany(x))"
},
{
"input": "Translate into first-order logic: Ableton makes music software.",
"output": "MakesMusicSoftware(ableton)"
},
{
"input": "Translate into first-order logic: Every swimmer can go underwater.",
"output": "∀x (Swimmer(x) → GoesUnderwater(x))"
},
{
"input": "Translate into first-order logic: Everyone that eats fish they catch themselves is a swimmer.",
"output": "∀x (EatsFishCaughtThemselves(x) → Swimmer(x))"
},
{
"input": "Translate into first-order logic: Every penguin eats fish they catch themselves.",
"output": "∀x (Penguin(x) → EatsFishCaughtThemselves(x))"
},
{
"input": "Translate into first-order logic: All nonflying birds in Antarctica are penguins.",
"output": "∀x (NonFlyingBirdAntartica(x) → Penguin(x))"
},
{
"input": "Translate into first-order logic: Fido is a penguin or a swimmer.",
"output": "Penguin(fido) ∨ Swimmer(fido)"
},
{
"input": "Translate into first-order logic: Every swimmer can go underwater.",
"output": "∀x (Swimmer(x) → GoesUnderwater(x))"
},
{
"input": "Translate into first-order logic: Everyone that eats fish they catch themselves is a swimmer.",
"output": "∀x (EatsFishCaughtThemselves(x) → Swimmer(x))"
},
{
"input": "Translate into first-order logic: Every penguin eats fish they catch themselves.",
"output": "∀x (Penguin(x) → EatsFishCaughtThemselves(x))"
},
{
"input": "Translate into first-order logic: All nonflying birds in Antarctica are penguins.",
"output": "∀x (NonFlyingBirdAntartica(x) → Penguin(x))"
},
{
"input": "Translate into first-order logic: Fido is a penguin or a swimmer.",
"output": "Penguin(fido) ∨ Swimmer(fido)"
},
{
"input": "Translate into first-order logic: Every swimmer can go underwater.",
"output": "∀x (Swimmer(x) → GoesUnderwater(x))"
},
{
"input": "Translate into first-order logic: Everyone that eats fish they catch themselves is a swimmer.",
"output": "∀x (EatsFishCaughtThemselves(x) → Swimmer(x))"
},
{
"input": "Translate into first-order logic: Every penguin eats fish they catch themselves.",
"output": "∀x (Penguin(x) → EatsFishCaughtThemselves(x))"
},
{
"input": "Translate into first-order logic: All nonflying birds in Antarctica are penguins.",
"output": "∀x (NonFlyingBirdAntartica(x) → Penguin(x))"
},
{
"input": "Translate into first-order logic: Fido is a penguin or a swimmer.",
"output": "Penguin(fido) ∨ Swimmer(fido)"
},
{
"input": "Translate into first-order logic: All professors are teachers.",
"output": "∀x (Professor(x) → Teacher(x))"
},
{
"input": "Translate into first-order logic: All researchers are professors.",
"output": "∀x (Researcher(x) → Professor(x))"
},
{
"input": "Translate into first-order logic: No teachers are students.",
"output": "∀x (Teacher(x) → ¬Student(x))"
},
{
"input": "Translate into first-order logic: All people who study are students.",
"output": "∀x (Study(x) → Student(x))"
},
{
"input": "Translate into first-order logic: Leon is not studying or a researcher.",
"output": "¬Study(leon) ⊕ Researcher(leon)"
},
{
"input": "Translate into first-order logic: If Leon is not studying, then Leon is a teacher.",
"output": "¬Study(leon) → Teacher(leon)"
},
{
"input": "Translate into first-order logic: All professors are teachers.",
"output": "∀x (Professor(x) → Teacher(x))"
},
{
"input": "Translate into first-order logic: All researchers are professors.",
"output": "∀x (Researcher(x) → Professor(x))"
},
{
"input": "Translate into first-order logic: No teachers are students.",
"output": "∀x (Teacher(x) → ¬Student(x))"
},
{
"input": "Translate into first-order logic: All people who study are students.",
"output": "∀x (Study(x) → Student(x))"
},
{
"input": "Translate into first-order logic: Leon is not studying or a researcher.",
"output": "¬Study(leon) ⊕ Researcher(leon)"
},
{
"input": "Translate into first-order logic: If Leon is not studying, then Leon is a teacher.",
"output": "¬Study(leon) → Teacher(leon)"
},
{
"input": "Translate into first-order logic: All professors are teachers.",
"output": "∀x (Professor(x) → Teacher(x))"
},
{
"input": "Translate into first-order logic: All researchers are professors.",
"output": "∀x (Researcher(x) → Professor(x))"
},
{
"input": "Translate into first-order logic: No teachers are students.",
"output": "∀x (Teacher(x) → ¬Student(x))"
},
{
"input": "Translate into first-order logic: All people who study are students.",
"output": "∀x (Study(x) → Student(x))"
},
{
"input": "Translate into first-order logic: Leon is not studying or a researcher.",
"output": "¬Study(leon) ⊕ Researcher(leon)"
},
{
"input": "Translate into first-order logic: If Leon is not studying, then Leon is a teacher.",
"output": "¬Study(leon) → Teacher(leon)"
},
{
"input": "Translate into first-order logic: A cutman is responsible for preventing and treating physical damage to a fighter.",
"output": "∀x (Cutman(x) → Prevent(x, physicalDamage) ∧ Treat(x, physicalDamage))"
},
{
"input": "Translate into first-order logic: Cutmen appear in matches such as a boxing, kickboxing or a mixed martial arts bout.",
"output": "∀x (Cutman(x) → Appear(x, boxing) ∨ Appear(x, kickboxing) ∨ Appear(x, mixedMartialBout))"
},
{
"input": "Translate into first-order logic: Cutmen typically handle swelling, nosebleeds and lacerations.",
"output": "∀x (Cutman(x) → Handle(x, swelling) ∧ Handle(x, nosebleeds) ∧ Handle(x, lacerations))"
},
{
"input": "Translate into first-order logic: Jack is a cutman.",
"output": "Cutman(jack)"
},
{
"input": "Translate into first-order logic: A cutman is responsible for preventing and treating physical damage to a fighter.",
"output": "∀x (Cutman(x) → Prevent(x, physicalDamage) ∧ Treat(x, physicalDamage))"
},
{
"input": "Translate into first-order logic: Cutmen appear in matches such as a boxing, kickboxing or a mixed martial arts bout.",
"output": "∀x (Cutman(x) → Appear(x, boxing) ∨ Appear(x, kickboxing) ∨ Appear(x, mixedMartialBout))"
},
{
"input": "Translate into first-order logic: Cutmen typically handle swelling, nosebleeds and lacerations.",
"output": "∀x (Cutman(x) → Handle(x, swelling) ∧ Handle(x, nosebleeds) ∧ Handle(x, lacerations))"
},
{
"input": "Translate into first-order logic: Jack is a cutman.",
"output": "Cutman(jack)"
},
{
"input": "Translate into first-order logic: A cutman is responsible for preventing and treating physical damage to a fighter.",
"output": "∀x (Cutman(x) → Prevent(x, physicalDamage) ∧ Treat(x, physicalDamage))"
},
{
"input": "Translate into first-order logic: Cutmen appear in matches such as a boxing, kickboxing or a mixed martial arts bout.",
"output": "∀x (Cutman(x) → Appear(x, boxing) ∨ Appear(x, kickboxing) ∨ Appear(x, mixedMartialBout))"
},
{
"input": "Translate into first-order logic: Cutmen typically handle swelling, nosebleeds and lacerations.",
"output": "∀x (Cutman(x) → Handle(x, swelling) ∧ Handle(x, nosebleeds) ∧ Handle(x, lacerations))"
},
{
"input": "Translate into first-order logic: Jack is a cutman.",
"output": "Cutman(jack)"
},
{
"input": "Translate into first-order logic: The Mona Lisa is one of the world's best-known artworks.",
"output": "Painting(monaLisa) ∧ WorldsBestKnown(monaLisa)"
},
{
"input": "Translate into first-order logic: The Mona Lisa is a portrait painted by Leonardo da Vinci.",
"output": "PaintedBy(monaLisa, leonardodaVinci) ∧ Portrait(monaLisa)"
},
{
"input": "Translate into first-order logic: Leonardo da Vinci was a scientist and painter.",
"output": "Scientist(leonardodaVinci) ∧ Painter(leonardodaVinci)"
},
{
"input": "Translate into first-order logic: Painting genres are history, portrait, animal, landscape, and still life.",
"output": "∀x (Painting(x) → (History(x) ∨ Portrait(x) ∨ Animal(x) ∨ Landscape(x) ∨ StillLife(x)))"
},
{
"input": "Translate into first-order logic: The Mona Lisa is one of the world's best-known artworks.",
"output": "Painting(monaLisa) ∧ WorldsBestKnown(monaLisa)"
},
{
"input": "Translate into first-order logic: The Mona Lisa is a portrait painted by Leonardo da Vinci.",
"output": "PaintedBy(monaLisa, leonardodaVinci) ∧ Portrait(monaLisa)"
},
{
"input": "Translate into first-order logic: Leonardo da Vinci was a scientist and painter.",
"output": "Scientist(leonardodaVinci) ∧ Painter(leonardodaVinci)"
},
{
"input": "Translate into first-order logic: Painting genres are history, portrait, animal, landscape, and still life.",
"output": "∀x (Painting(x) → (History(x) ∨ Portrait(x) ∨ Animal(x) ∨ Landscape(x) ∨ StillLife(x)))"
},
{
"input": "Translate into first-order logic: The Mona Lisa is one of the world's best-known artworks.",
"output": "Painting(monaLisa) ∧ WorldsBestKnown(monaLisa)"
},
{
"input": "Translate into first-order logic: The Mona Lisa is a portrait painted by Leonardo da Vinci.",
"output": "PaintedBy(monaLisa, leonardodaVinci) ∧ Portrait(monaLisa)"
},
{
"input": "Translate into first-order logic: Leonardo da Vinci was a scientist and painter.",
"output": "Scientist(leonardodaVinci) ∧ Painter(leonardodaVinci)"
},
{
"input": "Translate into first-order logic: Painting genres are history, portrait, animal, landscape, and still life.",
"output": "∀x (Painting(x) → (History(x) ∨ Portrait(x) ∨ Animal(x) ∨ Landscape(x) ∨ StillLife(x)))"
},
{
"input": "Translate into first-order logic: No professional tennis umpires are professional tennis players.",
"output": "∀x (ProfessionalTennisUmpire(x) → ¬ProfessionalTennisPlayer(x))"
},
{
"input": "Translate into first-order logic: If you are a World Tour player, then you are a professional tennis player.",
"output": "∀x (WorldTourPlayer(x) → ProfessionalTennisPlayer(x))"
},
{
"input": "Translate into first-order logic: All Grand Slam champions are World Tour players.",
"output": "∀x (GrandSlamChampion(x) → WorldTourPlayer(x))"
},
{
"input": "Translate into first-order logic: All Grand Slam umpires are professional tennis umpires.",
"output": "∀x (GrandSlamUmpire(x) → ProfessionalTennisUmpire(x))"
},
{
"input": "Translate into first-order logic: Nadal is a World Tour player or a Grand Slam champion",
"output": "WorldTourPlayer(nadal) ∨ GrandSlamChampion(nadal)"
},
{
"input": "Translate into first-order logic: No professional tennis umpires are professional tennis players.",
"output": "∀x (ProfessionalTennisUmpire(x) → ¬ProfessionalTennisPlayer(x))"
},
{
"input": "Translate into first-order logic: If you are a World Tour player, then you are a professional tennis player.",
"output": "∀x (WorldTourPlayer(x) → ProfessionalTennisPlayer(x))"
},
{
"input": "Translate into first-order logic: All Grand Slam champions are World Tour players.",
"output": "∀x (GrandSlamChampion(x) → WorldTourPlayer(x))"
},
{
"input": "Translate into first-order logic: All Grand Slam umpires are professional tennis umpires.",
"output": "∀x (GrandSlamUmpire(x) → ProfessionalTennisUmpire(x))"
},
{
"input": "Translate into first-order logic: Nadal is a World Tour player or a Grand Slam champion",
"output": "WorldTourPlayer(nadal) ∨ GrandSlamChampion(nadal)"
},
{
"input": "Translate into first-order logic: No professional tennis umpires are professional tennis players.",
"output": "∀x (ProfessionalTennisUmpire(x) → ¬ProfessionalTennisPlayer(x))"
},
{
"input": "Translate into first-order logic: If you are a World Tour player, then you are a professional tennis player.",
"output": "∀x (WorldTourPlayer(x) → ProfessionalTennisPlayer(x))"
},
{
"input": "Translate into first-order logic: All Grand Slam champions are World Tour players.",
"output": "∀x (GrandSlamChampion(x) → WorldTourPlayer(x))"
},
{
"input": "Translate into first-order logic: All Grand Slam umpires are professional tennis umpires.",
"output": "∀x (GrandSlamUmpire(x) → ProfessionalTennisUmpire(x))"
},
{
"input": "Translate into first-order logic: Nadal is a World Tour player or a Grand Slam champion",
"output": "WorldTourPlayer(nadal) ∨ GrandSlamChampion(nadal)"
},
{
"input": "Translate into first-order logic: No professional tennis umpires are professional tennis players.",
"output": "∀x (ProfessionalTennisUmpire(x) → ¬ProfessionalTennisPlayer(x))"
},
{
"input": "Translate into first-order logic: If you are a World Tour player, then you are a professional tennis player.",
"output": "∀x (WorldTourPlayer(x) → ProfessionalTennisPlayer(x))"
},
{
"input": "Translate into first-order logic: All Grand Slam champions are World Tour players.",
"output": "∀x (GrandSlamChampion(x) → WorldTourPlayer(x))"
},
{
"input": "Translate into first-order logic: All Grand Slam umpires are professional tennis umpires.",
"output": "∀x (GrandSlamUmpire(x) → ProfessionalTennisUmpire(x))"
},
{
"input": "Translate into first-order logic: Nadal is a World Tour player or a Grand Slam champion",
"output": "WorldTourPlayer(nadal) ∨ GrandSlamChampion(nadal)"
},
{
"input": "Translate into first-order logic: No professional tennis umpires are professional tennis players.",
"output": "∀x (ProfessionalTennisUmpire(x) → ¬ProfessionalTennisPlayer(x))"
},
{
"input": "Translate into first-order logic: If you are a World Tour player, then you are a professional tennis player.",
"output": "∀x (WorldTourPlayer(x) → ProfessionalTennisPlayer(x))"
},
{
"input": "Translate into first-order logic: All Grand Slam champions are World Tour players.",
"output": "∀x (GrandSlamChampion(x) → WorldTourPlayer(x))"
},
{
"input": "Translate into first-order logic: All Grand Slam umpires are professional tennis umpires.",
"output": "∀x (GrandSlamUmpire(x) → ProfessionalTennisUmpire(x))"
},
{
"input": "Translate into first-order logic: Nadal is a World Tour player or a Grand Slam champion",
"output": "WorldTourPlayer(nadal) ∨ GrandSlamChampion(nadal)"
},
{
"input": "Translate into first-order logic: No professional tennis umpires are professional tennis players.",
"output": "∀x (ProfessionalTennisUmpire(x) → ¬ProfessionalTennisPlayer(x))"
},
{
"input": "Translate into first-order logic: If you are a World Tour player, then you are a professional tennis player.",
"output": "∀x (WorldTourPlayer(x) → ProfessionalTennisPlayer(x))"
},
{
"input": "Translate into first-order logic: All Grand Slam champions are World Tour players.",
"output": "∀x (GrandSlamChampion(x) → WorldTourPlayer(x))"
},
{
"input": "Translate into first-order logic: All Grand Slam umpires are professional tennis umpires.",
"output": "∀x (GrandSlamUmpire(x) → ProfessionalTennisUmpire(x))"
},
{
"input": "Translate into first-order logic: Nadal is a World Tour player or a Grand Slam champion",
"output": "WorldTourPlayer(nadal) ∨ GrandSlamChampion(nadal)"
},
{
"input": "Translate into first-order logic: Buisnesses are either sanctioned or unsanctioned.",
"output": "∀x (Buisness(x) → Sanctioned(x) ⊕ ¬Sanctioned(x))"
},
{
"input": "Translate into first-order logic: Sanctioned buisnesses are limited.",
"output": "∀x (Buisness(x) ∧ Sanctioned(x) → Limited(x))"
},
{
"input": "Translate into first-order logic: Unsanctioned buisnesses are free.",
"output": "∀x (Buisness(x) ∧ ¬Sanctioned(x) → Free(x))"
},
{
"input": "Translate into first-order logic: The Crude Oil Data Exchange is a buisness that isn't free.",
"output": "Buisness(crudeoildataexchange) ∧ ¬Free(crudeoildataexchange)"
},
{
"input": "Translate into first-order logic: Buisnesses are either sanctioned or unsanctioned.",
"output": "∀x (Buisness(x) → Sanctioned(x) ⊕ ¬Sanctioned(x))"
},
{
"input": "Translate into first-order logic: Sanctioned buisnesses are limited.",
"output": "∀x (Buisness(x) ∧ Sanctioned(x) → Limited(x))"
},
{
"input": "Translate into first-order logic: Unsanctioned buisnesses are free.",
"output": "∀x (Buisness(x) ∧ ¬Sanctioned(x) → Free(x))"
},
{
"input": "Translate into first-order logic: The Crude Oil Data Exchange is a buisness that isn't free.",
"output": "Buisness(crudeoildataexchange) ∧ ¬Free(crudeoildataexchange)"
},
{
"input": "Translate into first-order logic: Buisnesses are either sanctioned or unsanctioned.",
"output": "∀x (Buisness(x) → Sanctioned(x) ⊕ ¬Sanctioned(x))"
},
{
"input": "Translate into first-order logic: Sanctioned buisnesses are limited.",
"output": "∀x (Buisness(x) ∧ Sanctioned(x) → Limited(x))"
},
{
"input": "Translate into first-order logic: Unsanctioned buisnesses are free.",
"output": "∀x (Buisness(x) ∧ ¬Sanctioned(x) → Free(x))"
},
{
"input": "Translate into first-order logic: The Crude Oil Data Exchange is a buisness that isn't free.",
"output": "Buisness(crudeoildataexchange) ∧ ¬Free(crudeoildataexchange)"
},
{
"input": "Translate into first-order logic: When something is depressing, it is sad.",
"output": "∀x (Depressing(x) → Sad(x))"
},
{
"input": "Translate into first-order logic: V is depressing.",
"output": "∀x (V(x) → Depressing(x))"
},
{
"input": "Translate into first-order logic: Palstaves are a type of early bronze axe.",
"output": "∀x (Palstave(x) → From(x, earlybronzeage) ∧ Axe(x))"
},
{
"input": "Translate into first-order logic: Commonly found in northern, western and south-western Europe, palstaves are cast in moulds.",
"output": "∀x ∀y (Palstave(x) ∧ Mould(y) → FoundIn(x, northerneurope) ∧ FoundIn(x, westerneurope) ∧ FoundIn(x, south-westerneurope) ∧ CastIn(x, y))"
},
{
"input": "Translate into first-order logic: John Evans is an archeologist who popularized the term \"palstave\".",
"output": "Archeologist(johnevans) ∧ Popularized(johnevans, termpalstave)"
},
{
"input": "Translate into first-order logic: A paalstab is not an axe, but rather a digging shovel.",
"output": "∀x (Paalstab(x) → ¬Axe(x) ∧ DiggingShovel(x))"
},
{
"input": "Translate into first-order logic: Palstaves are a type of early bronze axe.",
"output": "∀x (Palstave(x) → From(x, earlybronzeage) ∧ Axe(x))"
},
{
"input": "Translate into first-order logic: Commonly found in northern, western and south-western Europe, palstaves are cast in moulds.",
"output": "∀x ∀y (Palstave(x) ∧ Mould(y) → FoundIn(x, northerneurope) ∧ FoundIn(x, westerneurope) ∧ FoundIn(x, south-westerneurope) ∧ CastIn(x, y))"
},
{
"input": "Translate into first-order logic: John Evans is an archeologist who popularized the term \"palstave\".",
"output": "Archeologist(johnevans) ∧ Popularized(johnevans, termpalstave)"
},
{
"input": "Translate into first-order logic: A paalstab is not an axe, but rather a digging shovel.",
"output": "∀x (Paalstab(x) → ¬Axe(x) ∧ DiggingShovel(x))"
},
{
"input": "Translate into first-order logic: Palstaves are a type of early bronze axe.",
"output": "∀x (Palstave(x) → From(x, earlybronzeage) ∧ Axe(x))"
},
{
"input": "Translate into first-order logic: Commonly found in northern, western and south-western Europe, palstaves are cast in moulds.",
"output": "∀x ∀y (Palstave(x) ∧ Mould(y) → FoundIn(x, northerneurope) ∧ FoundIn(x, westerneurope) ∧ FoundIn(x, south-westerneurope) ∧ CastIn(x, y))"
},
{
"input": "Translate into first-order logic: John Evans is an archeologist who popularized the term \"palstave\".",
"output": "Archeologist(johnevans) ∧ Popularized(johnevans, termpalstave)"
},
{
"input": "Translate into first-order logic: A paalstab is not an axe, but rather a digging shovel.",
"output": "∀x (Paalstab(x) → ¬Axe(x) ∧ DiggingShovel(x))"
},
{
"input": "Translate into first-order logic: Koei Tecmo is a Japanese video game and anime holding company.",
"output": "Japanese(koeitecmo) ∧ VideoGameHoldingCompany(koeitecmo) ∧ AnimeHoldingCompany(koeitecmo)"
},
{
"input": "Translate into first-order logic: Holding companies hold several companies.",
"output": "∀x ∃y (HoldingCompany(x) → Company(y) ∧ Holds(x, y))"
},
{
"input": "Translate into first-order logic: Tecmo was disbanded in Japan, while Koei survived, but was renamed.",
"output": "Disbanded(tecmo) ∧ DisbandedIn(tecmo, japan) ∧ Survived(koei) ∧ Renamed(koei)"
},
{
"input": "Translate into first-order logic: Video game holding companies are holding companies.",
"output": "∀x (VideoGameHoldingCompany(x) → HoldingCompany(x))"
},
{
"input": "Translate into first-order logic: Koei Tecmo is a Japanese video game and anime holding company.",
"output": "Japanese(koeitecmo) ∧ VideoGameHoldingCompany(koeitecmo) ∧ AnimeHoldingCompany(koeitecmo)"
},
{
"input": "Translate into first-order logic: Holding companies hold several companies.",
"output": "∀x ∃y (HoldingCompany(x) → Company(y) ∧ Holds(x, y))"
},
{
"input": "Translate into first-order logic: Tecmo was disbanded in Japan, while Koei survived, but was renamed.",
"output": "Disbanded(tecmo) ∧ DisbandedIn(tecmo, japan) ∧ Survived(koei) ∧ Renamed(koei)"
},
{
"input": "Translate into first-order logic: Video game holding companies are holding companies.",
"output": "∀x (VideoGameHoldingCompany(x) → HoldingCompany(x))"
},
{
"input": "Translate into first-order logic: Koei Tecmo is a Japanese video game and anime holding company.",
"output": "Japanese(koeitecmo) ∧ VideoGameHoldingCompany(koeitecmo) ∧ AnimeHoldingCompany(koeitecmo)"
},
{
"input": "Translate into first-order logic: Holding companies hold several companies.",
"output": "∀x ∃y (HoldingCompany(x) → Company(y) ∧ Holds(x, y))"
},
{
"input": "Translate into first-order logic: Tecmo was disbanded in Japan, while Koei survived, but was renamed.",
"output": "Disbanded(tecmo) ∧ DisbandedIn(tecmo, japan) ∧ Survived(koei) ∧ Renamed(koei)"
},
{
"input": "Translate into first-order logic: Video game holding companies are holding companies.",
"output": "∀x (VideoGameHoldingCompany(x) → HoldingCompany(x))"
},
{
"input": "Translate into first-order logic: The PlayStation EyeToy is a camera accessory for the Playstation 2.",
"output": "Accessory(pseyetoy, ps2)"
},
{
"input": "Translate into first-order logic: The PlayStation Eye is a camera accessory for the Playstation 3.",
"output": "Accessory(pseye, ps3)"
},
{
"input": "Translate into first-order logic: The Playstation Camera is a camera accessory for the Playstation 4 and the Playstation 5.",
"output": "Accessory(pscamera, ps4) ∧ Accessory(pscamera, ps5)"
},
{
"input": "Translate into first-order logic: Camera accessory for the system is compatible with that system",
"output": "∀x ∀y (Accessory(x, y) → Compatible(x, y))"
},
{
"input": "Translate into first-order logic: Only the Playstation Camera is compatible with more than one system.",
"output": "¬Compatible(pseye, ps2) ∧ ¬Compatible(pseye, ps4)∧¬Compatible(pseye, ps5)∧¬Compatible(pseyetoy, ps3)∧¬Compatible(pseyetoy, ps4)∧¬Compatible(pseyetoy, ps5)"
},
{
"input": "Translate into first-order logic: The PlayStation EyeToy is a camera accessory for the Playstation 2.",
"output": "Accessory(pseyetoy, ps2)"
},
{
"input": "Translate into first-order logic: The PlayStation Eye is a camera accessory for the Playstation 3.",
"output": "Accessory(pseye, ps3)"
},
{
"input": "Translate into first-order logic: The Playstation Camera is a camera accessory for the Playstation 4 and the Playstation 5.",
"output": "Accessory(pscamera, ps4) ∧ Accessory(pscamera, ps5)"
},
{
"input": "Translate into first-order logic: Camera accessory for the system is compatible with that system",
"output": "∀x ∀y (Accessory(x, y) → Compatible(x, y))"
},
{
"input": "Translate into first-order logic: Only the Playstation Camera is compatible with more than one system.",
"output": "¬Compatible(pseye, ps2) ∧ ¬Compatible(pseye, ps4)∧¬Compatible(pseye, ps5)∧¬Compatible(pseyetoy, ps3)∧¬Compatible(pseyetoy, ps4)∧¬Compatible(pseyetoy, ps5)"
},
{
"input": "Translate into first-order logic: The PlayStation EyeToy is a camera accessory for the Playstation 2.",
"output": "Accessory(pseyetoy, ps2)"
},
{
"input": "Translate into first-order logic: The PlayStation Eye is a camera accessory for the Playstation 3.",
"output": "Accessory(pseye, ps3)"
},
{
"input": "Translate into first-order logic: The Playstation Camera is a camera accessory for the Playstation 4 and the Playstation 5.",
"output": "Accessory(pscamera, ps4) ∧ Accessory(pscamera, ps5)"
},
{
"input": "Translate into first-order logic: Camera accessory for the system is compatible with that system",
"output": "∀x ∀y (Accessory(x, y) → Compatible(x, y))"
},
{
"input": "Translate into first-order logic: Only the Playstation Camera is compatible with more than one system.",
"output": "¬Compatible(pseye, ps2) ∧ ¬Compatible(pseye, ps4)∧¬Compatible(pseye, ps5)∧¬Compatible(pseyetoy, ps3)∧¬Compatible(pseyetoy, ps4)∧¬Compatible(pseyetoy, ps5)"
},
{
"input": "Translate into first-order logic: Adam Buska is a European football player.",
"output": "FootballPlayer(adambuska) ∧ European(adambuska)"
},
{
"input": "Translate into first-order logic: If a European plays football, they play what Americans call soccer.",
"output": "∀x ((FootballPlayer(x) ∧ European(x)) → PlaysAmericanSoccer(x))"
},
{
"input": "Translate into first-order logic: If the game has sold more than 1 million copies, then it is on the Best Seller list.",
"output": "∀x (SoldMillion(x) → BestSeller(x))"
},
{
"input": "Translate into first-order logic: All Games developed by Paradox Development Studio sold more than 1 million copies.",
"output": "∀x (DevelopedByParadox(x) → SoldMillion(x))"
},
{
"input": "Translate into first-order logic: Some games published before 2010 support the Linux OS system.",
"output": "∃x ((PublishedBefore2010(x) ∧ SupportLinuxSystem(x)))"
},
{
"input": "Translate into first-order logic: All games on the Best Seller list are popular among young people.",
"output": "∀x (BestSeller(x) → Popular(x))"
},
{
"input": "Translate into first-order logic: FIFA22 neither supports the Linux OS system nor is it popular among young people.",
"output": "¬(SupportLinuxSystem(fifa21) ∨ Popular(fifa21))"
},
{
"input": "Translate into first-order logic: If the game has sold more than 1 million copies, then it is on the Best Seller list.",
"output": "∀x (SoldMillion(x) → BestSeller(x))"
},
{
"input": "Translate into first-order logic: All Games developed by Paradox Development Studio sold more than 1 million copies.",
"output": "∀x (DevelopedByParadox(x) → SoldMillion(x))"
},
{
"input": "Translate into first-order logic: Some games published before 2010 support the Linux OS system.",
"output": "∃x ((PublishedBefore2010(x) ∧ SupportLinuxSystem(x)))"
},
{
"input": "Translate into first-order logic: All games on the Best Seller list are popular among young people.",
"output": "∀x (BestSeller(x) → Popular(x))"
},
{
"input": "Translate into first-order logic: FIFA22 neither supports the Linux OS system nor is it popular among young people.",
"output": "¬(SupportLinuxSystem(fifa21) ∨ Popular(fifa21))"
},
{
"input": "Translate into first-order logic: If the game has sold more than 1 million copies, then it is on the Best Seller list.",
"output": "∀x (SoldMillion(x) → BestSeller(x))"
},
{
"input": "Translate into first-order logic: All Games developed by Paradox Development Studio sold more than 1 million copies.",
"output": "∀x (DevelopedByParadox(x) → SoldMillion(x))"
},
{
"input": "Translate into first-order logic: Some games published before 2010 support the Linux OS system.",
"output": "∃x ((PublishedBefore2010(x) ∧ SupportLinuxSystem(x)))"
},
{
"input": "Translate into first-order logic: All games on the Best Seller list are popular among young people.",
"output": "∀x (BestSeller(x) → Popular(x))"
},
{
"input": "Translate into first-order logic: FIFA22 neither supports the Linux OS system nor is it popular among young people.",
"output": "¬(SupportLinuxSystem(fifa21) ∨ Popular(fifa21))"
},
{
"input": "Translate into first-order logic: China is one of BRICS and its economy is emerging.",
"output": "∀x (China(x) → BRICS(x) ∧ EmergingEconomy(x))"
},
{
"input": "Translate into first-order logic: India is one of BRICS and its economy is emerging.",
"output": "∀x (India(x) → BRICS(x) ∧ EmergingEconomy(x))"
},
{
"input": "Translate into first-order logic: All people from China speak Chinese.",
"output": "∀x ∀y (From(x, y) ∧ China(y) → Speak(x, chinese))"
},
{
"input": "Translate into first-order logic: All people from India speak Hindi or English.",
"output": "∀x ∀y (From(x, y) ∧ India(y) → Speak(x, hindi) ∨ Speak(x, english))"
},
{
"input": "Translate into first-order logic: There is an Indian.",
"output": "∃x ∃y (From(x, y) ∧ India(y))"
},
{
"input": "Translate into first-order logic: China is one of BRICS and its economy is emerging.",
"output": "∀x (China(x) → BRICS(x) ∧ EmergingEconomy(x))"
},
{
"input": "Translate into first-order logic: India is one of BRICS and its economy is emerging.",
"output": "∀x (India(x) → BRICS(x) ∧ EmergingEconomy(x))"
},
{
"input": "Translate into first-order logic: All people from China speak Chinese.",
"output": "∀x ∀y (From(x, y) ∧ China(y) → Speak(x, chinese))"
},
{
"input": "Translate into first-order logic: All people from India speak Hindi or English.",
"output": "∀x ∀y (From(x, y) ∧ India(y) → Speak(x, hindi) ∨ Speak(x, english))"
},
{
"input": "Translate into first-order logic: There is an Indian.",
"output": "∃x ∃y (From(x, y) ∧ India(y))"
},
{
"input": "Translate into first-order logic: China is one of BRICS and its economy is emerging.",
"output": "∀x (China(x) → BRICS(x) ∧ EmergingEconomy(x))"
},
{
"input": "Translate into first-order logic: India is one of BRICS and its economy is emerging.",
"output": "∀x (India(x) → BRICS(x) ∧ EmergingEconomy(x))"
},
{
"input": "Translate into first-order logic: All people from China speak Chinese.",
"output": "∀x ∀y (From(x, y) ∧ China(y) → Speak(x, chinese))"
},
{
"input": "Translate into first-order logic: All people from India speak Hindi or English.",
"output": "∀x ∀y (From(x, y) ∧ India(y) → Speak(x, hindi) ∨ Speak(x, english))"
},
{
"input": "Translate into first-order logic: There is an Indian.",
"output": "∃x ∃y (From(x, y) ∧ India(y))"
},
{
"input": "Translate into first-order logic: Daveed Diggs is an actor and film producer.",
"output": "Actor(daveedDiggs) ∧ FilmProducer(daveedDiggs)"
},
{
"input": "Translate into first-order logic: Daveed Diggs played two roles in the musical Hamilton.",
"output": "PlayedTwoRoles(daveedDiggs) ∧ PlayedIn(daveedDiggs, hamilton) ∧ Musical(hamilton)"
},
{
"input": "Translate into first-order logic: One of the actors from Hamilton won the best actor award.",
"output": "∃x (Actor(x) ∧ PlayedIn(x, hamilton) ∧ WonBestActorAward(x))"
},
{
"input": "Translate into first-order logic: The actor playing Thomas Jefferson won the best actor award.",
"output": "∀x (Actor(x) ∧ Played(x, thomasJefferson) → WonBestActorAward(x))"
},
{
"input": "Translate into first-order logic: Daveed Diggs played Thomas Jefferson.",
"output": "Played(daveedDiggs, thomasJefferson)"
},
{
"input": "Translate into first-order logic: Musicals are not films.",
"output": "∀x (Musical(x) → ¬Film(x))"
},
{
"input": "Translate into first-order logic: Daveed Diggs is an actor and film producer.",
"output": "Actor(daveedDiggs) ∧ FilmProducer(daveedDiggs)"
},
{
"input": "Translate into first-order logic: Daveed Diggs played two roles in the musical Hamilton.",
"output": "PlayedTwoRoles(daveedDiggs) ∧ PlayedIn(daveedDiggs, hamilton) ∧ Musical(hamilton)"
},
{
"input": "Translate into first-order logic: One of the actors from Hamilton won the best actor award.",
"output": "∃x (Actor(x) ∧ PlayedIn(x, hamilton) ∧ WonBestActorAward(x))"
},
{
"input": "Translate into first-order logic: The actor playing Thomas Jefferson won the best actor award.",
"output": "∀x (Actor(x) ∧ Played(x, thomasJefferson) → WonBestActorAward(x))"
},
{
"input": "Translate into first-order logic: Daveed Diggs played Thomas Jefferson.",
"output": "Played(daveedDiggs, thomasJefferson)"
},
{
"input": "Translate into first-order logic: Musicals are not films.",
"output": "∀x (Musical(x) → ¬Film(x))"
},
{
"input": "Translate into first-order logic: Daveed Diggs is an actor and film producer.",
"output": "Actor(daveedDiggs) ∧ FilmProducer(daveedDiggs)"
},
{
"input": "Translate into first-order logic: Daveed Diggs played two roles in the musical Hamilton.",
"output": "PlayedTwoRoles(daveedDiggs) ∧ PlayedIn(daveedDiggs, hamilton) ∧ Musical(hamilton)"
},
{
"input": "Translate into first-order logic: One of the actors from Hamilton won the best actor award.",
"output": "∃x (Actor(x) ∧ PlayedIn(x, hamilton) ∧ WonBestActorAward(x))"
},
{
"input": "Translate into first-order logic: The actor playing Thomas Jefferson won the best actor award.",
"output": "∀x (Actor(x) ∧ Played(x, thomasJefferson) → WonBestActorAward(x))"
},
{
"input": "Translate into first-order logic: Daveed Diggs played Thomas Jefferson.",
"output": "Played(daveedDiggs, thomasJefferson)"
},
{
"input": "Translate into first-order logic: Musicals are not films.",
"output": "∀x (Musical(x) → ¬Film(x))"
},
{
"input": "Translate into first-order logic: Ernest Pohl was a Polish football player.",
"output": "PolishFootballPlayer(ernestpohl)"
},
{
"input": "Translate into first-order logic: A football player in the Polish First Division has scored over 180 goals.",
"output": "∃x (In(x, polishfirstdivision) ∧ ScoredMoreThan180Goals(x))"
},
{
"input": "Translate into first-order logic: Ernest Pohl scored more than 180 goals in the Polish First Division.",
"output": "ScoredMoreThan180Goals(ernestpohl) ∧ In(ernestpohl, polishfirstdivision)"
},
{
"input": "Translate into first-order logic: Górnik Zabrze's stadium was named after a soccer player from Ruda Śląska.",
"output": "∃x (NamedAfter(gornikzabrze, x) ∧ FootballPlayer(x) ∧ From(x, rudaslaska))"
},
{
"input": "Translate into first-order logic: Ernest Pohl is from Ruda Śląska.",
"output": "From(ernestpohl, rudaslaska)"
},
{
"input": "Translate into first-order logic: Ernest Pohl was a Polish football player.",
"output": "PolishFootballPlayer(ernestpohl)"
},
{
"input": "Translate into first-order logic: A football player in the Polish First Division has scored over 180 goals.",
"output": "∃x (In(x, polishfirstdivision) ∧ ScoredMoreThan180Goals(x))"
},
{
"input": "Translate into first-order logic: Ernest Pohl scored more than 180 goals in the Polish First Division.",
"output": "ScoredMoreThan180Goals(ernestpohl) ∧ In(ernestpohl, polishfirstdivision)"
},
{
"input": "Translate into first-order logic: Górnik Zabrze's stadium was named after a soccer player from Ruda Śląska.",
"output": "∃x (NamedAfter(gornikzabrze, x) ∧ FootballPlayer(x) ∧ From(x, rudaslaska))"
},
{
"input": "Translate into first-order logic: Ernest Pohl is from Ruda Śląska.",
"output": "From(ernestpohl, rudaslaska)"
},
{
"input": "Translate into first-order logic: Ann J. Land was a member of the Philadelphia City Council and was also a member of the Democratic Party.",
"output": "PhiladephiaCouncil(annJLand) ∧ DemocraticParty(annJLand)"
},
{
"input": "Translate into first-order logic: Ann J. Land ran unopposed for the Philadephia City Council in 1980.",
"output": "Year(y1980) → PhiladephiaCouncil(annJLand) ∧ RunFor(annJLand)"
},
{
"input": "Translate into first-order logic: People who run unopposed for the Philadelphia City Council are elected to the positions they run for in the same year.",
"output": "∀x (RunFor(x) ∧ PhiladephiaCouncil(x) → Elected(x))"
},
{
"input": "Translate into first-order logic: Michael Nutter was a political challenger.",
"output": "Challenger(nutter)"
},
{
"input": "Translate into first-order logic: Ann J. Land defeated Michael Nutter and ran for the Philadelphia City Council in 1987.",
"output": "Year(y1987) → PhiladephiaCouncil(annJLand) ∧ RunFor(annJLand) ∧ Defeated(annJLand, nutter)"
},
{
"input": "Translate into first-order logic: Ann J. Land was a member of the Philadelphia City Council and was also a member of the Democratic Party.",
"output": "PhiladephiaCouncil(annJLand) ∧ DemocraticParty(annJLand)"
},
{
"input": "Translate into first-order logic: Ann J. Land ran unopposed for the Philadephia City Council in 1980.",
"output": "Year(y1980) → PhiladephiaCouncil(annJLand) ∧ RunFor(annJLand)"
},
{
"input": "Translate into first-order logic: People who run unopposed for the Philadelphia City Council are elected to the positions they run for in the same year.",
"output": "∀x (RunFor(x) ∧ PhiladephiaCouncil(x) → Elected(x))"
},
{
"input": "Translate into first-order logic: Michael Nutter was a political challenger.",
"output": "Challenger(nutter)"
},
{
"input": "Translate into first-order logic: Ann J. Land defeated Michael Nutter and ran for the Philadelphia City Council in 1987.",
"output": "Year(y1987) → PhiladephiaCouncil(annJLand) ∧ RunFor(annJLand) ∧ Defeated(annJLand, nutter)"
},
{
"input": "Translate into first-order logic: Ann J. Land was a member of the Philadelphia City Council and was also a member of the Democratic Party.",
"output": "PhiladephiaCouncil(annJLand) ∧ DemocraticParty(annJLand)"
},
{
"input": "Translate into first-order logic: Ann J. Land ran unopposed for the Philadephia City Council in 1980.",
"output": "Year(y1980) → PhiladephiaCouncil(annJLand) ∧ RunFor(annJLand)"
},
{
"input": "Translate into first-order logic: People who run unopposed for the Philadelphia City Council are elected to the positions they run for in the same year.",
"output": "∀x (RunFor(x) ∧ PhiladephiaCouncil(x) → Elected(x))"
},
{
"input": "Translate into first-order logic: Michael Nutter was a political challenger.",
"output": "Challenger(nutter)"
},
{
"input": "Translate into first-order logic: Ann J. Land defeated Michael Nutter and ran for the Philadelphia City Council in 1987.",
"output": "Year(y1987) → PhiladephiaCouncil(annJLand) ∧ RunFor(annJLand) ∧ Defeated(annJLand, nutter)"
},
{
"input": "Translate into first-order logic: Aberdeen won the cup in the 2013 final.",
"output": "WonCup(aberdeen, twentythirteen)"
},
{
"input": "Translate into first-order logic: Rangers won the cup in 2014 final.",
"output": "WonCup(rangers, twentyfourteen)"
},
{
"input": "Translate into first-order logic: Aberdeen and Rangers are different teams.",
"output": "Different(aberdeen, rangers) ∧ Different(rangers, aberdeen)"
},
{
"input": "Translate into first-order logic: Different teams cannot win the same cup in a given year's final.",
"output": "∀x ∀y ∀z (Different(x, y)  ∧ WonCup(x, z)  → ¬WonCup(y, z))"
},
{
"input": "Translate into first-order logic: Aberdeen won the cup in the 2013 final.",
"output": "WonCup(aberdeen, twentythirteen)"
},
{
"input": "Translate into first-order logic: Rangers won the cup in 2014 final.",
"output": "WonCup(rangers, twentyfourteen)"
},
{
"input": "Translate into first-order logic: Aberdeen and Rangers are different teams.",
"output": "Different(aberdeen, rangers) ∧ Different(rangers, aberdeen)"
},
{
"input": "Translate into first-order logic: Different teams cannot win the same cup in a given year's final.",
"output": "∀x ∀y ∀z (Different(x, y)  ∧ WonCup(x, z)  → ¬WonCup(y, z))"
},
{
"input": "Translate into first-order logic: Aberdeen won the cup in the 2013 final.",
"output": "WonCup(aberdeen, twentythirteen)"
},
{
"input": "Translate into first-order logic: Rangers won the cup in 2014 final.",
"output": "WonCup(rangers, twentyfourteen)"
},
{
"input": "Translate into first-order logic: Aberdeen and Rangers are different teams.",
"output": "Different(aberdeen, rangers) ∧ Different(rangers, aberdeen)"
},
{
"input": "Translate into first-order logic: Different teams cannot win the same cup in a given year's final.",
"output": "∀x ∀y ∀z (Different(x, y)  ∧ WonCup(x, z)  → ¬WonCup(y, z))"
},
{
"input": "Translate into first-order logic: All young working professionals who have regular 9-5 jobs also have pets.",
"output": "∀x (Working(x) → Pets(x))"
},
{
"input": "Translate into first-order logic: Some people who live in Manhattan are young working professionals who have regular 9-5 jobs.",
"output": "∃x (Manhattan(x) ∧ Working(x))"
},
{
"input": "Translate into first-order logic: All people who have pets are people who have at least one child.",
"output": "∀x (Pets(x) → Child(x))"
},
{
"input": "Translate into first-order logic: People who do not have at least one child are people who own a sports car.",
"output": "∀x (Child(x) → ¬Car(x))"
},
{
"input": "Translate into first-order logic: Mary either does not own a sports car or, if they do, then they do not have at least one child.",
"output": "¬(Car(mary) ⊕ Child(mary))"
},
{
"input": "Translate into first-order logic: All young working professionals who have regular 9-5 jobs also have pets.",
"output": "∀x (Working(x) → Pets(x))"
},
{
"input": "Translate into first-order logic: Some people who live in Manhattan are young working professionals who have regular 9-5 jobs.",
"output": "∃x (Manhattan(x) ∧ Working(x))"
},
{
"input": "Translate into first-order logic: All people who have pets are people who have at least one child.",
"output": "∀x (Pets(x) → Child(x))"
},
{
"input": "Translate into first-order logic: People who do not have at least one child are people who own a sports car.",
"output": "∀x (Child(x) → ¬Car(x))"
},
{
"input": "Translate into first-order logic: Mary either does not own a sports car or, if they do, then they do not have at least one child.",
"output": "¬(Car(mary) ⊕ Child(mary))"
},
{
"input": "Translate into first-order logic: All young working professionals who have regular 9-5 jobs also have pets.",
"output": "∀x (Working(x) → Pets(x))"
},
{
"input": "Translate into first-order logic: Some people who live in Manhattan are young working professionals who have regular 9-5 jobs.",
"output": "∃x (Manhattan(x) ∧ Working(x))"
},
{
"input": "Translate into first-order logic: All people who have pets are people who have at least one child.",
"output": "∀x (Pets(x) → Child(x))"
},
{
"input": "Translate into first-order logic: People who do not have at least one child are people who own a sports car.",
"output": "∀x (Child(x) → ¬Car(x))"
},
{
"input": "Translate into first-order logic: Mary either does not own a sports car or, if they do, then they do not have at least one child.",
"output": "¬(Car(mary) ⊕ Child(mary))"
},
{
"input": "Translate into first-order logic: Either block design or event-related design.",
"output": "∀x (BlockDesign(x) ∨ Event-relatedDesign(x))"
},
{
"input": "Translate into first-order logic: All event-related designs are brain image acquisition.",
"output": "∀x (Event-relatedDesign(x) → BrainImageAcquisition(x))"
},
{
"input": "Translate into first-order logic: All brain image acquisition is preceded by data processing.",
"output": "∀x (BrainImageAcquisition(x) → PrecededByDataProcessing(x))"
},
{
"input": "Translate into first-order logic: Nothing preceded by data processing acquires data.",
"output": "∀x (PrecededByDataProcessing(x) → ¬AcquiringData(x))"
},
{
"input": "Translate into first-order logic: Picture memory is either an event-related design and acquiring data or neither an event-related design nor acquiring data.",
"output": "(Event-relatedDesign(pictureMemory) ∧ AcquiringData(pictureMemory)) ∨ (¬Event-relatedDesign(pictureMemory) ∧ ¬AcquiringData(pictureMemory))"
},
{
"input": "Translate into first-order logic: Either block design or event-related design.",
"output": "∀x (BlockDesign(x) ∨ Event-relatedDesign(x))"
},
{
"input": "Translate into first-order logic: All event-related designs are brain image acquisition.",
"output": "∀x (Event-relatedDesign(x) → BrainImageAcquisition(x))"
},
{
"input": "Translate into first-order logic: All brain image acquisition is preceded by data processing.",
"output": "∀x (BrainImageAcquisition(x) → PrecededByDataProcessing(x))"
},
{
"input": "Translate into first-order logic: Nothing preceded by data processing acquires data.",
"output": "∀x (PrecededByDataProcessing(x) → ¬AcquiringData(x))"
},
{
"input": "Translate into first-order logic: Picture memory is either an event-related design and acquiring data or neither an event-related design nor acquiring data.",
"output": "(Event-relatedDesign(pictureMemory) ∧ AcquiringData(pictureMemory)) ∨ (¬Event-relatedDesign(pictureMemory) ∧ ¬AcquiringData(pictureMemory))"
},
{
"input": "Translate into first-order logic: Either block design or event-related design.",
"output": "∀x (BlockDesign(x) ∨ Event-relatedDesign(x))"
},
{
"input": "Translate into first-order logic: All event-related designs are brain image acquisition.",
"output": "∀x (Event-relatedDesign(x) → BrainImageAcquisition(x))"
},
{
"input": "Translate into first-order logic: All brain image acquisition is preceded by data processing.",
"output": "∀x (BrainImageAcquisition(x) → PrecededByDataProcessing(x))"
},
{
"input": "Translate into first-order logic: Nothing preceded by data processing acquires data.",
"output": "∀x (PrecededByDataProcessing(x) → ¬AcquiringData(x))"
},
{
"input": "Translate into first-order logic: Picture memory is either an event-related design and acquiring data or neither an event-related design nor acquiring data.",
"output": "(Event-relatedDesign(pictureMemory) ∧ AcquiringData(pictureMemory)) ∨ (¬Event-relatedDesign(pictureMemory) ∧ ¬AcquiringData(pictureMemory))"
},
{
"input": "Translate into first-order logic: Either block design or event-related design.",
"output": "∀x (BlockDesign(x) ∨ Event-relatedDesign(x))"
},
{
"input": "Translate into first-order logic: All event-related designs are brain image acquisition.",
"output": "∀x (Event-relatedDesign(x) → BrainImageAcquisition(x))"
},
{
"input": "Translate into first-order logic: All brain image acquisition is preceded by data processing.",
"output": "∀x (BrainImageAcquisition(x) → PrecededByDataProcessing(x))"
},
{
"input": "Translate into first-order logic: Nothing preceded by data processing acquires data.",
"output": "∀x (PrecededByDataProcessing(x) → ¬AcquiringData(x))"
},
{
"input": "Translate into first-order logic: Picture memory is either an event-related design and acquiring data or neither an event-related design nor acquiring data.",
"output": "(Event-relatedDesign(pictureMemory) ∧ AcquiringData(pictureMemory)) ∨ (¬Event-relatedDesign(pictureMemory) ∧ ¬AcquiringData(pictureMemory))"
},
{
"input": "Translate into first-order logic: The USS Lyon was a US Navy ship involved in WWII.",
"output": "(USNavyShip(usslyon) ∧ InWWII(usslyon))"
},
{
"input": "Translate into first-order logic: All ships involved in WWII are currently decommissioned or in a museum.",
"output": "∀x (InWWII(x) → (Decommissioned(x) ∨ InMuseum(x)))"
},
{
"input": "Translate into first-order logic: All disposable chopsticks are made from trees.",
"output": "∀x (DisposableChopsticks(x) → MadeFromTrees(x))"
},
{
"input": "Translate into first-order logic: Some chopsticks are eco-friendly.",
"output": "∃x (EcoFriendly(x))"
},
{
"input": "Translate into first-order logic: Either disposable chopsticks or reusable chopsticks.",
"output": "∀x (DisposableChopsticks(x) ⊕ Reusable(x)) "
},
{
"input": "Translate into first-order logic: If chopsticks are made from metals, then they are not made from plastics.",
"output": "∀x (MadeFromMetals(x) → ¬MadeFromPlastics(x))"
},
{
"input": "Translate into first-order logic: All reusable chopsticks are made from metal.",
"output": "∀x (Reusable(x) → MadeFromMetals(x))"
},
{
"input": "Translate into first-order logic: Chopsticks at restaurants are either made from metals and made from plastics, or neither made from metals nor made from plastics.",
"output": "¬(MadeFromMetals(chopsticksAtRestaurants) ⊕ MadeFromPlastics(chopsticksAtRestaurants))"
},
{
"input": "Translate into first-order logic: All disposable chopsticks are made from trees.",
"output": "∀x (DisposableChopsticks(x) → MadeFromTrees(x))"
},
{
"input": "Translate into first-order logic: Some chopsticks are eco-friendly.",
"output": "∃x (EcoFriendly(x))"
},
{
"input": "Translate into first-order logic: Either disposable chopsticks or reusable chopsticks.",
"output": "∀x (DisposableChopsticks(x) ⊕ Reusable(x)) "
},
{
"input": "Translate into first-order logic: If chopsticks are made from metals, then they are not made from plastics.",
"output": "∀x (MadeFromMetals(x) → ¬MadeFromPlastics(x))"
},
{
"input": "Translate into first-order logic: All reusable chopsticks are made from metal.",
"output": "∀x (Reusable(x) → MadeFromMetals(x))"
},
{
"input": "Translate into first-order logic: Chopsticks at restaurants are either made from metals and made from plastics, or neither made from metals nor made from plastics.",
"output": "¬(MadeFromMetals(chopsticksAtRestaurants) ⊕ MadeFromPlastics(chopsticksAtRestaurants))"
},
{
"input": "Translate into first-order logic: All disposable chopsticks are made from trees.",
"output": "∀x (DisposableChopsticks(x) → MadeFromTrees(x))"
},
{
"input": "Translate into first-order logic: Some chopsticks are eco-friendly.",
"output": "∃x (EcoFriendly(x))"
},
{
"input": "Translate into first-order logic: Either disposable chopsticks or reusable chopsticks.",
"output": "∀x (DisposableChopsticks(x) ⊕ Reusable(x)) "
},
{
"input": "Translate into first-order logic: If chopsticks are made from metals, then they are not made from plastics.",
"output": "∀x (MadeFromMetals(x) → ¬MadeFromPlastics(x))"
},
{
"input": "Translate into first-order logic: All reusable chopsticks are made from metal.",
"output": "∀x (Reusable(x) → MadeFromMetals(x))"
},
{
"input": "Translate into first-order logic: Chopsticks at restaurants are either made from metals and made from plastics, or neither made from metals nor made from plastics.",
"output": "¬(MadeFromMetals(chopsticksAtRestaurants) ⊕ MadeFromPlastics(chopsticksAtRestaurants))"
},
{
"input": "Translate into first-order logic: Anything that is lazy is unproductive.",
"output": "∀x (Lazy(x) → Unproductive(x))"
},
{
"input": "Translate into first-order logic: No one unproductive is an energetic person.",
"output": "∀x (Unproductive(x) → ¬Energetic(x))"
},
{
"input": "Translate into first-order logic: If something is a sloth, then it is lazy.",
"output": "∀x (Sloth(x) → Lazy(x))"
},
{
"input": "Translate into first-order logic: Some animals are sloths.",
"output": "∃x (Animal(x) ∧ Sloth(x))"
},
{
"input": "Translate into first-order logic: Sid is not either an energetic person or a sloth.",
"output": "¬Energetic(sid) ∨ Sloth(sid)"
},
{
"input": "Translate into first-order logic: Anything that is lazy is unproductive.",
"output": "∀x (Lazy(x) → Unproductive(x))"
},
{
"input": "Translate into first-order logic: No one unproductive is an energetic person.",
"output": "∀x (Unproductive(x) → ¬Energetic(x))"
},
{
"input": "Translate into first-order logic: If something is a sloth, then it is lazy.",
"output": "∀x (Sloth(x) → Lazy(x))"
},
{
"input": "Translate into first-order logic: Some animals are sloths.",
"output": "∃x (Animal(x) ∧ Sloth(x))"
},
{
"input": "Translate into first-order logic: Sid is not either an energetic person or a sloth.",
"output": "¬Energetic(sid) ∨ Sloth(sid)"
},
{
"input": "Translate into first-order logic: Anything that is lazy is unproductive.",
"output": "∀x (Lazy(x) → Unproductive(x))"
},
{
"input": "Translate into first-order logic: No one unproductive is an energetic person.",
"output": "∀x (Unproductive(x) → ¬Energetic(x))"
},
{
"input": "Translate into first-order logic: If something is a sloth, then it is lazy.",
"output": "∀x (Sloth(x) → Lazy(x))"
},
{
"input": "Translate into first-order logic: Some animals are sloths.",
"output": "∃x (Animal(x) ∧ Sloth(x))"
},
{
"input": "Translate into first-order logic: Sid is not either an energetic person or a sloth.",
"output": "¬Energetic(sid) ∨ Sloth(sid)"
},
{
"input": "Translate into first-order logic: European soccer clubs can attend UCL, UEL and UECL.",
"output": "∀x (European(x) ∧ SoccerClub(x) → Attend(x, ucl) ∨ Attend(x, uel) ∨ Attend(x, uecl))"
},
{
"input": "Translate into first-order logic: A soccer club eligible to attend UCL has a higher ranking than a soccer club eligible to attend UEL.",
"output": "∀x ∀y (SoccerClub(x) ∧ SoccerClub(y) ∧ Attend(x, ucl) ∧ Attend(y, uel) → HigherRank(x, y))"
},
{
"input": "Translate into first-order logic: A soccer club eligible to attend UEL has a higher ranking than a soccer club eligible to attend UECL.",
"output": "∀x ∀y (SoccerClub(x) ∧ SoccerClub(y) ∧ Attend(x, uel) ∧ Attend(y, uecl) → HigherRank(x, y))"
},
{
"input": "Translate into first-order logic: Manchester United and Machester City are both European soccer clubs.",
"output": "European(manchesterunited) ∧ SoccerClub(manchesterunited) ∧ European(manchestercity) ∧ SoccerClub(manchestercity)"
},
{
"input": "Translate into first-order logic: Manchester United is eligible to attend UEL next season.",
"output": "Attend(manchesterunited, uel)"
},
{
"input": "Translate into first-order logic: Manchester City is eligible to attend UCL next season.",
"output": "Attend(manchestercity, ucl)"
},
{
"input": "Translate into first-order logic: If a person coach a football club, the person is a football coach.",
"output": "∀x ∀y (Coach(x, y) ∧ IsFootballClub(y) → IsFootballCoach(x))"
},
{
"input": "Translate into first-order logic: If a person has a position in a club for a position in a year, and the club is in NFL in the same year, the person plays in NFL.",
"output": "∀x ∀y ∀z (PlayFor(x, y) ∧ NFLTeamYear(y, z) ∧ InTeam(x, z) → PlayInNFL(x))"
},
{
"input": "Translate into first-order logic: Minnesota Vikings is a football club.",
"output": "IsFootballClub(minnesota_Vikings)"
},
{
"input": "Translate into first-order logic: Dennis Green coached Minnesota Vikings.",
"output": "Coach(dennis_Green, minnesota_Vikings)"
},
{
"input": "Translate into first-order logic: Cris Carter had 13 touchdown receptions.",
"output": "TouchDownReceptionTime(cris_Carter, t13)"
},
{
"input": "Translate into first-order logic: Minnesota Vikings was in the National Football League in 1997.",
"output": "NFLTeamYear(minnesota_Vikings, y1997)"
},
{
"input": "Translate into first-order logic: John Randle was Minnesota Vikings defensive tackle in 1997.",
"output": "Position(john_Randle, defensive_tackle) ∧ InTeam(john_Randle, y1997) ∧ PlayFor(john_Randle, minnesota_Vikings)"
},
{
"input": "Translate into first-order logic: If a person coach a football club, the person is a football coach.",
"output": "∀x ∀y (Coach(x, y) ∧ IsFootballClub(y) → IsFootballCoach(x))"
},
{
"input": "Translate into first-order logic: If a person has a position in a club for a position in a year, and the club is in NFL in the same year, the person plays in NFL.",
"output": "∀x ∀y ∀z (PlayFor(x, y) ∧ NFLTeamYear(y, z) ∧ InTeam(x, z) → PlayInNFL(x))"
},
{
"input": "Translate into first-order logic: Minnesota Vikings is a football club.",
"output": "IsFootballClub(minnesota_Vikings)"
},
{
"input": "Translate into first-order logic: Dennis Green coached Minnesota Vikings.",
"output": "Coach(dennis_Green, minnesota_Vikings)"
},
{
"input": "Translate into first-order logic: Cris Carter had 13 touchdown receptions.",
"output": "TouchDownReceptionTime(cris_Carter, t13)"
},
{
"input": "Translate into first-order logic: Minnesota Vikings was in the National Football League in 1997.",
"output": "NFLTeamYear(minnesota_Vikings, y1997)"
},
{
"input": "Translate into first-order logic: John Randle was Minnesota Vikings defensive tackle in 1997.",
"output": "Position(john_Randle, defensive_tackle) ∧ InTeam(john_Randle, y1997) ∧ PlayFor(john_Randle, minnesota_Vikings)"
},
{
"input": "Translate into first-order logic: If a person coach a football club, the person is a football coach.",
"output": "∀x ∀y (Coach(x, y) ∧ IsFootballClub(y) → IsFootballCoach(x))"
},
{
"input": "Translate into first-order logic: If a person has a position in a club for a position in a year, and the club is in NFL in the same year, the person plays in NFL.",
"output": "∀x ∀y ∀z (PlayFor(x, y) ∧ NFLTeamYear(y, z) ∧ InTeam(x, z) → PlayInNFL(x))"
},
{
"input": "Translate into first-order logic: Minnesota Vikings is a football club.",
"output": "IsFootballClub(minnesota_Vikings)"
},
{
"input": "Translate into first-order logic: Dennis Green coached Minnesota Vikings.",
"output": "Coach(dennis_Green, minnesota_Vikings)"
},
{
"input": "Translate into first-order logic: Cris Carter had 13 touchdown receptions.",
"output": "TouchDownReceptionTime(cris_Carter, t13)"
},
{
"input": "Translate into first-order logic: Minnesota Vikings was in the National Football League in 1997.",
"output": "NFLTeamYear(minnesota_Vikings, y1997)"
},
{
"input": "Translate into first-order logic: John Randle was Minnesota Vikings defensive tackle in 1997.",
"output": "Position(john_Randle, defensive_tackle) ∧ InTeam(john_Randle, y1997) ∧ PlayFor(john_Randle, minnesota_Vikings)"
},
{
"input": "Translate into first-order logic: All cats are cute.",
"output": "∀x (Cat(x) → Cute(x))"
},
{
"input": "Translate into first-order logic: Ghosts do not exist.",
"output": "∀x (¬Ghost(x))"
},
{
"input": "Translate into first-order logic: An animal is either a cat or a dog.",
"output": "∀x (Cat(x) ∨ Dog(x))"
},
{
"input": "Translate into first-order logic: Nothing that barks is lovely.",
"output": "∀x (Bark(x) → ¬Lovely(x))"
},
{
"input": "Translate into first-order logic: If something is a dog, then it barks.",
"output": "∀x (Dog(x) → Bark(x))"
},
{
"input": "Translate into first-order logic: Grace is either a cat and a dog, or neither a cat nor a dog.",
"output": "(Cat(grace) ∧ Dog(grace)) ⊕ (¬Cat(grace) ∧ ¬Dog(grace))"
},
{
"input": "Translate into first-order logic: All cats are cute.",
"output": "∀x (Cat(x) → Cute(x))"
},
{
"input": "Translate into first-order logic: Ghosts do not exist.",
"output": "∀x (¬Ghost(x))"
},
{
"input": "Translate into first-order logic: An animal is either a cat or a dog.",
"output": "∀x (Cat(x) ∨ Dog(x))"
},
{
"input": "Translate into first-order logic: Nothing that barks is lovely.",
"output": "∀x (Bark(x) → ¬Lovely(x))"
},
{
"input": "Translate into first-order logic: If something is a dog, then it barks.",
"output": "∀x (Dog(x) → Bark(x))"
},
{
"input": "Translate into first-order logic: Grace is either a cat and a dog, or neither a cat nor a dog.",
"output": "(Cat(grace) ∧ Dog(grace)) ⊕ (¬Cat(grace) ∧ ¬Dog(grace))"
},
{
"input": "Translate into first-order logic: All cats are cute.",
"output": "∀x (Cat(x) → Cute(x))"
},
{
"input": "Translate into first-order logic: Ghosts do not exist.",
"output": "∀x (¬Ghost(x))"
},
{
"input": "Translate into first-order logic: An animal is either a cat or a dog.",
"output": "∀x (Cat(x) ∨ Dog(x))"
},
{
"input": "Translate into first-order logic: Nothing that barks is lovely.",
"output": "∀x (Bark(x) → ¬Lovely(x))"
},
{
"input": "Translate into first-order logic: If something is a dog, then it barks.",
"output": "∀x (Dog(x) → Bark(x))"
},
{
"input": "Translate into first-order logic: Grace is either a cat and a dog, or neither a cat nor a dog.",
"output": "(Cat(grace) ∧ Dog(grace)) ⊕ (¬Cat(grace) ∧ ¬Dog(grace))"
},
{
"input": "Translate into first-order logic: Shafaq-Asiman is a large complex of offshore geological structures in the Caspian Sea.",
"output": "LargeComplex(shafaq-asiman) ∧ LargeComplex(shafaq-asiman) ∧ Offshore(shafaq-asiman) ∧ GeologicalStructures(shafaq-asiman) ∧ In(shafaq-asiman, caspiansea)"
},
{
"input": "Translate into first-order logic: Baku is northwest of Shafaq-Asiman.",
"output": "NorthwestOf(baku, shafaq-asiman)"
},
{
"input": "Translate into first-order logic: If place A is northwest of place B, then place B is southeast of place A.",
"output": "∀x ∀y (NorthwestOf(x, y) → SoutheastOf(y, x))"
},
{
"input": "Translate into first-order logic: Shafaq-Asiman is a large complex of offshore geological structures in the Caspian Sea.",
"output": "LargeComplex(shafaq-asiman) ∧ LargeComplex(shafaq-asiman) ∧ Offshore(shafaq-asiman) ∧ GeologicalStructures(shafaq-asiman) ∧ In(shafaq-asiman, caspiansea)"
},
{
"input": "Translate into first-order logic: Baku is northwest of Shafaq-Asiman.",
"output": "NorthwestOf(baku, shafaq-asiman)"
},
{
"input": "Translate into first-order logic: If place A is northwest of place B, then place B is southeast of place A.",
"output": "∀x ∀y (NorthwestOf(x, y) → SoutheastOf(y, x))"
},
{
"input": "Translate into first-order logic: Shafaq-Asiman is a large complex of offshore geological structures in the Caspian Sea.",
"output": "LargeComplex(shafaq-asiman) ∧ LargeComplex(shafaq-asiman) ∧ Offshore(shafaq-asiman) ∧ GeologicalStructures(shafaq-asiman) ∧ In(shafaq-asiman, caspiansea)"
},
{
"input": "Translate into first-order logic: Baku is northwest of Shafaq-Asiman.",
"output": "NorthwestOf(baku, shafaq-asiman)"
},
{
"input": "Translate into first-order logic: If place A is northwest of place B, then place B is southeast of place A.",
"output": "∀x ∀y (NorthwestOf(x, y) → SoutheastOf(y, x))"
},
{
"input": "Translate into first-order logic: Herodicus was a Greek physician, dietician, sophist, and gymnastic-master.",
"output": "Greek(herodicus) ∧ Physician(herodicus) ∧ Dietician(herodicus) ∧ Sophist(herodicus) ∧ GymnasticMaster(herodicus)"
},
{
"input": "Translate into first-order logic: Herodicus was born in the city of Selymbria.",
"output": "Born(herodicus, selymbia) ∧ City(selymbia)"
},
{
"input": "Translate into first-order logic: Selymbria is a colony of the city-state Megara.",
"output": "Colony(selymbia, megara) ∧ CityState(megara)"
},
{
"input": "Translate into first-order logic: One of the tutors of Hippocrates was Herodicus.",
"output": "Tutored(herodicus, hippocrates)"
},
{
"input": "Translate into first-order logic: Massages were recommended by Herodicus.",
"output": "Recommended(herodicus, massages)"
},
{
"input": "Translate into first-order logic: Some of theories of Herodicus are considered to be the foundation of sports medicine.",
"output": "∃x (Theory(x) ∧ From(x, herodicus) ∧ FoundationOf(x, sportsMedicine))"
},
{
"input": "Translate into first-order logic: Herodicus was a Greek physician, dietician, sophist, and gymnastic-master.",
"output": "Greek(herodicus) ∧ Physician(herodicus) ∧ Dietician(herodicus) ∧ Sophist(herodicus) ∧ GymnasticMaster(herodicus)"
},
{
"input": "Translate into first-order logic: Herodicus was born in the city of Selymbria.",
"output": "Born(herodicus, selymbia) ∧ City(selymbia)"
},
{
"input": "Translate into first-order logic: Selymbria is a colony of the city-state Megara.",
"output": "Colony(selymbia, megara) ∧ CityState(megara)"
},
{
"input": "Translate into first-order logic: One of the tutors of Hippocrates was Herodicus.",
"output": "Tutored(herodicus, hippocrates)"
},
{
"input": "Translate into first-order logic: Massages were recommended by Herodicus.",
"output": "Recommended(herodicus, massages)"
},
{
"input": "Translate into first-order logic: Some of theories of Herodicus are considered to be the foundation of sports medicine.",
"output": "∃x (Theory(x) ∧ From(x, herodicus) ∧ FoundationOf(x, sportsMedicine))"
},
{
"input": "Translate into first-order logic: Herodicus was a Greek physician, dietician, sophist, and gymnastic-master.",
"output": "Greek(herodicus) ∧ Physician(herodicus) ∧ Dietician(herodicus) ∧ Sophist(herodicus) ∧ GymnasticMaster(herodicus)"
},
{
"input": "Translate into first-order logic: Herodicus was born in the city of Selymbria.",
"output": "Born(herodicus, selymbia) ∧ City(selymbia)"
},
{
"input": "Translate into first-order logic: Selymbria is a colony of the city-state Megara.",
"output": "Colony(selymbia, megara) ∧ CityState(megara)"
},
{
"input": "Translate into first-order logic: One of the tutors of Hippocrates was Herodicus.",
"output": "Tutored(herodicus, hippocrates)"
},
{
"input": "Translate into first-order logic: Massages were recommended by Herodicus.",
"output": "Recommended(herodicus, massages)"
},
{
"input": "Translate into first-order logic: Some of theories of Herodicus are considered to be the foundation of sports medicine.",
"output": "∃x (Theory(x) ∧ From(x, herodicus) ∧ FoundationOf(x, sportsMedicine))"
},
{
"input": "Translate into first-order logic: Herodicus was a Greek physician, dietician, sophist, and gymnastic-master.",
"output": "Greek(herodicus) ∧ Physician(herodicus) ∧ Dietician(herodicus) ∧ Sophist(herodicus) ∧ GymnasticMaster(herodicus)"
},
{
"input": "Translate into first-order logic: Herodicus was born in the city of Selymbria.",
"output": "Born(herodicus, selymbia) ∧ City(selymbia)"
},
{
"input": "Translate into first-order logic: Selymbria is a colony of the city-state Megara.",
"output": "Colony(selymbia, megara) ∧ CityState(megara)"
},
{
"input": "Translate into first-order logic: One of the tutors of Hippocrates was Herodicus.",
"output": "Tutored(herodicus, hippocrates)"
},
{
"input": "Translate into first-order logic: Massages were recommended by Herodicus.",
"output": "Recommended(herodicus, massages)"
},
{
"input": "Translate into first-order logic: Some of theories of Herodicus are considered to be the foundation of sports medicine.",
"output": "∃x (Theory(x) ∧ From(x, herodicus) ∧ FoundationOf(x, sportsMedicine))"
},
{
"input": "Translate into first-order logic: Herodicus was a Greek physician, dietician, sophist, and gymnastic-master.",
"output": "Greek(herodicus) ∧ Physician(herodicus) ∧ Dietician(herodicus) ∧ Sophist(herodicus) ∧ GymnasticMaster(herodicus)"
},
{
"input": "Translate into first-order logic: Herodicus was born in the city of Selymbria.",
"output": "Born(herodicus, selymbia) ∧ City(selymbia)"
},
{
"input": "Translate into first-order logic: Selymbria is a colony of the city-state Megara.",
"output": "Colony(selymbia, megara) ∧ CityState(megara)"
},
{
"input": "Translate into first-order logic: One of the tutors of Hippocrates was Herodicus.",
"output": "Tutored(herodicus, hippocrates)"
},
{
"input": "Translate into first-order logic: Massages were recommended by Herodicus.",
"output": "Recommended(herodicus, massages)"
},
{
"input": "Translate into first-order logic: Some of theories of Herodicus are considered to be the foundation of sports medicine.",
"output": "∃x (Theory(x) ∧ From(x, herodicus) ∧ FoundationOf(x, sportsMedicine))"
},
{
"input": "Translate into first-order logic: No kid loves the Opera.",
"output": "∀x (Kid(x) → ¬OperaLover(x))"
},
{
"input": "Translate into first-order logic: All adults love the Opera.",
"output": "∀x (Adult(x) → OperaLover(x))"
},
{
"input": "Translate into first-order logic: If someone is a scientist, then they are an adult.",
"output": "∀x (Scientist(x) → Adult(x))"
},
{
"input": "Translate into first-order logic: Some students are kids.",
"output": "∃x (Student(x) ∧ Kid(x))"
},
{
"input": "Translate into first-order logic: Billy is a kid.",
"output": "Kid(billy)"
},
{
"input": "Translate into first-order logic: No kid loves the Opera.",
"output": "∀x (Kid(x) → ¬OperaLover(x))"
},
{
"input": "Translate into first-order logic: All adults love the Opera.",
"output": "∀x (Adult(x) → OperaLover(x))"
},
{
"input": "Translate into first-order logic: If someone is a scientist, then they are an adult.",
"output": "∀x (Scientist(x) → Adult(x))"
},
{
"input": "Translate into first-order logic: Some students are kids.",
"output": "∃x (Student(x) ∧ Kid(x))"
},
{
"input": "Translate into first-order logic: Billy is a kid.",
"output": "Kid(billy)"
},
{
"input": "Translate into first-order logic: No kid loves the Opera.",
"output": "∀x (Kid(x) → ¬OperaLover(x))"
},
{
"input": "Translate into first-order logic: All adults love the Opera.",
"output": "∀x (Adult(x) → OperaLover(x))"
},
{
"input": "Translate into first-order logic: If someone is a scientist, then they are an adult.",
"output": "∀x (Scientist(x) → Adult(x))"
},
{
"input": "Translate into first-order logic: Some students are kids.",
"output": "∃x (Student(x) ∧ Kid(x))"
},
{
"input": "Translate into first-order logic: Billy is a kid.",
"output": "Kid(billy)"
},
{
"input": "Translate into first-order logic: Brian Winter is a Scottish football referee.",
"output": "Scottish(brianwinter) ∧ FootballReferee(brianwinter)"
},
{
"input": "Translate into first-order logic: After being injured, Brian Winter retired in 2012.",
"output": "Injured(brianwinter) ∧ Retired(brianwinter)"
},
{
"input": "Translate into first-order logic: Brian Winter was appointed as a referee observer after his retirement.",
"output": "RefereeObserver(brianwinter)"
},
{
"input": "Translate into first-order logic: Some football referees become referee observers.",
"output": "∃x (FootballReferee(x) ∧ RefereeObserver(x))"
},
{
"input": "Translate into first-order logic: The son of Brian Winter, Andy Winter, is a football player who plays for Hamilton Academical.",
"output": "Son(andywinter, brianwinter) ∧ FootballPlayer(andywinter) ∧ PlaysFor(andywinter, hamiltonacademical)"
},
{
"input": "Translate into first-order logic: Brian Winter is a Scottish football referee.",
"output": "Scottish(brianwinter) ∧ FootballReferee(brianwinter)"
},
{
"input": "Translate into first-order logic: After being injured, Brian Winter retired in 2012.",
"output": "Injured(brianwinter) ∧ Retired(brianwinter)"
},
{
"input": "Translate into first-order logic: Brian Winter was appointed as a referee observer after his retirement.",
"output": "RefereeObserver(brianwinter)"
},
{
"input": "Translate into first-order logic: Some football referees become referee observers.",
"output": "∃x (FootballReferee(x) ∧ RefereeObserver(x))"
},
{
"input": "Translate into first-order logic: The son of Brian Winter, Andy Winter, is a football player who plays for Hamilton Academical.",
"output": "Son(andywinter, brianwinter) ∧ FootballPlayer(andywinter) ∧ PlaysFor(andywinter, hamiltonacademical)"
},
{
"input": "Translate into first-order logic: Brian Winter is a Scottish football referee.",
"output": "Scottish(brianwinter) ∧ FootballReferee(brianwinter)"
},
{
"input": "Translate into first-order logic: After being injured, Brian Winter retired in 2012.",
"output": "Injured(brianwinter) ∧ Retired(brianwinter)"
},
{
"input": "Translate into first-order logic: Brian Winter was appointed as a referee observer after his retirement.",
"output": "RefereeObserver(brianwinter)"
},
{
"input": "Translate into first-order logic: Some football referees become referee observers.",
"output": "∃x (FootballReferee(x) ∧ RefereeObserver(x))"
},
{
"input": "Translate into first-order logic: The son of Brian Winter, Andy Winter, is a football player who plays for Hamilton Academical.",
"output": "Son(andywinter, brianwinter) ∧ FootballPlayer(andywinter) ∧ PlaysFor(andywinter, hamiltonacademical)"
},
{
"input": "Translate into first-order logic: Brian Winter is a Scottish football referee.",
"output": "Scottish(brianwinter) ∧ FootballReferee(brianwinter)"
},
{
"input": "Translate into first-order logic: After being injured, Brian Winter retired in 2012.",
"output": "Injured(brianwinter) ∧ Retired(brianwinter)"
},
{
"input": "Translate into first-order logic: Brian Winter was appointed as a referee observer after his retirement.",
"output": "RefereeObserver(brianwinter)"
},
{
"input": "Translate into first-order logic: Some football referees become referee observers.",
"output": "∃x (FootballReferee(x) ∧ RefereeObserver(x))"
},
{
"input": "Translate into first-order logic: The son of Brian Winter, Andy Winter, is a football player who plays for Hamilton Academical.",
"output": "Son(andywinter, brianwinter) ∧ FootballPlayer(andywinter) ∧ PlaysFor(andywinter, hamiltonacademical)"
},
{
"input": "Translate into first-order logic: People are either interested in puzzles or bad at chess.",
"output": "∀x (Puzzles(x) ∨ BadChess(x))"
},
{
"input": "Translate into first-order logic: If a person is bad at chess, then they don't play a lot of chess.",
"output": "∀x (BadChess(x) → ¬PlaysLots(x))"
},
{
"input": "Translate into first-order logic: A person is either a planner or a creative person.",
"output": "∀x (Plans(x) ∨ Creative(x))"
},
{
"input": "Translate into first-order logic: Erica is someone who plays a lot of chess.",
"output": "PlaysLots(erica)"
},
{
"input": "Translate into first-order logic: If Erica is neither bad at chess nor creative, then Erica is either someone who plans and is creative, or someone who neither plans nor is creative.",
"output": "¬(BadChess(erica) ∨ Creative(erica)) → (Plans(erica) ⊕ Creative(erica))"
},
{
"input": "Translate into first-order logic: People are either interested in puzzles or bad at chess.",
"output": "∀x (Puzzles(x) ∨ BadChess(x))"
},
{
"input": "Translate into first-order logic: If a person is bad at chess, then they don't play a lot of chess.",
"output": "∀x (BadChess(x) → ¬PlaysLots(x))"
},
{
"input": "Translate into first-order logic: A person is either a planner or a creative person.",
"output": "∀x (Plans(x) ∨ Creative(x))"
},
{
"input": "Translate into first-order logic: Erica is someone who plays a lot of chess.",
"output": "PlaysLots(erica)"
},
{
"input": "Translate into first-order logic: If Erica is neither bad at chess nor creative, then Erica is either someone who plans and is creative, or someone who neither plans nor is creative.",
"output": "¬(BadChess(erica) ∨ Creative(erica)) → (Plans(erica) ⊕ Creative(erica))"
},
{
"input": "Translate into first-order logic: People are either interested in puzzles or bad at chess.",
"output": "∀x (Puzzles(x) ∨ BadChess(x))"
},
{
"input": "Translate into first-order logic: If a person is bad at chess, then they don't play a lot of chess.",
"output": "∀x (BadChess(x) → ¬PlaysLots(x))"
},
{
"input": "Translate into first-order logic: A person is either a planner or a creative person.",
"output": "∀x (Plans(x) ∨ Creative(x))"
},
{
"input": "Translate into first-order logic: Erica is someone who plays a lot of chess.",
"output": "PlaysLots(erica)"
},
{
"input": "Translate into first-order logic: If Erica is neither bad at chess nor creative, then Erica is either someone who plans and is creative, or someone who neither plans nor is creative.",
"output": "¬(BadChess(erica) ∨ Creative(erica)) → (Plans(erica) ⊕ Creative(erica))"
},
{
"input": "Translate into first-order logic: People are either interested in puzzles or bad at chess.",
"output": "∀x (Puzzles(x) ∨ BadChess(x))"
},
{
"input": "Translate into first-order logic: If a person is bad at chess, then they don't play a lot of chess.",
"output": "∀x (BadChess(x) → ¬PlaysLots(x))"
},
{
"input": "Translate into first-order logic: A person is either a planner or a creative person.",
"output": "∀x (Plans(x) ∨ Creative(x))"
},
{
"input": "Translate into first-order logic: Erica is someone who plays a lot of chess.",
"output": "PlaysLots(erica)"
},
{
"input": "Translate into first-order logic: If Erica is neither bad at chess nor creative, then Erica is either someone who plans and is creative, or someone who neither plans nor is creative.",
"output": "¬(BadChess(erica) ∨ Creative(erica)) → (Plans(erica) ⊕ Creative(erica))"
},
{
"input": "Translate into first-order logic: People are either interested in puzzles or bad at chess.",
"output": "∀x (Puzzles(x) ∨ BadChess(x))"
},
{
"input": "Translate into first-order logic: If a person is bad at chess, then they don't play a lot of chess.",
"output": "∀x (BadChess(x) → ¬PlaysLots(x))"
},
{
"input": "Translate into first-order logic: A person is either a planner or a creative person.",
"output": "∀x (Plans(x) ∨ Creative(x))"
},
{
"input": "Translate into first-order logic: Erica is someone who plays a lot of chess.",
"output": "PlaysLots(erica)"
},
{
"input": "Translate into first-order logic: If Erica is neither bad at chess nor creative, then Erica is either someone who plans and is creative, or someone who neither plans nor is creative.",
"output": "¬(BadChess(erica) ∨ Creative(erica)) → (Plans(erica) ⊕ Creative(erica))"
},
{
"input": "Translate into first-order logic: People are either interested in puzzles or bad at chess.",
"output": "∀x (Puzzles(x) ∨ BadChess(x))"
},
{
"input": "Translate into first-order logic: If a person is bad at chess, then they don't play a lot of chess.",
"output": "∀x (BadChess(x) → ¬PlaysLots(x))"
},
{
"input": "Translate into first-order logic: A person is either a planner or a creative person.",
"output": "∀x (Plans(x) ∨ Creative(x))"
},
{
"input": "Translate into first-order logic: Erica is someone who plays a lot of chess.",
"output": "PlaysLots(erica)"
},
{
"input": "Translate into first-order logic: If Erica is neither bad at chess nor creative, then Erica is either someone who plans and is creative, or someone who neither plans nor is creative.",
"output": "¬(BadChess(erica) ∨ Creative(erica)) → (Plans(erica) ⊕ Creative(erica))"
},
{
"input": "Translate into first-order logic: People are either interested in puzzles or bad at chess.",
"output": "∀x (Puzzles(x) ∨ BadChess(x))"
},
{
"input": "Translate into first-order logic: If a person is bad at chess, then they don't play a lot of chess.",
"output": "∀x (BadChess(x) → ¬PlaysLots(x))"
},
{
"input": "Translate into first-order logic: A person is either a planner or a creative person.",
"output": "∀x (Plans(x) ∨ Creative(x))"
},
{
"input": "Translate into first-order logic: Erica is someone who plays a lot of chess.",
"output": "PlaysLots(erica)"
},
{
"input": "Translate into first-order logic: If Erica is neither bad at chess nor creative, then Erica is either someone who plans and is creative, or someone who neither plans nor is creative.",
"output": "¬(BadChess(erica) ∨ Creative(erica)) → (Plans(erica) ⊕ Creative(erica))"
},
{
"input": "Translate into first-order logic: People are either interested in puzzles or bad at chess.",
"output": "∀x (Puzzles(x) ∨ BadChess(x))"
},
{
"input": "Translate into first-order logic: If a person is bad at chess, then they don't play a lot of chess.",
"output": "∀x (BadChess(x) → ¬PlaysLots(x))"
},
{
"input": "Translate into first-order logic: A person is either a planner or a creative person.",
"output": "∀x (Plans(x) ∨ Creative(x))"
},
{
"input": "Translate into first-order logic: Erica is someone who plays a lot of chess.",
"output": "PlaysLots(erica)"
},
{
"input": "Translate into first-order logic: If Erica is neither bad at chess nor creative, then Erica is either someone who plans and is creative, or someone who neither plans nor is creative.",
"output": "¬(BadChess(erica) ∨ Creative(erica)) → (Plans(erica) ⊕ Creative(erica))"
},
{
"input": "Translate into first-order logic: People are either interested in puzzles or bad at chess.",
"output": "∀x (Puzzles(x) ∨ BadChess(x))"
},
{
"input": "Translate into first-order logic: If a person is bad at chess, then they don't play a lot of chess.",
"output": "∀x (BadChess(x) → ¬PlaysLots(x))"
},
{
"input": "Translate into first-order logic: A person is either a planner or a creative person.",
"output": "∀x (Plans(x) ∨ Creative(x))"
},
{
"input": "Translate into first-order logic: Erica is someone who plays a lot of chess.",
"output": "PlaysLots(erica)"
},
{
"input": "Translate into first-order logic: If Erica is neither bad at chess nor creative, then Erica is either someone who plans and is creative, or someone who neither plans nor is creative.",
"output": "¬(BadChess(erica) ∨ Creative(erica)) → (Plans(erica) ⊕ Creative(erica))"
},
{
"input": "Translate into first-order logic: People are either interested in puzzles or bad at chess.",
"output": "∀x (Puzzles(x) ∨ BadChess(x))"
},
{
"input": "Translate into first-order logic: If a person is bad at chess, then they don't play a lot of chess.",
"output": "∀x (BadChess(x) → ¬PlaysLots(x))"
},
{
"input": "Translate into first-order logic: A person is either a planner or a creative person.",
"output": "∀x (Plans(x) ∨ Creative(x))"
},
{
"input": "Translate into first-order logic: Erica is someone who plays a lot of chess.",
"output": "PlaysLots(erica)"
},
{
"input": "Translate into first-order logic: If Erica is neither bad at chess nor creative, then Erica is either someone who plans and is creative, or someone who neither plans nor is creative.",
"output": "¬(BadChess(erica) ∨ Creative(erica)) → (Plans(erica) ⊕ Creative(erica))"
},
{
"input": "Translate into first-order logic: Soccer players have a right foot and a left foot.",
"output": "∀x (SoccerPlayer(x) → HasLeftFoot(x) ∧ HasRightFoot(x))"
},
{
"input": "Translate into first-order logic: Top soccer players are soccer players who can use their both feet very efficiently.",
"output": "∀x (SoccerPlayer(x) ∧ Efficient(x, left) ∧ Efficient(x, right) → Top(x))"
},
{
"input": "Translate into first-order logic: If a soccer player can score many goals using left foot, then they can use that foot very efficiently.",
"output": "∀x (SoccerPlayer(x) ∧ ScoreManyGoals(x, left) → Efficient(x, left))"
},
{
"input": "Translate into first-order logic: If a soccer player can score many goals using right foot, then they can use that foot very efficiently.",
"output": "∀x (SoccerPlayer(x) ∧ ScoreManyGoals(x, right) → Efficient(x, right))"
},
{
"input": "Translate into first-order logic: Cristiano Ronaldo is a soccer player.",
"output": "SoccerPlayer(ronaldo)"
},
{
"input": "Translate into first-order logic: Cristiano Ronaldo can use his right foot very efficiently.",
"output": "Efficient(ronaldo, right)"
},
{
"input": "Translate into first-order logic: Cristiano Ronaldo have scored more than one hundred goals using his left foot.",
"output": "ScoreManyGoals(ronaldo, left)"
},
{
"input": "Translate into first-order logic: Soccer players have a right foot and a left foot.",
"output": "∀x (SoccerPlayer(x) → HasLeftFoot(x) ∧ HasRightFoot(x))"
},
{
"input": "Translate into first-order logic: Top soccer players are soccer players who can use their both feet very efficiently.",
"output": "∀x (SoccerPlayer(x) ∧ Efficient(x, left) ∧ Efficient(x, right) → Top(x))"
},
{
"input": "Translate into first-order logic: If a soccer player can score many goals using left foot, then they can use that foot very efficiently.",
"output": "∀x (SoccerPlayer(x) ∧ ScoreManyGoals(x, left) → Efficient(x, left))"
},
{
"input": "Translate into first-order logic: If a soccer player can score many goals using right foot, then they can use that foot very efficiently.",
"output": "∀x (SoccerPlayer(x) ∧ ScoreManyGoals(x, right) → Efficient(x, right))"
},
{
"input": "Translate into first-order logic: Cristiano Ronaldo is a soccer player.",
"output": "SoccerPlayer(ronaldo)"
},
{
"input": "Translate into first-order logic: Cristiano Ronaldo can use his right foot very efficiently.",
"output": "Efficient(ronaldo, right)"
},
{
"input": "Translate into first-order logic: Cristiano Ronaldo have scored more than one hundred goals using his left foot.",
"output": "ScoreManyGoals(ronaldo, left)"
},
{
"input": "Translate into first-order logic: The National Lobster Hatchery is a hatchery located in Padstow England.",
"output": "Hatchery(nationallobsterhatchery) ∧ LocatedIn(nationallobsterhatchery, padstowengland)"
},
{
"input": "Translate into first-order logic: The National Lobster Hatchery is open to visitors.",
"output": "OpenToVisitors(nationallobsterhatchery)"
},
{
"input": "Translate into first-order logic: A hatchery is either for profit, or for conservation.",
"output": "∀x (Hatchery(x) → ForConservation(x) ∨ ForProfit(x))"
},
{
"input": "Translate into first-order logic: If a hatchery is for conservation, it might release animals into the wild.",
"output": "∃x (Hatchery(x) ∧ ForConservation(x) ∧ ReleasesAnimalsToWild(x))"
},
{
"input": "Translate into first-order logic: The National Lobster Hatchery is not for profit.",
"output": "¬ForProfit(nationallobsterhatchery)"
},
{
"input": "Translate into first-order logic: The National Lobster Hatchery is a hatchery located in Padstow England.",
"output": "Hatchery(nationallobsterhatchery) ∧ LocatedIn(nationallobsterhatchery, padstowengland)"
},
{
"input": "Translate into first-order logic: The National Lobster Hatchery is open to visitors.",
"output": "OpenToVisitors(nationallobsterhatchery)"
},
{
"input": "Translate into first-order logic: A hatchery is either for profit, or for conservation.",
"output": "∀x (Hatchery(x) → ForConservation(x) ∨ ForProfit(x))"
},
{
"input": "Translate into first-order logic: If a hatchery is for conservation, it might release animals into the wild.",
"output": "∃x (Hatchery(x) ∧ ForConservation(x) ∧ ReleasesAnimalsToWild(x))"
},
{
"input": "Translate into first-order logic: The National Lobster Hatchery is not for profit.",
"output": "¬ForProfit(nationallobsterhatchery)"
},
{
"input": "Translate into first-order logic: The National Lobster Hatchery is a hatchery located in Padstow England.",
"output": "Hatchery(nationallobsterhatchery) ∧ LocatedIn(nationallobsterhatchery, padstowengland)"
},
{
"input": "Translate into first-order logic: The National Lobster Hatchery is open to visitors.",
"output": "OpenToVisitors(nationallobsterhatchery)"
},
{
"input": "Translate into first-order logic: A hatchery is either for profit, or for conservation.",
"output": "∀x (Hatchery(x) → ForConservation(x) ∨ ForProfit(x))"
},
{
"input": "Translate into first-order logic: If a hatchery is for conservation, it might release animals into the wild.",
"output": "∃x (Hatchery(x) ∧ ForConservation(x) ∧ ReleasesAnimalsToWild(x))"
},
{
"input": "Translate into first-order logic: The National Lobster Hatchery is not for profit.",
"output": "¬ForProfit(nationallobsterhatchery)"
},
{
"input": "Translate into first-order logic: Rhos Aelwyd F.C. is a Welsh football club.",
"output": "∀x (Rhosaelwydfc(x) → FootballClub(x) ∧ BasedInPonciau(x) ∧ Welsh(x))"
},
{
"input": "Translate into first-order logic: Rhos Aelwyd F.C. is the only club based in Ponciau.",
"output": "∀x (BasedInPonciau(x) ↔ Rhosaelwydfc(x))"
},
{
"input": "Translate into first-order logic: The Premier Division was won in 2005–06 by a team from Ponciau.",
"output": "∃x (BasedInPonciau(x) ∧ WonPremierDivisionDuring(x, y2005))"
},
{
"input": "Translate into first-order logic: The winner of the Premier Division in 2009–10 was promoted back to the Cymru Alliance.",
"output": "∀x (WonPremierDivisionDuring(x, y2009) → Promoted(x))"
},
{
"input": "Translate into first-order logic: The Premier Division in 2009–10 was won by the same team that won in 2005-06.",
"output": "∀x (WonPremierDivisionDuring(x, y2009) ↔ WonPremierDivisionDuring(x, y2005))"
},
{
"input": "Translate into first-order logic: Rhos Aelwyd F.C. is a Welsh football club.",
"output": "∀x (Rhosaelwydfc(x) → FootballClub(x) ∧ BasedInPonciau(x) ∧ Welsh(x))"
},
{
"input": "Translate into first-order logic: Rhos Aelwyd F.C. is the only club based in Ponciau.",
"output": "∀x (BasedInPonciau(x) ↔ Rhosaelwydfc(x))"
},
{
"input": "Translate into first-order logic: The Premier Division was won in 2005–06 by a team from Ponciau.",
"output": "∃x (BasedInPonciau(x) ∧ WonPremierDivisionDuring(x, y2005))"
},
{
"input": "Translate into first-order logic: The winner of the Premier Division in 2009–10 was promoted back to the Cymru Alliance.",
"output": "∀x (WonPremierDivisionDuring(x, y2009) → Promoted(x))"
},
{
"input": "Translate into first-order logic: The Premier Division in 2009–10 was won by the same team that won in 2005-06.",
"output": "∀x (WonPremierDivisionDuring(x, y2009) ↔ WonPremierDivisionDuring(x, y2005))"
},
{
"input": "Translate into first-order logic: All OS are software.",
"output": "∀x (OS(x) → Software(x))"
},
{
"input": "Translate into first-order logic: All Mac are OS.",
"output": "∀x (Mac(x) → OS(x))"
},
{
"input": "Translate into first-order logic: An OS is either Mac or Windows.",
"output": "∀x (Mac(x) ∨ Windows(x))"
},
{
"input": "Translate into first-order logic: All Windows are convenient.",
"output": "∀x (Windows(x) → Convenient(x))"
},
{
"input": "Translate into first-order logic: All software has code.",
"output": "∀x (Software(x) → Code(x))"
},
{
"input": "Translate into first-order logic: If something is convenient, then it is popular.",
"output": "∀x (Convenient(x) → Popular(x))"
},
{
"input": "Translate into first-order logic: Burger is a piece of code and a Mac.",
"output": "Code(burger) ∧ Mac(burger))"
},
{
"input": "Translate into first-order logic: PyTorch is either Windows and software, or neither Windows nor software.",
"output": "(Windows(pytorch) ∧ Software(pytorch)) ⊕ (¬Windows(pytorch) ∧ ¬Software(pytorch))"
},
{
"input": "Translate into first-order logic: All OS are software.",
"output": "∀x (OS(x) → Software(x))"
},
{
"input": "Translate into first-order logic: All Mac are OS.",
"output": "∀x (Mac(x) → OS(x))"
},
{
"input": "Translate into first-order logic: An OS is either Mac or Windows.",
"output": "∀x (Mac(x) ∨ Windows(x))"
},
{
"input": "Translate into first-order logic: All Windows are convenient.",
"output": "∀x (Windows(x) → Convenient(x))"
},
{
"input": "Translate into first-order logic: All software has code.",
"output": "∀x (Software(x) → Code(x))"
},
{
"input": "Translate into first-order logic: If something is convenient, then it is popular.",
"output": "∀x (Convenient(x) → Popular(x))"
},
{
"input": "Translate into first-order logic: Burger is a piece of code and a Mac.",
"output": "Code(burger) ∧ Mac(burger))"
},
{
"input": "Translate into first-order logic: PyTorch is either Windows and software, or neither Windows nor software.",
"output": "(Windows(pytorch) ∧ Software(pytorch)) ⊕ (¬Windows(pytorch) ∧ ¬Software(pytorch))"
},
{
"input": "Translate into first-order logic: All OS are software.",
"output": "∀x (OS(x) → Software(x))"
},
{
"input": "Translate into first-order logic: All Mac are OS.",
"output": "∀x (Mac(x) → OS(x))"
},
{
"input": "Translate into first-order logic: An OS is either Mac or Windows.",
"output": "∀x (Mac(x) ∨ Windows(x))"
},
{
"input": "Translate into first-order logic: All Windows are convenient.",
"output": "∀x (Windows(x) → Convenient(x))"
},
{
"input": "Translate into first-order logic: All software has code.",
"output": "∀x (Software(x) → Code(x))"
},
{
"input": "Translate into first-order logic: If something is convenient, then it is popular.",
"output": "∀x (Convenient(x) → Popular(x))"
},
{
"input": "Translate into first-order logic: Burger is a piece of code and a Mac.",
"output": "Code(burger) ∧ Mac(burger))"
},
{
"input": "Translate into first-order logic: PyTorch is either Windows and software, or neither Windows nor software.",
"output": "(Windows(pytorch) ∧ Software(pytorch)) ⊕ (¬Windows(pytorch) ∧ ¬Software(pytorch))"
},
{
"input": "Translate into first-order logic: All OS are software.",
"output": "∀x (OS(x) → Software(x))"
},
{
"input": "Translate into first-order logic: All Mac are OS.",
"output": "∀x (Mac(x) → OS(x))"
},
{
"input": "Translate into first-order logic: An OS is either Mac or Windows.",
"output": "∀x (Mac(x) ∨ Windows(x))"
},
{
"input": "Translate into first-order logic: All Windows are convenient.",
"output": "∀x (Windows(x) → Convenient(x))"
},
{
"input": "Translate into first-order logic: All software has code.",
"output": "∀x (Software(x) → Code(x))"
},
{
"input": "Translate into first-order logic: If something is convenient, then it is popular.",
"output": "∀x (Convenient(x) → Popular(x))"
},
{
"input": "Translate into first-order logic: Burger is a piece of code and a Mac.",
"output": "Code(burger) ∧ Mac(burger))"
},
{
"input": "Translate into first-order logic: PyTorch is either Windows and software, or neither Windows nor software.",
"output": "(Windows(pytorch) ∧ Software(pytorch)) ⊕ (¬Windows(pytorch) ∧ ¬Software(pytorch))"
},
{
"input": "Translate into first-order logic: Roads are made of either concrete or asphalt.",
"output": "∀x (Road(x) → (MadeOfConcrete(x) ∨ MadeOfAsphalt(x))"
},
{
"input": "Translate into first-order logic: Roads made of concrete last longer than roads made with asphalt.",
"output": "∀x ∀y (Road(x) ∧ MadeOfConcrete(x) ∧ Road(y) ∧ MadeOfAsphalt(y) → LastLonger(x, y))"
},
{
"input": "Translate into first-order logic: Roads made of asphalt are smoother than roads made of concrete.",
"output": "∀x ∀y (Road(x) ∧ MadeOfAsphalt(x) ∧ Road(y) ∧ MadeOfConcrete(y) → Smoother(x, y))"
},
{
"input": "Translate into first-order logic: Everyone prefers the smoother of two roads.",
"output": "∀x ∀y ∀z (Road(x) ∧ Road(y) ∧ Smoother(x, y) → Prefers(z, x))"
},
{
"input": "Translate into first-order logic: Road one is made of concrete and Road two is made of asphalt.",
"output": "Road(one) ∧ MadeOfConcrete(one) ∧ Road(two) ∧ MadeOfAsphalt(two)"
},
{
"input": "Translate into first-order logic: Roads are made of either concrete or asphalt.",
"output": "∀x (Road(x) → (MadeOfConcrete(x) ∨ MadeOfAsphalt(x))"
},
{
"input": "Translate into first-order logic: Roads made of concrete last longer than roads made with asphalt.",
"output": "∀x ∀y (Road(x) ∧ MadeOfConcrete(x) ∧ Road(y) ∧ MadeOfAsphalt(y) → LastLonger(x, y))"
},
{
"input": "Translate into first-order logic: Roads made of asphalt are smoother than roads made of concrete.",
"output": "∀x ∀y (Road(x) ∧ MadeOfAsphalt(x) ∧ Road(y) ∧ MadeOfConcrete(y) → Smoother(x, y))"
},
{
"input": "Translate into first-order logic: Everyone prefers the smoother of two roads.",
"output": "∀x ∀y ∀z (Road(x) ∧ Road(y) ∧ Smoother(x, y) → Prefers(z, x))"
},
{
"input": "Translate into first-order logic: Road one is made of concrete and Road two is made of asphalt.",
"output": "Road(one) ∧ MadeOfConcrete(one) ∧ Road(two) ∧ MadeOfAsphalt(two)"
},
{
"input": "Translate into first-order logic: Roads are made of either concrete or asphalt.",
"output": "∀x (Road(x) → (MadeOfConcrete(x) ∨ MadeOfAsphalt(x))"
},
{
"input": "Translate into first-order logic: Roads made of concrete last longer than roads made with asphalt.",
"output": "∀x ∀y (Road(x) ∧ MadeOfConcrete(x) ∧ Road(y) ∧ MadeOfAsphalt(y) → LastLonger(x, y))"
},
{
"input": "Translate into first-order logic: Roads made of asphalt are smoother than roads made of concrete.",
"output": "∀x ∀y (Road(x) ∧ MadeOfAsphalt(x) ∧ Road(y) ∧ MadeOfConcrete(y) → Smoother(x, y))"
},
{
"input": "Translate into first-order logic: Everyone prefers the smoother of two roads.",
"output": "∀x ∀y ∀z (Road(x) ∧ Road(y) ∧ Smoother(x, y) → Prefers(z, x))"
},
{
"input": "Translate into first-order logic: Road one is made of concrete and Road two is made of asphalt.",
"output": "Road(one) ∧ MadeOfConcrete(one) ∧ Road(two) ∧ MadeOfAsphalt(two)"
},
{
"input": "Translate into first-order logic: Camp Davern is a traditional summer camp for boys and girls.",
"output": "TraditionalSummerCamp(campdavern) ∧ ForBoysAndGirls(campdavern)"
},
{
"input": "Translate into first-order logic: Camp Davern was established in the year 1946.",
"output": "EstablishedIn(campdavern, year1946)"
},
{
"input": "Translate into first-order logic: Camp Davern was operated by the YMCA until the year 2015.",
"output": "OperatedByYMCAUntil(campdavern, year2015)"
},
{
"input": "Translate into first-order logic: Camp Davern is one of Ontario's oldest summer camps.",
"output": "OneOf(campdavern, ontariosoldestsummercamps)"
},
{
"input": "Translate into first-order logic: Camp Davern is a traditional summer camp for boys and girls.",
"output": "TraditionalSummerCamp(campdavern) ∧ ForBoysAndGirls(campdavern)"
},
{
"input": "Translate into first-order logic: Camp Davern was established in the year 1946.",
"output": "EstablishedIn(campdavern, year1946)"
},
{
"input": "Translate into first-order logic: Camp Davern was operated by the YMCA until the year 2015.",
"output": "OperatedByYMCAUntil(campdavern, year2015)"
},
{
"input": "Translate into first-order logic: Camp Davern is one of Ontario's oldest summer camps.",
"output": "OneOf(campdavern, ontariosoldestsummercamps)"
},
{
"input": "Translate into first-order logic: Camp Davern is a traditional summer camp for boys and girls.",
"output": "TraditionalSummerCamp(campdavern) ∧ ForBoysAndGirls(campdavern)"
},
{
"input": "Translate into first-order logic: Camp Davern was established in the year 1946.",
"output": "EstablishedIn(campdavern, year1946)"
},
{
"input": "Translate into first-order logic: Camp Davern was operated by the YMCA until the year 2015.",
"output": "OperatedByYMCAUntil(campdavern, year2015)"
},
{
"input": "Translate into first-order logic: Camp Davern is one of Ontario's oldest summer camps.",
"output": "OneOf(campdavern, ontariosoldestsummercamps)"
},
{
"input": "Translate into first-order logic: If people publish journals, then they do not work in the entertainment industry.",
"output": "∀x (PublishJournals(x) → ¬Entertainment(x))"
},
{
"input": "Translate into first-order logic: All people who are award-winning novelists publish journals.",
"output": "∀x (Novelist(x) → PublishJournals(x))"
},
{
"input": "Translate into first-order logic: People either work in the entertainment industry or are highly acclaimed in their profession.",
"output": "∀x (Entertainment(x) ∨ Acclaimed(x))"
},
{
"input": "Translate into first-order logic: If people are highly acclaimed in their profession, then they often hold tenured and high-ranking positions at their workplace.",
"output": "∀x (Acclaimed(x) → Tenured(x))"
},
{
"input": "Translate into first-order logic: If people are highly acclaimed in their profession, then they often receive glowing feedback and recommendations from their colleagues.",
"output": "∀x (Acclaimed(x) → Glowing(x))"
},
{
"input": "Translate into first-order logic: If Emily is either both highly acclaimed in her profession and often holds tenured and high-ranking positions at her workplace, or she is neither highly acclaimed in her profession nor often holds tenured and high-ranking positions at her workplace, then Emily is not highly acclaimed in her profession.",
"output": "(Acclaimed(emily) ∧ Tenured(emily)) ∨ (¬Acclaimed(emily) ∧ ¬Tenured(emily)) → ¬Acclaimed(emily)"
},
{
"input": "Translate into first-order logic: If people publish journals, then they do not work in the entertainment industry.",
"output": "∀x (PublishJournals(x) → ¬Entertainment(x))"
},
{
"input": "Translate into first-order logic: All people who are award-winning novelists publish journals.",
"output": "∀x (Novelist(x) → PublishJournals(x))"
},
{
"input": "Translate into first-order logic: People either work in the entertainment industry or are highly acclaimed in their profession.",
"output": "∀x (Entertainment(x) ∨ Acclaimed(x))"
},
{
"input": "Translate into first-order logic: If people are highly acclaimed in their profession, then they often hold tenured and high-ranking positions at their workplace.",
"output": "∀x (Acclaimed(x) → Tenured(x))"
},
{
"input": "Translate into first-order logic: If people are highly acclaimed in their profession, then they often receive glowing feedback and recommendations from their colleagues.",
"output": "∀x (Acclaimed(x) → Glowing(x))"
},
{
"input": "Translate into first-order logic: If Emily is either both highly acclaimed in her profession and often holds tenured and high-ranking positions at her workplace, or she is neither highly acclaimed in her profession nor often holds tenured and high-ranking positions at her workplace, then Emily is not highly acclaimed in her profession.",
"output": "(Acclaimed(emily) ∧ Tenured(emily)) ∨ (¬Acclaimed(emily) ∧ ¬Tenured(emily)) → ¬Acclaimed(emily)"
},
{
"input": "Translate into first-order logic: If people publish journals, then they do not work in the entertainment industry.",
"output": "∀x (PublishJournals(x) → ¬Entertainment(x))"
},
{
"input": "Translate into first-order logic: All people who are award-winning novelists publish journals.",
"output": "∀x (Novelist(x) → PublishJournals(x))"
},
{
"input": "Translate into first-order logic: People either work in the entertainment industry or are highly acclaimed in their profession.",
"output": "∀x (Entertainment(x) ∨ Acclaimed(x))"
},
{
"input": "Translate into first-order logic: If people are highly acclaimed in their profession, then they often hold tenured and high-ranking positions at their workplace.",
"output": "∀x (Acclaimed(x) → Tenured(x))"
},
{
"input": "Translate into first-order logic: If people are highly acclaimed in their profession, then they often receive glowing feedback and recommendations from their colleagues.",
"output": "∀x (Acclaimed(x) → Glowing(x))"
},
{
"input": "Translate into first-order logic: If Emily is either both highly acclaimed in her profession and often holds tenured and high-ranking positions at her workplace, or she is neither highly acclaimed in her profession nor often holds tenured and high-ranking positions at her workplace, then Emily is not highly acclaimed in her profession.",
"output": "(Acclaimed(emily) ∧ Tenured(emily)) ∨ (¬Acclaimed(emily) ∧ ¬Tenured(emily)) → ¬Acclaimed(emily)"
},
{
"input": "Translate into first-order logic: Thick as Thieves is a young adult fantasy novel, written by Megan Whalen Turner.",
"output": "YoungAdultFantasyNovel(thickastheives) ∧ WrittenBy(thickastheives, megan)"
},
{
"input": "Translate into first-order logic: Thick as Thieves was published by Greenwillow Books.",
"output": "PublishedBy(thickastheives, greenwillowbooks)"
},
{
"input": "Translate into first-order logic: If a book was published by a company, than the author of that book worked with the company that published the book.",
"output": "∀x ∀y ∀z (WrittenBy(x, y) ∧ PublishedBy(x, z) → WorkedWith(y, z))"
},
{
"input": "Translate into first-order logic: The fictional Mede Empire is where Thick as Thieves is set.",
"output": "Fictional(medeempire) ∧ SetIn(thickastheives, medeempire)"
},
{
"input": "Translate into first-order logic: The Mede Empire plots to swallow up some nearby countries.",
"output": "∃x (Country(x) Nearby(medeempire, x) ∧ PlotsToSwallowUp(medeempire, x))"
},
{
"input": "Translate into first-order logic: Attolia and Sounis are countries near the Mede Empire.",
"output": "Country(attolia) ∧ Nearby(medeempire, attolia) ∧ Country(sounis) ∧ Nearby(medeempire, sounis)"
},
{
"input": "Translate into first-order logic: Thick as Thieves was sold both as a hardcover and an e-book.",
"output": "SoldAs(thickastheives, hardcover) ∧ SoldAs(thickastheives, softcover)"
},
{
"input": "Translate into first-order logic: Thick as Thieves is a young adult fantasy novel, written by Megan Whalen Turner.",
"output": "YoungAdultFantasyNovel(thickastheives) ∧ WrittenBy(thickastheives, megan)"
},
{
"input": "Translate into first-order logic: Thick as Thieves was published by Greenwillow Books.",
"output": "PublishedBy(thickastheives, greenwillowbooks)"
},
{
"input": "Translate into first-order logic: If a book was published by a company, than the author of that book worked with the company that published the book.",
"output": "∀x ∀y ∀z (WrittenBy(x, y) ∧ PublishedBy(x, z) → WorkedWith(y, z))"
},
{
"input": "Translate into first-order logic: The fictional Mede Empire is where Thick as Thieves is set.",
"output": "Fictional(medeempire) ∧ SetIn(thickastheives, medeempire)"
},
{
"input": "Translate into first-order logic: The Mede Empire plots to swallow up some nearby countries.",
"output": "∃x (Country(x) Nearby(medeempire, x) ∧ PlotsToSwallowUp(medeempire, x))"
},
{
"input": "Translate into first-order logic: Attolia and Sounis are countries near the Mede Empire.",
"output": "Country(attolia) ∧ Nearby(medeempire, attolia) ∧ Country(sounis) ∧ Nearby(medeempire, sounis)"
},
{
"input": "Translate into first-order logic: Thick as Thieves was sold both as a hardcover and an e-book.",
"output": "SoldAs(thickastheives, hardcover) ∧ SoldAs(thickastheives, softcover)"
},
{
"input": "Translate into first-order logic: Thick as Thieves is a young adult fantasy novel, written by Megan Whalen Turner.",
"output": "YoungAdultFantasyNovel(thickastheives) ∧ WrittenBy(thickastheives, megan)"
},
{
"input": "Translate into first-order logic: Thick as Thieves was published by Greenwillow Books.",
"output": "PublishedBy(thickastheives, greenwillowbooks)"
},
{
"input": "Translate into first-order logic: If a book was published by a company, than the author of that book worked with the company that published the book.",
"output": "∀x ∀y ∀z (WrittenBy(x, y) ∧ PublishedBy(x, z) → WorkedWith(y, z))"
},
{
"input": "Translate into first-order logic: The fictional Mede Empire is where Thick as Thieves is set.",
"output": "Fictional(medeempire) ∧ SetIn(thickastheives, medeempire)"
},
{
"input": "Translate into first-order logic: The Mede Empire plots to swallow up some nearby countries.",
"output": "∃x (Country(x) Nearby(medeempire, x) ∧ PlotsToSwallowUp(medeempire, x))"
},
{
"input": "Translate into first-order logic: Attolia and Sounis are countries near the Mede Empire.",
"output": "Country(attolia) ∧ Nearby(medeempire, attolia) ∧ Country(sounis) ∧ Nearby(medeempire, sounis)"
},
{
"input": "Translate into first-order logic: Thick as Thieves was sold both as a hardcover and an e-book.",
"output": "SoldAs(thickastheives, hardcover) ∧ SoldAs(thickastheives, softcover)"
},
{
"input": "Translate into first-order logic: Thick as Thieves is a young adult fantasy novel, written by Megan Whalen Turner.",
"output": "YoungAdultFantasyNovel(thickastheives) ∧ WrittenBy(thickastheives, megan)"
},
{
"input": "Translate into first-order logic: Thick as Thieves was published by Greenwillow Books.",
"output": "PublishedBy(thickastheives, greenwillowbooks)"
},
{
"input": "Translate into first-order logic: If a book was published by a company, than the author of that book worked with the company that published the book.",
"output": "∀x ∀y ∀z (WrittenBy(x, y) ∧ PublishedBy(x, z) → WorkedWith(y, z))"
},
{
"input": "Translate into first-order logic: The fictional Mede Empire is where Thick as Thieves is set.",
"output": "Fictional(medeempire) ∧ SetIn(thickastheives, medeempire)"
},
{
"input": "Translate into first-order logic: The Mede Empire plots to swallow up some nearby countries.",
"output": "∃x (Country(x) Nearby(medeempire, x) ∧ PlotsToSwallowUp(medeempire, x))"
},
{
"input": "Translate into first-order logic: Attolia and Sounis are countries near the Mede Empire.",
"output": "Country(attolia) ∧ Nearby(medeempire, attolia) ∧ Country(sounis) ∧ Nearby(medeempire, sounis)"
},
{
"input": "Translate into first-order logic: Thick as Thieves was sold both as a hardcover and an e-book.",
"output": "SoldAs(thickastheives, hardcover) ∧ SoldAs(thickastheives, softcover)"
},
{
"input": "Translate into first-order logic: WeTab is a MeeGo-based tablet computer.",
"output": "∀x (WeTab(x) → MeeGoBased(x) ∧ TabletComputer(x))"
},
{
"input": "Translate into first-order logic: There is a WeTab product.",
"output": "∃x (WeTab(x))"
},
{
"input": "Translate into first-order logic: WeTab was announced by Neofonie.",
"output": "∀x (WeTab(x) → Announce(neofonie, x))"
},
{
"input": "Translate into first-order logic: Neofonie is a German producer.",
"output": "German(neofonie) ∧ Producer(neofonie)"
},
{
"input": "Translate into first-order logic: Germans speak English or German.",
"output": "∀x (German(x) → Speak(x, english) ∨ Speak(x, german))"
},
{
"input": "Translate into first-order logic: WeTab is a MeeGo-based tablet computer.",
"output": "∀x (WeTab(x) → MeeGoBased(x) ∧ TabletComputer(x))"
},
{
"input": "Translate into first-order logic: There is a WeTab product.",
"output": "∃x (WeTab(x))"
},
{
"input": "Translate into first-order logic: WeTab was announced by Neofonie.",
"output": "∀x (WeTab(x) → Announce(neofonie, x))"
},
{
"input": "Translate into first-order logic: Neofonie is a German producer.",
"output": "German(neofonie) ∧ Producer(neofonie)"
},
{
"input": "Translate into first-order logic: Germans speak English or German.",
"output": "∀x (German(x) → Speak(x, english) ∨ Speak(x, german))"
},
{
"input": "Translate into first-order logic: Some employees working in business analysis are good at math.",
"output": "∃x ( BusinessAnalysis(x) ∧ GoodAtMath(x))"
},
{
"input": "Translate into first-order logic: All employees working in business analysis are working in this company.",
"output": "∀x (BusinessAnalysis(x) → WorkInCompany(x))"
},
{
"input": "Translate into first-order logic: No employees working in this company are from China.",
"output": "∀x (WorkInCompany(x) → ¬FromChina(x))"
},
{
"input": "Translate into first-order logic: All employees working in software engineering are from China.",
"output": "∀x (SoftwareEngineering(x) → FromChina(x))"
},
{
"input": "Translate into first-order logic: James is working in software engineering.",
"output": "SoftwareEngineering(james)"
},
{
"input": "Translate into first-order logic: Some employees working in business analysis are good at math.",
"output": "∃x ( BusinessAnalysis(x) ∧ GoodAtMath(x))"
},
{
"input": "Translate into first-order logic: All employees working in business analysis are working in this company.",
"output": "∀x (BusinessAnalysis(x) → WorkInCompany(x))"
},
{
"input": "Translate into first-order logic: No employees working in this company are from China.",
"output": "∀x (WorkInCompany(x) → ¬FromChina(x))"
},
{
"input": "Translate into first-order logic: All employees working in software engineering are from China.",
"output": "∀x (SoftwareEngineering(x) → FromChina(x))"
},
{
"input": "Translate into first-order logic: James is working in software engineering.",
"output": "SoftwareEngineering(james)"
},
{
"input": "Translate into first-order logic: Some employees working in business analysis are good at math.",
"output": "∃x ( BusinessAnalysis(x) ∧ GoodAtMath(x))"
},
{
"input": "Translate into first-order logic: All employees working in business analysis are working in this company.",
"output": "∀x (BusinessAnalysis(x) → WorkInCompany(x))"
},
{
"input": "Translate into first-order logic: No employees working in this company are from China.",
"output": "∀x (WorkInCompany(x) → ¬FromChina(x))"
},
{
"input": "Translate into first-order logic: All employees working in software engineering are from China.",
"output": "∀x (SoftwareEngineering(x) → FromChina(x))"
},
{
"input": "Translate into first-order logic: James is working in software engineering.",
"output": "SoftwareEngineering(james)"
},
{
"input": "Translate into first-order logic: The party provides five kinds of fruits: strawberry, orange, blueberry, grape, and cherry.",
"output": "Party(strawberry) ∨ Party(orange) ∨ Party(blueberry) ∨ Party(grape) ∨ Party(cherry) "
},
{
"input": "Translate into first-order logic: All fruits are provided in the same weight at the beginning of the party.",
"output": "∀x (Party(x) → SameWeight(x))"
},
{
"input": "Translate into first-order logic: If the fruit had the lowest remaining weight at the end of the party, then it means it was the most popular fruit.",
"output": "∀x (LowestAmount(x) → MostPopular(x)) "
},
{
"input": "Translate into first-order logic: At the end of the party, strawberries had the lowest remaining weight.",
"output": "LowestAmount(strawberries)"
},
{
"input": "Translate into first-order logic: At the end of the party, the amount of leftover blueberries was lower than that of cherries.",
"output": "Lower(blueberry, cherry)"
},
{
"input": "Translate into first-order logic: Benjamin only ate oranges and grapes at the party.",
"output": "Eat(orange, benjamin) ∧ Eat(grape, benjamin) ∧ ¬Eat(blueberry, benjamin) ∧ ¬Eat(cherry, benjamin) ∧ ¬Eat(strawberry, benjamin)"
},
{
"input": "Translate into first-order logic: The party provides five kinds of fruits: strawberry, orange, blueberry, grape, and cherry.",
"output": "Party(strawberry) ∨ Party(orange) ∨ Party(blueberry) ∨ Party(grape) ∨ Party(cherry) "
},
{
"input": "Translate into first-order logic: All fruits are provided in the same weight at the beginning of the party.",
"output": "∀x (Party(x) → SameWeight(x))"
},
{
"input": "Translate into first-order logic: If the fruit had the lowest remaining weight at the end of the party, then it means it was the most popular fruit.",
"output": "∀x (LowestAmount(x) → MostPopular(x)) "
},
{
"input": "Translate into first-order logic: At the end of the party, strawberries had the lowest remaining weight.",
"output": "LowestAmount(strawberries)"
},
{
"input": "Translate into first-order logic: At the end of the party, the amount of leftover blueberries was lower than that of cherries.",
"output": "Lower(blueberry, cherry)"
},
{
"input": "Translate into first-order logic: Benjamin only ate oranges and grapes at the party.",
"output": "Eat(orange, benjamin) ∧ Eat(grape, benjamin) ∧ ¬Eat(blueberry, benjamin) ∧ ¬Eat(cherry, benjamin) ∧ ¬Eat(strawberry, benjamin)"
},
{
"input": "Translate into first-order logic: The party provides five kinds of fruits: strawberry, orange, blueberry, grape, and cherry.",
"output": "Party(strawberry) ∨ Party(orange) ∨ Party(blueberry) ∨ Party(grape) ∨ Party(cherry) "
},
{
"input": "Translate into first-order logic: All fruits are provided in the same weight at the beginning of the party.",
"output": "∀x (Party(x) → SameWeight(x))"
},
{
"input": "Translate into first-order logic: If the fruit had the lowest remaining weight at the end of the party, then it means it was the most popular fruit.",
"output": "∀x (LowestAmount(x) → MostPopular(x)) "
},
{
"input": "Translate into first-order logic: At the end of the party, strawberries had the lowest remaining weight.",
"output": "LowestAmount(strawberries)"
},
{
"input": "Translate into first-order logic: At the end of the party, the amount of leftover blueberries was lower than that of cherries.",
"output": "Lower(blueberry, cherry)"
},
{
"input": "Translate into first-order logic: Benjamin only ate oranges and grapes at the party.",
"output": "Eat(orange, benjamin) ∧ Eat(grape, benjamin) ∧ ¬Eat(blueberry, benjamin) ∧ ¬Eat(cherry, benjamin) ∧ ¬Eat(strawberry, benjamin)"
},
{
"input": "Translate into first-order logic: All students who attend in person have registered for the conference.",
"output": "∀x (Attend(x) → Registered(x))"
},
{
"input": "Translate into first-order logic: Students either attend the conference in person or remotely.",
"output": "∀x (Attend(x) → InPerson(x) ⊕ Remotely(x))"
},
{
"input": "Translate into first-order logic: No students from China attend the conference remotely.",
"output": "∀x ((Attend(x) ∧ China(x)) → ¬Remotely(x))"
},
{
"input": "Translate into first-order logic: James attends the conference but he does not attend the conference remotely.",
"output": "Attend(james) ∧ ¬Remotely(james)"
},
{
"input": "Translate into first-order logic: Jack attends the conference and he is a student from China.",
"output": "China(jack) ∧ Attend(jack)"
},
{
"input": "Translate into first-order logic: All students who attend in person have registered for the conference.",
"output": "∀x (Attend(x) → Registered(x))"
},
{
"input": "Translate into first-order logic: Students either attend the conference in person or remotely.",
"output": "∀x (Attend(x) → InPerson(x) ⊕ Remotely(x))"
},
{
"input": "Translate into first-order logic: No students from China attend the conference remotely.",
"output": "∀x ((Attend(x) ∧ China(x)) → ¬Remotely(x))"
},
{
"input": "Translate into first-order logic: James attends the conference but he does not attend the conference remotely.",
"output": "Attend(james) ∧ ¬Remotely(james)"
},
{
"input": "Translate into first-order logic: Jack attends the conference and he is a student from China.",
"output": "China(jack) ∧ Attend(jack)"
},
{
"input": "Translate into first-order logic: All students who attend in person have registered for the conference.",
"output": "∀x (Attend(x) → Registered(x))"
},
{
"input": "Translate into first-order logic: Students either attend the conference in person or remotely.",
"output": "∀x (Attend(x) → InPerson(x) ⊕ Remotely(x))"
},
{
"input": "Translate into first-order logic: No students from China attend the conference remotely.",
"output": "∀x ((Attend(x) ∧ China(x)) → ¬Remotely(x))"
},
{
"input": "Translate into first-order logic: James attends the conference but he does not attend the conference remotely.",
"output": "Attend(james) ∧ ¬Remotely(james)"
},
{
"input": "Translate into first-order logic: Jack attends the conference and he is a student from China.",
"output": "China(jack) ∧ Attend(jack)"
},
{
"input": "Translate into first-order logic: David Ha'ivri is a political strategist.",
"output": "PoliticalStrategist(davidhaivri)"
},
{
"input": "Translate into first-order logic: If you are born in Israel to at least one Israeli parent, then you receive citizenship at birth.",
"output": "∀x ∃y (BornInIsrael(x) ∧ ParentOf(x, y) ∧ Israeli(y) → IsraeliCitizen(x))"
},
{
"input": "Translate into first-order logic: David Ha'ivri emigrated to the United States from Israel, where he was born to Israeli parents.",
"output": "∃x (EmigratedTo(davidhaivri, america) ∧ BornInIsrael(davidhaivri) ∧ ParentOf(davidhaivri, x) ∧ Israeli(x))"
},
{
"input": "Translate into first-order logic: Several Zionist leaders have been elected to the Shomron Regional Municipal council.",
"output": "∃x (ZionistLeader(x) ∧ ElectedTo(x, shomronmunicipalcouncil))"
},
{
"input": "Translate into first-order logic: David Ha'ivri is a Zionist leader.",
"output": "ZionstLeader(davidhaivri)"
},
{
"input": "Translate into first-order logic: David Ha'ivri is a political strategist.",
"output": "PoliticalStrategist(davidhaivri)"
},
{
"input": "Translate into first-order logic: If you are born in Israel to at least one Israeli parent, then you receive citizenship at birth.",
"output": "∀x ∃y (BornInIsrael(x) ∧ ParentOf(x, y) ∧ Israeli(y) → IsraeliCitizen(x))"
},
{
"input": "Translate into first-order logic: David Ha'ivri emigrated to the United States from Israel, where he was born to Israeli parents.",
"output": "∃x (EmigratedTo(davidhaivri, america) ∧ BornInIsrael(davidhaivri) ∧ ParentOf(davidhaivri, x) ∧ Israeli(x))"
},
{
"input": "Translate into first-order logic: Several Zionist leaders have been elected to the Shomron Regional Municipal council.",
"output": "∃x (ZionistLeader(x) ∧ ElectedTo(x, shomronmunicipalcouncil))"
},
{
"input": "Translate into first-order logic: David Ha'ivri is a Zionist leader.",
"output": "ZionstLeader(davidhaivri)"
},
{
"input": "Translate into first-order logic: David Ha'ivri is a political strategist.",
"output": "PoliticalStrategist(davidhaivri)"
},
{
"input": "Translate into first-order logic: If you are born in Israel to at least one Israeli parent, then you receive citizenship at birth.",
"output": "∀x ∃y (BornInIsrael(x) ∧ ParentOf(x, y) ∧ Israeli(y) → IsraeliCitizen(x))"
},
{
"input": "Translate into first-order logic: David Ha'ivri emigrated to the United States from Israel, where he was born to Israeli parents.",
"output": "∃x (EmigratedTo(davidhaivri, america) ∧ BornInIsrael(davidhaivri) ∧ ParentOf(davidhaivri, x) ∧ Israeli(x))"
},
{
"input": "Translate into first-order logic: Several Zionist leaders have been elected to the Shomron Regional Municipal council.",
"output": "∃x (ZionistLeader(x) ∧ ElectedTo(x, shomronmunicipalcouncil))"
},
{
"input": "Translate into first-order logic: David Ha'ivri is a Zionist leader.",
"output": "ZionstLeader(davidhaivri)"
},
{
"input": "Translate into first-order logic: Mary has the flu.",
"output": "Have(mary, flu)"
},
{
"input": "Translate into first-order logic: Flu and influenza are the same disease.",
"output": "∀x (Have(x, flu) ↔ Have(x, influenza))"
},
{
"input": "Translate into first-order logic: Susan doesn't have influenza.",
"output": "¬Have(susan, influenza)"
},
{
"input": "Translate into first-order logic: James Cocks was a British lawyer.",
"output": "British(james) ∧ Lawyer(james)"
},
{
"input": "Translate into first-order logic: James Cocks was a Whig politician who sat in the House of Commons.",
"output": "Whig(james) ∧ Politician(james) ∧ SatInHouseOfCommons(james)"
},
{
"input": "Translate into first-order logic: A British is a European.",
"output": "∀x (British(x) → European(x))"
},
{
"input": "Translate into first-order logic: Any lawyer is familiar with laws.",
"output": "∀x (Lawyer(x) → FamiliarWithLaws(x))"
},
{
"input": "Translate into first-order logic: Some Whigs speak French.",
"output": "∃x (Whig(x) ∧ SpeakFrench(x))"
},
{
"input": "Translate into first-order logic: James Cocks was a British lawyer.",
"output": "British(james) ∧ Lawyer(james)"
},
{
"input": "Translate into first-order logic: James Cocks was a Whig politician who sat in the House of Commons.",
"output": "Whig(james) ∧ Politician(james) ∧ SatInHouseOfCommons(james)"
},
{
"input": "Translate into first-order logic: A British is a European.",
"output": "∀x (British(x) → European(x))"
},
{
"input": "Translate into first-order logic: Any lawyer is familiar with laws.",
"output": "∀x (Lawyer(x) → FamiliarWithLaws(x))"
},
{
"input": "Translate into first-order logic: Some Whigs speak French.",
"output": "∃x (Whig(x) ∧ SpeakFrench(x))"
},
{
"input": "Translate into first-order logic: James Cocks was a British lawyer.",
"output": "British(james) ∧ Lawyer(james)"
},
{
"input": "Translate into first-order logic: James Cocks was a Whig politician who sat in the House of Commons.",
"output": "Whig(james) ∧ Politician(james) ∧ SatInHouseOfCommons(james)"
},
{
"input": "Translate into first-order logic: A British is a European.",
"output": "∀x (British(x) → European(x))"
},
{
"input": "Translate into first-order logic: Any lawyer is familiar with laws.",
"output": "∀x (Lawyer(x) → FamiliarWithLaws(x))"
},
{
"input": "Translate into first-order logic: Some Whigs speak French.",
"output": "∃x (Whig(x) ∧ SpeakFrench(x))"
},
{
"input": "Translate into first-order logic: Beasts of Prey is either a fantasy novel or a science fiction novel.",
"output": "Novel(beastsofprey) ∧ Fantasy(beastsofprey) ∨ ScienceFiction(beastsofprey)"
},
{
"input": "Translate into first-order logic: Science fiction novels are not about mythological creatures",
"output": "∀x ∀y (ScienceFiction(x) ∧ Mythological(y) ∧ Creature(y) → ¬About(x, y))"
},
{
"input": "Translate into first-order logic: Beasts of Prey Is about a creature known as the Shetani.",
"output": "About(beastsofprey, shetani) ∧ Creature(shetani)"
},
{
"input": "Translate into first-order logic: Shetanis are mythological.",
"output": "Mythological(shetani)"
},
{
"input": "Translate into first-order logic: Beasts of Prey is either a fantasy novel or a science fiction novel.",
"output": "Novel(beastsofprey) ∧ Fantasy(beastsofprey) ∨ ScienceFiction(beastsofprey)"
},
{
"input": "Translate into first-order logic: Science fiction novels are not about mythological creatures",
"output": "∀x ∀y (ScienceFiction(x) ∧ Mythological(y) ∧ Creature(y) → ¬About(x, y))"
},
{
"input": "Translate into first-order logic: Beasts of Prey Is about a creature known as the Shetani.",
"output": "About(beastsofprey, shetani) ∧ Creature(shetani)"
},
{
"input": "Translate into first-order logic: Shetanis are mythological.",
"output": "Mythological(shetani)"
},
{
"input": "Translate into first-order logic: Beasts of Prey is either a fantasy novel or a science fiction novel.",
"output": "Novel(beastsofprey) ∧ Fantasy(beastsofprey) ∨ ScienceFiction(beastsofprey)"
},
{
"input": "Translate into first-order logic: Science fiction novels are not about mythological creatures",
"output": "∀x ∀y (ScienceFiction(x) ∧ Mythological(y) ∧ Creature(y) → ¬About(x, y))"
},
{
"input": "Translate into first-order logic: Beasts of Prey Is about a creature known as the Shetani.",
"output": "About(beastsofprey, shetani) ∧ Creature(shetani)"
},
{
"input": "Translate into first-order logic: Shetanis are mythological.",
"output": "Mythological(shetani)"
},
{
"input": "Translate into first-order logic: Odell is an English surname originating in Odell, Bedfordshire.",
"output": "∀x (Odell(x) → Surname(x))"
},
{
"input": "Translate into first-order logic: In some families Odell is spelled O'Dell, in a mistaken Irish adaptation.",
"output": "∃x (Odell(x) ∧ SpelledODell(x))"
},
{
"input": "Translate into first-order logic: Notable people with the surname include Amy Odell, Jack Odell, and Mats Odell.",
"output": "Odell(amyOdell) ∧ NotablePeople(amyOdell) ∧ Odell(jackOdell) ∧ NotablePeople(jackOdell) ∧ Odell(matsOdell) ∧ NotablePeople(matsOdell)"
},
{
"input": "Translate into first-order logic: Amy Odell is a British singer-songwriter.",
"output": "British(amyOdell) ∧ Singer(amyOdell) ∧ SongWriter(amyOdell)"
},
{
"input": "Translate into first-order logic: Jack Odell is an English toy inventor.",
"output": "English(jackOdell) ∧ ToyInvertor(jackOdell)"
},
{
"input": "Translate into first-order logic: Odell is an English surname originating in Odell, Bedfordshire.",
"output": "∀x (Odell(x) → Surname(x))"
},
{
"input": "Translate into first-order logic: In some families Odell is spelled O'Dell, in a mistaken Irish adaptation.",
"output": "∃x (Odell(x) ∧ SpelledODell(x))"
},
{
"input": "Translate into first-order logic: Notable people with the surname include Amy Odell, Jack Odell, and Mats Odell.",
"output": "Odell(amyOdell) ∧ NotablePeople(amyOdell) ∧ Odell(jackOdell) ∧ NotablePeople(jackOdell) ∧ Odell(matsOdell) ∧ NotablePeople(matsOdell)"
},
{
"input": "Translate into first-order logic: Amy Odell is a British singer-songwriter.",
"output": "British(amyOdell) ∧ Singer(amyOdell) ∧ SongWriter(amyOdell)"
},
{
"input": "Translate into first-order logic: Jack Odell is an English toy inventor.",
"output": "English(jackOdell) ∧ ToyInvertor(jackOdell)"
},
{
"input": "Translate into first-order logic: Odell is an English surname originating in Odell, Bedfordshire.",
"output": "∀x (Odell(x) → Surname(x))"
},
{
"input": "Translate into first-order logic: In some families Odell is spelled O'Dell, in a mistaken Irish adaptation.",
"output": "∃x (Odell(x) ∧ SpelledODell(x))"
},
{
"input": "Translate into first-order logic: Notable people with the surname include Amy Odell, Jack Odell, and Mats Odell.",
"output": "Odell(amyOdell) ∧ NotablePeople(amyOdell) ∧ Odell(jackOdell) ∧ NotablePeople(jackOdell) ∧ Odell(matsOdell) ∧ NotablePeople(matsOdell)"
},
{
"input": "Translate into first-order logic: Amy Odell is a British singer-songwriter.",
"output": "British(amyOdell) ∧ Singer(amyOdell) ∧ SongWriter(amyOdell)"
},
{
"input": "Translate into first-order logic: Jack Odell is an English toy inventor.",
"output": "English(jackOdell) ∧ ToyInvertor(jackOdell)"
},
{
"input": "Translate into first-order logic: Odell is an English surname originating in Odell, Bedfordshire.",
"output": "∀x (Odell(x) → Surname(x))"
},
{
"input": "Translate into first-order logic: In some families Odell is spelled O'Dell, in a mistaken Irish adaptation.",
"output": "∃x (Odell(x) ∧ SpelledODell(x))"
},
{
"input": "Translate into first-order logic: Notable people with the surname include Amy Odell, Jack Odell, and Mats Odell.",
"output": "Odell(amyOdell) ∧ NotablePeople(amyOdell) ∧ Odell(jackOdell) ∧ NotablePeople(jackOdell) ∧ Odell(matsOdell) ∧ NotablePeople(matsOdell)"
},
{
"input": "Translate into first-order logic: Amy Odell is a British singer-songwriter.",
"output": "British(amyOdell) ∧ Singer(amyOdell) ∧ SongWriter(amyOdell)"
},
{
"input": "Translate into first-order logic: Jack Odell is an English toy inventor.",
"output": "English(jackOdell) ∧ ToyInvertor(jackOdell)"
},
{
"input": "Translate into first-order logic: If you go somewhere by train, you will not lose time.",
"output": "∀x (Train(x) → ¬LoseTime(x))"
},
{
"input": "Translate into first-order logic: If you go somewhere by car and meet traffic jam, you will lose time.",
"output": "∀x ((Car(x) ∧ MeetJam(x)) → LoseTime(x))"
},
{
"input": "Translate into first-order logic: If you lose time, you will be late for work.",
"output": "∀x (LoseTime(x) ↔ LateForWork(x))"
},
{
"input": "Translate into first-order logic: Mary can get from New Haven to New York City either by train or car.",
"output": "Train(mary) ⊕ Car(mary)"
},
{
"input": "Translate into first-order logic: Mary is late for work.",
"output": "LateForWork(mary)"
},
{
"input": "Translate into first-order logic: If you go somewhere by train, you will not lose time.",
"output": "∀x (Train(x) → ¬LoseTime(x))"
},
{
"input": "Translate into first-order logic: If you go somewhere by car and meet traffic jam, you will lose time.",
"output": "∀x ((Car(x) ∧ MeetJam(x)) → LoseTime(x))"
},
{
"input": "Translate into first-order logic: If you lose time, you will be late for work.",
"output": "∀x (LoseTime(x) ↔ LateForWork(x))"
},
{
"input": "Translate into first-order logic: Mary can get from New Haven to New York City either by train or car.",
"output": "Train(mary) ⊕ Car(mary)"
},
{
"input": "Translate into first-order logic: Mary is late for work.",
"output": "LateForWork(mary)"
},
{
"input": "Translate into first-order logic: If you go somewhere by train, you will not lose time.",
"output": "∀x (Train(x) → ¬LoseTime(x))"
},
{
"input": "Translate into first-order logic: If you go somewhere by car and meet traffic jam, you will lose time.",
"output": "∀x ((Car(x) ∧ MeetJam(x)) → LoseTime(x))"
},
{
"input": "Translate into first-order logic: If you lose time, you will be late for work.",
"output": "∀x (LoseTime(x) ↔ LateForWork(x))"
},
{
"input": "Translate into first-order logic: Mary can get from New Haven to New York City either by train or car.",
"output": "Train(mary) ⊕ Car(mary)"
},
{
"input": "Translate into first-order logic: Mary is late for work.",
"output": "LateForWork(mary)"
},
{
"input": "Translate into first-order logic: If a person is hungry, the person is uncomfortable.",
"output": "∀x (Hungry(x) → Uncomfortable(x))"
},
{
"input": "Translate into first-order logic: If a person is uncomfortable, the person is unhappy.",
"output": "∀x (Uncomfortable(x) → ¬Happy(x))"
},
{
"input": "Translate into first-order logic: Tipped employees do not get a guaranteed minimum wage.",
"output": "∀x (Tipped(x) → ¬GetMinWage(x))"
},
{
"input": "Translate into first-order logic: If a person is a white-collar worker, they will get a guaranteed minimum wage (All white-collar workers get a guaranteed minimum wage).",
"output": "∀x (WhiteCollar(x) → GetMinWage(x))"
},
{
"input": "Translate into first-order logic: All lawyers are white-collar workers.",
"output": "∀x (Lawyer(x) → WhiteCollar(x))"
},
{
"input": "Translate into first-order logic: Every advocate is a lawyer.",
"output": "∀x (Advocate(x) → Lawyer(x))"
},
{
"input": "Translate into first-order logic: Mary is not a lawyer or a tipped employee.",
"output": "¬Lawyer(mary) ⊕ Tipped(mary)"
},
{
"input": "Translate into first-order logic: Tipped employees do not get a guaranteed minimum wage.",
"output": "∀x (Tipped(x) → ¬GetMinWage(x))"
},
{
"input": "Translate into first-order logic: If a person is a white-collar worker, they will get a guaranteed minimum wage (All white-collar workers get a guaranteed minimum wage).",
"output": "∀x (WhiteCollar(x) → GetMinWage(x))"
},
{
"input": "Translate into first-order logic: All lawyers are white-collar workers.",
"output": "∀x (Lawyer(x) → WhiteCollar(x))"
},
{
"input": "Translate into first-order logic: Every advocate is a lawyer.",
"output": "∀x (Advocate(x) → Lawyer(x))"
},
{
"input": "Translate into first-order logic: Mary is not a lawyer or a tipped employee.",
"output": "¬Lawyer(mary) ⊕ Tipped(mary)"
},
{
"input": "Translate into first-order logic: Tipped employees do not get a guaranteed minimum wage.",
"output": "∀x (Tipped(x) → ¬GetMinWage(x))"
},
{
"input": "Translate into first-order logic: If a person is a white-collar worker, they will get a guaranteed minimum wage (All white-collar workers get a guaranteed minimum wage).",
"output": "∀x (WhiteCollar(x) → GetMinWage(x))"
},
{
"input": "Translate into first-order logic: All lawyers are white-collar workers.",
"output": "∀x (Lawyer(x) → WhiteCollar(x))"
},
{
"input": "Translate into first-order logic: Every advocate is a lawyer.",
"output": "∀x (Advocate(x) → Lawyer(x))"
},
{
"input": "Translate into first-order logic: Mary is not a lawyer or a tipped employee.",
"output": "¬Lawyer(mary) ⊕ Tipped(mary)"
},
{
"input": "Translate into first-order logic: Tipped employees do not get a guaranteed minimum wage.",
"output": "∀x (Tipped(x) → ¬GetMinWage(x))"
},
{
"input": "Translate into first-order logic: If a person is a white-collar worker, they will get a guaranteed minimum wage (All white-collar workers get a guaranteed minimum wage).",
"output": "∀x (WhiteCollar(x) → GetMinWage(x))"
},
{
"input": "Translate into first-order logic: All lawyers are white-collar workers.",
"output": "∀x (Lawyer(x) → WhiteCollar(x))"
},
{
"input": "Translate into first-order logic: Every advocate is a lawyer.",
"output": "∀x (Advocate(x) → Lawyer(x))"
},
{
"input": "Translate into first-order logic: Mary is not a lawyer or a tipped employee.",
"output": "¬Lawyer(mary) ⊕ Tipped(mary)"
},
{
"input": "Translate into first-order logic: Tipped employees do not get a guaranteed minimum wage.",
"output": "∀x (Tipped(x) → ¬GetMinWage(x))"
},
{
"input": "Translate into first-order logic: If a person is a white-collar worker, they will get a guaranteed minimum wage (All white-collar workers get a guaranteed minimum wage).",
"output": "∀x (WhiteCollar(x) → GetMinWage(x))"
},
{
"input": "Translate into first-order logic: All lawyers are white-collar workers.",
"output": "∀x (Lawyer(x) → WhiteCollar(x))"
},
{
"input": "Translate into first-order logic: Every advocate is a lawyer.",
"output": "∀x (Advocate(x) → Lawyer(x))"
},
{
"input": "Translate into first-order logic: Mary is not a lawyer or a tipped employee.",
"output": "¬Lawyer(mary) ⊕ Tipped(mary)"
},
{
"input": "Translate into first-order logic: Tipped employees do not get a guaranteed minimum wage.",
"output": "∀x (Tipped(x) → ¬GetMinWage(x))"
},
{
"input": "Translate into first-order logic: If a person is a white-collar worker, they will get a guaranteed minimum wage (All white-collar workers get a guaranteed minimum wage).",
"output": "∀x (WhiteCollar(x) → GetMinWage(x))"
},
{
"input": "Translate into first-order logic: All lawyers are white-collar workers.",
"output": "∀x (Lawyer(x) → WhiteCollar(x))"
},
{
"input": "Translate into first-order logic: Every advocate is a lawyer.",
"output": "∀x (Advocate(x) → Lawyer(x))"
},
{
"input": "Translate into first-order logic: Mary is not a lawyer or a tipped employee.",
"output": "¬Lawyer(mary) ⊕ Tipped(mary)"
},
{
"input": "Translate into first-order logic: Asa Hoffmann was born in New York City.",
"output": "BornIn(asaHoffmann, newyorkcity)"
},
{
"input": "Translate into first-order logic: Asa Hoffman lives in Manhattan.",
"output": "LivesIn(asaHoffmann, manhattan)"
},
{
"input": "Translate into first-order logic: Asa Hoffman is a chess player.",
"output": "IsChessPlayer(asaHoffmann)"
},
{
"input": "Translate into first-order logic: Some chess players are grandmasters.",
"output": "∃x (IsChestPlayer(x) ∧ IsGrandMaster(x))"
},
{
"input": "Translate into first-order logic: People born and living in New York City are New Yorkers.",
"output": "∀x (BornIn(x, newyorkcity) ∧ LivesIn(x, newyorkcity) → IsNewYorker(x))"
},
{
"input": "Translate into first-order logic: People liviing in Manhattan live in New York City.",
"output": "∀x (LivesIn(x, manhattan) → LivesIn(x, newyorkcity))"
},
{
"input": "Translate into first-order logic: Asa Hoffmann was born in New York City.",
"output": "BornIn(asaHoffmann, newyorkcity)"
},
{
"input": "Translate into first-order logic: Asa Hoffman lives in Manhattan.",
"output": "LivesIn(asaHoffmann, manhattan)"
},
{
"input": "Translate into first-order logic: Asa Hoffman is a chess player.",
"output": "IsChessPlayer(asaHoffmann)"
},
{
"input": "Translate into first-order logic: Some chess players are grandmasters.",
"output": "∃x (IsChestPlayer(x) ∧ IsGrandMaster(x))"
},
{
"input": "Translate into first-order logic: People born and living in New York City are New Yorkers.",
"output": "∀x (BornIn(x, newyorkcity) ∧ LivesIn(x, newyorkcity) → IsNewYorker(x))"
},
{
"input": "Translate into first-order logic: People liviing in Manhattan live in New York City.",
"output": "∀x (LivesIn(x, manhattan) → LivesIn(x, newyorkcity))"
},
{
"input": "Translate into first-order logic: Asa Hoffmann was born in New York City.",
"output": "BornIn(asaHoffmann, newyorkcity)"
},
{
"input": "Translate into first-order logic: Asa Hoffman lives in Manhattan.",
"output": "LivesIn(asaHoffmann, manhattan)"
},
{
"input": "Translate into first-order logic: Asa Hoffman is a chess player.",
"output": "IsChessPlayer(asaHoffmann)"
},
{
"input": "Translate into first-order logic: Some chess players are grandmasters.",
"output": "∃x (IsChestPlayer(x) ∧ IsGrandMaster(x))"
},
{
"input": "Translate into first-order logic: People born and living in New York City are New Yorkers.",
"output": "∀x (BornIn(x, newyorkcity) ∧ LivesIn(x, newyorkcity) → IsNewYorker(x))"
},
{
"input": "Translate into first-order logic: People liviing in Manhattan live in New York City.",
"output": "∀x (LivesIn(x, manhattan) → LivesIn(x, newyorkcity))"
},
{
"input": "Translate into first-order logic: Some of those who apply for a Schengen Visa get it.",
"output": "∃x (ApplyVisa(x) → GetVisa(x))"
},
{
"input": "Translate into first-order logic: To apply for a Schengen Visa, you need to provide financial guarantees.",
"output": "∀x (ApplyVisa(x) → FinancialGuarantees(x))"
},
{
"input": "Translate into first-order logic: If you need to provide financial guarantees, you must request documents from the bank.",
"output": "∀x (FinancialGuarantees(x) → RequestDocuments(x))"
},
{
"input": "Translate into first-order logic: Do not close your bank account if you request documents from the bank.",
"output": "∀x (RequestDocuments(x) → ¬CloseBankAccount(x))"
},
{
"input": "Translate into first-order logic: Philip closed his bank account.",
"output": "CloseBankAccount(philip)"
},
{
"input": "Translate into first-order logic: Some of those who apply for a Schengen Visa get it.",
"output": "∃x (ApplyVisa(x) → GetVisa(x))"
},
{
"input": "Translate into first-order logic: To apply for a Schengen Visa, you need to provide financial guarantees.",
"output": "∀x (ApplyVisa(x) → FinancialGuarantees(x))"
},
{
"input": "Translate into first-order logic: If you need to provide financial guarantees, you must request documents from the bank.",
"output": "∀x (FinancialGuarantees(x) → RequestDocuments(x))"
},
{
"input": "Translate into first-order logic: Do not close your bank account if you request documents from the bank.",
"output": "∀x (RequestDocuments(x) → ¬CloseBankAccount(x))"
},
{
"input": "Translate into first-order logic: Philip closed his bank account.",
"output": "CloseBankAccount(philip)"
},
{
"input": "Translate into first-order logic: Some of those who apply for a Schengen Visa get it.",
"output": "∃x (ApplyVisa(x) → GetVisa(x))"
},
{
"input": "Translate into first-order logic: To apply for a Schengen Visa, you need to provide financial guarantees.",
"output": "∀x (ApplyVisa(x) → FinancialGuarantees(x))"
},
{
"input": "Translate into first-order logic: If you need to provide financial guarantees, you must request documents from the bank.",
"output": "∀x (FinancialGuarantees(x) → RequestDocuments(x))"
},
{
"input": "Translate into first-order logic: Do not close your bank account if you request documents from the bank.",
"output": "∀x (RequestDocuments(x) → ¬CloseBankAccount(x))"
},
{
"input": "Translate into first-order logic: Philip closed his bank account.",
"output": "CloseBankAccount(philip)"
},
{
"input": "Translate into first-order logic: Some fears lead to anxiety.",
"output": "∃x (Fear(x) ∧ Anxiety(x))"
},
{
"input": "Translate into first-order logic: Some anxiety leads to terror.",
"output": "∃x (Anxiety(x) ∧ Terror(x))"
},
{
"input": "Translate into first-order logic: The Great Lakes are Lake Superior, Lake Michigan, Lake Huron, Lake Erie, and Lake Ontario.",
"output": "∀x (GreatLake(x) → Superior(x) ∨ Michigan(x) ∨ Huron(x) ∨ Erie(x) ∨ Ontario(x))"
},
{
"input": "Translate into first-order logic: Some major settlements of Lake Erie are in NY, PA, OH, and MI.",
"output": "∃x ∀y (Erie(y) ∧ MajorSettlementOf(x, y) ∧ In(x, ny) ∨ In(x, pa) ∨ In(x, oh) ∨ In(x, mi))"
},
{
"input": "Translate into first-order logic: NY, PA, OH, MI are states in the US.",
"output": "State(ny, us) ∧ State(pa, us) ∧ State(oh, us) ∧ State(mi, us)"
},
{
"input": "Translate into first-order logic: ON is a state of Canada.",
"output": "State(on, canada)"
},
{
"input": "Translate into first-order logic: There is a major settlement of Lake Huron in ON.",
"output": "∃x ∀y (Huron(y) ∧ MajorSettlementOf(x, y) ∧ In(x, on))"
},
{
"input": "Translate into first-order logic: All states are in their country.",
"output": "∀x ∀y (State(x, y) → In(x, y))"
},
{
"input": "Translate into first-order logic: The US is in North America.",
"output": "In(us, northamerica)"
},
{
"input": "Translate into first-order logic: The Great Lakes began to form at the end of the Last Glacial Period.",
"output": "∀x (GreatLake(x) → FormAtEndOf(x, lastglacialperiod))"
},
{
"input": "Translate into first-order logic: The Great Lakes are Lake Superior, Lake Michigan, Lake Huron, Lake Erie, and Lake Ontario.",
"output": "∀x (GreatLake(x) → Superior(x) ∨ Michigan(x) ∨ Huron(x) ∨ Erie(x) ∨ Ontario(x))"
},
{
"input": "Translate into first-order logic: Some major settlements of Lake Erie are in NY, PA, OH, and MI.",
"output": "∃x ∀y (Erie(y) ∧ MajorSettlementOf(x, y) ∧ In(x, ny) ∨ In(x, pa) ∨ In(x, oh) ∨ In(x, mi))"
},
{
"input": "Translate into first-order logic: NY, PA, OH, MI are states in the US.",
"output": "State(ny, us) ∧ State(pa, us) ∧ State(oh, us) ∧ State(mi, us)"
},
{
"input": "Translate into first-order logic: ON is a state of Canada.",
"output": "State(on, canada)"
},
{
"input": "Translate into first-order logic: There is a major settlement of Lake Huron in ON.",
"output": "∃x ∀y (Huron(y) ∧ MajorSettlementOf(x, y) ∧ In(x, on))"
},
{
"input": "Translate into first-order logic: All states are in their country.",
"output": "∀x ∀y (State(x, y) → In(x, y))"
},
{
"input": "Translate into first-order logic: The US is in North America.",
"output": "In(us, northamerica)"
},
{
"input": "Translate into first-order logic: The Great Lakes began to form at the end of the Last Glacial Period.",
"output": "∀x (GreatLake(x) → FormAtEndOf(x, lastglacialperiod))"
},
{
"input": "Translate into first-order logic: All defenders are soccer players.",
"output": "∀x (Defender(x) → SoccerPlayer(x))"
},
{
"input": "Translate into first-order logic: No soccer players are professional basketball players.",
"output": "∀x (SoccerPlayer(x) → ¬ProfessionalBasketballPlayer(x))"
},
{
"input": "Translate into first-order logic: All centerbacks are defenders.",
"output": "∀x (CenterBack(x) → Defender(x))"
},
{
"input": "Translate into first-order logic: All NBA players are professional basketball players.",
"output": "∀x (NBAPlayer(x) → ProfessionalBasketballPlayer(x))"
},
{
"input": "Translate into first-order logic: If Stephen Curry is not an NBA player, then Stephen Curry is not an NBA player or a soccer player.",
"output": "¬NBAPlayer(stephencurry) → ¬(NBAPlayer(stephencurry) ⊕ SoccerPlayer(stephencurry))"
},
{
"input": "Translate into first-order logic: All defenders are soccer players.",
"output": "∀x (Defender(x) → SoccerPlayer(x))"
},
{
"input": "Translate into first-order logic: No soccer players are professional basketball players.",
"output": "∀x (SoccerPlayer(x) → ¬ProfessionalBasketballPlayer(x))"
},
{
"input": "Translate into first-order logic: All centerbacks are defenders.",
"output": "∀x (CenterBack(x) → Defender(x))"
},
{
"input": "Translate into first-order logic: All NBA players are professional basketball players.",
"output": "∀x (NBAPlayer(x) → ProfessionalBasketballPlayer(x))"
},
{
"input": "Translate into first-order logic: If Stephen Curry is not an NBA player, then Stephen Curry is not an NBA player or a soccer player.",
"output": "¬NBAPlayer(stephencurry) → ¬(NBAPlayer(stephencurry) ⊕ SoccerPlayer(stephencurry))"
},
{
"input": "Translate into first-order logic: All defenders are soccer players.",
"output": "∀x (Defender(x) → SoccerPlayer(x))"
},
{
"input": "Translate into first-order logic: No soccer players are professional basketball players.",
"output": "∀x (SoccerPlayer(x) → ¬ProfessionalBasketballPlayer(x))"
},
{
"input": "Translate into first-order logic: All centerbacks are defenders.",
"output": "∀x (CenterBack(x) → Defender(x))"
},
{
"input": "Translate into first-order logic: All NBA players are professional basketball players.",
"output": "∀x (NBAPlayer(x) → ProfessionalBasketballPlayer(x))"
},
{
"input": "Translate into first-order logic: If Stephen Curry is not an NBA player, then Stephen Curry is not an NBA player or a soccer player.",
"output": "¬NBAPlayer(stephencurry) → ¬(NBAPlayer(stephencurry) ⊕ SoccerPlayer(stephencurry))"
},
{
"input": "Translate into first-order logic: Naive cynicism was proposed by Justin Kruger and a colleague.",
"output": "Proposed(justinKruger, naiveCynicism) ∧ Proposed(colleagueOfJustinKruger, naiveCynicism) "
},
{
"input": "Translate into first-order logic: Thomas Gilovich is a colleague of Justin Kruger.",
"output": "Colleague(thomasGilovich, justinKruger)"
},
{
"input": "Translate into first-order logic: Naive cynicism is a philosophy of mind.",
"output": "PhilosophyOfMind(naiveCynicism)"
},
{
"input": "Translate into first-order logic: Naive cynicism was proposed by Justin Kruger and a colleague.",
"output": "Proposed(justinKruger, naiveCynicism) ∧ Proposed(colleagueOfJustinKruger, naiveCynicism) "
},
{
"input": "Translate into first-order logic: Thomas Gilovich is a colleague of Justin Kruger.",
"output": "Colleague(thomasGilovich, justinKruger)"
},
{
"input": "Translate into first-order logic: Naive cynicism is a philosophy of mind.",
"output": "PhilosophyOfMind(naiveCynicism)"
},
{
"input": "Translate into first-order logic: Naive cynicism was proposed by Justin Kruger and a colleague.",
"output": "Proposed(justinKruger, naiveCynicism) ∧ Proposed(colleagueOfJustinKruger, naiveCynicism) "
},
{
"input": "Translate into first-order logic: Thomas Gilovich is a colleague of Justin Kruger.",
"output": "Colleague(thomasGilovich, justinKruger)"
},
{
"input": "Translate into first-order logic: Naive cynicism is a philosophy of mind.",
"output": "PhilosophyOfMind(naiveCynicism)"
},
{
"input": "Translate into first-order logic: The Turing Award has been awarded to Donald Knuth, Marvin Minsky, Richard Hamming and John McCarthy.",
"output": "TuringAwarded(donaldKnuth) ∧ TuringAwarded(marvinMinsky) ∧ TuringAwarded(richardHamming) ∧ TuringAwarded(johnMccarthy)"
},
{
"input": "Translate into first-order logic: Donald Knuth made major contributions to the analysis of algorithms.",
"output": "ContributedTo(donaldKnuth, algorithms)"
},
{
"input": "Translate into first-order logic: Marvin Minsky is recognized by his contributions to the field of artificial intelligence.",
"output": "ContributedTo(marvinMinsky, ai)"
},
{
"input": "Translate into first-order logic: Richard Hamming did research on numerical methods.",
"output": "ContributedTo(richardHamming, numericalMethods)"
},
{
"input": "Translate into first-order logic: John McCarthy had a central role in creating and shaping the field of artificial inteligence.",
"output": "ContributedTo(johnMccarthy, ai)"
},
{
"input": "Translate into first-order logic: The Turing Award has been awarded to Donald Knuth, Marvin Minsky, Richard Hamming and John McCarthy.",
"output": "TuringAwarded(donaldKnuth) ∧ TuringAwarded(marvinMinsky) ∧ TuringAwarded(richardHamming) ∧ TuringAwarded(johnMccarthy)"
},
{
"input": "Translate into first-order logic: Donald Knuth made major contributions to the analysis of algorithms.",
"output": "ContributedTo(donaldKnuth, algorithms)"
},
{
"input": "Translate into first-order logic: Marvin Minsky is recognized by his contributions to the field of artificial intelligence.",
"output": "ContributedTo(marvinMinsky, ai)"
},
{
"input": "Translate into first-order logic: Richard Hamming did research on numerical methods.",
"output": "ContributedTo(richardHamming, numericalMethods)"
},
{
"input": "Translate into first-order logic: John McCarthy had a central role in creating and shaping the field of artificial inteligence.",
"output": "ContributedTo(johnMccarthy, ai)"
},
{
"input": "Translate into first-order logic: The Turing Award has been awarded to Donald Knuth, Marvin Minsky, Richard Hamming and John McCarthy.",
"output": "TuringAwarded(donaldKnuth) ∧ TuringAwarded(marvinMinsky) ∧ TuringAwarded(richardHamming) ∧ TuringAwarded(johnMccarthy)"
},
{
"input": "Translate into first-order logic: Donald Knuth made major contributions to the analysis of algorithms.",
"output": "ContributedTo(donaldKnuth, algorithms)"
},
{
"input": "Translate into first-order logic: Marvin Minsky is recognized by his contributions to the field of artificial intelligence.",
"output": "ContributedTo(marvinMinsky, ai)"
},
{
"input": "Translate into first-order logic: Richard Hamming did research on numerical methods.",
"output": "ContributedTo(richardHamming, numericalMethods)"
},
{
"input": "Translate into first-order logic: John McCarthy had a central role in creating and shaping the field of artificial inteligence.",
"output": "ContributedTo(johnMccarthy, ai)"
},
{
"input": "Translate into first-order logic: The Turing Award has been awarded to Donald Knuth, Marvin Minsky, Richard Hamming and John McCarthy.",
"output": "TuringAwarded(donaldKnuth) ∧ TuringAwarded(marvinMinsky) ∧ TuringAwarded(richardHamming) ∧ TuringAwarded(johnMccarthy)"
},
{
"input": "Translate into first-order logic: Donald Knuth made major contributions to the analysis of algorithms.",
"output": "ContributedTo(donaldKnuth, algorithms)"
},
{
"input": "Translate into first-order logic: Marvin Minsky is recognized by his contributions to the field of artificial intelligence.",
"output": "ContributedTo(marvinMinsky, ai)"
},
{
"input": "Translate into first-order logic: Richard Hamming did research on numerical methods.",
"output": "ContributedTo(richardHamming, numericalMethods)"
},
{
"input": "Translate into first-order logic: John McCarthy had a central role in creating and shaping the field of artificial inteligence.",
"output": "ContributedTo(johnMccarthy, ai)"
},
{
"input": "Translate into first-order logic: No easy Leetcode problems have an AC rate lower than 20 percent.",
"output": "∀x (Easy(x) → ¬LowerAC(x))"
},
{
"input": "Translate into first-order logic: All Leetcode problems recommended to novices are easy.",
"output": "∀x (Recommended(x) → Easy(x))"
},
{
"input": "Translate into first-order logic: Leetcode problems either have an AC rate lower than 20 percent or are starred by more than 1 thousand users.",
"output": "∀x (LowerAC(x) ⊕ Starred(x))"
},
{
"input": "Translate into first-order logic: All hard Leetcode problems are starred by more than 1 thousand users.",
"output": "∀x (Hard(x) → Starred(x))"
},
{
"input": "Translate into first-order logic: No Leetcode problems published after 2022 are starred by more than 1 thousand users.",
"output": "∀x (PublishedAfter2022(x) → ¬Starred(x))"
},
{
"input": "Translate into first-order logic: 2Sum is not recommended to novices and hard.",
"output": "¬(Recommended(twosum) ∧ Hard(twosum))"
},
{
"input": "Translate into first-order logic: 4Sum is either starred by more than 1 thousand users and published after 2022, or neither starred by more than 1 thousand users nor published after 2022.",
"output": "¬(Starred(foursum) ⊕ PublishedAfter2022(foursum))"
},
{
"input": "Translate into first-order logic: No easy Leetcode problems have an AC rate lower than 20 percent.",
"output": "∀x (Easy(x) → ¬LowerAC(x))"
},
{
"input": "Translate into first-order logic: All Leetcode problems recommended to novices are easy.",
"output": "∀x (Recommended(x) → Easy(x))"
},
{
"input": "Translate into first-order logic: Leetcode problems either have an AC rate lower than 20 percent or are starred by more than 1 thousand users.",
"output": "∀x (LowerAC(x) ⊕ Starred(x))"
},
{
"input": "Translate into first-order logic: All hard Leetcode problems are starred by more than 1 thousand users.",
"output": "∀x (Hard(x) → Starred(x))"
},
{
"input": "Translate into first-order logic: No Leetcode problems published after 2022 are starred by more than 1 thousand users.",
"output": "∀x (PublishedAfter2022(x) → ¬Starred(x))"
},
{
"input": "Translate into first-order logic: 2Sum is not recommended to novices and hard.",
"output": "¬(Recommended(twosum) ∧ Hard(twosum))"
},
{
"input": "Translate into first-order logic: 4Sum is either starred by more than 1 thousand users and published after 2022, or neither starred by more than 1 thousand users nor published after 2022.",
"output": "¬(Starred(foursum) ⊕ PublishedAfter2022(foursum))"
},
{
"input": "Translate into first-order logic: No easy Leetcode problems have an AC rate lower than 20 percent.",
"output": "∀x (Easy(x) → ¬LowerAC(x))"
},
{
"input": "Translate into first-order logic: All Leetcode problems recommended to novices are easy.",
"output": "∀x (Recommended(x) → Easy(x))"
},
{
"input": "Translate into first-order logic: Leetcode problems either have an AC rate lower than 20 percent or are starred by more than 1 thousand users.",
"output": "∀x (LowerAC(x) ⊕ Starred(x))"
},
{
"input": "Translate into first-order logic: All hard Leetcode problems are starred by more than 1 thousand users.",
"output": "∀x (Hard(x) → Starred(x))"
},
{
"input": "Translate into first-order logic: No Leetcode problems published after 2022 are starred by more than 1 thousand users.",
"output": "∀x (PublishedAfter2022(x) → ¬Starred(x))"
},
{
"input": "Translate into first-order logic: 2Sum is not recommended to novices and hard.",
"output": "¬(Recommended(twosum) ∧ Hard(twosum))"
},
{
"input": "Translate into first-order logic: 4Sum is either starred by more than 1 thousand users and published after 2022, or neither starred by more than 1 thousand users nor published after 2022.",
"output": "¬(Starred(foursum) ⊕ PublishedAfter2022(foursum))"
},
{
"input": "Translate into first-order logic: No easy Leetcode problems have an AC rate lower than 20 percent.",
"output": "∀x (Easy(x) → ¬LowerAC(x))"
},
{
"input": "Translate into first-order logic: All Leetcode problems recommended to novices are easy.",
"output": "∀x (Recommended(x) → Easy(x))"
},
{
"input": "Translate into first-order logic: Leetcode problems either have an AC rate lower than 20 percent or are starred by more than 1 thousand users.",
"output": "∀x (LowerAC(x) ⊕ Starred(x))"
},
{
"input": "Translate into first-order logic: All hard Leetcode problems are starred by more than 1 thousand users.",
"output": "∀x (Hard(x) → Starred(x))"
},
{
"input": "Translate into first-order logic: No Leetcode problems published after 2022 are starred by more than 1 thousand users.",
"output": "∀x (PublishedAfter2022(x) → ¬Starred(x))"
},
{
"input": "Translate into first-order logic: 2Sum is not recommended to novices and hard.",
"output": "¬(Recommended(twosum) ∧ Hard(twosum))"
},
{
"input": "Translate into first-order logic: 4Sum is either starred by more than 1 thousand users and published after 2022, or neither starred by more than 1 thousand users nor published after 2022.",
"output": "¬(Starred(foursum) ⊕ PublishedAfter2022(foursum))"
},
{
"input": "Translate into first-order logic: Show Your Love is a song recorded by the South Korean boy band BtoB 4u.",
"output": "Song(showyourlove) ∧ RecordedBy(showyourlove, btob4u) ∧ SouthKorean(btob4u) ∧ BoyBand(btob4u)"
},
{
"input": "Translate into first-order logic: The lead single of the extended play Inside is Show Your Love.",
"output": "ExtendedPlay(inside) ∧ LeadSingle(showyourlove) ∧ LeadSingleOf(showyourlove, inside)"
},
{
"input": "Translate into first-order logic: Show Your Love contains a hopeful message.",
"output": "Contains(showyourlove, hopefulmessage)"
},
{
"input": "Translate into first-order logic: BtoB 4u member Hyunsik wrote Show Your Love.",
"output": "Member(hyunsik, btob4u) ∧ Wrote(hyunsik, showyourlove)"
},
{
"input": "Translate into first-order logic: There is a music video for Show Your Love.",
"output": "HasMusicVideo(showyourlove)"
},
{
"input": "Translate into first-order logic: Show Your Love is a song recorded by the South Korean boy band BtoB 4u.",
"output": "Song(showyourlove) ∧ RecordedBy(showyourlove, btob4u) ∧ SouthKorean(btob4u) ∧ BoyBand(btob4u)"
},
{
"input": "Translate into first-order logic: The lead single of the extended play Inside is Show Your Love.",
"output": "ExtendedPlay(inside) ∧ LeadSingle(showyourlove) ∧ LeadSingleOf(showyourlove, inside)"
},
{
"input": "Translate into first-order logic: Show Your Love contains a hopeful message.",
"output": "Contains(showyourlove, hopefulmessage)"
},
{
"input": "Translate into first-order logic: BtoB 4u member Hyunsik wrote Show Your Love.",
"output": "Member(hyunsik, btob4u) ∧ Wrote(hyunsik, showyourlove)"
},
{
"input": "Translate into first-order logic: There is a music video for Show Your Love.",
"output": "HasMusicVideo(showyourlove)"
},
{
"input": "Translate into first-order logic: Show Your Love is a song recorded by the South Korean boy band BtoB 4u.",
"output": "Song(showyourlove) ∧ RecordedBy(showyourlove, btob4u) ∧ SouthKorean(btob4u) ∧ BoyBand(btob4u)"
},
{
"input": "Translate into first-order logic: The lead single of the extended play Inside is Show Your Love.",
"output": "ExtendedPlay(inside) ∧ LeadSingle(showyourlove) ∧ LeadSingleOf(showyourlove, inside)"
},
{
"input": "Translate into first-order logic: Show Your Love contains a hopeful message.",
"output": "Contains(showyourlove, hopefulmessage)"
},
{
"input": "Translate into first-order logic: BtoB 4u member Hyunsik wrote Show Your Love.",
"output": "Member(hyunsik, btob4u) ∧ Wrote(hyunsik, showyourlove)"
},
{
"input": "Translate into first-order logic: There is a music video for Show Your Love.",
"output": "HasMusicVideo(showyourlove)"
},
{
"input": "Translate into first-order logic: All tables are round.",
"output": "∀x (Table(x) → Round(x))"
},
{
"input": "Translate into first-order logic: Some furniture are tables.",
"output": "∃x (Furniture(x) ∧ Table(x))"
},
{
"input": "Translate into first-order logic: All juvenile delinquents are maladjusted individuals.",
"output": "∀x (JuvenileDelinquent(x) → MaladjustedIndividual(x))"
},
{
"input": "Translate into first-order logic: Some juvenile delinquents are products of broken homes.",
"output": "∃x (JuvenileDelinquent(x)  ∧ ProductOfBrokenHome(x))"
},
{
"input": "Translate into first-order logic: Either brain reading or brain decoding.",
"output": "∀x (BrainReading(x) ∨ BrainDecoding(x)) "
},
{
"input": "Translate into first-order logic: All brain decoding is extracting information from BOLD signals.",
"output": "∀x (BrainDecoding(x) → ExtractingInformationFromBOLDSignals(x))"
},
{
"input": "Translate into first-order logic: No extracting information from BOLD signals is without statistical pattern analysis.",
"output": "∀x (ExtractingInformationFromBOLDSignals(x) → ¬WithoutStatisticalPatternAnalysis(x))"
},
{
"input": "Translate into first-order logic: Writing a novel is without statistical pattern analysis.",
"output": "∀x (WritingANovel(x) → WithoutStatisticalPatternAnalysis(x)) "
},
{
"input": "Translate into first-order logic: If multivoxel (pattern) analysis is without statistical pattern analysis and a brain reading, then multivoxel (pattern) analysis is without statistical pattern analysis and brain decoding.",
"output": "WithoutStatisticalPatternAnalysis(multivoxelPatternAnalysis) ∧ BrainReading(multivoxelPatternAnalysis) → WithoutStatisticalPatternAnalysis(multivoxelPatternAnalysis) ∧ BrainDecoding(multivoxelPatternAnalysis)"
},
{
"input": "Translate into first-order logic: Either brain reading or brain decoding.",
"output": "∀x (BrainReading(x) ∨ BrainDecoding(x)) "
},
{
"input": "Translate into first-order logic: All brain decoding is extracting information from BOLD signals.",
"output": "∀x (BrainDecoding(x) → ExtractingInformationFromBOLDSignals(x))"
},
{
"input": "Translate into first-order logic: No extracting information from BOLD signals is without statistical pattern analysis.",
"output": "∀x (ExtractingInformationFromBOLDSignals(x) → ¬WithoutStatisticalPatternAnalysis(x))"
},
{
"input": "Translate into first-order logic: Writing a novel is without statistical pattern analysis.",
"output": "∀x (WritingANovel(x) → WithoutStatisticalPatternAnalysis(x)) "
},
{
"input": "Translate into first-order logic: If multivoxel (pattern) analysis is without statistical pattern analysis and a brain reading, then multivoxel (pattern) analysis is without statistical pattern analysis and brain decoding.",
"output": "WithoutStatisticalPatternAnalysis(multivoxelPatternAnalysis) ∧ BrainReading(multivoxelPatternAnalysis) → WithoutStatisticalPatternAnalysis(multivoxelPatternAnalysis) ∧ BrainDecoding(multivoxelPatternAnalysis)"
},
{
"input": "Translate into first-order logic: Either brain reading or brain decoding.",
"output": "∀x (BrainReading(x) ∨ BrainDecoding(x)) "
},
{
"input": "Translate into first-order logic: All brain decoding is extracting information from BOLD signals.",
"output": "∀x (BrainDecoding(x) → ExtractingInformationFromBOLDSignals(x))"
},
{
"input": "Translate into first-order logic: No extracting information from BOLD signals is without statistical pattern analysis.",
"output": "∀x (ExtractingInformationFromBOLDSignals(x) → ¬WithoutStatisticalPatternAnalysis(x))"
},
{
"input": "Translate into first-order logic: Writing a novel is without statistical pattern analysis.",
"output": "∀x (WritingANovel(x) → WithoutStatisticalPatternAnalysis(x)) "
},
{
"input": "Translate into first-order logic: If multivoxel (pattern) analysis is without statistical pattern analysis and a brain reading, then multivoxel (pattern) analysis is without statistical pattern analysis and brain decoding.",
"output": "WithoutStatisticalPatternAnalysis(multivoxelPatternAnalysis) ∧ BrainReading(multivoxelPatternAnalysis) → WithoutStatisticalPatternAnalysis(multivoxelPatternAnalysis) ∧ BrainDecoding(multivoxelPatternAnalysis)"
},
{
"input": "Translate into first-order logic: Either brain reading or brain decoding.",
"output": "∀x (BrainReading(x) ∨ BrainDecoding(x)) "
},
{
"input": "Translate into first-order logic: All brain decoding is extracting information from BOLD signals.",
"output": "∀x (BrainDecoding(x) → ExtractingInformationFromBOLDSignals(x))"
},
{
"input": "Translate into first-order logic: No extracting information from BOLD signals is without statistical pattern analysis.",
"output": "∀x (ExtractingInformationFromBOLDSignals(x) → ¬WithoutStatisticalPatternAnalysis(x))"
},
{
"input": "Translate into first-order logic: Writing a novel is without statistical pattern analysis.",
"output": "∀x (WritingANovel(x) → WithoutStatisticalPatternAnalysis(x)) "
},
{
"input": "Translate into first-order logic: If multivoxel (pattern) analysis is without statistical pattern analysis and a brain reading, then multivoxel (pattern) analysis is without statistical pattern analysis and brain decoding.",
"output": "WithoutStatisticalPatternAnalysis(multivoxelPatternAnalysis) ∧ BrainReading(multivoxelPatternAnalysis) → WithoutStatisticalPatternAnalysis(multivoxelPatternAnalysis) ∧ BrainDecoding(multivoxelPatternAnalysis)"
},
{
"input": "Translate into first-order logic: Either brain reading or brain decoding.",
"output": "∀x (BrainReading(x) ∨ BrainDecoding(x)) "
},
{
"input": "Translate into first-order logic: All brain decoding is extracting information from BOLD signals.",
"output": "∀x (BrainDecoding(x) → ExtractingInformationFromBOLDSignals(x))"
},
{
"input": "Translate into first-order logic: No extracting information from BOLD signals is without statistical pattern analysis.",
"output": "∀x (ExtractingInformationFromBOLDSignals(x) → ¬WithoutStatisticalPatternAnalysis(x))"
},
{
"input": "Translate into first-order logic: Writing a novel is without statistical pattern analysis.",
"output": "∀x (WritingANovel(x) → WithoutStatisticalPatternAnalysis(x)) "
},
{
"input": "Translate into first-order logic: If multivoxel (pattern) analysis is without statistical pattern analysis and a brain reading, then multivoxel (pattern) analysis is without statistical pattern analysis and brain decoding.",
"output": "WithoutStatisticalPatternAnalysis(multivoxelPatternAnalysis) ∧ BrainReading(multivoxelPatternAnalysis) → WithoutStatisticalPatternAnalysis(multivoxelPatternAnalysis) ∧ BrainDecoding(multivoxelPatternAnalysis)"
},
{
"input": "Translate into first-order logic: Either brain reading or brain decoding.",
"output": "∀x (BrainReading(x) ∨ BrainDecoding(x)) "
},
{
"input": "Translate into first-order logic: All brain decoding is extracting information from BOLD signals.",
"output": "∀x (BrainDecoding(x) → ExtractingInformationFromBOLDSignals(x))"
},
{
"input": "Translate into first-order logic: No extracting information from BOLD signals is without statistical pattern analysis.",
"output": "∀x (ExtractingInformationFromBOLDSignals(x) → ¬WithoutStatisticalPatternAnalysis(x))"
},
{
"input": "Translate into first-order logic: Writing a novel is without statistical pattern analysis.",
"output": "∀x (WritingANovel(x) → WithoutStatisticalPatternAnalysis(x)) "
},
{
"input": "Translate into first-order logic: If multivoxel (pattern) analysis is without statistical pattern analysis and a brain reading, then multivoxel (pattern) analysis is without statistical pattern analysis and brain decoding.",
"output": "WithoutStatisticalPatternAnalysis(multivoxelPatternAnalysis) ∧ BrainReading(multivoxelPatternAnalysis) → WithoutStatisticalPatternAnalysis(multivoxelPatternAnalysis) ∧ BrainDecoding(multivoxelPatternAnalysis)"
},
{
"input": "Translate into first-order logic: If you have room for dessert, you have room for broccoli.",
"output": "∀x (RoomFor(x, dessert) → RoomFor(x, broccoli))"
},
{
"input": "Translate into first-order logic: Everyone at Luis's dinner party has room for dessert, including Luis.",
"output": "∀x (AtLuisParty(x) → RoomFor(x, dessert))"
},
{
"input": "Translate into first-order logic: Mauricia does not have room for broccoli.",
"output": "¬RoomFor(mauricia, broccoli)"
},
{
"input": "Translate into first-order logic: Luis's dinner party is the first ever dinner party that Allison has attended.",
"output": "FirstDinnerParty(allison, luisparty) ∧ AtLuisParty(allison)"
},
{
"input": "Translate into first-order logic: Gustave has room for both broccoli and asparagus.",
"output": "RoomFor(gustave, broccoli) ∧ RoomFor(gustave, asparagus)"
},
{
"input": "Translate into first-order logic: Broccoli and asparagus are both vegetables.",
"output": "Vegetable(broccoli) ∧ Vegetable(asparagus)"
},
{
"input": "Translate into first-order logic: If you have room for dessert, you have room for broccoli.",
"output": "∀x (RoomFor(x, dessert) → RoomFor(x, broccoli))"
},
{
"input": "Translate into first-order logic: Everyone at Luis's dinner party has room for dessert, including Luis.",
"output": "∀x (AtLuisParty(x) → RoomFor(x, dessert))"
},
{
"input": "Translate into first-order logic: Mauricia does not have room for broccoli.",
"output": "¬RoomFor(mauricia, broccoli)"
},
{
"input": "Translate into first-order logic: Luis's dinner party is the first ever dinner party that Allison has attended.",
"output": "FirstDinnerParty(allison, luisparty) ∧ AtLuisParty(allison)"
},
{
"input": "Translate into first-order logic: Gustave has room for both broccoli and asparagus.",
"output": "RoomFor(gustave, broccoli) ∧ RoomFor(gustave, asparagus)"
},
{
"input": "Translate into first-order logic: Broccoli and asparagus are both vegetables.",
"output": "Vegetable(broccoli) ∧ Vegetable(asparagus)"
},
{
"input": "Translate into first-order logic: If you have room for dessert, you have room for broccoli.",
"output": "∀x (RoomFor(x, dessert) → RoomFor(x, broccoli))"
},
{
"input": "Translate into first-order logic: Everyone at Luis's dinner party has room for dessert, including Luis.",
"output": "∀x (AtLuisParty(x) → RoomFor(x, dessert))"
},
{
"input": "Translate into first-order logic: Mauricia does not have room for broccoli.",
"output": "¬RoomFor(mauricia, broccoli)"
},
{
"input": "Translate into first-order logic: Luis's dinner party is the first ever dinner party that Allison has attended.",
"output": "FirstDinnerParty(allison, luisparty) ∧ AtLuisParty(allison)"
},
{
"input": "Translate into first-order logic: Gustave has room for both broccoli and asparagus.",
"output": "RoomFor(gustave, broccoli) ∧ RoomFor(gustave, asparagus)"
},
{
"input": "Translate into first-order logic: Broccoli and asparagus are both vegetables.",
"output": "Vegetable(broccoli) ∧ Vegetable(asparagus)"
},
{
"input": "Translate into first-order logic: Imagine Dragons is an American pop rock band.",
"output": "American(imagineDragon) ∧ RockBand(imagineDragon)"
},
{
"input": "Translate into first-order logic: The lead singer of Imagine Dragons is Dan.",
"output": "LeadSinger(imagineDragon, dan)"
},
{
"input": "Translate into first-order logic: Dan is also a songwriter.",
"output": "SongWriter(dan)"
},
{
"input": "Translate into first-order logic: All lead singers are singers.",
"output": "∀x ∀y (LeadSinger(x, y) → Singer(y))"
},
{
"input": "Translate into first-order logic: All singers are musicians.",
"output": "∀x (Singer(x) → Musician(x))"
},
{
"input": "Translate into first-order logic: Demons is one of the most popular singles of Imagine Dragons.",
"output": "PopularSingle(imagineDragon, demons)"
},
{
"input": "Translate into first-order logic: Some singles of Imagine Dragons have been on Billboard Hot 100.",
"output": "∃x (PopularSingle(imagineDragon, x) ∧ BillboardHot100(x))"
},
{
"input": "Translate into first-order logic: Imagine Dragons is an American pop rock band.",
"output": "American(imagineDragon) ∧ RockBand(imagineDragon)"
},
{
"input": "Translate into first-order logic: The lead singer of Imagine Dragons is Dan.",
"output": "LeadSinger(imagineDragon, dan)"
},
{
"input": "Translate into first-order logic: Dan is also a songwriter.",
"output": "SongWriter(dan)"
},
{
"input": "Translate into first-order logic: All lead singers are singers.",
"output": "∀x ∀y (LeadSinger(x, y) → Singer(y))"
},
{
"input": "Translate into first-order logic: All singers are musicians.",
"output": "∀x (Singer(x) → Musician(x))"
},
{
"input": "Translate into first-order logic: Demons is one of the most popular singles of Imagine Dragons.",
"output": "PopularSingle(imagineDragon, demons)"
},
{
"input": "Translate into first-order logic: Some singles of Imagine Dragons have been on Billboard Hot 100.",
"output": "∃x (PopularSingle(imagineDragon, x) ∧ BillboardHot100(x))"
},
{
"input": "Translate into first-order logic: Imagine Dragons is an American pop rock band.",
"output": "American(imagineDragon) ∧ RockBand(imagineDragon)"
},
{
"input": "Translate into first-order logic: The lead singer of Imagine Dragons is Dan.",
"output": "LeadSinger(imagineDragon, dan)"
},
{
"input": "Translate into first-order logic: Dan is also a songwriter.",
"output": "SongWriter(dan)"
},
{
"input": "Translate into first-order logic: All lead singers are singers.",
"output": "∀x ∀y (LeadSinger(x, y) → Singer(y))"
},
{
"input": "Translate into first-order logic: All singers are musicians.",
"output": "∀x (Singer(x) → Musician(x))"
},
{
"input": "Translate into first-order logic: Demons is one of the most popular singles of Imagine Dragons.",
"output": "PopularSingle(imagineDragon, demons)"
},
{
"input": "Translate into first-order logic: Some singles of Imagine Dragons have been on Billboard Hot 100.",
"output": "∃x (PopularSingle(imagineDragon, x) ∧ BillboardHot100(x))"
},
{
"input": "Translate into first-order logic: All bread is food.",
"output": "∀x (Bread(x) → Food(x))"
},
{
"input": "Translate into first-order logic: Some sandwiches are bread.",
"output": "∃x (Sandwich(x) ∧ Bread(x))"
},
{
"input": "Translate into first-order logic: All food is edible.",
"output": "∀x (Food(x) → Edible(x))"
},
{
"input": "Translate into first-order logic: No edible things are poisonous.",
"output": "∀x (Edible(x) → ¬Poisonous(x))"
},
{
"input": "Translate into first-order logic: Deodorant is poisonous.",
"output": "Poisonous(deodorant)"
},
{
"input": "Translate into first-order logic: All bread is food.",
"output": "∀x (Bread(x) → Food(x))"
},
{
"input": "Translate into first-order logic: Some sandwiches are bread.",
"output": "∃x (Sandwich(x) ∧ Bread(x))"
},
{
"input": "Translate into first-order logic: All food is edible.",
"output": "∀x (Food(x) → Edible(x))"
},
{
"input": "Translate into first-order logic: No edible things are poisonous.",
"output": "∀x (Edible(x) → ¬Poisonous(x))"
},
{
"input": "Translate into first-order logic: Deodorant is poisonous.",
"output": "Poisonous(deodorant)"
},
{
"input": "Translate into first-order logic: All bread is food.",
"output": "∀x (Bread(x) → Food(x))"
},
{
"input": "Translate into first-order logic: Some sandwiches are bread.",
"output": "∃x (Sandwich(x) ∧ Bread(x))"
},
{
"input": "Translate into first-order logic: All food is edible.",
"output": "∀x (Food(x) → Edible(x))"
},
{
"input": "Translate into first-order logic: No edible things are poisonous.",
"output": "∀x (Edible(x) → ¬Poisonous(x))"
},
{
"input": "Translate into first-order logic: Deodorant is poisonous.",
"output": "Poisonous(deodorant)"
},
{
"input": "Translate into first-order logic: Common utilities include water, electricity, gas, heating, sewer, trash, and recycling.",
"output": "CommonUtilities(water) ∧ CommonUtilities(electricity) ∧ CommonUtilities(gas) ∧ CommonUtilities(heating)"
},
{
"input": "Translate into first-order logic: Many apartment rents cover the cost of water and electricity.",
"output": "∃x (Cover(x, water) ∧ Cover(x, electricity))"
},
{
"input": "Translate into first-order logic: Susan lives in an apartment where the rent covers all utilities.",
"output": "∀x (Cover(susan, x))"
},
{
"input": "Translate into first-order logic: The rent of the apartment where Ava lives does not cover any utility expenses.",
"output": "∀x (¬Cover(ava, x))"
},
{
"input": "Translate into first-order logic: Noah lives in an apartment where the rent does not cover heating.",
"output": "¬Cover(noah, heating)"
},
{
"input": "Translate into first-order logic: Common utilities include water, electricity, gas, heating, sewer, trash, and recycling.",
"output": "CommonUtilities(water) ∧ CommonUtilities(electricity) ∧ CommonUtilities(gas) ∧ CommonUtilities(heating)"
},
{
"input": "Translate into first-order logic: Many apartment rents cover the cost of water and electricity.",
"output": "∃x (Cover(x, water) ∧ Cover(x, electricity))"
},
{
"input": "Translate into first-order logic: Susan lives in an apartment where the rent covers all utilities.",
"output": "∀x (Cover(susan, x))"
},
{
"input": "Translate into first-order logic: The rent of the apartment where Ava lives does not cover any utility expenses.",
"output": "∀x (¬Cover(ava, x))"
},
{
"input": "Translate into first-order logic: Noah lives in an apartment where the rent does not cover heating.",
"output": "¬Cover(noah, heating)"
},
{
"input": "Translate into first-order logic: Common utilities include water, electricity, gas, heating, sewer, trash, and recycling.",
"output": "CommonUtilities(water) ∧ CommonUtilities(electricity) ∧ CommonUtilities(gas) ∧ CommonUtilities(heating)"
},
{
"input": "Translate into first-order logic: Many apartment rents cover the cost of water and electricity.",
"output": "∃x (Cover(x, water) ∧ Cover(x, electricity))"
},
{
"input": "Translate into first-order logic: Susan lives in an apartment where the rent covers all utilities.",
"output": "∀x (Cover(susan, x))"
},
{
"input": "Translate into first-order logic: The rent of the apartment where Ava lives does not cover any utility expenses.",
"output": "∀x (¬Cover(ava, x))"
},
{
"input": "Translate into first-order logic: Noah lives in an apartment where the rent does not cover heating.",
"output": "¬Cover(noah, heating)"
},
{
"input": "Translate into first-order logic: All clothes are products.",
"output": "∀x (Clothes(x) → Product(x))"
},
{
"input": "Translate into first-order logic: No products are perfect.",
"output": "∀x (Product(x) → ¬Perfect(x))"
},
{
"input": "Translate into first-order logic: All dresses are clothes.",
"output": "∀x (Dress(x) → Clothes(x))"
},
{
"input": "Translate into first-order logic: All skirts are dresses.",
"output": "∀x (Skirt(x) → Dress(x))"
},
{
"input": "Translate into first-order logic: If Nike is clothes, then Nike is perfect and a dress.",
"output": "Clothes(nike) → Perfect(nike) ∧ Dress(nike)"
},
{
"input": "Translate into first-order logic: All clothes are products.",
"output": "∀x (Clothes(x) → Product(x))"
},
{
"input": "Translate into first-order logic: No products are perfect.",
"output": "∀x (Product(x) → ¬Perfect(x))"
},
{
"input": "Translate into first-order logic: All dresses are clothes.",
"output": "∀x (Dress(x) → Clothes(x))"
},
{
"input": "Translate into first-order logic: All skirts are dresses.",
"output": "∀x (Skirt(x) → Dress(x))"
},
{
"input": "Translate into first-order logic: If Nike is clothes, then Nike is perfect and a dress.",
"output": "Clothes(nike) → Perfect(nike) ∧ Dress(nike)"
},
{
"input": "Translate into first-order logic: All clothes are products.",
"output": "∀x (Clothes(x) → Product(x))"
},
{
"input": "Translate into first-order logic: No products are perfect.",
"output": "∀x (Product(x) → ¬Perfect(x))"
},
{
"input": "Translate into first-order logic: All dresses are clothes.",
"output": "∀x (Dress(x) → Clothes(x))"
},
{
"input": "Translate into first-order logic: All skirts are dresses.",
"output": "∀x (Skirt(x) → Dress(x))"
},
{
"input": "Translate into first-order logic: If Nike is clothes, then Nike is perfect and a dress.",
"output": "Clothes(nike) → Perfect(nike) ∧ Dress(nike)"
},
{
"input": "Translate into first-order logic: All pets are animals.",
"output": "∀x (Pet(x) → Animal(x))"
},
{
"input": "Translate into first-order logic: Pets can be either a dog or a cat.",
"output": "∀x (Pet(x) → Dog(x) ⊕ Cat(x))"
},
{
"input": "Translate into first-order logic: If a person has a pet, they care for that pet.",
"output": "∀x ∀y (HasPet(x) → Cares(x, y))"
},
{
"input": "Translate into first-order logic: Dogs and Cats can be naughty.",
"output": "∃x ((Cat(x) ∧ Naughty(x)) ∨ (Dog(x) ∧ Naughty(x)))"
},
{
"input": "Translate into first-order logic: Pets who are naughty are not liked as much.",
"output": "∀x ∀y (Pet(x) ∧ Naughty(x) → ¬Liked(x, y))"
},
{
"input": "Translate into first-order logic: Charlie has a naughty pet dog named Leo.",
"output": "HasPet(charlie) ∧ Pet(leo) ∧ Dog(leo) ∧ Naughty(leo)"
},
{
"input": "Translate into first-order logic: All pets are animals.",
"output": "∀x (Pet(x) → Animal(x))"
},
{
"input": "Translate into first-order logic: Pets can be either a dog or a cat.",
"output": "∀x (Pet(x) → Dog(x) ⊕ Cat(x))"
},
{
"input": "Translate into first-order logic: If a person has a pet, they care for that pet.",
"output": "∀x ∀y (HasPet(x) → Cares(x, y))"
},
{
"input": "Translate into first-order logic: Dogs and Cats can be naughty.",
"output": "∃x ((Cat(x) ∧ Naughty(x)) ∨ (Dog(x) ∧ Naughty(x)))"
},
{
"input": "Translate into first-order logic: Pets who are naughty are not liked as much.",
"output": "∀x ∀y (Pet(x) ∧ Naughty(x) → ¬Liked(x, y))"
},
{
"input": "Translate into first-order logic: Charlie has a naughty pet dog named Leo.",
"output": "HasPet(charlie) ∧ Pet(leo) ∧ Dog(leo) ∧ Naughty(leo)"
},
{
"input": "Translate into first-order logic: All pets are animals.",
"output": "∀x (Pet(x) → Animal(x))"
},
{
"input": "Translate into first-order logic: Pets can be either a dog or a cat.",
"output": "∀x (Pet(x) → Dog(x) ⊕ Cat(x))"
},
{
"input": "Translate into first-order logic: If a person has a pet, they care for that pet.",
"output": "∀x ∀y (HasPet(x) → Cares(x, y))"
},
{
"input": "Translate into first-order logic: Dogs and Cats can be naughty.",
"output": "∃x ((Cat(x) ∧ Naughty(x)) ∨ (Dog(x) ∧ Naughty(x)))"
},
{
"input": "Translate into first-order logic: Pets who are naughty are not liked as much.",
"output": "∀x ∀y (Pet(x) ∧ Naughty(x) → ¬Liked(x, y))"
},
{
"input": "Translate into first-order logic: Charlie has a naughty pet dog named Leo.",
"output": "HasPet(charlie) ∧ Pet(leo) ∧ Dog(leo) ∧ Naughty(leo)"
},
{
"input": "Translate into first-order logic: Surprises are either fun or dreadful.",
"output": "∀x (Surprise(x) → (Fun(x) ⊕ Dreadful(x)))"
},
{
"input": "Translate into first-order logic: All scares are surprises.",
"output": "∀x (Scare(x) → Surprise(x))"
},
{
"input": "Translate into first-order logic: All books written by Cixin Liu have sold more than 1 million copies.",
"output": "∀x (Book(x) ∧ WrittenBy(x, cixinliu) → SoldMoreThan(x, onemillion))"
},
{
"input": "Translate into first-order logic: Some books that have won the Hugo Award were written by Cixin Liu.",
"output": "∃x (Won(x, hugoaward) ∧ Book(x) ∧ WrittenBy(x, cixinliu))"
},
{
"input": "Translate into first-order logic: All books about the future are influenced by Isaac Asimov.",
"output": "∀x (Book(x) ∧ AboutFuture(x) → InfluencedBy(x, isaacasimov))"
},
{
"input": "Translate into first-order logic: The book the Three Body Problem has sold more than 1 million copies.",
"output": "Book(threebodyproblem) ∧ SoldMoreThan(threebodyproblem, onemillion)"
},
{
"input": "Translate into first-order logic: The Three Body Problem is about the future.",
"output": "AboutFuture(threebodyproblem)"
},
{
"input": "Translate into first-order logic: All books written by Cixin Liu have sold more than 1 million copies.",
"output": "∀x (Book(x) ∧ WrittenBy(x, cixinliu) → SoldMoreThan(x, onemillion))"
},
{
"input": "Translate into first-order logic: Some books that have won the Hugo Award were written by Cixin Liu.",
"output": "∃x (Won(x, hugoaward) ∧ Book(x) ∧ WrittenBy(x, cixinliu))"
},
{
"input": "Translate into first-order logic: All books about the future are influenced by Isaac Asimov.",
"output": "∀x (Book(x) ∧ AboutFuture(x) → InfluencedBy(x, isaacasimov))"
},
{
"input": "Translate into first-order logic: The book the Three Body Problem has sold more than 1 million copies.",
"output": "Book(threebodyproblem) ∧ SoldMoreThan(threebodyproblem, onemillion)"
},
{
"input": "Translate into first-order logic: The Three Body Problem is about the future.",
"output": "AboutFuture(threebodyproblem)"
},
{
"input": "Translate into first-order logic: All books written by Cixin Liu have sold more than 1 million copies.",
"output": "∀x (Book(x) ∧ WrittenBy(x, cixinliu) → SoldMoreThan(x, onemillion))"
},
{
"input": "Translate into first-order logic: Some books that have won the Hugo Award were written by Cixin Liu.",
"output": "∃x (Won(x, hugoaward) ∧ Book(x) ∧ WrittenBy(x, cixinliu))"
},
{
"input": "Translate into first-order logic: All books about the future are influenced by Isaac Asimov.",
"output": "∀x (Book(x) ∧ AboutFuture(x) → InfluencedBy(x, isaacasimov))"
},
{
"input": "Translate into first-order logic: The book the Three Body Problem has sold more than 1 million copies.",
"output": "Book(threebodyproblem) ∧ SoldMoreThan(threebodyproblem, onemillion)"
},
{
"input": "Translate into first-order logic: The Three Body Problem is about the future.",
"output": "AboutFuture(threebodyproblem)"
},
{
"input": "Translate into first-order logic: Some students who major in computer science get up early.",
"output": "∃x (ComputerScience(x) ∧ GetUpEarly(x))"
},
{
"input": "Translate into first-order logic: If a student gets up early, then he/she will study in the morning.",
"output": "∀x (GetUpEarly(x) → StudyMorning(x))"
},
{
"input": "Translate into first-order logic: All students studying in the morning are good at time management.",
"output": "∀x (StudyMorning(x) → GoodAtTimeManagement(x))"
},
{
"input": "Translate into first-order logic: All students good at time management are popular among students.",
"output": "∀x (GoodAtTimeManagement(x) → Popular(x))"
},
{
"input": "Translate into first-order logic: James is not popular among students.",
"output": "¬Popular(james)"
},
{
"input": "Translate into first-order logic: Some students who major in computer science get up early.",
"output": "∃x (ComputerScience(x) ∧ GetUpEarly(x))"
},
{
"input": "Translate into first-order logic: If a student gets up early, then he/she will study in the morning.",
"output": "∀x (GetUpEarly(x) → StudyMorning(x))"
},
{
"input": "Translate into first-order logic: All students studying in the morning are good at time management.",
"output": "∀x (StudyMorning(x) → GoodAtTimeManagement(x))"
},
{
"input": "Translate into first-order logic: All students good at time management are popular among students.",
"output": "∀x (GoodAtTimeManagement(x) → Popular(x))"
},
{
"input": "Translate into first-order logic: James is not popular among students.",
"output": "¬Popular(james)"
},
{
"input": "Translate into first-order logic: Some students who major in computer science get up early.",
"output": "∃x (ComputerScience(x) ∧ GetUpEarly(x))"
},
{
"input": "Translate into first-order logic: If a student gets up early, then he/she will study in the morning.",
"output": "∀x (GetUpEarly(x) → StudyMorning(x))"
},
{
"input": "Translate into first-order logic: All students studying in the morning are good at time management.",
"output": "∀x (StudyMorning(x) → GoodAtTimeManagement(x))"
},
{
"input": "Translate into first-order logic: All students good at time management are popular among students.",
"output": "∀x (GoodAtTimeManagement(x) → Popular(x))"
},
{
"input": "Translate into first-order logic: James is not popular among students.",
"output": "¬Popular(james)"
},
{
"input": "Translate into first-order logic: There is no dog on the roof.",
"output": "¬(∃x (Dog(x) ∧ OnRoof(x)))"
},
{
"input": "Translate into first-order logic: If there is a dog on the roof something went wrong.",
"output": "∀x ∃y ((Dog(x) ∧ OnRoof(x)) → WentWrong(y))"
},
{
"input": "Translate into first-order logic: Elephantopus is a genus of perennial plants in the daisy family.",
"output": "∀x (Elephantopus(x) → Genus(x, perennialplants) ∧ BelongTo(x, daisyfamily))"
},
{
"input": "Translate into first-order logic: Elephantopus is widespread over much of Africa, southern Asia, Australia, and the Americas.",
"output": "∀x (Elephantopus(x) → WidespreadOver(x, africa) ∧ WidespreadOver(x, southernasia) ∧ WidespreadOver(x, australia) ∧ WidespreadOver(x, americas))"
},
{
"input": "Translate into first-order logic: Several species of Elephantopus are native to the southeastern United States.",
"output": "∃x (Elephantopus(x) ∧ NativeTo(x, southeasternunitedstates))"
},
{
"input": "Translate into first-order logic: Elephantopus scaber is a traditional medicine.",
"output": "∀x (ElephantopusScaber(x) → TraditionalMedicine(x))"
},
{
"input": "Translate into first-order logic: Elephantopus is a genus of perennial plants in the daisy family.",
"output": "∀x (Elephantopus(x) → Genus(x, perennialplants) ∧ BelongTo(x, daisyfamily))"
},
{
"input": "Translate into first-order logic: Elephantopus is widespread over much of Africa, southern Asia, Australia, and the Americas.",
"output": "∀x (Elephantopus(x) → WidespreadOver(x, africa) ∧ WidespreadOver(x, southernasia) ∧ WidespreadOver(x, australia) ∧ WidespreadOver(x, americas))"
},
{
"input": "Translate into first-order logic: Several species of Elephantopus are native to the southeastern United States.",
"output": "∃x (Elephantopus(x) ∧ NativeTo(x, southeasternunitedstates))"
},
{
"input": "Translate into first-order logic: Elephantopus scaber is a traditional medicine.",
"output": "∀x (ElephantopusScaber(x) → TraditionalMedicine(x))"
},
{
"input": "Translate into first-order logic: Elephantopus is a genus of perennial plants in the daisy family.",
"output": "∀x (Elephantopus(x) → Genus(x, perennialplants) ∧ BelongTo(x, daisyfamily))"
},
{
"input": "Translate into first-order logic: Elephantopus is widespread over much of Africa, southern Asia, Australia, and the Americas.",
"output": "∀x (Elephantopus(x) → WidespreadOver(x, africa) ∧ WidespreadOver(x, southernasia) ∧ WidespreadOver(x, australia) ∧ WidespreadOver(x, americas))"
},
{
"input": "Translate into first-order logic: Several species of Elephantopus are native to the southeastern United States.",
"output": "∃x (Elephantopus(x) ∧ NativeTo(x, southeasternunitedstates))"
},
{
"input": "Translate into first-order logic: Elephantopus scaber is a traditional medicine.",
"output": "∀x (ElephantopusScaber(x) → TraditionalMedicine(x))"
},
{
"input": "Translate into first-order logic: All Yale dormitories are located on York Street.",
"output": "∀x (YaleDormitory(x) → InYorkStreet(x))"
},
{
"input": "Translate into first-order logic: All buildings managed by Yale Housing are dormitories.",
"output": "∀x (ManagedByYaleHousing(x) → YaleDormitory(x))"
},
{
"input": "Translate into first-order logic: All buildings operated by Yale Housing staff are managed by Yale Housing.",
"output": "∀x (OperatedByYaleHousingStaffs(x) → ManagedByYaleHousing(x))"
},
{
"input": "Translate into first-order logic: No buildings open to students are established after 1800.",
"output": "∀x (OpenToStudents(x) → ¬EstablishedAfter1800(x))"
},
{
"input": "Translate into first-order logic: All buildings located on York Street are open to students.",
"output": "∀x (InYorkStreet(x) → OpenToStudents(x))"
},
{
"input": "Translate into first-order logic: Harkness is either a building operated by Yale Housing staff or located on York Street.",
"output": "OperatedByYaleHousingStaffs(harkness) ⊕ InYorkStreet(harkness)"
},
{
"input": "Translate into first-order logic: All Yale dormitories are located on York Street.",
"output": "∀x (YaleDormitory(x) → InYorkStreet(x))"
},
{
"input": "Translate into first-order logic: All buildings managed by Yale Housing are dormitories.",
"output": "∀x (ManagedByYaleHousing(x) → YaleDormitory(x))"
},
{
"input": "Translate into first-order logic: All buildings operated by Yale Housing staff are managed by Yale Housing.",
"output": "∀x (OperatedByYaleHousingStaffs(x) → ManagedByYaleHousing(x))"
},
{
"input": "Translate into first-order logic: No buildings open to students are established after 1800.",
"output": "∀x (OpenToStudents(x) → ¬EstablishedAfter1800(x))"
},
{
"input": "Translate into first-order logic: All buildings located on York Street are open to students.",
"output": "∀x (InYorkStreet(x) → OpenToStudents(x))"
},
{
"input": "Translate into first-order logic: Harkness is either a building operated by Yale Housing staff or located on York Street.",
"output": "OperatedByYaleHousingStaffs(harkness) ⊕ InYorkStreet(harkness)"
},
{
"input": "Translate into first-order logic: All Yale dormitories are located on York Street.",
"output": "∀x (YaleDormitory(x) → InYorkStreet(x))"
},
{
"input": "Translate into first-order logic: All buildings managed by Yale Housing are dormitories.",
"output": "∀x (ManagedByYaleHousing(x) → YaleDormitory(x))"
},
{
"input": "Translate into first-order logic: All buildings operated by Yale Housing staff are managed by Yale Housing.",
"output": "∀x (OperatedByYaleHousingStaffs(x) → ManagedByYaleHousing(x))"
},
{
"input": "Translate into first-order logic: No buildings open to students are established after 1800.",
"output": "∀x (OpenToStudents(x) → ¬EstablishedAfter1800(x))"
},
{
"input": "Translate into first-order logic: All buildings located on York Street are open to students.",
"output": "∀x (InYorkStreet(x) → OpenToStudents(x))"
},
{
"input": "Translate into first-order logic: Harkness is either a building operated by Yale Housing staff or located on York Street.",
"output": "OperatedByYaleHousingStaffs(harkness) ⊕ InYorkStreet(harkness)"
},
{
"input": "Translate into first-order logic: All Yale dormitories are located on York Street.",
"output": "∀x (YaleDormitory(x) → InYorkStreet(x))"
},
{
"input": "Translate into first-order logic: All buildings managed by Yale Housing are dormitories.",
"output": "∀x (ManagedByYaleHousing(x) → YaleDormitory(x))"
},
{
"input": "Translate into first-order logic: All buildings operated by Yale Housing staff are managed by Yale Housing.",
"output": "∀x (OperatedByYaleHousingStaffs(x) → ManagedByYaleHousing(x))"
},
{
"input": "Translate into first-order logic: No buildings open to students are established after 1800.",
"output": "∀x (OpenToStudents(x) → ¬EstablishedAfter1800(x))"
},
{
"input": "Translate into first-order logic: All buildings located on York Street are open to students.",
"output": "∀x (InYorkStreet(x) → OpenToStudents(x))"
},
{
"input": "Translate into first-order logic: Harkness is either a building operated by Yale Housing staff or located on York Street.",
"output": "OperatedByYaleHousingStaffs(harkness) ⊕ InYorkStreet(harkness)"
},
{
"input": "Translate into first-order logic: There are no mansion houses in an urban area.",
"output": "∀x (UrbanArea(x) → ¬MansionHouse(x))"
},
{
"input": "Translate into first-order logic: All skyscrapers reside in urban areas.",
"output": "∀x (Skyscraper(x) → UrbanArea(x))"
},
{
"input": "Translate into first-order logic: Every creepy haunted house is in a mansion house.",
"output": "∀x (CreepyHauntedHouse(x) → MansionHouse(x))"
},
{
"input": "Translate into first-order logic: Every terrifying Halloween scare comes from a creepy haunted house.",
"output": "∀x (TerrifyingHalloweenScare(x) → CreepyHauntedHouse(x))"
},
{
"input": "Translate into first-order logic: The Scream is a creepy haunted house or a terrifying Halloween scare.",
"output": "CreepyHauntedHouse(thescream) ∨ TerrifyingHalloweenScare(thescream)"
},
{
"input": "Translate into first-order logic: There are no mansion houses in an urban area.",
"output": "∀x (UrbanArea(x) → ¬MansionHouse(x))"
},
{
"input": "Translate into first-order logic: All skyscrapers reside in urban areas.",
"output": "∀x (Skyscraper(x) → UrbanArea(x))"
},
{
"input": "Translate into first-order logic: Every creepy haunted house is in a mansion house.",
"output": "∀x (CreepyHauntedHouse(x) → MansionHouse(x))"
},
{
"input": "Translate into first-order logic: Every terrifying Halloween scare comes from a creepy haunted house.",
"output": "∀x (TerrifyingHalloweenScare(x) → CreepyHauntedHouse(x))"
},
{
"input": "Translate into first-order logic: The Scream is a creepy haunted house or a terrifying Halloween scare.",
"output": "CreepyHauntedHouse(thescream) ∨ TerrifyingHalloweenScare(thescream)"
},
{
"input": "Translate into first-order logic: There are no mansion houses in an urban area.",
"output": "∀x (UrbanArea(x) → ¬MansionHouse(x))"
},
{
"input": "Translate into first-order logic: All skyscrapers reside in urban areas.",
"output": "∀x (Skyscraper(x) → UrbanArea(x))"
},
{
"input": "Translate into first-order logic: Every creepy haunted house is in a mansion house.",
"output": "∀x (CreepyHauntedHouse(x) → MansionHouse(x))"
},
{
"input": "Translate into first-order logic: Every terrifying Halloween scare comes from a creepy haunted house.",
"output": "∀x (TerrifyingHalloweenScare(x) → CreepyHauntedHouse(x))"
},
{
"input": "Translate into first-order logic: The Scream is a creepy haunted house or a terrifying Halloween scare.",
"output": "CreepyHauntedHouse(thescream) ∨ TerrifyingHalloweenScare(thescream)"
},
{
"input": "Translate into first-order logic: There are no mansion houses in an urban area.",
"output": "∀x (UrbanArea(x) → ¬MansionHouse(x))"
},
{
"input": "Translate into first-order logic: All skyscrapers reside in urban areas.",
"output": "∀x (Skyscraper(x) → UrbanArea(x))"
},
{
"input": "Translate into first-order logic: Every creepy haunted house is in a mansion house.",
"output": "∀x (CreepyHauntedHouse(x) → MansionHouse(x))"
},
{
"input": "Translate into first-order logic: Every terrifying Halloween scare comes from a creepy haunted house.",
"output": "∀x (TerrifyingHalloweenScare(x) → CreepyHauntedHouse(x))"
},
{
"input": "Translate into first-order logic: The Scream is a creepy haunted house or a terrifying Halloween scare.",
"output": "CreepyHauntedHouse(thescream) ∨ TerrifyingHalloweenScare(thescream)"
},
{
"input": "Translate into first-order logic: There are no mansion houses in an urban area.",
"output": "∀x (UrbanArea(x) → ¬MansionHouse(x))"
},
{
"input": "Translate into first-order logic: All skyscrapers reside in urban areas.",
"output": "∀x (Skyscraper(x) → UrbanArea(x))"
},
{
"input": "Translate into first-order logic: Every creepy haunted house is in a mansion house.",
"output": "∀x (CreepyHauntedHouse(x) → MansionHouse(x))"
},
{
"input": "Translate into first-order logic: Every terrifying Halloween scare comes from a creepy haunted house.",
"output": "∀x (TerrifyingHalloweenScare(x) → CreepyHauntedHouse(x))"
},
{
"input": "Translate into first-order logic: The Scream is a creepy haunted house or a terrifying Halloween scare.",
"output": "CreepyHauntedHouse(thescream) ∨ TerrifyingHalloweenScare(thescream)"
},
{
"input": "Translate into first-order logic: There are no mansion houses in an urban area.",
"output": "∀x (UrbanArea(x) → ¬MansionHouse(x))"
},
{
"input": "Translate into first-order logic: All skyscrapers reside in urban areas.",
"output": "∀x (Skyscraper(x) → UrbanArea(x))"
},
{
"input": "Translate into first-order logic: Every creepy haunted house is in a mansion house.",
"output": "∀x (CreepyHauntedHouse(x) → MansionHouse(x))"
},
{
"input": "Translate into first-order logic: Every terrifying Halloween scare comes from a creepy haunted house.",
"output": "∀x (TerrifyingHalloweenScare(x) → CreepyHauntedHouse(x))"
},
{
"input": "Translate into first-order logic: The Scream is a creepy haunted house or a terrifying Halloween scare.",
"output": "CreepyHauntedHouse(thescream) ∨ TerrifyingHalloweenScare(thescream)"
},
{
"input": "Translate into first-order logic: There are no mansion houses in an urban area.",
"output": "∀x (UrbanArea(x) → ¬MansionHouse(x))"
},
{
"input": "Translate into first-order logic: All skyscrapers reside in urban areas.",
"output": "∀x (Skyscraper(x) → UrbanArea(x))"
},
{
"input": "Translate into first-order logic: Every creepy haunted house is in a mansion house.",
"output": "∀x (CreepyHauntedHouse(x) → MansionHouse(x))"
},
{
"input": "Translate into first-order logic: Every terrifying Halloween scare comes from a creepy haunted house.",
"output": "∀x (TerrifyingHalloweenScare(x) → CreepyHauntedHouse(x))"
},
{
"input": "Translate into first-order logic: The Scream is a creepy haunted house or a terrifying Halloween scare.",
"output": "CreepyHauntedHouse(thescream) ∨ TerrifyingHalloweenScare(thescream)"
},
{
"input": "Translate into first-order logic: There are no mansion houses in an urban area.",
"output": "∀x (UrbanArea(x) → ¬MansionHouse(x))"
},
{
"input": "Translate into first-order logic: All skyscrapers reside in urban areas.",
"output": "∀x (Skyscraper(x) → UrbanArea(x))"
},
{
"input": "Translate into first-order logic: Every creepy haunted house is in a mansion house.",
"output": "∀x (CreepyHauntedHouse(x) → MansionHouse(x))"
},
{
"input": "Translate into first-order logic: Every terrifying Halloween scare comes from a creepy haunted house.",
"output": "∀x (TerrifyingHalloweenScare(x) → CreepyHauntedHouse(x))"
},
{
"input": "Translate into first-order logic: The Scream is a creepy haunted house or a terrifying Halloween scare.",
"output": "CreepyHauntedHouse(thescream) ∨ TerrifyingHalloweenScare(thescream)"
},
{
"input": "Translate into first-order logic: There are no mansion houses in an urban area.",
"output": "∀x (UrbanArea(x) → ¬MansionHouse(x))"
},
{
"input": "Translate into first-order logic: All skyscrapers reside in urban areas.",
"output": "∀x (Skyscraper(x) → UrbanArea(x))"
},
{
"input": "Translate into first-order logic: Every creepy haunted house is in a mansion house.",
"output": "∀x (CreepyHauntedHouse(x) → MansionHouse(x))"
},
{
"input": "Translate into first-order logic: Every terrifying Halloween scare comes from a creepy haunted house.",
"output": "∀x (TerrifyingHalloweenScare(x) → CreepyHauntedHouse(x))"
},
{
"input": "Translate into first-order logic: The Scream is a creepy haunted house or a terrifying Halloween scare.",
"output": "CreepyHauntedHouse(thescream) ∨ TerrifyingHalloweenScare(thescream)"
},
{
"input": "Translate into first-order logic: There are no mansion houses in an urban area.",
"output": "∀x (UrbanArea(x) → ¬MansionHouse(x))"
},
{
"input": "Translate into first-order logic: All skyscrapers reside in urban areas.",
"output": "∀x (Skyscraper(x) → UrbanArea(x))"
},
{
"input": "Translate into first-order logic: Every creepy haunted house is in a mansion house.",
"output": "∀x (CreepyHauntedHouse(x) → MansionHouse(x))"
},
{
"input": "Translate into first-order logic: Every terrifying Halloween scare comes from a creepy haunted house.",
"output": "∀x (TerrifyingHalloweenScare(x) → CreepyHauntedHouse(x))"
},
{
"input": "Translate into first-order logic: The Scream is a creepy haunted house or a terrifying Halloween scare.",
"output": "CreepyHauntedHouse(thescream) ∨ TerrifyingHalloweenScare(thescream)"
},
{
"input": "Translate into first-order logic: Phuoc Binh national park is a national park in Vietnam.",
"output": "NationalPark(phuocBinh) ∧ Locatedin(phuocBinh, vietnam)"
},
{
"input": "Translate into first-order logic: Any national park in Vietnam is classified as a nature reserve.",
"output": "∀x (NationalPark(x) ∧ Locatedin(x, vietnam) → NatureReserve(x))"
},
{
"input": "Translate into first-order logic: There is a national park in Vietnam classified as a UNESCO World Heritage Site.",
"output": "∃x (NationalPark(x) ∧ Locatedin(x, vietnam) ∧ UNESCOWorldHeritageSite(x))"
},
{
"input": "Translate into first-order logic: All national parks in Vietnam are either managed by the Ministry of Agriculture or by the People's Committee.",
"output": "∀x (NationalPark(x) ∧ Locatedin(x, vietnam) → Mangedby(x, ministryofAgriculture) ∨ Mangedby(x, peoplesCommittee))"
},
{
"input": "Translate into first-order logic: Phuoc Binh is not managed by the Ministry of Agriculture.",
"output": "¬Mangedby(phuocBinh, ministryofAgriculture)"
},
{
"input": "Translate into first-order logic: Phuoc Binh national park is a national park in Vietnam.",
"output": "NationalPark(phuocBinh) ∧ Locatedin(phuocBinh, vietnam)"
},
{
"input": "Translate into first-order logic: Any national park in Vietnam is classified as a nature reserve.",
"output": "∀x (NationalPark(x) ∧ Locatedin(x, vietnam) → NatureReserve(x))"
},
{
"input": "Translate into first-order logic: There is a national park in Vietnam classified as a UNESCO World Heritage Site.",
"output": "∃x (NationalPark(x) ∧ Locatedin(x, vietnam) ∧ UNESCOWorldHeritageSite(x))"
},
{
"input": "Translate into first-order logic: All national parks in Vietnam are either managed by the Ministry of Agriculture or by the People's Committee.",
"output": "∀x (NationalPark(x) ∧ Locatedin(x, vietnam) → Mangedby(x, ministryofAgriculture) ∨ Mangedby(x, peoplesCommittee))"
},
{
"input": "Translate into first-order logic: Phuoc Binh is not managed by the Ministry of Agriculture.",
"output": "¬Mangedby(phuocBinh, ministryofAgriculture)"
},
{
"input": "Translate into first-order logic: Phuoc Binh national park is a national park in Vietnam.",
"output": "NationalPark(phuocBinh) ∧ Locatedin(phuocBinh, vietnam)"
},
{
"input": "Translate into first-order logic: Any national park in Vietnam is classified as a nature reserve.",
"output": "∀x (NationalPark(x) ∧ Locatedin(x, vietnam) → NatureReserve(x))"
},
{
"input": "Translate into first-order logic: There is a national park in Vietnam classified as a UNESCO World Heritage Site.",
"output": "∃x (NationalPark(x) ∧ Locatedin(x, vietnam) ∧ UNESCOWorldHeritageSite(x))"
},
{
"input": "Translate into first-order logic: All national parks in Vietnam are either managed by the Ministry of Agriculture or by the People's Committee.",
"output": "∀x (NationalPark(x) ∧ Locatedin(x, vietnam) → Mangedby(x, ministryofAgriculture) ∨ Mangedby(x, peoplesCommittee))"
},
{
"input": "Translate into first-order logic: Phuoc Binh is not managed by the Ministry of Agriculture.",
"output": "¬Mangedby(phuocBinh, ministryofAgriculture)"
},
{
"input": "Translate into first-order logic: Greyhound racing is a competitive sport where spectators bet on greyhounds.",
"output": "∀x ∃y (GreyhoundRacing(x) → CompetitiveSport(x) ∧ Greyhound(y) ∧ SpectatorsBetOn(x, y))"
},
{
"input": "Translate into first-order logic: Coursing is a part of Greyhound racing.",
"output": "∀x (GreyhoundRacing(x) ↔ Coursing(x))"
},
{
"input": "Translate into first-order logic: Some competitive sports where spectators bet on things are banned.",
"output": "∃x ∃y (CompetitiveSport(x) ∧ SpectaorsBetOn(x, y) ∧ Banned(x))"
},
{
"input": "Translate into first-order logic: Coursing involves spectators betting on a hare being pursued by greyhounds.",
"output": "∀x ∃y ∃z (Coursing(x) → Hare(y) ∧ SpectatorsBetOn(x, y) ∧ GreyHound(z) ∧ Pursue(z, y))"
},
{
"input": "Translate into first-order logic: Hares are small game.",
"output": "∀x (Hare(x) → SmallGame(x))"
},
{
"input": "Translate into first-order logic: If a competitive sport involves spectators betting on small game, then it is banned.",
"output": "∀x ∃y (CompetitiveSport(x) ∧ SmallGame(y) ∧ SpectatorsBetOn(x, y) → Banned(x))"
},
{
"input": "Translate into first-order logic: Greyhound racing is a competitive sport where spectators bet on greyhounds.",
"output": "∀x ∃y (GreyhoundRacing(x) → CompetitiveSport(x) ∧ Greyhound(y) ∧ SpectatorsBetOn(x, y))"
},
{
"input": "Translate into first-order logic: Coursing is a part of Greyhound racing.",
"output": "∀x (GreyhoundRacing(x) ↔ Coursing(x))"
},
{
"input": "Translate into first-order logic: Some competitive sports where spectators bet on things are banned.",
"output": "∃x ∃y (CompetitiveSport(x) ∧ SpectaorsBetOn(x, y) ∧ Banned(x))"
},
{
"input": "Translate into first-order logic: Coursing involves spectators betting on a hare being pursued by greyhounds.",
"output": "∀x ∃y ∃z (Coursing(x) → Hare(y) ∧ SpectatorsBetOn(x, y) ∧ GreyHound(z) ∧ Pursue(z, y))"
},
{
"input": "Translate into first-order logic: Hares are small game.",
"output": "∀x (Hare(x) → SmallGame(x))"
},
{
"input": "Translate into first-order logic: If a competitive sport involves spectators betting on small game, then it is banned.",
"output": "∀x ∃y (CompetitiveSport(x) ∧ SmallGame(y) ∧ SpectatorsBetOn(x, y) → Banned(x))"
},
{
"input": "Translate into first-order logic: If a soccer player receives two yellow cards in one game, this player will be ejected from the rest of the game.",
"output": "∀x (SoccerPlayer(x) ∧ TwoYellow(x) → Eject(x))"
},
{
"input": "Translate into first-order logic: If a soccer player receives one red card in one game, this player will be ejected from the rest of the game.",
"output": "∀x (SoccerPlayer(x) ∧ OneRed(x) → Eject(x))   "
},
{
"input": "Translate into first-order logic: Henry is a soccer player.",
"output": "SoccerPlayer(henry)"
},
{
"input": "Translate into first-order logic: In one game, Henry first receives one yellow card, then he receives one red card.",
"output": "¬TwoYellow(henry) ∧ OneRed(henry)"
},
{
"input": "Translate into first-order logic: If a soccer player receives two yellow cards in one game, this player will be ejected from the rest of the game.",
"output": "∀x (SoccerPlayer(x) ∧ TwoYellow(x) → Eject(x))"
},
{
"input": "Translate into first-order logic: If a soccer player receives one red card in one game, this player will be ejected from the rest of the game.",
"output": "∀x (SoccerPlayer(x) ∧ OneRed(x) → Eject(x))   "
},
{
"input": "Translate into first-order logic: Henry is a soccer player.",
"output": "SoccerPlayer(henry)"
},
{
"input": "Translate into first-order logic: In one game, Henry first receives one yellow card, then he receives one red card.",
"output": "¬TwoYellow(henry) ∧ OneRed(henry)"
},
{
"input": "Translate into first-order logic: All trees are plants.",
"output": "∀x (Tree(x) → Plant(x))"
},
{
"input": "Translate into first-order logic: Some living things are trees.",
"output": "∃x (Living(x) ∧ Tree(x))"
},
{
"input": "Translate into first-order logic: Dagfinn is a given name.",
"output": "∀x (Dagfinn(x) → GivenName(x))"
},
{
"input": "Translate into first-order logic: Notable people with the given name include Dagfinn Aarskog, Dagfinn Bakke and Dagfinn Dahl.",
"output": "Dagfinn(dagfinnAarskog) ∧ NotablePeople(dagfinnAarskog) ∧ Dagfinn(dagfinnBakke) ∧ NotablePeople(dagfinnBakke) ∧ Dagfinn(dagfinnDahl) ∧ NotablePeople(dagfinnDahl)"
},
{
"input": "Translate into first-order logic: Dagfinn Aarskog is a Norwegian physician.",
"output": "Norwegian(dagfinnAarskog) ∧ Physician(dagfinnAarskog)"
},
{
"input": "Translate into first-order logic: Dagfinn Dahl is a Norwegian barrister.",
"output": "Norwegian(dagfinnDahl) ∧ Barrister(dagfinnDahl)"
},
{
"input": "Translate into first-order logic: Dagfinn is a given name.",
"output": "∀x (Dagfinn(x) → GivenName(x))"
},
{
"input": "Translate into first-order logic: Notable people with the given name include Dagfinn Aarskog, Dagfinn Bakke and Dagfinn Dahl.",
"output": "Dagfinn(dagfinnAarskog) ∧ NotablePeople(dagfinnAarskog) ∧ Dagfinn(dagfinnBakke) ∧ NotablePeople(dagfinnBakke) ∧ Dagfinn(dagfinnDahl) ∧ NotablePeople(dagfinnDahl)"
},
{
"input": "Translate into first-order logic: Dagfinn Aarskog is a Norwegian physician.",
"output": "Norwegian(dagfinnAarskog) ∧ Physician(dagfinnAarskog)"
},
{
"input": "Translate into first-order logic: Dagfinn Dahl is a Norwegian barrister.",
"output": "Norwegian(dagfinnDahl) ∧ Barrister(dagfinnDahl)"
},
{
"input": "Translate into first-order logic: Dagfinn is a given name.",
"output": "∀x (Dagfinn(x) → GivenName(x))"
},
{
"input": "Translate into first-order logic: Notable people with the given name include Dagfinn Aarskog, Dagfinn Bakke and Dagfinn Dahl.",
"output": "Dagfinn(dagfinnAarskog) ∧ NotablePeople(dagfinnAarskog) ∧ Dagfinn(dagfinnBakke) ∧ NotablePeople(dagfinnBakke) ∧ Dagfinn(dagfinnDahl) ∧ NotablePeople(dagfinnDahl)"
},
{
"input": "Translate into first-order logic: Dagfinn Aarskog is a Norwegian physician.",
"output": "Norwegian(dagfinnAarskog) ∧ Physician(dagfinnAarskog)"
},
{
"input": "Translate into first-order logic: Dagfinn Dahl is a Norwegian barrister.",
"output": "Norwegian(dagfinnDahl) ∧ Barrister(dagfinnDahl)"
},
{
"input": "Translate into first-order logic: If entertainment is interesting, it will be popular.",
"output": "∀x ((Entertainment(x) ∧ Interesting(x)) → Popular(x))"
},
{
"input": "Translate into first-order logic: All popular things are well-known.",
"output": "∀x (Popular(x) → WellKnown(x))"
},
{
"input": "Translate into first-order logic: It is not true that some giant language models do not have good performance.",
"output": "¬(∃x (LanguageModel(x) ∧ Giant(x) ∧ ¬GoodPerformance(x)))"
},
{
"input": "Translate into first-order logic: All language models with good performance are used by some researchers.",
"output": "∀x ((LanguageModel(x) ∧ GoodPerformance(x)) → UsedBySomeResearchers(x))"
},
{
"input": "Translate into first-order logic: If a language model is used by some researchers, it is popular.",
"output": "∀x (UsedBySomeResearchers(x) → Popular(x))"
},
{
"input": "Translate into first-order logic: If BERT is a giant language model, then GPT-3 is also a giant language model.",
"output": "(LanguageModel(bert) ∧ Giant(bert)) → (LanguageModel(gpt-3) ∧ Giant(gpt-3))."
},
{
"input": "Translate into first-order logic: BERT is a giant language model.",
"output": "LanguageModel(bert) ∧ Giant(bert) "
},
{
"input": "Translate into first-order logic: St Johnstone is a Scottish team.",
"output": "Scottish(johnstone)"
},
{
"input": "Translate into first-order logic: St Johnstone is part of the Scottish Premiership.",
"output": "PartOf(johnstone, scottishpremiership)"
},
{
"input": "Translate into first-order logic: If a team is part of the league, it has joined the league.",
"output": "∀x ∀y (PartOf(x, y) → Joined(x, y))"
},
{
"input": "Translate into first-order logic: St Johnstone and Minsk are different teams.",
"output": "Different(misnk, johnstone) ∧ Different(johnstone, minsk)"
},
{
"input": "Translate into first-order logic: For two different teams, either one team wins or the other team wins.",
"output": "∀x ∀y (Different(x, y) → WonGame(x, y) ⊕ WonGame(y, x))"
},
{
"input": "Translate into first-order logic: Minsk won against St Johnstone.",
"output": "WonGame(minsk, johnstone)"
},
{
"input": "Translate into first-order logic: St Johnstone is a Scottish team.",
"output": "Scottish(johnstone)"
},
{
"input": "Translate into first-order logic: St Johnstone is part of the Scottish Premiership.",
"output": "PartOf(johnstone, scottishpremiership)"
},
{
"input": "Translate into first-order logic: If a team is part of the league, it has joined the league.",
"output": "∀x ∀y (PartOf(x, y) → Joined(x, y))"
},
{
"input": "Translate into first-order logic: St Johnstone and Minsk are different teams.",
"output": "Different(misnk, johnstone) ∧ Different(johnstone, minsk)"
},
{
"input": "Translate into first-order logic: For two different teams, either one team wins or the other team wins.",
"output": "∀x ∀y (Different(x, y) → WonGame(x, y) ⊕ WonGame(y, x))"
},
{
"input": "Translate into first-order logic: Minsk won against St Johnstone.",
"output": "WonGame(minsk, johnstone)"
},
{
"input": "Translate into first-order logic: St Johnstone is a Scottish team.",
"output": "Scottish(johnstone)"
},
{
"input": "Translate into first-order logic: St Johnstone is part of the Scottish Premiership.",
"output": "PartOf(johnstone, scottishpremiership)"
},
{
"input": "Translate into first-order logic: If a team is part of the league, it has joined the league.",
"output": "∀x ∀y (PartOf(x, y) → Joined(x, y))"
},
{
"input": "Translate into first-order logic: St Johnstone and Minsk are different teams.",
"output": "Different(misnk, johnstone) ∧ Different(johnstone, minsk)"
},
{
"input": "Translate into first-order logic: For two different teams, either one team wins or the other team wins.",
"output": "∀x ∀y (Different(x, y) → WonGame(x, y) ⊕ WonGame(y, x))"
},
{
"input": "Translate into first-order logic: Minsk won against St Johnstone.",
"output": "WonGame(minsk, johnstone)"
},
{
"input": "Translate into first-order logic: No Boeing-737 plane is equipped with more than 300 seats.",
"output": "∀x (Boeing737(x) → ¬Seats300(x))"
},
{
"input": "Translate into first-order logic: All planes in Delta are of type Boeing-737.",
"output": "∀x (Delta(x) → Boeing737(x))"
},
{
"input": "Translate into first-order logic: Planes are either equipped with more than 300 seats or have a capacity of 100 passengers.",
"output": "∀x (Seats300(x) ∨ Passengers100(x))"
},
{
"input": "Translate into first-order logic: All planes with a capacity of 100 passengers are scheduled for a short-distance flight.",
"output": "∀x (Passengers100(x) → ShortDistance(x))"
},
{
"input": "Translate into first-order logic: All planes with a capacity of 100 passengers are produced before 2010.",
"output": "∀x (Passengers100(x) → ProducedBefore2010(x))"
},
{
"input": "Translate into first-order logic: Jake32 is either a Boeing-737 plane or a plane in Delta.",
"output": "Boeing737(jake32) ⊕ Delta(jake32) "
},
{
"input": "Translate into first-order logic: T10 is either a Boeing-737 plane and in Delta, or neither a Boeing-737 plane nor in Delta.",
"output": "Boeing737(t10) ⊕ Delta(t10)"
},
{
"input": "Translate into first-order logic: No Boeing-737 plane is equipped with more than 300 seats.",
"output": "∀x (Boeing737(x) → ¬Seats300(x))"
},
{
"input": "Translate into first-order logic: All planes in Delta are of type Boeing-737.",
"output": "∀x (Delta(x) → Boeing737(x))"
},
{
"input": "Translate into first-order logic: Planes are either equipped with more than 300 seats or have a capacity of 100 passengers.",
"output": "∀x (Seats300(x) ∨ Passengers100(x))"
},
{
"input": "Translate into first-order logic: All planes with a capacity of 100 passengers are scheduled for a short-distance flight.",
"output": "∀x (Passengers100(x) → ShortDistance(x))"
},
{
"input": "Translate into first-order logic: All planes with a capacity of 100 passengers are produced before 2010.",
"output": "∀x (Passengers100(x) → ProducedBefore2010(x))"
},
{
"input": "Translate into first-order logic: Jake32 is either a Boeing-737 plane or a plane in Delta.",
"output": "Boeing737(jake32) ⊕ Delta(jake32) "
},
{
"input": "Translate into first-order logic: T10 is either a Boeing-737 plane and in Delta, or neither a Boeing-737 plane nor in Delta.",
"output": "Boeing737(t10) ⊕ Delta(t10)"
},
{
"input": "Translate into first-order logic: No Boeing-737 plane is equipped with more than 300 seats.",
"output": "∀x (Boeing737(x) → ¬Seats300(x))"
},
{
"input": "Translate into first-order logic: All planes in Delta are of type Boeing-737.",
"output": "∀x (Delta(x) → Boeing737(x))"
},
{
"input": "Translate into first-order logic: Planes are either equipped with more than 300 seats or have a capacity of 100 passengers.",
"output": "∀x (Seats300(x) ∨ Passengers100(x))"
},
{
"input": "Translate into first-order logic: All planes with a capacity of 100 passengers are scheduled for a short-distance flight.",
"output": "∀x (Passengers100(x) → ShortDistance(x))"
},
{
"input": "Translate into first-order logic: All planes with a capacity of 100 passengers are produced before 2010.",
"output": "∀x (Passengers100(x) → ProducedBefore2010(x))"
},
{
"input": "Translate into first-order logic: Jake32 is either a Boeing-737 plane or a plane in Delta.",
"output": "Boeing737(jake32) ⊕ Delta(jake32) "
},
{
"input": "Translate into first-order logic: T10 is either a Boeing-737 plane and in Delta, or neither a Boeing-737 plane nor in Delta.",
"output": "Boeing737(t10) ⊕ Delta(t10)"
},
{
"input": "Translate into first-order logic: No Boeing-737 plane is equipped with more than 300 seats.",
"output": "∀x (Boeing737(x) → ¬Seats300(x))"
},
{
"input": "Translate into first-order logic: All planes in Delta are of type Boeing-737.",
"output": "∀x (Delta(x) → Boeing737(x))"
},
{
"input": "Translate into first-order logic: Planes are either equipped with more than 300 seats or have a capacity of 100 passengers.",
"output": "∀x (Seats300(x) ∨ Passengers100(x))"
},
{
"input": "Translate into first-order logic: All planes with a capacity of 100 passengers are scheduled for a short-distance flight.",
"output": "∀x (Passengers100(x) → ShortDistance(x))"
},
{
"input": "Translate into first-order logic: All planes with a capacity of 100 passengers are produced before 2010.",
"output": "∀x (Passengers100(x) → ProducedBefore2010(x))"
},
{
"input": "Translate into first-order logic: Jake32 is either a Boeing-737 plane or a plane in Delta.",
"output": "Boeing737(jake32) ⊕ Delta(jake32) "
},
{
"input": "Translate into first-order logic: T10 is either a Boeing-737 plane and in Delta, or neither a Boeing-737 plane nor in Delta.",
"output": "Boeing737(t10) ⊕ Delta(t10)"
},
{
"input": "Translate into first-order logic: The SAT test is wholly owned and developed by the College Board.",
"output": "Own(sat, collegeBoard) ∧ ¬Own(sat, others)"
},
{
"input": "Translate into first-order logic: The SAT test is intended to assess student's readiness for college.",
"output": "Test(sat, readiness)"
},
{
"input": "Translate into first-order logic: The SAT was originally designed not to be aligned with high school curricula.",
"output": "∀x (Year(x) ∧ Before2016(x) → ¬AlignHighSchool(x)) "
},
{
"input": "Translate into first-order logic: Several adjustments were made for the version of the SAT introduced in 2016 to reflect more closely on what students learn in high school.",
"output": "∃x (Year(x) ∧ Since2016(x) ∧ AlignHighSchool(x)) "
},
{
"input": "Translate into first-order logic: The SAT test is wholly owned and developed by the College Board.",
"output": "Own(sat, collegeBoard) ∧ ¬Own(sat, others)"
},
{
"input": "Translate into first-order logic: The SAT test is intended to assess student's readiness for college.",
"output": "Test(sat, readiness)"
},
{
"input": "Translate into first-order logic: The SAT was originally designed not to be aligned with high school curricula.",
"output": "∀x (Year(x) ∧ Before2016(x) → ¬AlignHighSchool(x)) "
},
{
"input": "Translate into first-order logic: Several adjustments were made for the version of the SAT introduced in 2016 to reflect more closely on what students learn in high school.",
"output": "∃x (Year(x) ∧ Since2016(x) ∧ AlignHighSchool(x)) "
},
{
"input": "Translate into first-order logic: The SAT test is wholly owned and developed by the College Board.",
"output": "Own(sat, collegeBoard) ∧ ¬Own(sat, others)"
},
{
"input": "Translate into first-order logic: The SAT test is intended to assess student's readiness for college.",
"output": "Test(sat, readiness)"
},
{
"input": "Translate into first-order logic: The SAT was originally designed not to be aligned with high school curricula.",
"output": "∀x (Year(x) ∧ Before2016(x) → ¬AlignHighSchool(x)) "
},
{
"input": "Translate into first-order logic: Several adjustments were made for the version of the SAT introduced in 2016 to reflect more closely on what students learn in high school.",
"output": "∃x (Year(x) ∧ Since2016(x) ∧ AlignHighSchool(x)) "
},
{
"input": "Translate into first-order logic: Rafa Nadal was born in Mallorca.",
"output": "BornIn(rafaNadal, mallorca)"
},
{
"input": "Translate into first-order logic: Rafa Nadal is a professional tennis player.",
"output": "ProfessionalTennisPlayer(rafaNadal)"
},
{
"input": "Translate into first-order logic: Nadal's win ratio is higher than 80%.",
"output": "HighWinRatio(rafaNadal)"
},
{
"input": "Translate into first-order logic: All players in the Big 3 are professionals who have a high win ratio.",
"output": "∀x (ProfessionalTennisPlayer(x) ∧ HighWinRatio(x) → InBig3(x))"
},
{
"input": "Translate into first-order logic: Rafa Nadal was born in Mallorca.",
"output": "BornIn(rafaNadal, mallorca)"
},
{
"input": "Translate into first-order logic: Rafa Nadal is a professional tennis player.",
"output": "ProfessionalTennisPlayer(rafaNadal)"
},
{
"input": "Translate into first-order logic: Nadal's win ratio is higher than 80%.",
"output": "HighWinRatio(rafaNadal)"
},
{
"input": "Translate into first-order logic: All players in the Big 3 are professionals who have a high win ratio.",
"output": "∀x (ProfessionalTennisPlayer(x) ∧ HighWinRatio(x) → InBig3(x))"
},
{
"input": "Translate into first-order logic: Rafa Nadal was born in Mallorca.",
"output": "BornIn(rafaNadal, mallorca)"
},
{
"input": "Translate into first-order logic: Rafa Nadal is a professional tennis player.",
"output": "ProfessionalTennisPlayer(rafaNadal)"
},
{
"input": "Translate into first-order logic: Nadal's win ratio is higher than 80%.",
"output": "HighWinRatio(rafaNadal)"
},
{
"input": "Translate into first-order logic: All players in the Big 3 are professionals who have a high win ratio.",
"output": "∀x (ProfessionalTennisPlayer(x) ∧ HighWinRatio(x) → InBig3(x))"
},
{
"input": "Translate into first-order logic: No cookie is healthy.",
"output": "∀x (Cookie(x) → ¬Healthy(x))"
},
{
"input": "Translate into first-order logic: All oreos are cookies.",
"output": "∀x (Oreo(x) → Cookie(x))"
},
{
"input": "Translate into first-order logic: No animals are plants.",
"output": "∀x (Animal(x) → ¬Plant(x))"
},
{
"input": "Translate into first-order logic: All humans are animals.",
"output": "∀x (Human(x) → Animal(x))"
},
{
"input": "Translate into first-order logic: All pupils are human.",
"output": "∀x (Pupil(x) → Human(x))"
},
{
"input": "Translate into first-order logic: All flowers are plants.",
"output": "∀x (Flower(x) → Plant(x))"
},
{
"input": "Translate into first-order logic: If Jack is a human or a flower, then Jack is a human and a flower.",
"output": "Human(jack) ∨ Flower(jack) → Human(jack) ∧ Flower(jack)"
},
{
"input": "Translate into first-order logic: No animals are plants.",
"output": "∀x (Animal(x) → ¬Plant(x))"
},
{
"input": "Translate into first-order logic: All humans are animals.",
"output": "∀x (Human(x) → Animal(x))"
},
{
"input": "Translate into first-order logic: All pupils are human.",
"output": "∀x (Pupil(x) → Human(x))"
},
{
"input": "Translate into first-order logic: All flowers are plants.",
"output": "∀x (Flower(x) → Plant(x))"
},
{
"input": "Translate into first-order logic: If Jack is a human or a flower, then Jack is a human and a flower.",
"output": "Human(jack) ∨ Flower(jack) → Human(jack) ∧ Flower(jack)"
},
{
"input": "Translate into first-order logic: No animals are plants.",
"output": "∀x (Animal(x) → ¬Plant(x))"
},
{
"input": "Translate into first-order logic: All humans are animals.",
"output": "∀x (Human(x) → Animal(x))"
},
{
"input": "Translate into first-order logic: All pupils are human.",
"output": "∀x (Pupil(x) → Human(x))"
},
{
"input": "Translate into first-order logic: All flowers are plants.",
"output": "∀x (Flower(x) → Plant(x))"
},
{
"input": "Translate into first-order logic: If Jack is a human or a flower, then Jack is a human and a flower.",
"output": "Human(jack) ∨ Flower(jack) → Human(jack) ∧ Flower(jack)"
},
{
"input": "Translate into first-order logic: No animals are plants.",
"output": "∀x (Animal(x) → ¬Plant(x))"
},
{
"input": "Translate into first-order logic: All humans are animals.",
"output": "∀x (Human(x) → Animal(x))"
},
{
"input": "Translate into first-order logic: All pupils are human.",
"output": "∀x (Pupil(x) → Human(x))"
},
{
"input": "Translate into first-order logic: All flowers are plants.",
"output": "∀x (Flower(x) → Plant(x))"
},
{
"input": "Translate into first-order logic: If Jack is a human or a flower, then Jack is a human and a flower.",
"output": "Human(jack) ∨ Flower(jack) → Human(jack) ∧ Flower(jack)"
},
{
"input": "Translate into first-order logic: No shoes are food.",
"output": "∀x (Shoes(x) → ¬Food(x))"
},
{
"input": "Translate into first-order logic: All slippers are shoes.",
"output": "∀x (Slipper(x) → Shoes(x))"
},
{
"input": "Translate into first-order logic: A thing is either food or clothes.",
"output": "∀x (Food(x) ⊕ Clothes(x))"
},
{
"input": "Translate into first-order logic: No wearable things are airtight.",
"output": "∀x (Wearable(x) → ¬AirTight(x))"
},
{
"input": "Translate into first-order logic: All clothes are wearable.",
"output": "∀x (Clothes(x) → Wearable(x))"
},
{
"input": "Translate into first-order logic: If a watch is not airtight and clothes, then a watch is either both airtight and clothes, or neither airtight nor clothes.",
"output": "¬(AirTight(watch) ∧ Clothes(watch)) → (AirTight(watch) ∧ Clothes(watch)) ⊕ (¬AirTight(watch) ∧ ¬Clothes(watch))"
},
{
"input": "Translate into first-order logic: No shoes are food.",
"output": "∀x (Shoes(x) → ¬Food(x))"
},
{
"input": "Translate into first-order logic: All slippers are shoes.",
"output": "∀x (Slipper(x) → Shoes(x))"
},
{
"input": "Translate into first-order logic: A thing is either food or clothes.",
"output": "∀x (Food(x) ⊕ Clothes(x))"
},
{
"input": "Translate into first-order logic: No wearable things are airtight.",
"output": "∀x (Wearable(x) → ¬AirTight(x))"
},
{
"input": "Translate into first-order logic: All clothes are wearable.",
"output": "∀x (Clothes(x) → Wearable(x))"
},
{
"input": "Translate into first-order logic: If a watch is not airtight and clothes, then a watch is either both airtight and clothes, or neither airtight nor clothes.",
"output": "¬(AirTight(watch) ∧ Clothes(watch)) → (AirTight(watch) ∧ Clothes(watch)) ⊕ (¬AirTight(watch) ∧ ¬Clothes(watch))"
},
{
"input": "Translate into first-order logic: No shoes are food.",
"output": "∀x (Shoes(x) → ¬Food(x))"
},
{
"input": "Translate into first-order logic: All slippers are shoes.",
"output": "∀x (Slipper(x) → Shoes(x))"
},
{
"input": "Translate into first-order logic: A thing is either food or clothes.",
"output": "∀x (Food(x) ⊕ Clothes(x))"
},
{
"input": "Translate into first-order logic: No wearable things are airtight.",
"output": "∀x (Wearable(x) → ¬AirTight(x))"
},
{
"input": "Translate into first-order logic: All clothes are wearable.",
"output": "∀x (Clothes(x) → Wearable(x))"
},
{
"input": "Translate into first-order logic: If a watch is not airtight and clothes, then a watch is either both airtight and clothes, or neither airtight nor clothes.",
"output": "¬(AirTight(watch) ∧ Clothes(watch)) → (AirTight(watch) ∧ Clothes(watch)) ⊕ (¬AirTight(watch) ∧ ¬Clothes(watch))"
},
{
"input": "Translate into first-order logic: An Olympian is a person who trains for an Olympic sport and goes to the Olympics.",
"output": "∀x (DoesOlympicSport(x) ∧ GoesToOlympicGames(x) → IsOlympian(x))"
},
{
"input": "Translate into first-order logic: Carlos Reyes trains for an Olympic sport.",
"output": "DoesOlympicSport(carlosReyes)"
},
{
"input": "Translate into first-order logic: Carlos Reyes went to the Olympics.",
"output": "GoesToOlympicGames(carlosReyes)"
},
{
"input": "Translate into first-order logic: Carlos Reyes is a welterweight.",
"output": "IsWelterWeight(carlosReyes)"
},
{
"input": "Translate into first-order logic: Heavy weights are not welterweights.",
"output": "∀x (IsWelterWeight(x) → ¬IsHeavyWeight(x))"
},
{
"input": "Translate into first-order logic: An Olympian is a person who trains for an Olympic sport and goes to the Olympics.",
"output": "∀x (DoesOlympicSport(x) ∧ GoesToOlympicGames(x) → IsOlympian(x))"
},
{
"input": "Translate into first-order logic: Carlos Reyes trains for an Olympic sport.",
"output": "DoesOlympicSport(carlosReyes)"
},
{
"input": "Translate into first-order logic: Carlos Reyes went to the Olympics.",
"output": "GoesToOlympicGames(carlosReyes)"
},
{
"input": "Translate into first-order logic: Carlos Reyes is a welterweight.",
"output": "IsWelterWeight(carlosReyes)"
},
{
"input": "Translate into first-order logic: Heavy weights are not welterweights.",
"output": "∀x (IsWelterWeight(x) → ¬IsHeavyWeight(x))"
},
{
"input": "Translate into first-order logic: An Olympian is a person who trains for an Olympic sport and goes to the Olympics.",
"output": "∀x (DoesOlympicSport(x) ∧ GoesToOlympicGames(x) → IsOlympian(x))"
},
{
"input": "Translate into first-order logic: Carlos Reyes trains for an Olympic sport.",
"output": "DoesOlympicSport(carlosReyes)"
},
{
"input": "Translate into first-order logic: Carlos Reyes went to the Olympics.",
"output": "GoesToOlympicGames(carlosReyes)"
},
{
"input": "Translate into first-order logic: Carlos Reyes is a welterweight.",
"output": "IsWelterWeight(carlosReyes)"
},
{
"input": "Translate into first-order logic: Heavy weights are not welterweights.",
"output": "∀x (IsWelterWeight(x) → ¬IsHeavyWeight(x))"
},
{
"input": "Translate into first-order logic: If people have a lot of decorations in their room, they cannot pack and move out of their rooms very easily.",
"output": "∀x (Decor(x) → ¬MoveOut(x))"
},
{
"input": "Translate into first-order logic: If people have high ambitions and future career goals, then they can pack and move out of their rooms very easily.",
"output": "∀x (Ambitious(x) → MoveOut(x))"
},
{
"input": "Translate into first-order logic: If people are big fans of pop bands and singers, then they have a lot of decorations in their room.",
"output": "∀x (Fans(x) → Decor(x))"
},
{
"input": "Translate into first-order logic: All young teenage girls who attend college are big fans of pop bands and singers.",
"output": "∀x (CollegeTeen(x) → Ambitious(x))"
},
{
"input": "Translate into first-order logic: If Sam has high ambitions and future career goals, then Sam is a big fan of pop bands and singers.",
"output": "Ambitious(sam) → Fans(sam)"
},
{
"input": "Translate into first-order logic: If people have a lot of decorations in their room, they cannot pack and move out of their rooms very easily.",
"output": "∀x (Decor(x) → ¬MoveOut(x))"
},
{
"input": "Translate into first-order logic: If people have high ambitions and future career goals, then they can pack and move out of their rooms very easily.",
"output": "∀x (Ambitious(x) → MoveOut(x))"
},
{
"input": "Translate into first-order logic: If people are big fans of pop bands and singers, then they have a lot of decorations in their room.",
"output": "∀x (Fans(x) → Decor(x))"
},
{
"input": "Translate into first-order logic: All young teenage girls who attend college are big fans of pop bands and singers.",
"output": "∀x (CollegeTeen(x) → Ambitious(x))"
},
{
"input": "Translate into first-order logic: If Sam has high ambitions and future career goals, then Sam is a big fan of pop bands and singers.",
"output": "Ambitious(sam) → Fans(sam)"
},
{
"input": "Translate into first-order logic: If people have a lot of decorations in their room, they cannot pack and move out of their rooms very easily.",
"output": "∀x (Decor(x) → ¬MoveOut(x))"
},
{
"input": "Translate into first-order logic: If people have high ambitions and future career goals, then they can pack and move out of their rooms very easily.",
"output": "∀x (Ambitious(x) → MoveOut(x))"
},
{
"input": "Translate into first-order logic: If people are big fans of pop bands and singers, then they have a lot of decorations in their room.",
"output": "∀x (Fans(x) → Decor(x))"
},
{
"input": "Translate into first-order logic: All young teenage girls who attend college are big fans of pop bands and singers.",
"output": "∀x (CollegeTeen(x) → Ambitious(x))"
},
{
"input": "Translate into first-order logic: If Sam has high ambitions and future career goals, then Sam is a big fan of pop bands and singers.",
"output": "Ambitious(sam) → Fans(sam)"
},
{
"input": "Translate into first-order logic: If people have a lot of decorations in their room, they cannot pack and move out of their rooms very easily.",
"output": "∀x (Decor(x) → ¬MoveOut(x))"
},
{
"input": "Translate into first-order logic: If people have high ambitions and future career goals, then they can pack and move out of their rooms very easily.",
"output": "∀x (Ambitious(x) → MoveOut(x))"
},
{
"input": "Translate into first-order logic: If people are big fans of pop bands and singers, then they have a lot of decorations in their room.",
"output": "∀x (Fans(x) → Decor(x))"
},
{
"input": "Translate into first-order logic: All young teenage girls who attend college are big fans of pop bands and singers.",
"output": "∀x (CollegeTeen(x) → Ambitious(x))"
},
{
"input": "Translate into first-order logic: If Sam has high ambitions and future career goals, then Sam is a big fan of pop bands and singers.",
"output": "Ambitious(sam) → Fans(sam)"
},
{
"input": "Translate into first-order logic: If people have a lot of decorations in their room, they cannot pack and move out of their rooms very easily.",
"output": "∀x (Decor(x) → ¬MoveOut(x))"
},
{
"input": "Translate into first-order logic: If people have high ambitions and future career goals, then they can pack and move out of their rooms very easily.",
"output": "∀x (Ambitious(x) → MoveOut(x))"
},
{
"input": "Translate into first-order logic: If people are big fans of pop bands and singers, then they have a lot of decorations in their room.",
"output": "∀x (Fans(x) → Decor(x))"
},
{
"input": "Translate into first-order logic: All young teenage girls who attend college are big fans of pop bands and singers.",
"output": "∀x (CollegeTeen(x) → Ambitious(x))"
},
{
"input": "Translate into first-order logic: If Sam has high ambitions and future career goals, then Sam is a big fan of pop bands and singers.",
"output": "Ambitious(sam) → Fans(sam)"
},
{
"input": "Translate into first-order logic: If people have a lot of decorations in their room, they cannot pack and move out of their rooms very easily.",
"output": "∀x (Decor(x) → ¬MoveOut(x))"
},
{
"input": "Translate into first-order logic: If people have high ambitions and future career goals, then they can pack and move out of their rooms very easily.",
"output": "∀x (Ambitious(x) → MoveOut(x))"
},
{
"input": "Translate into first-order logic: If people are big fans of pop bands and singers, then they have a lot of decorations in their room.",
"output": "∀x (Fans(x) → Decor(x))"
},
{
"input": "Translate into first-order logic: All young teenage girls who attend college are big fans of pop bands and singers.",
"output": "∀x (CollegeTeen(x) → Ambitious(x))"
},
{
"input": "Translate into first-order logic: If Sam has high ambitions and future career goals, then Sam is a big fan of pop bands and singers.",
"output": "Ambitious(sam) → Fans(sam)"
},
{
"input": "Translate into first-order logic: If people have a lot of decorations in their room, they cannot pack and move out of their rooms very easily.",
"output": "∀x (Decor(x) → ¬MoveOut(x))"
},
{
"input": "Translate into first-order logic: If people have high ambitions and future career goals, then they can pack and move out of their rooms very easily.",
"output": "∀x (Ambitious(x) → MoveOut(x))"
},
{
"input": "Translate into first-order logic: If people are big fans of pop bands and singers, then they have a lot of decorations in their room.",
"output": "∀x (Fans(x) → Decor(x))"
},
{
"input": "Translate into first-order logic: All young teenage girls who attend college are big fans of pop bands and singers.",
"output": "∀x (CollegeTeen(x) → Ambitious(x))"
},
{
"input": "Translate into first-order logic: If Sam has high ambitions and future career goals, then Sam is a big fan of pop bands and singers.",
"output": "Ambitious(sam) → Fans(sam)"
},
{
"input": "Translate into first-order logic: If people have a lot of decorations in their room, they cannot pack and move out of their rooms very easily.",
"output": "∀x (Decor(x) → ¬MoveOut(x))"
},
{
"input": "Translate into first-order logic: If people have high ambitions and future career goals, then they can pack and move out of their rooms very easily.",
"output": "∀x (Ambitious(x) → MoveOut(x))"
},
{
"input": "Translate into first-order logic: If people are big fans of pop bands and singers, then they have a lot of decorations in their room.",
"output": "∀x (Fans(x) → Decor(x))"
},
{
"input": "Translate into first-order logic: All young teenage girls who attend college are big fans of pop bands and singers.",
"output": "∀x (CollegeTeen(x) → Ambitious(x))"
},
{
"input": "Translate into first-order logic: If Sam has high ambitions and future career goals, then Sam is a big fan of pop bands and singers.",
"output": "Ambitious(sam) → Fans(sam)"
},
{
"input": "Translate into first-order logic: If people have a lot of decorations in their room, they cannot pack and move out of their rooms very easily.",
"output": "∀x (Decor(x) → ¬MoveOut(x))"
},
{
"input": "Translate into first-order logic: If people have high ambitions and future career goals, then they can pack and move out of their rooms very easily.",
"output": "∀x (Ambitious(x) → MoveOut(x))"
},
{
"input": "Translate into first-order logic: If people are big fans of pop bands and singers, then they have a lot of decorations in their room.",
"output": "∀x (Fans(x) → Decor(x))"
},
{
"input": "Translate into first-order logic: All young teenage girls who attend college are big fans of pop bands and singers.",
"output": "∀x (CollegeTeen(x) → Ambitious(x))"
},
{
"input": "Translate into first-order logic: If Sam has high ambitions and future career goals, then Sam is a big fan of pop bands and singers.",
"output": "Ambitious(sam) → Fans(sam)"
},
{
"input": "Translate into first-order logic: A student who loves shrieking will be punished.",
"output": "∀x (Student(x) ∧ Shriek(x) → Punished(x))"
},
{
"input": "Translate into first-order logic: If a person swears, then he is a student.",
"output": "∀x (Swear(x) → Student(x))"
},
{
"input": "Translate into first-order logic: If someone is a teacher, then Bob will talk to him.",
"output": "∀x (Teacher(x) → Talk(bob, x))"
},
{
"input": "Translate into first-order logic: All gentlemen are in a suit.",
"output": "∀x (Gentleman(x) → Suit(x))"
},
{
"input": "Translate into first-order logic: All teachers are men.",
"output": "∀x (Teacher(x) → Man(x))"
},
{
"input": "Translate into first-order logic: There is a teacher.",
"output": "∃x (Teacher(x))"
},
{
"input": "Translate into first-order logic: If someone is not a gentlemen, then he is not nice.",
"output": "∀x (¬Gentleman(x) → ¬Nice(x))"
},
{
"input": "Translate into first-order logic: Willy is nice.",
"output": "Nice(willy)"
},
{
"input": "Translate into first-order logic: Bob loves shrieking and swearing.",
"output": "Shriek(bob) ∧ Swear(bob)"
},
{
"input": "Translate into first-order logic: A student who loves shrieking will be punished.",
"output": "∀x (Student(x) ∧ Shriek(x) → Punished(x))"
},
{
"input": "Translate into first-order logic: If a person swears, then he is a student.",
"output": "∀x (Swear(x) → Student(x))"
},
{
"input": "Translate into first-order logic: If someone is a teacher, then Bob will talk to him.",
"output": "∀x (Teacher(x) → Talk(bob, x))"
},
{
"input": "Translate into first-order logic: All gentlemen are in a suit.",
"output": "∀x (Gentleman(x) → Suit(x))"
},
{
"input": "Translate into first-order logic: All teachers are men.",
"output": "∀x (Teacher(x) → Man(x))"
},
{
"input": "Translate into first-order logic: There is a teacher.",
"output": "∃x (Teacher(x))"
},
{
"input": "Translate into first-order logic: If someone is not a gentlemen, then he is not nice.",
"output": "∀x (¬Gentleman(x) → ¬Nice(x))"
},
{
"input": "Translate into first-order logic: Willy is nice.",
"output": "Nice(willy)"
},
{
"input": "Translate into first-order logic: Bob loves shrieking and swearing.",
"output": "Shriek(bob) ∧ Swear(bob)"
},
{
"input": "Translate into first-order logic: A student who loves shrieking will be punished.",
"output": "∀x (Student(x) ∧ Shriek(x) → Punished(x))"
},
{
"input": "Translate into first-order logic: If a person swears, then he is a student.",
"output": "∀x (Swear(x) → Student(x))"
},
{
"input": "Translate into first-order logic: If someone is a teacher, then Bob will talk to him.",
"output": "∀x (Teacher(x) → Talk(bob, x))"
},
{
"input": "Translate into first-order logic: All gentlemen are in a suit.",
"output": "∀x (Gentleman(x) → Suit(x))"
},
{
"input": "Translate into first-order logic: All teachers are men.",
"output": "∀x (Teacher(x) → Man(x))"
},
{
"input": "Translate into first-order logic: There is a teacher.",
"output": "∃x (Teacher(x))"
},
{
"input": "Translate into first-order logic: If someone is not a gentlemen, then he is not nice.",
"output": "∀x (¬Gentleman(x) → ¬Nice(x))"
},
{
"input": "Translate into first-order logic: Willy is nice.",
"output": "Nice(willy)"
},
{
"input": "Translate into first-order logic: Bob loves shrieking and swearing.",
"output": "Shriek(bob) ∧ Swear(bob)"
},
{
"input": "Translate into first-order logic: Quincy McDuffie is an American professional wide receiver in Canadian Football.",
"output": "American(quincymcduffie) ∧ Professional(quincymcduffie) ∧ WideReciever(quincymcduffie) ∧ In(quincymcduffie, canadianfootball)"
},
{
"input": "Translate into first-order logic: People who can catch balls are good wide receivers.",
"output": "∀x ∃y (CanCatch(x, y) ∧ Ball(y) → Good(x, widereciever))"
},
{
"input": "Translate into first-order logic: Quincy McDuffie can catch many footballs easily.",
"output": "∃x (Football(x) ∧ CanCatch(quincymcduffie, x))"
},
{
"input": "Translate into first-order logic: Good wide receivers play professionally.",
"output": "∀x (Good(x, widereciever) → Professional(x))"
},
{
"input": "Translate into first-order logic: Good wide receivers can catch with both their left and right hand.",
"output": "∀x (Good(x, widereciever) → CanCatchWith(x, lefthand) ∧ CanCatchWith(x, righthand))"
},
{
"input": "Translate into first-order logic: All footballs are balls.",
"output": "∀x (Football(x) → Ball(x))"
},
{
"input": "Translate into first-order logic: Quincy McDuffie is an American professional wide receiver in Canadian Football.",
"output": "American(quincymcduffie) ∧ Professional(quincymcduffie) ∧ WideReciever(quincymcduffie) ∧ In(quincymcduffie, canadianfootball)"
},
{
"input": "Translate into first-order logic: People who can catch balls are good wide receivers.",
"output": "∀x ∃y (CanCatch(x, y) ∧ Ball(y) → Good(x, widereciever))"
},
{
"input": "Translate into first-order logic: Quincy McDuffie can catch many footballs easily.",
"output": "∃x (Football(x) ∧ CanCatch(quincymcduffie, x))"
},
{
"input": "Translate into first-order logic: Good wide receivers play professionally.",
"output": "∀x (Good(x, widereciever) → Professional(x))"
},
{
"input": "Translate into first-order logic: Good wide receivers can catch with both their left and right hand.",
"output": "∀x (Good(x, widereciever) → CanCatchWith(x, lefthand) ∧ CanCatchWith(x, righthand))"
},
{
"input": "Translate into first-order logic: All footballs are balls.",
"output": "∀x (Football(x) → Ball(x))"
},
{
"input": "Translate into first-order logic: Quincy McDuffie is an American professional wide receiver in Canadian Football.",
"output": "American(quincymcduffie) ∧ Professional(quincymcduffie) ∧ WideReciever(quincymcduffie) ∧ In(quincymcduffie, canadianfootball)"
},
{
"input": "Translate into first-order logic: People who can catch balls are good wide receivers.",
"output": "∀x ∃y (CanCatch(x, y) ∧ Ball(y) → Good(x, widereciever))"
},
{
"input": "Translate into first-order logic: Quincy McDuffie can catch many footballs easily.",
"output": "∃x (Football(x) ∧ CanCatch(quincymcduffie, x))"
},
{
"input": "Translate into first-order logic: Good wide receivers play professionally.",
"output": "∀x (Good(x, widereciever) → Professional(x))"
},
{
"input": "Translate into first-order logic: Good wide receivers can catch with both their left and right hand.",
"output": "∀x (Good(x, widereciever) → CanCatchWith(x, lefthand) ∧ CanCatchWith(x, righthand))"
},
{
"input": "Translate into first-order logic: All footballs are balls.",
"output": "∀x (Football(x) → Ball(x))"
},
{
"input": "Translate into first-order logic: Boves is a railway station located in France.",
"output": "RailwayStation(boves) ∧ Locate(boves, france)"
},
{
"input": "Translate into first-order logic: The preceding station of Boves is Longueau.",
"output": "Precede(boves, longueau)"
},
{
"input": "Translate into first-order logic: The preceding station of Dommartin is Boves.",
"output": "Precede(dommartin, boves)"
},
{
"input": "Translate into first-order logic: France is a European country.",
"output": "Locate(france, europe)"
},
{
"input": "Translate into first-order logic: Dommartin is situated on the Paris–Lille railway.",
"output": "Situate(dommartin, pairsLille)"
},
{
"input": "Translate into first-order logic: Any two contiguous stations are on the same railway.",
"output": "∀x ∀y ∀z ((Situate(x, z) ∧ (Precede(x, y) ∨ Precede(y, x))) → Situate(y, z))"
},
{
"input": "Translate into first-order logic: Boves is served by regional TER Hauts-de-France trains.",
"output": "Serve(hautsDeFrance, boves)"
},
{
"input": "Translate into first-order logic: If A is located in B and B is located in C, then A is located in C.",
"output": "∀x ∀y ∀z ((Locate(x, y) ∧ Locate(y, z)) → Locate(x, z))"
},
{
"input": "Translate into first-order logic: If A precedes B and B preceds C, than A preceds C.",
"output": "∀x ∀y ∀z ((Precede(x, y) ∧ Precede(y, z)) → Precede(x, z))"
},
{
"input": "Translate into first-order logic: Boves is a railway station located in France.",
"output": "RailwayStation(boves) ∧ Locate(boves, france)"
},
{
"input": "Translate into first-order logic: The preceding station of Boves is Longueau.",
"output": "Precede(boves, longueau)"
},
{
"input": "Translate into first-order logic: The preceding station of Dommartin is Boves.",
"output": "Precede(dommartin, boves)"
},
{
"input": "Translate into first-order logic: France is a European country.",
"output": "Locate(france, europe)"
},
{
"input": "Translate into first-order logic: Dommartin is situated on the Paris–Lille railway.",
"output": "Situate(dommartin, pairsLille)"
},
{
"input": "Translate into first-order logic: Any two contiguous stations are on the same railway.",
"output": "∀x ∀y ∀z ((Situate(x, z) ∧ (Precede(x, y) ∨ Precede(y, x))) → Situate(y, z))"
},
{
"input": "Translate into first-order logic: Boves is served by regional TER Hauts-de-France trains.",
"output": "Serve(hautsDeFrance, boves)"
},
{
"input": "Translate into first-order logic: If A is located in B and B is located in C, then A is located in C.",
"output": "∀x ∀y ∀z ((Locate(x, y) ∧ Locate(y, z)) → Locate(x, z))"
},
{
"input": "Translate into first-order logic: If A precedes B and B preceds C, than A preceds C.",
"output": "∀x ∀y ∀z ((Precede(x, y) ∧ Precede(y, z)) → Precede(x, z))"
},
{
"input": "Translate into first-order logic: Boves is a railway station located in France.",
"output": "RailwayStation(boves) ∧ Locate(boves, france)"
},
{
"input": "Translate into first-order logic: The preceding station of Boves is Longueau.",
"output": "Precede(boves, longueau)"
},
{
"input": "Translate into first-order logic: The preceding station of Dommartin is Boves.",
"output": "Precede(dommartin, boves)"
},
{
"input": "Translate into first-order logic: France is a European country.",
"output": "Locate(france, europe)"
},
{
"input": "Translate into first-order logic: Dommartin is situated on the Paris–Lille railway.",
"output": "Situate(dommartin, pairsLille)"
},
{
"input": "Translate into first-order logic: Any two contiguous stations are on the same railway.",
"output": "∀x ∀y ∀z ((Situate(x, z) ∧ (Precede(x, y) ∨ Precede(y, x))) → Situate(y, z))"
},
{
"input": "Translate into first-order logic: Boves is served by regional TER Hauts-de-France trains.",
"output": "Serve(hautsDeFrance, boves)"
},
{
"input": "Translate into first-order logic: If A is located in B and B is located in C, then A is located in C.",
"output": "∀x ∀y ∀z ((Locate(x, y) ∧ Locate(y, z)) → Locate(x, z))"
},
{
"input": "Translate into first-order logic: If A precedes B and B preceds C, than A preceds C.",
"output": "∀x ∀y ∀z ((Precede(x, y) ∧ Precede(y, z)) → Precede(x, z))"
},
{
"input": "Translate into first-order logic: Edwin Smith was a New Zealand Rower from Auckland.",
"output": "From(edwinsmith, newzealand) ∧ Rower(edwinsmith) ∧ From(edwinsmith, auckland)"
},
{
"input": "Translate into first-order logic: Edwin Smith was also known as Ted Smith.",
"output": "KnownAs(edwinsmith, tedsmith)"
},
{
"input": "Translate into first-order logic: Edwin Smith went to Rose Road Primary School, located in Grey Lynn.",
"output": "WentTo(edwinsmith, roseroadprimaryschool) ∧ LocatedIn(roseroadprimaryschool, greylynn)"
},
{
"input": "Translate into first-order logic: Edwin Smith was a sergeant who served with the New Zealand 24th battalion in Italy and Egypt.",
"output": "Sergeant(edwinsmith) ∧ ServedWith(edwinsmith, newzealand24thbattalion) ∧ ServedIn(edwinsmith, italy) ∧ ServedIn(edwinsmith, egypt)"
},
{
"input": "Translate into first-order logic: Broadway Sheetmetals was a buisness that was ran and owned by Edwin Smith, who was a sheetmetal worker.",
"output": "Buisness(broadwaysheetmetals) ∧ Ran(edwinsmith, broadwaysheetmetals) ∧ Owned(edwinsmith, broadwaysheetmetals) ∧ SheetmetalWorker(edwinsmith)"
},
{
"input": "Translate into first-order logic: Edwin Smith was a New Zealand Rower from Auckland.",
"output": "From(edwinsmith, newzealand) ∧ Rower(edwinsmith) ∧ From(edwinsmith, auckland)"
},
{
"input": "Translate into first-order logic: Edwin Smith was also known as Ted Smith.",
"output": "KnownAs(edwinsmith, tedsmith)"
},
{
"input": "Translate into first-order logic: Edwin Smith went to Rose Road Primary School, located in Grey Lynn.",
"output": "WentTo(edwinsmith, roseroadprimaryschool) ∧ LocatedIn(roseroadprimaryschool, greylynn)"
},
{
"input": "Translate into first-order logic: Edwin Smith was a sergeant who served with the New Zealand 24th battalion in Italy and Egypt.",
"output": "Sergeant(edwinsmith) ∧ ServedWith(edwinsmith, newzealand24thbattalion) ∧ ServedIn(edwinsmith, italy) ∧ ServedIn(edwinsmith, egypt)"
},
{
"input": "Translate into first-order logic: Broadway Sheetmetals was a buisness that was ran and owned by Edwin Smith, who was a sheetmetal worker.",
"output": "Buisness(broadwaysheetmetals) ∧ Ran(edwinsmith, broadwaysheetmetals) ∧ Owned(edwinsmith, broadwaysheetmetals) ∧ SheetmetalWorker(edwinsmith)"
},
{
"input": "Translate into first-order logic: Edwin Smith was a New Zealand Rower from Auckland.",
"output": "From(edwinsmith, newzealand) ∧ Rower(edwinsmith) ∧ From(edwinsmith, auckland)"
},
{
"input": "Translate into first-order logic: Edwin Smith was also known as Ted Smith.",
"output": "KnownAs(edwinsmith, tedsmith)"
},
{
"input": "Translate into first-order logic: Edwin Smith went to Rose Road Primary School, located in Grey Lynn.",
"output": "WentTo(edwinsmith, roseroadprimaryschool) ∧ LocatedIn(roseroadprimaryschool, greylynn)"
},
{
"input": "Translate into first-order logic: Edwin Smith was a sergeant who served with the New Zealand 24th battalion in Italy and Egypt.",
"output": "Sergeant(edwinsmith) ∧ ServedWith(edwinsmith, newzealand24thbattalion) ∧ ServedIn(edwinsmith, italy) ∧ ServedIn(edwinsmith, egypt)"
},
{
"input": "Translate into first-order logic: Broadway Sheetmetals was a buisness that was ran and owned by Edwin Smith, who was a sheetmetal worker.",
"output": "Buisness(broadwaysheetmetals) ∧ Ran(edwinsmith, broadwaysheetmetals) ∧ Owned(edwinsmith, broadwaysheetmetals) ∧ SheetmetalWorker(edwinsmith)"
},
{
"input": "Translate into first-order logic: Edwin Smith was a New Zealand Rower from Auckland.",
"output": "From(edwinsmith, newzealand) ∧ Rower(edwinsmith) ∧ From(edwinsmith, auckland)"
},
{
"input": "Translate into first-order logic: Edwin Smith was also known as Ted Smith.",
"output": "KnownAs(edwinsmith, tedsmith)"
},
{
"input": "Translate into first-order logic: Edwin Smith went to Rose Road Primary School, located in Grey Lynn.",
"output": "WentTo(edwinsmith, roseroadprimaryschool) ∧ LocatedIn(roseroadprimaryschool, greylynn)"
},
{
"input": "Translate into first-order logic: Edwin Smith was a sergeant who served with the New Zealand 24th battalion in Italy and Egypt.",
"output": "Sergeant(edwinsmith) ∧ ServedWith(edwinsmith, newzealand24thbattalion) ∧ ServedIn(edwinsmith, italy) ∧ ServedIn(edwinsmith, egypt)"
},
{
"input": "Translate into first-order logic: Broadway Sheetmetals was a buisness that was ran and owned by Edwin Smith, who was a sheetmetal worker.",
"output": "Buisness(broadwaysheetmetals) ∧ Ran(edwinsmith, broadwaysheetmetals) ∧ Owned(edwinsmith, broadwaysheetmetals) ∧ SheetmetalWorker(edwinsmith)"
},
{
"input": "Translate into first-order logic: A werewolf is a human that can turn into a wolf.",
"output": "∀x (Human(x) ∧ CanTurnInto(x, wolf) → Werewolf(x))"
},
{
"input": "Translate into first-order logic: A werewolf has been scratched or bitten by another werewolf.",
"output": "∀x ∃y (Werewolf(x) → (BittenBy(x, y) ∨ ScratchedBy(x, y)) ∧ Werewolf(y))"
},
{
"input": "Translate into first-order logic: If someone has been scratched or bitten, they have been attacked.",
"output": "∀x ∃y (BittenBy(x, y) ∨ ScratchedBy(x, y)) → AttackedBy(x,y)"
},
{
"input": "Translate into first-order logic: A werewolf is a human that can turn into a wolf.",
"output": "∀x (Human(x) ∧ CanTurnInto(x, wolf) → Werewolf(x))"
},
{
"input": "Translate into first-order logic: A werewolf has been scratched or bitten by another werewolf.",
"output": "∀x ∃y (Werewolf(x) → (BittenBy(x, y) ∨ ScratchedBy(x, y)) ∧ Werewolf(y))"
},
{
"input": "Translate into first-order logic: If someone has been scratched or bitten, they have been attacked.",
"output": "∀x ∃y (BittenBy(x, y) ∨ ScratchedBy(x, y)) → AttackedBy(x,y)"
},
{
"input": "Translate into first-order logic: A werewolf is a human that can turn into a wolf.",
"output": "∀x (Human(x) ∧ CanTurnInto(x, wolf) → Werewolf(x))"
},
{
"input": "Translate into first-order logic: A werewolf has been scratched or bitten by another werewolf.",
"output": "∀x ∃y (Werewolf(x) → (BittenBy(x, y) ∨ ScratchedBy(x, y)) ∧ Werewolf(y))"
},
{
"input": "Translate into first-order logic: If someone has been scratched or bitten, they have been attacked.",
"output": "∀x ∃y (BittenBy(x, y) ∨ ScratchedBy(x, y)) → AttackedBy(x,y)"
},
{
"input": "Translate into first-order logic: UFC Fight Night was a mixed martial arts event and was held in Sweden.",
"output": "Event(uFCFightNight) ∧ MixedMartial(uFCFightNight) ∧ Sweden(uFCFightNight)"
},
{
"input": "Translate into first-order logic: At UFC Fight Night, Sadollah was scheduled to fight Musoke.",
"output": "Event(uFCFightNight) → ScheduledToFight(sadollah, musoke)"
},
{
"input": "Translate into first-order logic: Sadollah fought Akiyama at UFC Fight Night.",
"output": "Event(uFCFightNight) → Fight(sadollah, akiyama)"
},
{
"input": "Translate into first-order logic: Musoke fought Yakovlev at UFC Fight Night.",
"output": "Event(uFCFightNight) → Fight(musoke, yakovlev)"
},
{
"input": "Translate into first-order logic: Jung was injured at UFC Fight Night.",
"output": "Event(uFCFightNight) → Injured(jung)"
},
{
"input": "Translate into first-order logic: Injured people did not fight at UFC Fight Night.",
"output": "∀x (Injured(x) → ¬FightInUFC(x))"
},
{
"input": "Translate into first-order logic: UFC Fight Night was a mixed martial arts event and was held in Sweden.",
"output": "Event(uFCFightNight) ∧ MixedMartial(uFCFightNight) ∧ Sweden(uFCFightNight)"
},
{
"input": "Translate into first-order logic: At UFC Fight Night, Sadollah was scheduled to fight Musoke.",
"output": "Event(uFCFightNight) → ScheduledToFight(sadollah, musoke)"
},
{
"input": "Translate into first-order logic: Sadollah fought Akiyama at UFC Fight Night.",
"output": "Event(uFCFightNight) → Fight(sadollah, akiyama)"
},
{
"input": "Translate into first-order logic: Musoke fought Yakovlev at UFC Fight Night.",
"output": "Event(uFCFightNight) → Fight(musoke, yakovlev)"
},
{
"input": "Translate into first-order logic: Jung was injured at UFC Fight Night.",
"output": "Event(uFCFightNight) → Injured(jung)"
},
{
"input": "Translate into first-order logic: Injured people did not fight at UFC Fight Night.",
"output": "∀x (Injured(x) → ¬FightInUFC(x))"
},
{
"input": "Translate into first-order logic: UFC Fight Night was a mixed martial arts event and was held in Sweden.",
"output": "Event(uFCFightNight) ∧ MixedMartial(uFCFightNight) ∧ Sweden(uFCFightNight)"
},
{
"input": "Translate into first-order logic: At UFC Fight Night, Sadollah was scheduled to fight Musoke.",
"output": "Event(uFCFightNight) → ScheduledToFight(sadollah, musoke)"
},
{
"input": "Translate into first-order logic: Sadollah fought Akiyama at UFC Fight Night.",
"output": "Event(uFCFightNight) → Fight(sadollah, akiyama)"
},
{
"input": "Translate into first-order logic: Musoke fought Yakovlev at UFC Fight Night.",
"output": "Event(uFCFightNight) → Fight(musoke, yakovlev)"
},
{
"input": "Translate into first-order logic: Jung was injured at UFC Fight Night.",
"output": "Event(uFCFightNight) → Injured(jung)"
},
{
"input": "Translate into first-order logic: Injured people did not fight at UFC Fight Night.",
"output": "∀x (Injured(x) → ¬FightInUFC(x))"
},
{
"input": "Translate into first-order logic: UFC Fight Night was a mixed martial arts event and was held in Sweden.",
"output": "Event(uFCFightNight) ∧ MixedMartial(uFCFightNight) ∧ Sweden(uFCFightNight)"
},
{
"input": "Translate into first-order logic: At UFC Fight Night, Sadollah was scheduled to fight Musoke.",
"output": "Event(uFCFightNight) → ScheduledToFight(sadollah, musoke)"
},
{
"input": "Translate into first-order logic: Sadollah fought Akiyama at UFC Fight Night.",
"output": "Event(uFCFightNight) → Fight(sadollah, akiyama)"
},
{
"input": "Translate into first-order logic: Musoke fought Yakovlev at UFC Fight Night.",
"output": "Event(uFCFightNight) → Fight(musoke, yakovlev)"
},
{
"input": "Translate into first-order logic: Jung was injured at UFC Fight Night.",
"output": "Event(uFCFightNight) → Injured(jung)"
},
{
"input": "Translate into first-order logic: Injured people did not fight at UFC Fight Night.",
"output": "∀x (Injured(x) → ¬FightInUFC(x))"
},
{
"input": "Translate into first-order logic: All drinks are edible.",
"output": "∀x (Drink(x) → Edible(x))"
},
{
"input": "Translate into first-order logic: All juices are drinks.",
"output": "∀x (Juice(x) → Drink(x))"
},
{
"input": "Translate into first-order logic: All orange juice is a juice.",
"output": "∀x (OrangeJuice(x) → Juice(x))"
},
{
"input": "Translate into first-order logic: A juice is either an orange juice or an apple juice.",
"output": "∀x (OrangeJuice(x) ∨ AppleJuice(x))"
},
{
"input": "Translate into first-order logic: All apple juice is sweet.",
"output": "∀x (AppleJuice(x) → Sweet(x))"
},
{
"input": "Translate into first-order logic: If coke is apple juice, then coke is a drink.",
"output": "AppleJuice(coke) → Drink(coke)"
},
{
"input": "Translate into first-order logic: If coke is not apple juice, then coke is not edible.",
"output": "¬AppleJuice(coke) → ¬Edible(coke)"
},
{
"input": "Translate into first-order logic: All drinks are edible.",
"output": "∀x (Drink(x) → Edible(x))"
},
{
"input": "Translate into first-order logic: All juices are drinks.",
"output": "∀x (Juice(x) → Drink(x))"
},
{
"input": "Translate into first-order logic: All orange juice is a juice.",
"output": "∀x (OrangeJuice(x) → Juice(x))"
},
{
"input": "Translate into first-order logic: A juice is either an orange juice or an apple juice.",
"output": "∀x (OrangeJuice(x) ∨ AppleJuice(x))"
},
{
"input": "Translate into first-order logic: All apple juice is sweet.",
"output": "∀x (AppleJuice(x) → Sweet(x))"
},
{
"input": "Translate into first-order logic: If coke is apple juice, then coke is a drink.",
"output": "AppleJuice(coke) → Drink(coke)"
},
{
"input": "Translate into first-order logic: If coke is not apple juice, then coke is not edible.",
"output": "¬AppleJuice(coke) → ¬Edible(coke)"
},
{
"input": "Translate into first-order logic: All drinks are edible.",
"output": "∀x (Drink(x) → Edible(x))"
},
{
"input": "Translate into first-order logic: All juices are drinks.",
"output": "∀x (Juice(x) → Drink(x))"
},
{
"input": "Translate into first-order logic: All orange juice is a juice.",
"output": "∀x (OrangeJuice(x) → Juice(x))"
},
{
"input": "Translate into first-order logic: A juice is either an orange juice or an apple juice.",
"output": "∀x (OrangeJuice(x) ∨ AppleJuice(x))"
},
{
"input": "Translate into first-order logic: All apple juice is sweet.",
"output": "∀x (AppleJuice(x) → Sweet(x))"
},
{
"input": "Translate into first-order logic: If coke is apple juice, then coke is a drink.",
"output": "AppleJuice(coke) → Drink(coke)"
},
{
"input": "Translate into first-order logic: If coke is not apple juice, then coke is not edible.",
"output": "¬AppleJuice(coke) → ¬Edible(coke)"
},
{
"input": "Translate into first-order logic: Federico Garcia Lorca was a talented Spanish poet and he supported the Popular Front.",
"output": "TalentedPoet(lorca) ∧ SupportPopulists(lorca)"
},
{
"input": "Translate into first-order logic: The Spanish Nationalists opposed anyone who supported the Popular Front",
"output": "∀x (SupportPopulists(x) → Opposed(nationalists, x))"
},
{
"input": "Translate into first-order logic: Talented poets are popular.",
"output": "∀x (TalentedPoet(x) → Popular(x))"
},
{
"input": "Translate into first-order logic: Spanish Nationalists killed anyone who they opposed and were popular.",
"output": "∀x (Opposed(nationalists, x) ∧ Popular(x) → Killed(nationalists, x))"
},
{
"input": "Translate into first-order logic: Daniel supported the Popular Front but was not popular.",
"output": "SupportPopulists(daniel) ∧ ¬Popular(daniel)"
},
{
"input": "Translate into first-order logic: Federico Garcia Lorca was a talented Spanish poet and he supported the Popular Front.",
"output": "TalentedPoet(lorca) ∧ SupportPopulists(lorca)"
},
{
"input": "Translate into first-order logic: The Spanish Nationalists opposed anyone who supported the Popular Front",
"output": "∀x (SupportPopulists(x) → Opposed(nationalists, x))"
},
{
"input": "Translate into first-order logic: Talented poets are popular.",
"output": "∀x (TalentedPoet(x) → Popular(x))"
},
{
"input": "Translate into first-order logic: Spanish Nationalists killed anyone who they opposed and were popular.",
"output": "∀x (Opposed(nationalists, x) ∧ Popular(x) → Killed(nationalists, x))"
},
{
"input": "Translate into first-order logic: Daniel supported the Popular Front but was not popular.",
"output": "SupportPopulists(daniel) ∧ ¬Popular(daniel)"
},
{
"input": "Translate into first-order logic: People either drink kombucha every day or drink Coca-Cola or Pepsi products every day.",
"output": "∀x (Kombucha(x) ∨ CocaCola(x))"
},
{
"input": "Translate into first-order logic: If people drink Coca-Cola or Pepsi products every day, then they grew up with extremely busy parents who did not have time to pack them lunch.",
"output": "∀x (CocaCola(x) → BusyParents(x))"
},
{
"input": "Translate into first-order logic: If people drink Coca-Cola or Pepsi products every day, then they have to visit the dentist frequently.",
"output": "∀x (CocaCola(x) → Dentist(x))"
},
{
"input": "Translate into first-order logic: If people grew up with extremely busy parents who did not have time to pack them lunch, then they have erratic and diverse eating habits.",
"output": "∀x (BusyParents(x) → Erratic(x))"
},
{
"input": "Translate into first-order logic: If people have erratic and diverse eating habits, then they do not have consistent everyday routines and like sticking to a solid schedule.",
"output": "∀x (Erratic(x) → ¬Consistent(x))"
},
{
"input": "Translate into first-order logic: Franny either both grew up with extremely busy parents who did not have time to pack her lunch and has consistent everyday routines and like sticking to a solid schedule, or she neither grew up with extremely busy parents who did not have time to pack her lunch nor has consistent everyday routines and likes sticking to a schedule.",
"output": "(BusyParents(franny) ∧ Consistent(franny)) ⊕ (¬BusyParents(franny) ∧ ¬Consistent(franny))"
},
{
"input": "Translate into first-order logic: People either drink kombucha every day or drink Coca-Cola or Pepsi products every day.",
"output": "∀x (Kombucha(x) ∨ CocaCola(x))"
},
{
"input": "Translate into first-order logic: If people drink Coca-Cola or Pepsi products every day, then they grew up with extremely busy parents who did not have time to pack them lunch.",
"output": "∀x (CocaCola(x) → BusyParents(x))"
},
{
"input": "Translate into first-order logic: If people drink Coca-Cola or Pepsi products every day, then they have to visit the dentist frequently.",
"output": "∀x (CocaCola(x) → Dentist(x))"
},
{
"input": "Translate into first-order logic: If people grew up with extremely busy parents who did not have time to pack them lunch, then they have erratic and diverse eating habits.",
"output": "∀x (BusyParents(x) → Erratic(x))"
},
{
"input": "Translate into first-order logic: If people have erratic and diverse eating habits, then they do not have consistent everyday routines and like sticking to a solid schedule.",
"output": "∀x (Erratic(x) → ¬Consistent(x))"
},
{
"input": "Translate into first-order logic: Franny either both grew up with extremely busy parents who did not have time to pack her lunch and has consistent everyday routines and like sticking to a solid schedule, or she neither grew up with extremely busy parents who did not have time to pack her lunch nor has consistent everyday routines and likes sticking to a schedule.",
"output": "(BusyParents(franny) ∧ Consistent(franny)) ⊕ (¬BusyParents(franny) ∧ ¬Consistent(franny))"
},
{
"input": "Translate into first-order logic: People either drink kombucha every day or drink Coca-Cola or Pepsi products every day.",
"output": "∀x (Kombucha(x) ∨ CocaCola(x))"
},
{
"input": "Translate into first-order logic: If people drink Coca-Cola or Pepsi products every day, then they grew up with extremely busy parents who did not have time to pack them lunch.",
"output": "∀x (CocaCola(x) → BusyParents(x))"
},
{
"input": "Translate into first-order logic: If people drink Coca-Cola or Pepsi products every day, then they have to visit the dentist frequently.",
"output": "∀x (CocaCola(x) → Dentist(x))"
},
{
"input": "Translate into first-order logic: If people grew up with extremely busy parents who did not have time to pack them lunch, then they have erratic and diverse eating habits.",
"output": "∀x (BusyParents(x) → Erratic(x))"
},
{
"input": "Translate into first-order logic: If people have erratic and diverse eating habits, then they do not have consistent everyday routines and like sticking to a solid schedule.",
"output": "∀x (Erratic(x) → ¬Consistent(x))"
},
{
"input": "Translate into first-order logic: Franny either both grew up with extremely busy parents who did not have time to pack her lunch and has consistent everyday routines and like sticking to a solid schedule, or she neither grew up with extremely busy parents who did not have time to pack her lunch nor has consistent everyday routines and likes sticking to a schedule.",
"output": "(BusyParents(franny) ∧ Consistent(franny)) ⊕ (¬BusyParents(franny) ∧ ¬Consistent(franny))"
},
{
"input": "Translate into first-order logic: If a customer subscribes to AMC A List, then he/she can watch 3 movies every week without any additional fees.",
"output": "∀x (SubscribedTo(x, amcalist) → ThreeMovies(x) ∧ NoFees(x))"
},
{
"input": "Translate into first-order logic: Some customers go to cinemas every week.",
"output": "∃x (CinemaEveryWeek(x))"
},
{
"input": "Translate into first-order logic: Customers who prefer TV series will not watch TV series in cinemas.",
"output": "∀x (Prefer(x, tvseries) → ¬WatchTVIn(x, cinemas))"
},
{
"input": "Translate into first-order logic: James watches TV series in cinemas.",
"output": "WatchTVIn(james, cinemas)"
},
{
"input": "Translate into first-order logic: James subscribes to AMC A List.",
"output": "SubscribedTo(james, amcalist)"
},
{
"input": "Translate into first-order logic: Peter prefers TV series.",
"output": "Prefer(peter, tvseries)"
},
{
"input": "Translate into first-order logic: If a customer subscribes to AMC A List, then he/she can watch 3 movies every week without any additional fees.",
"output": "∀x (SubscribedTo(x, amcalist) → ThreeMovies(x) ∧ NoFees(x))"
},
{
"input": "Translate into first-order logic: Some customers go to cinemas every week.",
"output": "∃x (CinemaEveryWeek(x))"
},
{
"input": "Translate into first-order logic: Customers who prefer TV series will not watch TV series in cinemas.",
"output": "∀x (Prefer(x, tvseries) → ¬WatchTVIn(x, cinemas))"
},
{
"input": "Translate into first-order logic: James watches TV series in cinemas.",
"output": "WatchTVIn(james, cinemas)"
},
{
"input": "Translate into first-order logic: James subscribes to AMC A List.",
"output": "SubscribedTo(james, amcalist)"
},
{
"input": "Translate into first-order logic: Peter prefers TV series.",
"output": "Prefer(peter, tvseries)"
},
{
"input": "Translate into first-order logic: If a customer subscribes to AMC A List, then he/she can watch 3 movies every week without any additional fees.",
"output": "∀x (SubscribedTo(x, amcalist) → ThreeMovies(x) ∧ NoFees(x))"
},
{
"input": "Translate into first-order logic: Some customers go to cinemas every week.",
"output": "∃x (CinemaEveryWeek(x))"
},
{
"input": "Translate into first-order logic: Customers who prefer TV series will not watch TV series in cinemas.",
"output": "∀x (Prefer(x, tvseries) → ¬WatchTVIn(x, cinemas))"
},
{
"input": "Translate into first-order logic: James watches TV series in cinemas.",
"output": "WatchTVIn(james, cinemas)"
},
{
"input": "Translate into first-order logic: James subscribes to AMC A List.",
"output": "SubscribedTo(james, amcalist)"
},
{
"input": "Translate into first-order logic: Peter prefers TV series.",
"output": "Prefer(peter, tvseries)"
},
{
"input": "Translate into first-order logic: Bulbophyllum attenuatum is in the genus bulbophyllum.",
"output": "InGenus(bulbophyllumattenuatum, bulbophyllum)"
},
{
"input": "Translate into first-order logic: All bulbophyllum are orchids.",
"output": "∀x (InGenus(x, bulbophyllum) → Orchid(x))"
},
{
"input": "Translate into first-order logic: There are eight federal districts of Russia: Central, Northwestern, Southern, North Caucasian, Volga, Ural, Siberian and Far Eastern.",
"output": "FederalDistrictOfRussia(central) ∨ FederalDistrictOfRussia(northwestern) ∨ FederalDistrictOfRussia(southern) ∨ FederalDistrictOfRussia(northcaucasian) ∨ FederalDistrictOfRussia(volga) ∨ FederalDistrictOfRussia(ural) ∨ FederalDistrictOfRussia(siberian) ∨ FederalDistrictOfRussia(fareastern)"
},
{
"input": "Translate into first-order logic: The Central federal district has the largest population among all federal districts in Russia.",
"output": "FederalDistrictOfRussia(central) ∧ LargestPopulationIn(central) "
},
{
"input": "Translate into first-order logic: Moscow is the administrative center of the Central federal district.",
"output": "AdministrativeCenterOf(moscow, central)"
},
{
"input": "Translate into first-order logic: Yekaterinburg is the administrative center of the Ural federal district.",
"output": "AdministrativeCenterOf(yekaterinburg, ural)"
},
{
"input": "Translate into first-order logic: Vladivostok is the administrative center of the Far Eastern federal district.",
"output": "AdministrativeCenterOf(vladivostok, fareastern)"
},
{
"input": "Translate into first-order logic: The Far Eastern federal district has the largest area among all federal districts in Russia.",
"output": "FederalDistrictOfRussia(fareastern) ∧ LargestAreaIn(fareastern)"
},
{
"input": "Translate into first-order logic: Some federal districts of Russia were established in 2000.",
"output": "∃x (FederalDistrictOfRussia(x) → EstablishedIn(x, 2000))"
},
{
"input": "Translate into first-order logic: There are eight federal districts of Russia: Central, Northwestern, Southern, North Caucasian, Volga, Ural, Siberian and Far Eastern.",
"output": "FederalDistrictOfRussia(central) ∨ FederalDistrictOfRussia(northwestern) ∨ FederalDistrictOfRussia(southern) ∨ FederalDistrictOfRussia(northcaucasian) ∨ FederalDistrictOfRussia(volga) ∨ FederalDistrictOfRussia(ural) ∨ FederalDistrictOfRussia(siberian) ∨ FederalDistrictOfRussia(fareastern)"
},
{
"input": "Translate into first-order logic: The Central federal district has the largest population among all federal districts in Russia.",
"output": "FederalDistrictOfRussia(central) ∧ LargestPopulationIn(central) "
},
{
"input": "Translate into first-order logic: Moscow is the administrative center of the Central federal district.",
"output": "AdministrativeCenterOf(moscow, central)"
},
{
"input": "Translate into first-order logic: Yekaterinburg is the administrative center of the Ural federal district.",
"output": "AdministrativeCenterOf(yekaterinburg, ural)"
},
{
"input": "Translate into first-order logic: Vladivostok is the administrative center of the Far Eastern federal district.",
"output": "AdministrativeCenterOf(vladivostok, fareastern)"
},
{
"input": "Translate into first-order logic: The Far Eastern federal district has the largest area among all federal districts in Russia.",
"output": "FederalDistrictOfRussia(fareastern) ∧ LargestAreaIn(fareastern)"
},
{
"input": "Translate into first-order logic: Some federal districts of Russia were established in 2000.",
"output": "∃x (FederalDistrictOfRussia(x) → EstablishedIn(x, 2000))"
},
{
"input": "Translate into first-order logic: There are eight federal districts of Russia: Central, Northwestern, Southern, North Caucasian, Volga, Ural, Siberian and Far Eastern.",
"output": "FederalDistrictOfRussia(central) ∨ FederalDistrictOfRussia(northwestern) ∨ FederalDistrictOfRussia(southern) ∨ FederalDistrictOfRussia(northcaucasian) ∨ FederalDistrictOfRussia(volga) ∨ FederalDistrictOfRussia(ural) ∨ FederalDistrictOfRussia(siberian) ∨ FederalDistrictOfRussia(fareastern)"
},
{
"input": "Translate into first-order logic: The Central federal district has the largest population among all federal districts in Russia.",
"output": "FederalDistrictOfRussia(central) ∧ LargestPopulationIn(central) "
},
{
"input": "Translate into first-order logic: Moscow is the administrative center of the Central federal district.",
"output": "AdministrativeCenterOf(moscow, central)"
},
{
"input": "Translate into first-order logic: Yekaterinburg is the administrative center of the Ural federal district.",
"output": "AdministrativeCenterOf(yekaterinburg, ural)"
},
{
"input": "Translate into first-order logic: Vladivostok is the administrative center of the Far Eastern federal district.",
"output": "AdministrativeCenterOf(vladivostok, fareastern)"
},
{
"input": "Translate into first-order logic: The Far Eastern federal district has the largest area among all federal districts in Russia.",
"output": "FederalDistrictOfRussia(fareastern) ∧ LargestAreaIn(fareastern)"
},
{
"input": "Translate into first-order logic: Some federal districts of Russia were established in 2000.",
"output": "∃x (FederalDistrictOfRussia(x) → EstablishedIn(x, 2000))"
},
{
"input": "Translate into first-order logic: All cancers are malignant tumors.",
"output": "∀x (Cancer(x) → MalignantTumor(x))"
},
{
"input": "Translate into first-order logic: No malignant tumor can be treated at home.",
"output": "∀x (MalignantTumor(x) → ¬CanBeTreatedAtHome(x))"
},
{
"input": "Translate into first-order logic: All colorectal cancer is cancer.",
"output": "∀x (ColorectalCancer(x) → Cancer(x))"
},
{
"input": "Translate into first-order logic: Having a cold can be treated at home.",
"output": "∀x (HavingACold(x) → CanBeTreatedAtHome(x))"
},
{
"input": "Translate into first-order logic: Breast cancer is neither having a cold nor a malignant tumor (exclusive).",
"output": "¬(HavingACold(breastCancer) ⊕ MalignantTumor(breastCancer))"
},
{
"input": "Translate into first-order logic: All cancers are malignant tumors.",
"output": "∀x (Cancer(x) → MalignantTumor(x))"
},
{
"input": "Translate into first-order logic: No malignant tumor can be treated at home.",
"output": "∀x (MalignantTumor(x) → ¬CanBeTreatedAtHome(x))"
},
{
"input": "Translate into first-order logic: All colorectal cancer is cancer.",
"output": "∀x (ColorectalCancer(x) → Cancer(x))"
},
{
"input": "Translate into first-order logic: Having a cold can be treated at home.",
"output": "∀x (HavingACold(x) → CanBeTreatedAtHome(x))"
},
{
"input": "Translate into first-order logic: Breast cancer is neither having a cold nor a malignant tumor (exclusive).",
"output": "¬(HavingACold(breastCancer) ⊕ MalignantTumor(breastCancer))"
},
{
"input": "Translate into first-order logic: All cancers are malignant tumors.",
"output": "∀x (Cancer(x) → MalignantTumor(x))"
},
{
"input": "Translate into first-order logic: No malignant tumor can be treated at home.",
"output": "∀x (MalignantTumor(x) → ¬CanBeTreatedAtHome(x))"
},
{
"input": "Translate into first-order logic: All colorectal cancer is cancer.",
"output": "∀x (ColorectalCancer(x) → Cancer(x))"
},
{
"input": "Translate into first-order logic: Having a cold can be treated at home.",
"output": "∀x (HavingACold(x) → CanBeTreatedAtHome(x))"
},
{
"input": "Translate into first-order logic: Breast cancer is neither having a cold nor a malignant tumor (exclusive).",
"output": "¬(HavingACold(breastCancer) ⊕ MalignantTumor(breastCancer))"
},
{
"input": "Translate into first-order logic: All cancers are malignant tumors.",
"output": "∀x (Cancer(x) → MalignantTumor(x))"
},
{
"input": "Translate into first-order logic: No malignant tumor can be treated at home.",
"output": "∀x (MalignantTumor(x) → ¬CanBeTreatedAtHome(x))"
},
{
"input": "Translate into first-order logic: All colorectal cancer is cancer.",
"output": "∀x (ColorectalCancer(x) → Cancer(x))"
},
{
"input": "Translate into first-order logic: Having a cold can be treated at home.",
"output": "∀x (HavingACold(x) → CanBeTreatedAtHome(x))"
},
{
"input": "Translate into first-order logic: Breast cancer is neither having a cold nor a malignant tumor (exclusive).",
"output": "¬(HavingACold(breastCancer) ⊕ MalignantTumor(breastCancer))"
},
{
"input": "Translate into first-order logic: All cancers are malignant tumors.",
"output": "∀x (Cancer(x) → MalignantTumor(x))"
},
{
"input": "Translate into first-order logic: No malignant tumor can be treated at home.",
"output": "∀x (MalignantTumor(x) → ¬CanBeTreatedAtHome(x))"
},
{
"input": "Translate into first-order logic: All colorectal cancer is cancer.",
"output": "∀x (ColorectalCancer(x) → Cancer(x))"
},
{
"input": "Translate into first-order logic: Having a cold can be treated at home.",
"output": "∀x (HavingACold(x) → CanBeTreatedAtHome(x))"
},
{
"input": "Translate into first-order logic: Breast cancer is neither having a cold nor a malignant tumor (exclusive).",
"output": "¬(HavingACold(breastCancer) ⊕ MalignantTumor(breastCancer))"
},
{
"input": "Translate into first-order logic: All cancers are malignant tumors.",
"output": "∀x (Cancer(x) → MalignantTumor(x))"
},
{
"input": "Translate into first-order logic: No malignant tumor can be treated at home.",
"output": "∀x (MalignantTumor(x) → ¬CanBeTreatedAtHome(x))"
},
{
"input": "Translate into first-order logic: All colorectal cancer is cancer.",
"output": "∀x (ColorectalCancer(x) → Cancer(x))"
},
{
"input": "Translate into first-order logic: Having a cold can be treated at home.",
"output": "∀x (HavingACold(x) → CanBeTreatedAtHome(x))"
},
{
"input": "Translate into first-order logic: Breast cancer is neither having a cold nor a malignant tumor (exclusive).",
"output": "¬(HavingACold(breastCancer) ⊕ MalignantTumor(breastCancer))"
},
{
"input": "Translate into first-order logic: I should not worry about things outside of my control.",
"output": "∀x (OutsideControl(x) → ¬ShouldWorry(x))"
},
{
"input": "Translate into first-order logic: Traffic is outside of my control.",
"output": "∀x (Traffic(x) → OutsideControl(x))"
},
{
"input": "Translate into first-order logic: Roversi is an Italian surname.",
"output": "∀x (UseAsSurname(x, roversi) → UseItalianSurname(x))"
},
{
"input": "Translate into first-order logic: Alba Roversi uses Roversi as a surname.",
"output": "UseAsSurname(alba, roversi)"
},
{
"input": "Translate into first-order logic: Paolo Roversi uses Roversi as a surname.",
"output": "UseAsSurname(paolo, roversi)"
},
{
"input": "Translate into first-order logic: Roberto Roversi uses Roversi as a surname.",
"output": "UseAsSurname(roberto, roversi)"
},
{
"input": "Translate into first-order logic: Paolo Roversi is a photographer.",
"output": "Photographer(paolo)"
},
{
"input": "Translate into first-order logic: A photographer is a professional or an amateur.",
"output": "∀x (Photographer(x) → Professional(x) ∨ Amateur(x))"
},
{
"input": "Translate into first-order logic: Roversi is an Italian surname.",
"output": "∀x (UseAsSurname(x, roversi) → UseItalianSurname(x))"
},
{
"input": "Translate into first-order logic: Alba Roversi uses Roversi as a surname.",
"output": "UseAsSurname(alba, roversi)"
},
{
"input": "Translate into first-order logic: Paolo Roversi uses Roversi as a surname.",
"output": "UseAsSurname(paolo, roversi)"
},
{
"input": "Translate into first-order logic: Roberto Roversi uses Roversi as a surname.",
"output": "UseAsSurname(roberto, roversi)"
},
{
"input": "Translate into first-order logic: Paolo Roversi is a photographer.",
"output": "Photographer(paolo)"
},
{
"input": "Translate into first-order logic: A photographer is a professional or an amateur.",
"output": "∀x (Photographer(x) → Professional(x) ∨ Amateur(x))"
},
{
"input": "Translate into first-order logic: Roversi is an Italian surname.",
"output": "∀x (UseAsSurname(x, roversi) → UseItalianSurname(x))"
},
{
"input": "Translate into first-order logic: Alba Roversi uses Roversi as a surname.",
"output": "UseAsSurname(alba, roversi)"
},
{
"input": "Translate into first-order logic: Paolo Roversi uses Roversi as a surname.",
"output": "UseAsSurname(paolo, roversi)"
},
{
"input": "Translate into first-order logic: Roberto Roversi uses Roversi as a surname.",
"output": "UseAsSurname(roberto, roversi)"
},
{
"input": "Translate into first-order logic: Paolo Roversi is a photographer.",
"output": "Photographer(paolo)"
},
{
"input": "Translate into first-order logic: A photographer is a professional or an amateur.",
"output": "∀x (Photographer(x) → Professional(x) ∨ Amateur(x))"
},
{
"input": "Translate into first-order logic: Zaha Hadid is a British-Iraqi architect, artist and designer.",
"output": "British-IraqiArchitect(zahaHadid)"
},
{
"input": "Translate into first-order logic: Zaha Hadid was born on 31 October 1950 in Baghdad, Iraq.",
"output": "BornIn(zahaHadid, y1950)"
},
{
"input": "Translate into first-order logic: Hadid was a visiting professor of Architectural Design at the Yale School of Architecture.",
"output": "Visitingprofessor(zahaHadid, yaleSchoolofArchitecture)"
},
{
"input": "Translate into first-order logic: Max is an aspiring architecture student, and he plans to apply to Yale School of Architecture.",
"output": "AspiringArchitectureStudent(max) ∧ PlansToApplyTo(max, yaleSchoolofArchitecture)"
},
{
"input": "Translate into first-order logic: Zaha Hadid is a British-Iraqi architect, artist and designer.",
"output": "British-IraqiArchitect(zahaHadid)"
},
{
"input": "Translate into first-order logic: Zaha Hadid was born on 31 October 1950 in Baghdad, Iraq.",
"output": "BornIn(zahaHadid, y1950)"
},
{
"input": "Translate into first-order logic: Hadid was a visiting professor of Architectural Design at the Yale School of Architecture.",
"output": "Visitingprofessor(zahaHadid, yaleSchoolofArchitecture)"
},
{
"input": "Translate into first-order logic: Max is an aspiring architecture student, and he plans to apply to Yale School of Architecture.",
"output": "AspiringArchitectureStudent(max) ∧ PlansToApplyTo(max, yaleSchoolofArchitecture)"
},
{
"input": "Translate into first-order logic: Zaha Hadid is a British-Iraqi architect, artist and designer.",
"output": "British-IraqiArchitect(zahaHadid)"
},
{
"input": "Translate into first-order logic: Zaha Hadid was born on 31 October 1950 in Baghdad, Iraq.",
"output": "BornIn(zahaHadid, y1950)"
},
{
"input": "Translate into first-order logic: Hadid was a visiting professor of Architectural Design at the Yale School of Architecture.",
"output": "Visitingprofessor(zahaHadid, yaleSchoolofArchitecture)"
},
{
"input": "Translate into first-order logic: Max is an aspiring architecture student, and he plans to apply to Yale School of Architecture.",
"output": "AspiringArchitectureStudent(max) ∧ PlansToApplyTo(max, yaleSchoolofArchitecture)"
},
{
"input": "Translate into first-order logic: Zaha Hadid is a British-Iraqi architect, artist and designer.",
"output": "British-IraqiArchitect(zahaHadid)"
},
{
"input": "Translate into first-order logic: Zaha Hadid was born on 31 October 1950 in Baghdad, Iraq.",
"output": "BornIn(zahaHadid, y1950)"
},
{
"input": "Translate into first-order logic: Hadid was a visiting professor of Architectural Design at the Yale School of Architecture.",
"output": "Visitingprofessor(zahaHadid, yaleSchoolofArchitecture)"
},
{
"input": "Translate into first-order logic: Max is an aspiring architecture student, and he plans to apply to Yale School of Architecture.",
"output": "AspiringArchitectureStudent(max) ∧ PlansToApplyTo(max, yaleSchoolofArchitecture)"
},
{
"input": "Translate into first-order logic: Something is either an invasive neuroimaging technique or a noninvasive neuroimaging technique.",
"output": "∀x (InvasiveNeuroimagingTechnique(x) ∨ NoninvasiveNeuroimagingTechnique(x)) "
},
{
"input": "Translate into first-order logic: All noninvasive neuroimaging techniques provide a spatial resolution of brains.",
"output": " ∀x (NoninvasiveNeuroimagingTechnique(x) → ProvidesSpatialResolutionOfBrains(x)) "
},
{
"input": "Translate into first-order logic: If a technique provides a spatial resolution of brains, then it is a measurement of brain activity.",
"output": " ∀x (ProvidesSpatialResolutionOfBrains(x) → MeasurementOfBrainActivity(x)) "
},
{
"input": "Translate into first-order logic: All measurements of brain activity are used by neuroscience researchers.",
"output": " ∀x (MeasurementOfBrainActivity(x) → UsedByNeuroscienceResearchers(x))"
},
{
"input": "Translate into first-order logic: FMRI is either a measurement of brain activity or a noninvasive neuroimaging technique.",
"output": " MeasurementOfBrainActivity(fMRI) ⊕ NoninvasiveNeuroimagingTechnique(fMRI)"
},
{
"input": "Translate into first-order logic: Something is either an invasive neuroimaging technique or a noninvasive neuroimaging technique.",
"output": "∀x (InvasiveNeuroimagingTechnique(x) ∨ NoninvasiveNeuroimagingTechnique(x)) "
},
{
"input": "Translate into first-order logic: All noninvasive neuroimaging techniques provide a spatial resolution of brains.",
"output": " ∀x (NoninvasiveNeuroimagingTechnique(x) → ProvidesSpatialResolutionOfBrains(x)) "
},
{
"input": "Translate into first-order logic: If a technique provides a spatial resolution of brains, then it is a measurement of brain activity.",
"output": " ∀x (ProvidesSpatialResolutionOfBrains(x) → MeasurementOfBrainActivity(x)) "
},
{
"input": "Translate into first-order logic: All measurements of brain activity are used by neuroscience researchers.",
"output": " ∀x (MeasurementOfBrainActivity(x) → UsedByNeuroscienceResearchers(x))"
},
{
"input": "Translate into first-order logic: FMRI is either a measurement of brain activity or a noninvasive neuroimaging technique.",
"output": " MeasurementOfBrainActivity(fMRI) ⊕ NoninvasiveNeuroimagingTechnique(fMRI)"
},
{
"input": "Translate into first-order logic: Something is either an invasive neuroimaging technique or a noninvasive neuroimaging technique.",
"output": "∀x (InvasiveNeuroimagingTechnique(x) ∨ NoninvasiveNeuroimagingTechnique(x)) "
},
{
"input": "Translate into first-order logic: All noninvasive neuroimaging techniques provide a spatial resolution of brains.",
"output": " ∀x (NoninvasiveNeuroimagingTechnique(x) → ProvidesSpatialResolutionOfBrains(x)) "
},
{
"input": "Translate into first-order logic: If a technique provides a spatial resolution of brains, then it is a measurement of brain activity.",
"output": " ∀x (ProvidesSpatialResolutionOfBrains(x) → MeasurementOfBrainActivity(x)) "
},
{
"input": "Translate into first-order logic: All measurements of brain activity are used by neuroscience researchers.",
"output": " ∀x (MeasurementOfBrainActivity(x) → UsedByNeuroscienceResearchers(x))"
},
{
"input": "Translate into first-order logic: FMRI is either a measurement of brain activity or a noninvasive neuroimaging technique.",
"output": " MeasurementOfBrainActivity(fMRI) ⊕ NoninvasiveNeuroimagingTechnique(fMRI)"
},
{
"input": "Translate into first-order logic: Something is either an invasive neuroimaging technique or a noninvasive neuroimaging technique.",
"output": "∀x (InvasiveNeuroimagingTechnique(x) ∨ NoninvasiveNeuroimagingTechnique(x)) "
},
{
"input": "Translate into first-order logic: All noninvasive neuroimaging techniques provide a spatial resolution of brains.",
"output": " ∀x (NoninvasiveNeuroimagingTechnique(x) → ProvidesSpatialResolutionOfBrains(x)) "
},
{
"input": "Translate into first-order logic: If a technique provides a spatial resolution of brains, then it is a measurement of brain activity.",
"output": " ∀x (ProvidesSpatialResolutionOfBrains(x) → MeasurementOfBrainActivity(x)) "
},
{
"input": "Translate into first-order logic: All measurements of brain activity are used by neuroscience researchers.",
"output": " ∀x (MeasurementOfBrainActivity(x) → UsedByNeuroscienceResearchers(x))"
},
{
"input": "Translate into first-order logic: FMRI is either a measurement of brain activity or a noninvasive neuroimaging technique.",
"output": " MeasurementOfBrainActivity(fMRI) ⊕ NoninvasiveNeuroimagingTechnique(fMRI)"
},
{
"input": "Translate into first-order logic: Either present their work at the conference or provide a tutorial session at the conference.",
"output": "∀x ( Present(x) ∨ Tutorial(x))"
},
{
"input": "Translate into first-order logic: All who present their work at the conference will attend in person.",
"output": "∀x (Present(x) → InPerson(x))"
},
{
"input": "Translate into first-order logic: All those providing a tutorial session at the conference are invited to join the club.",
"output": "∀x (Tutorial(x) → Invited(x))"
},
{
"input": "Translate into first-order logic: All who attend the conference in person are provided with souvenirs.",
"output": "∀x (InPerson(x) → Souvenirs(x))"
},
{
"input": "Translate into first-order logic: All invited to join the club are provided with delicious meals.",
"output": "∀x (Invited(x) → Meals(x))"
},
{
"input": "Translate into first-order logic: All provided with delicious meals are happy to communicate with each other during the dinner.",
"output": "∀x (Meals(x) → HappyCommunicate(x))"
},
{
"input": "Translate into first-order logic: All provided with delicious meals are invited to take a photo with the audience.",
"output": "∀x (Meals(x) → InvitedTakePhoto(x))"
},
{
"input": "Translate into first-order logic: James does not attend the conference in person and is not provided with souvenirs.",
"output": "¬(InPerson(james) ∧ Souvenirs(james))"
},
{
"input": "Translate into first-order logic: Either present their work at the conference or provide a tutorial session at the conference.",
"output": "∀x ( Present(x) ∨ Tutorial(x))"
},
{
"input": "Translate into first-order logic: All who present their work at the conference will attend in person.",
"output": "∀x (Present(x) → InPerson(x))"
},
{
"input": "Translate into first-order logic: All those providing a tutorial session at the conference are invited to join the club.",
"output": "∀x (Tutorial(x) → Invited(x))"
},
{
"input": "Translate into first-order logic: All who attend the conference in person are provided with souvenirs.",
"output": "∀x (InPerson(x) → Souvenirs(x))"
},
{
"input": "Translate into first-order logic: All invited to join the club are provided with delicious meals.",
"output": "∀x (Invited(x) → Meals(x))"
},
{
"input": "Translate into first-order logic: All provided with delicious meals are happy to communicate with each other during the dinner.",
"output": "∀x (Meals(x) → HappyCommunicate(x))"
},
{
"input": "Translate into first-order logic: All provided with delicious meals are invited to take a photo with the audience.",
"output": "∀x (Meals(x) → InvitedTakePhoto(x))"
},
{
"input": "Translate into first-order logic: James does not attend the conference in person and is not provided with souvenirs.",
"output": "¬(InPerson(james) ∧ Souvenirs(james))"
},
{
"input": "Translate into first-order logic: Either present their work at the conference or provide a tutorial session at the conference.",
"output": "∀x ( Present(x) ∨ Tutorial(x))"
},
{
"input": "Translate into first-order logic: All who present their work at the conference will attend in person.",
"output": "∀x (Present(x) → InPerson(x))"
},
{
"input": "Translate into first-order logic: All those providing a tutorial session at the conference are invited to join the club.",
"output": "∀x (Tutorial(x) → Invited(x))"
},
{
"input": "Translate into first-order logic: All who attend the conference in person are provided with souvenirs.",
"output": "∀x (InPerson(x) → Souvenirs(x))"
},
{
"input": "Translate into first-order logic: All invited to join the club are provided with delicious meals.",
"output": "∀x (Invited(x) → Meals(x))"
},
{
"input": "Translate into first-order logic: All provided with delicious meals are happy to communicate with each other during the dinner.",
"output": "∀x (Meals(x) → HappyCommunicate(x))"
},
{
"input": "Translate into first-order logic: All provided with delicious meals are invited to take a photo with the audience.",
"output": "∀x (Meals(x) → InvitedTakePhoto(x))"
},
{
"input": "Translate into first-order logic: James does not attend the conference in person and is not provided with souvenirs.",
"output": "¬(InPerson(james) ∧ Souvenirs(james))"
},
{
"input": "Translate into first-order logic: Either present their work at the conference or provide a tutorial session at the conference.",
"output": "∀x ( Present(x) ∨ Tutorial(x))"
},
{
"input": "Translate into first-order logic: All who present their work at the conference will attend in person.",
"output": "∀x (Present(x) → InPerson(x))"
},
{
"input": "Translate into first-order logic: All those providing a tutorial session at the conference are invited to join the club.",
"output": "∀x (Tutorial(x) → Invited(x))"
},
{
"input": "Translate into first-order logic: All who attend the conference in person are provided with souvenirs.",
"output": "∀x (InPerson(x) → Souvenirs(x))"
},
{
"input": "Translate into first-order logic: All invited to join the club are provided with delicious meals.",
"output": "∀x (Invited(x) → Meals(x))"
},
{
"input": "Translate into first-order logic: All provided with delicious meals are happy to communicate with each other during the dinner.",
"output": "∀x (Meals(x) → HappyCommunicate(x))"
},
{
"input": "Translate into first-order logic: All provided with delicious meals are invited to take a photo with the audience.",
"output": "∀x (Meals(x) → InvitedTakePhoto(x))"
},
{
"input": "Translate into first-order logic: James does not attend the conference in person and is not provided with souvenirs.",
"output": "¬(InPerson(james) ∧ Souvenirs(james))"
},
{
"input": "Translate into first-order logic: Either present their work at the conference or provide a tutorial session at the conference.",
"output": "∀x ( Present(x) ∨ Tutorial(x))"
},
{
"input": "Translate into first-order logic: All who present their work at the conference will attend in person.",
"output": "∀x (Present(x) → InPerson(x))"
},
{
"input": "Translate into first-order logic: All those providing a tutorial session at the conference are invited to join the club.",
"output": "∀x (Tutorial(x) → Invited(x))"
},
{
"input": "Translate into first-order logic: All who attend the conference in person are provided with souvenirs.",
"output": "∀x (InPerson(x) → Souvenirs(x))"
},
{
"input": "Translate into first-order logic: All invited to join the club are provided with delicious meals.",
"output": "∀x (Invited(x) → Meals(x))"
},
{
"input": "Translate into first-order logic: All provided with delicious meals are happy to communicate with each other during the dinner.",
"output": "∀x (Meals(x) → HappyCommunicate(x))"
},
{
"input": "Translate into first-order logic: All provided with delicious meals are invited to take a photo with the audience.",
"output": "∀x (Meals(x) → InvitedTakePhoto(x))"
},
{
"input": "Translate into first-order logic: James does not attend the conference in person and is not provided with souvenirs.",
"output": "¬(InPerson(james) ∧ Souvenirs(james))"
},
{
"input": "Translate into first-order logic: The USS Salem is a heavy cruiser built for the United States navy.",
"output": "HeavyCruiser(usssalem) ∧ BuiltFor(usssalem, unitedstatesnavy)"
},
{
"input": "Translate into first-order logic: The last heavy cruiser to enter service was the USS Salem.",
"output": "LastHeavyCruiserToEnterService(usssalem)"
},
{
"input": "Translate into first-order logic: The USS Salem is a museum ship.",
"output": "MuseumShip(usssalem)"
},
{
"input": "Translate into first-order logic: Museum ships are open to the public.",
"output": "∀x (MuseumShip(x) → OpenToPublic(x))"
},
{
"input": "Translate into first-order logic: The USS Salem served in the Atlantic and Mediterranean.",
"output": "ServedIn(usssalem, atlantic) ∧ ServedIn(usssalem, mediterranean)"
},
{
"input": "Translate into first-order logic: The USS Salem is a heavy cruiser built for the United States navy.",
"output": "HeavyCruiser(usssalem) ∧ BuiltFor(usssalem, unitedstatesnavy)"
},
{
"input": "Translate into first-order logic: The last heavy cruiser to enter service was the USS Salem.",
"output": "LastHeavyCruiserToEnterService(usssalem)"
},
{
"input": "Translate into first-order logic: The USS Salem is a museum ship.",
"output": "MuseumShip(usssalem)"
},
{
"input": "Translate into first-order logic: Museum ships are open to the public.",
"output": "∀x (MuseumShip(x) → OpenToPublic(x))"
},
{
"input": "Translate into first-order logic: The USS Salem served in the Atlantic and Mediterranean.",
"output": "ServedIn(usssalem, atlantic) ∧ ServedIn(usssalem, mediterranean)"
},
{
"input": "Translate into first-order logic: The USS Salem is a heavy cruiser built for the United States navy.",
"output": "HeavyCruiser(usssalem) ∧ BuiltFor(usssalem, unitedstatesnavy)"
},
{
"input": "Translate into first-order logic: The last heavy cruiser to enter service was the USS Salem.",
"output": "LastHeavyCruiserToEnterService(usssalem)"
},
{
"input": "Translate into first-order logic: The USS Salem is a museum ship.",
"output": "MuseumShip(usssalem)"
},
{
"input": "Translate into first-order logic: Museum ships are open to the public.",
"output": "∀x (MuseumShip(x) → OpenToPublic(x))"
},
{
"input": "Translate into first-order logic: The USS Salem served in the Atlantic and Mediterranean.",
"output": "ServedIn(usssalem, atlantic) ∧ ServedIn(usssalem, mediterranean)"
},
{
"input": "Translate into first-order logic: TS Leda was a good passenger and cargo vessel.",
"output": "∀x (TSLeda(x) → Passenger(x) ∧ CargoVessel(x))"
},
{
"input": "Translate into first-order logic: TS Leda was the first Norweigian vessel that was built with stabilizers.",
"output": "∀x (TSLeda(x) → Norweigian(x) ∧ Stabilizers(x))"
},
{
"input": "Translate into first-order logic: Stabilizers are mechanical devices that are only on ships that have powerful steam turbine engines.",
"output": "∀x (Stabilizers(x) → OnlyOnShips(x) ∧ SteamTurbine(x))"
},
{
"input": "Translate into first-order logic: To be a good passenger and cargo vessel, ships must be quiet and good at sea.",
"output": "∀x (Passenger(x) ∧ CargoVessel(x) → Quiet(x) ∧ GoodSea(x))"
},
{
"input": "Translate into first-order logic: Some ships that are quiet and good at sea have powerful steam turbine engines.",
"output": "∃x (Quiet(x) ∧ GoodSea(x) ∧ SteamTurbine(x))"
},
{
"input": "Translate into first-order logic: TS Leda was a good passenger and cargo vessel.",
"output": "∀x (TSLeda(x) → Passenger(x) ∧ CargoVessel(x))"
},
{
"input": "Translate into first-order logic: TS Leda was the first Norweigian vessel that was built with stabilizers.",
"output": "∀x (TSLeda(x) → Norweigian(x) ∧ Stabilizers(x))"
},
{
"input": "Translate into first-order logic: Stabilizers are mechanical devices that are only on ships that have powerful steam turbine engines.",
"output": "∀x (Stabilizers(x) → OnlyOnShips(x) ∧ SteamTurbine(x))"
},
{
"input": "Translate into first-order logic: To be a good passenger and cargo vessel, ships must be quiet and good at sea.",
"output": "∀x (Passenger(x) ∧ CargoVessel(x) → Quiet(x) ∧ GoodSea(x))"
},
{
"input": "Translate into first-order logic: Some ships that are quiet and good at sea have powerful steam turbine engines.",
"output": "∃x (Quiet(x) ∧ GoodSea(x) ∧ SteamTurbine(x))"
},
{
"input": "Translate into first-order logic: TS Leda was a good passenger and cargo vessel.",
"output": "∀x (TSLeda(x) → Passenger(x) ∧ CargoVessel(x))"
},
{
"input": "Translate into first-order logic: TS Leda was the first Norweigian vessel that was built with stabilizers.",
"output": "∀x (TSLeda(x) → Norweigian(x) ∧ Stabilizers(x))"
},
{
"input": "Translate into first-order logic: Stabilizers are mechanical devices that are only on ships that have powerful steam turbine engines.",
"output": "∀x (Stabilizers(x) → OnlyOnShips(x) ∧ SteamTurbine(x))"
},
{
"input": "Translate into first-order logic: To be a good passenger and cargo vessel, ships must be quiet and good at sea.",
"output": "∀x (Passenger(x) ∧ CargoVessel(x) → Quiet(x) ∧ GoodSea(x))"
},
{
"input": "Translate into first-order logic: Some ships that are quiet and good at sea have powerful steam turbine engines.",
"output": "∃x (Quiet(x) ∧ GoodSea(x) ∧ SteamTurbine(x))"
},
{
"input": "Translate into first-order logic: Rosa was born in Santiago.",
"output": "Born(rosa, santiago)"
},
{
"input": "Translate into first-order logic: Santiago is the capital and largest city of Chile.",
"output": "Capital(santiago, chile) ∧ LargestCity(santiago, chile)"
},
{
"input": "Translate into first-order logic: Rosa is the daughter of a Catalan building contractor, Jose.",
"output": "Daughter(rosa, jose) ∧ BuildingContractor(jose) ∧ ¬Chilean(jose)"
},
{
"input": "Translate into first-order logic: Jose has a Chilean wife, Carmen.",
"output": "Wife(jose, carmen) ∧ Chilean(carmen)"
},
{
"input": "Translate into first-order logic: A building contractor is responsible for the day-to-day oversight of a construction site.",
"output": "∀x ∃y (BuildingContractor(x) ∧ ConstructionSite(y) → Oversee(x, y))"
},
{
"input": "Translate into first-order logic: Rosa was born in Santiago.",
"output": "Born(rosa, santiago)"
},
{
"input": "Translate into first-order logic: Santiago is the capital and largest city of Chile.",
"output": "Capital(santiago, chile) ∧ LargestCity(santiago, chile)"
},
{
"input": "Translate into first-order logic: Rosa is the daughter of a Catalan building contractor, Jose.",
"output": "Daughter(rosa, jose) ∧ BuildingContractor(jose) ∧ ¬Chilean(jose)"
},
{
"input": "Translate into first-order logic: Jose has a Chilean wife, Carmen.",
"output": "Wife(jose, carmen) ∧ Chilean(carmen)"
},
{
"input": "Translate into first-order logic: A building contractor is responsible for the day-to-day oversight of a construction site.",
"output": "∀x ∃y (BuildingContractor(x) ∧ ConstructionSite(y) → Oversee(x, y))"
},
{
"input": "Translate into first-order logic: Rosa was born in Santiago.",
"output": "Born(rosa, santiago)"
},
{
"input": "Translate into first-order logic: Santiago is the capital and largest city of Chile.",
"output": "Capital(santiago, chile) ∧ LargestCity(santiago, chile)"
},
{
"input": "Translate into first-order logic: Rosa is the daughter of a Catalan building contractor, Jose.",
"output": "Daughter(rosa, jose) ∧ BuildingContractor(jose) ∧ ¬Chilean(jose)"
},
{
"input": "Translate into first-order logic: Jose has a Chilean wife, Carmen.",
"output": "Wife(jose, carmen) ∧ Chilean(carmen)"
},
{
"input": "Translate into first-order logic: A building contractor is responsible for the day-to-day oversight of a construction site.",
"output": "∀x ∃y (BuildingContractor(x) ∧ ConstructionSite(y) → Oversee(x, y))"
},
{
"input": "Translate into first-order logic: Tyga is a rapper.",
"output": "IsRapper(tyga)"
},
{
"input": "Translate into first-order logic: Rappers release rap albums.",
"output": "ReleasedAlbum(tyga, wellDone3)"
},
{
"input": "Translate into first-order logic: Tyga released the Well Done 3 album.",
"output": "∀x ∀y (IsRapper(x) ∧ ReleasedAlbum(x, y) → IsRapAlbum(y))"
},
{
"input": "Translate into first-order logic: Rappers are not opera singers.",
"output": "∀x (IsRapper(x) → ¬IsOperaSinger(x))"
},
{
"input": "Translate into first-order logic: Tyga is a rapper.",
"output": "IsRapper(tyga)"
},
{
"input": "Translate into first-order logic: Rappers release rap albums.",
"output": "ReleasedAlbum(tyga, wellDone3)"
},
{
"input": "Translate into first-order logic: Tyga released the Well Done 3 album.",
"output": "∀x ∀y (IsRapper(x) ∧ ReleasedAlbum(x, y) → IsRapAlbum(y))"
},
{
"input": "Translate into first-order logic: Rappers are not opera singers.",
"output": "∀x (IsRapper(x) → ¬IsOperaSinger(x))"
},
{
"input": "Translate into first-order logic: Tyga is a rapper.",
"output": "IsRapper(tyga)"
},
{
"input": "Translate into first-order logic: Rappers release rap albums.",
"output": "ReleasedAlbum(tyga, wellDone3)"
},
{
"input": "Translate into first-order logic: Tyga released the Well Done 3 album.",
"output": "∀x ∀y (IsRapper(x) ∧ ReleasedAlbum(x, y) → IsRapAlbum(y))"
},
{
"input": "Translate into first-order logic: Rappers are not opera singers.",
"output": "∀x (IsRapper(x) → ¬IsOperaSinger(x))"
},
{
"input": "Translate into first-order logic: Deborah Wallace is a Scottish born actress, playwright and producer.",
"output": "BornIn(deborahwallace, scotland) ∧ Actress(deborahwallace) ∧ Playwright(deborahwallace) ∧ Producer(deborahwallace)"
},
{
"input": "Translate into first-order logic: Psyche is a play based on the life of James Miranda Barry.",
"output": "Play(psyche) ∧ BasedOn(psyche, lifeofjamesmirandabarry)"
},
{
"input": "Translate into first-order logic: Homesick, Psyche and The Void are plays from Deborah Wallace.",
"output": "Play(homesick) ∧ From(homesick, deborahwallace) ∧ Play(psyche) ∧ From(psyche, deborahwallace) ∧ Play(thevoid) ∧ From(thevoid, deborahwallace)"
},
{
"input": "Translate into first-order logic: Deborah Wallace co-produced Gasland.",
"output": "Co-Produced(deborahwallace, gasland)"
},
{
"input": "Translate into first-order logic: Deborah Wallace is a Scottish born actress, playwright and producer.",
"output": "BornIn(deborahwallace, scotland) ∧ Actress(deborahwallace) ∧ Playwright(deborahwallace) ∧ Producer(deborahwallace)"
},
{
"input": "Translate into first-order logic: Psyche is a play based on the life of James Miranda Barry.",
"output": "Play(psyche) ∧ BasedOn(psyche, lifeofjamesmirandabarry)"
},
{
"input": "Translate into first-order logic: Homesick, Psyche and The Void are plays from Deborah Wallace.",
"output": "Play(homesick) ∧ From(homesick, deborahwallace) ∧ Play(psyche) ∧ From(psyche, deborahwallace) ∧ Play(thevoid) ∧ From(thevoid, deborahwallace)"
},
{
"input": "Translate into first-order logic: Deborah Wallace co-produced Gasland.",
"output": "Co-Produced(deborahwallace, gasland)"
},
{
"input": "Translate into first-order logic: Deborah Wallace is a Scottish born actress, playwright and producer.",
"output": "BornIn(deborahwallace, scotland) ∧ Actress(deborahwallace) ∧ Playwright(deborahwallace) ∧ Producer(deborahwallace)"
},
{
"input": "Translate into first-order logic: Psyche is a play based on the life of James Miranda Barry.",
"output": "Play(psyche) ∧ BasedOn(psyche, lifeofjamesmirandabarry)"
},
{
"input": "Translate into first-order logic: Homesick, Psyche and The Void are plays from Deborah Wallace.",
"output": "Play(homesick) ∧ From(homesick, deborahwallace) ∧ Play(psyche) ∧ From(psyche, deborahwallace) ∧ Play(thevoid) ∧ From(thevoid, deborahwallace)"
},
{
"input": "Translate into first-order logic: Deborah Wallace co-produced Gasland.",
"output": "Co-Produced(deborahwallace, gasland)"
},
{
"input": "Translate into first-order logic: If an animal needs a large territory, then it travels far.",
"output": "∀x (NeedsLargeTerritory(x) → TravelFar(x))"
},
{
"input": "Translate into first-order logic: Everything that eats a lot needs a large territory.",
"output": "∀x (EatsALot(x) → NeedsLargeTerritory(x))"
},
{
"input": "Translate into first-order logic: If something is a big animal, then it will eat a lot.",
"output": "∀x (BigAnimal(x) → EatsALot(x))"
},
{
"input": "Translate into first-order logic: All bears are big animals.",
"output": "∀x (Bear(x) → BigAnimal(x))"
},
{
"input": "Translate into first-order logic: Larry is a big animal.",
"output": "BigAnimal(larry)"
},
{
"input": "Translate into first-order logic: If an animal needs a large territory, then it travels far.",
"output": "∀x (NeedsLargeTerritory(x) → TravelFar(x))"
},
{
"input": "Translate into first-order logic: Everything that eats a lot needs a large territory.",
"output": "∀x (EatsALot(x) → NeedsLargeTerritory(x))"
},
{
"input": "Translate into first-order logic: If something is a big animal, then it will eat a lot.",
"output": "∀x (BigAnimal(x) → EatsALot(x))"
},
{
"input": "Translate into first-order logic: All bears are big animals.",
"output": "∀x (Bear(x) → BigAnimal(x))"
},
{
"input": "Translate into first-order logic: Larry is a big animal.",
"output": "BigAnimal(larry)"
},
{
"input": "Translate into first-order logic: If an animal needs a large territory, then it travels far.",
"output": "∀x (NeedsLargeTerritory(x) → TravelFar(x))"
},
{
"input": "Translate into first-order logic: Everything that eats a lot needs a large territory.",
"output": "∀x (EatsALot(x) → NeedsLargeTerritory(x))"
},
{
"input": "Translate into first-order logic: If something is a big animal, then it will eat a lot.",
"output": "∀x (BigAnimal(x) → EatsALot(x))"
},
{
"input": "Translate into first-order logic: All bears are big animals.",
"output": "∀x (Bear(x) → BigAnimal(x))"
},
{
"input": "Translate into first-order logic: Larry is a big animal.",
"output": "BigAnimal(larry)"
},
{
"input": "Translate into first-order logic: No criminal is kind.",
"output": "∀x (Criminal(x) → ¬Kind(x))"
},
{
"input": "Translate into first-order logic: All person who breaks the law is a criminals.",
"output": "∀x (BreakLaw(x) → Criminal(x))"
},
{
"input": "Translate into first-order logic: People are either kind or evil.",
"output": "∀x (Kind(x) ⊕ Evil(x))"
},
{
"input": "Translate into first-order logic: If someone is evil, then they are ugly.",
"output": "∀x (Evil(x) → Ugly(x))"
},
{
"input": "Translate into first-order logic: If someone is evil, then they are cold-blood.",
"output": "∀x (Evil(x) → ColdBlood(x))"
},
{
"input": "Translate into first-order logic: If Garry is either evil and ugly or neither evil nor ugly, then Garry is not evil.",
"output": "((Evil(garry) ∧ Ugly(garry)) ⊕ (¬Evil(garry) ∧ ¬Ugly(garry))) → ¬Evil(garry)"
},
{
"input": "Translate into first-order logic: No criminal is kind.",
"output": "∀x (Criminal(x) → ¬Kind(x))"
},
{
"input": "Translate into first-order logic: All person who breaks the law is a criminals.",
"output": "∀x (BreakLaw(x) → Criminal(x))"
},
{
"input": "Translate into first-order logic: People are either kind or evil.",
"output": "∀x (Kind(x) ⊕ Evil(x))"
},
{
"input": "Translate into first-order logic: If someone is evil, then they are ugly.",
"output": "∀x (Evil(x) → Ugly(x))"
},
{
"input": "Translate into first-order logic: If someone is evil, then they are cold-blood.",
"output": "∀x (Evil(x) → ColdBlood(x))"
},
{
"input": "Translate into first-order logic: If Garry is either evil and ugly or neither evil nor ugly, then Garry is not evil.",
"output": "((Evil(garry) ∧ Ugly(garry)) ⊕ (¬Evil(garry) ∧ ¬Ugly(garry))) → ¬Evil(garry)"
},
{
"input": "Translate into first-order logic: No criminal is kind.",
"output": "∀x (Criminal(x) → ¬Kind(x))"
},
{
"input": "Translate into first-order logic: All person who breaks the law is a criminals.",
"output": "∀x (BreakLaw(x) → Criminal(x))"
},
{
"input": "Translate into first-order logic: People are either kind or evil.",
"output": "∀x (Kind(x) ⊕ Evil(x))"
},
{
"input": "Translate into first-order logic: If someone is evil, then they are ugly.",
"output": "∀x (Evil(x) → Ugly(x))"
},
{
"input": "Translate into first-order logic: If someone is evil, then they are cold-blood.",
"output": "∀x (Evil(x) → ColdBlood(x))"
},
{
"input": "Translate into first-order logic: If Garry is either evil and ugly or neither evil nor ugly, then Garry is not evil.",
"output": "((Evil(garry) ∧ Ugly(garry)) ⊕ (¬Evil(garry) ∧ ¬Ugly(garry))) → ¬Evil(garry)"
},
{
"input": "Translate into first-order logic: Phoneix's music is classified under the indie pop genre.",
"output": "IndiePop(phoenix)"
},
{
"input": "Translate into first-order logic: Phoenix is a band from France.",
"output": "Band(phoenix) ∧ France(phoenix)"
},
{
"input": "Translate into first-order logic: French bands write songs in French or in English.",
"output": "∀x ∀y (Band(x) ∧ France(x) ∧ Make(x, y) → FrenchSong(y) ⊕ EnglishSong(y))"
},
{
"input": "Translate into first-order logic: Aside from indie pop, pop rock and synth-pop are two other genres of music.",
"output": "∀x (IndiePop(x) → ¬PopRock(x) ∧ ¬SynthPop(x))"
},
{
"input": "Translate into first-order logic: Phoneix has no songs in French.",
"output": "∀x (Make(phoenix, x) → ¬FrenchSong(x))"
},
{
"input": "Translate into first-order logic: Phoneix's music is classified under the indie pop genre.",
"output": "IndiePop(phoenix)"
},
{
"input": "Translate into first-order logic: Phoenix is a band from France.",
"output": "Band(phoenix) ∧ France(phoenix)"
},
{
"input": "Translate into first-order logic: French bands write songs in French or in English.",
"output": "∀x ∀y (Band(x) ∧ France(x) ∧ Make(x, y) → FrenchSong(y) ⊕ EnglishSong(y))"
},
{
"input": "Translate into first-order logic: Aside from indie pop, pop rock and synth-pop are two other genres of music.",
"output": "∀x (IndiePop(x) → ¬PopRock(x) ∧ ¬SynthPop(x))"
},
{
"input": "Translate into first-order logic: Phoneix has no songs in French.",
"output": "∀x (Make(phoenix, x) → ¬FrenchSong(x))"
},
{
"input": "Translate into first-order logic: If people perform in school talent shows often, then they attend and are very engaged with school events.",
"output": "∀x (TalentShows(x) → Engaged(x))"
},
{
"input": "Translate into first-order logic: People either perform in school talent shows often or are inactive and disinterested members of their community.",
"output": "∀x (TalentShows(x) ∨ Inactive(x))"
},
{
"input": "Translate into first-order logic: If people chaperone high school dances, then they are not students who attend the school.",
"output": "∀x (Chaperone(x) → ¬Students(x))"
},
{
"input": "Translate into first-order logic: All people who are inactive and disinterested members of their community chaperone high school dances.",
"output": "∀x (Inactive(x) → Chaperone(x))"
},
{
"input": "Translate into first-order logic: All young children and teenagers who wish to further their academic careers and educational opportunities are students who attend the school.",
"output": "∀x (AcademicCareer(x) → Students(x))"
},
{
"input": "Translate into first-order logic: Bonnie either both attends and is very engaged with school events and is a student who attends the school, or she neither attends and is very engaged with school events nor is a student who attends the school.",
"output": "(Engaged(bonnie) ∧ Students(bonnie)) ⊕ (¬Engaged(bonnie) ∧ ¬Students(bonnie))"
},
{
"input": "Translate into first-order logic: Bonnie performs in school talent shows often.",
"output": "Engaged(bonnie)"
},
{
"input": "Translate into first-order logic: If people perform in school talent shows often, then they attend and are very engaged with school events.",
"output": "∀x (TalentShows(x) → Engaged(x))"
},
{
"input": "Translate into first-order logic: People either perform in school talent shows often or are inactive and disinterested members of their community.",
"output": "∀x (TalentShows(x) ∨ Inactive(x))"
},
{
"input": "Translate into first-order logic: If people chaperone high school dances, then they are not students who attend the school.",
"output": "∀x (Chaperone(x) → ¬Students(x))"
},
{
"input": "Translate into first-order logic: All people who are inactive and disinterested members of their community chaperone high school dances.",
"output": "∀x (Inactive(x) → Chaperone(x))"
},
{
"input": "Translate into first-order logic: All young children and teenagers who wish to further their academic careers and educational opportunities are students who attend the school.",
"output": "∀x (AcademicCareer(x) → Students(x))"
},
{
"input": "Translate into first-order logic: Bonnie either both attends and is very engaged with school events and is a student who attends the school, or she neither attends and is very engaged with school events nor is a student who attends the school.",
"output": "(Engaged(bonnie) ∧ Students(bonnie)) ⊕ (¬Engaged(bonnie) ∧ ¬Students(bonnie))"
},
{
"input": "Translate into first-order logic: If Bonnie is either both a young child or teenager who wishes to further her academic career and educational opportunities and chaperones high school dances or neither is a young child nor teenager who wishes to further her academic career and educational opportunities, then Bonnie is either a student who attends the school or is an inactive and disinterested member of the community.",
"output": "AcademicCareer(bonnie) ⊕ Chaperone(bonnie) → AcademicCareer(bonnie) ⊕ Inactive(bonnie)"
},
{
"input": "Translate into first-order logic: If people perform in school talent shows often, then they attend and are very engaged with school events.",
"output": "∀x (TalentShows(x) → Engaged(x))"
},
{
"input": "Translate into first-order logic: People either perform in school talent shows often or are inactive and disinterested members of their community.",
"output": "∀x (TalentShows(x) ∨ Inactive(x))"
},
{
"input": "Translate into first-order logic: If people chaperone high school dances, then they are not students who attend the school.",
"output": "∀x (Chaperone(x) → ¬Students(x))"
},
{
"input": "Translate into first-order logic: All people who are inactive and disinterested members of their community chaperone high school dances.",
"output": "∀x (Inactive(x) → Chaperone(x))"
},
{
"input": "Translate into first-order logic: All young children and teenagers who wish to further their academic careers and educational opportunities are students who attend the school.",
"output": "∀x (AcademicCareer(x) → Students(x))"
},
{
"input": "Translate into first-order logic: Bonnie either both attends and is very engaged with school events and is a student who attends the school, or she neither attends and is very engaged with school events nor is a student who attends the school.",
"output": "(Engaged(bonnie) ∧ Students(bonnie)) ⊕ (¬Engaged(bonnie) ∧ ¬Students(bonnie))"
},
{
"input": "Translate into first-order logic: If Bonnie either chaperones high school dances or, if she does not, she performs in school talent shows often, then Bonnie is both a young child or teenager who wishes to further her academic career and educational opportunities and an inactive and disinterested member of the community.",
"output": "Chaperone(bonnie) ⊕ TalentShows(bonnie) → AcademicCareer(bonnie) ∧ Inactive(bonnie))"
},
{
"input": "Translate into first-order logic: All employees who schedule a meeting with their customers will appear in the company today.",
"output": "∀x (Meeting(x) → AppearInCompany(x))"
},
{
"input": "Translate into first-order logic: Everyone who has lunch in the company schedules meetings with their customers.",
"output": "∀x (LunchInCompany(x) → Meetings(x))"
},
{
"input": "Translate into first-order logic: Employees will either have lunch in the company or have lunch at home.",
"output": "∀x (LunchInCompany(x) ∨ LunchAtHome(x))"
},
{
"input": "Translate into first-order logic: If an employee has lunch at home, then he/she is working remotely from home.",
"output": "∀x (LunchAtHome(x) → WorkRemotelyFromHome(x))"
},
{
"input": "Translate into first-order logic: All employees who are in other countries work remotely from home.",
"output": "∀x (InOtherCountries(x) → WorkRemotelyFromHome(x))"
},
{
"input": "Translate into first-order logic: No managers work remotely from home.",
"output": "∀x (Manager(x) → ¬WorkRemotelyFromHome(x))"
},
{
"input": "Translate into first-order logic: James is either a manager and appears in the company today or neither a manager nor appears in the company today.",
"output": "Manager(james) ⊕ AppearInCompany(james)"
},
{
"input": "Translate into first-order logic: James has lunch in the company.",
"output": "LunchInCompany(james)"
},
{
"input": "Translate into first-order logic: All employees who schedule a meeting with their customers will appear in the company today.",
"output": "∀x (Meeting(x) → AppearInCompany(x))"
},
{
"input": "Translate into first-order logic: Everyone who has lunch in the company schedules meetings with their customers.",
"output": "∀x (LunchInCompany(x) → Meetings(x))"
},
{
"input": "Translate into first-order logic: Employees will either have lunch in the company or have lunch at home.",
"output": "∀x (LunchInCompany(x) ∨ LunchAtHome(x))"
},
{
"input": "Translate into first-order logic: If an employee has lunch at home, then he/she is working remotely from home.",
"output": "∀x (LunchAtHome(x) → WorkRemotelyFromHome(x))"
},
{
"input": "Translate into first-order logic: All employees who are in other countries work remotely from home.",
"output": "∀x (InOtherCountries(x) → WorkRemotelyFromHome(x))"
},
{
"input": "Translate into first-order logic: No managers work remotely from home.",
"output": "∀x (Manager(x) → ¬WorkRemotelyFromHome(x))"
},
{
"input": "Translate into first-order logic: James is either a manager and appears in the company today or neither a manager nor appears in the company today.",
"output": "Manager(james) ⊕ AppearInCompany(james)"
},
{
"input": "Translate into first-order logic: James does not have lunch in the company.",
"output": "¬LunchInCompany(james)"
},
{
"input": "Translate into first-order logic: All employees who schedule a meeting with their customers will appear in the company today.",
"output": "∀x (Meeting(x) → AppearInCompany(x))"
},
{
"input": "Translate into first-order logic: Everyone who has lunch in the company schedules meetings with their customers.",
"output": "∀x (LunchInCompany(x) → Meetings(x))"
},
{
"input": "Translate into first-order logic: Employees will either have lunch in the company or have lunch at home.",
"output": "∀x (LunchInCompany(x) ∨ LunchAtHome(x))"
},
{
"input": "Translate into first-order logic: If an employee has lunch at home, then he/she is working remotely from home.",
"output": "∀x (LunchAtHome(x) → WorkRemotelyFromHome(x))"
},
{
"input": "Translate into first-order logic: All employees who are in other countries work remotely from home.",
"output": "∀x (InOtherCountries(x) → WorkRemotelyFromHome(x))"
},
{
"input": "Translate into first-order logic: No managers work remotely from home.",
"output": "∀x (Manager(x) → ¬WorkRemotelyFromHome(x))"
},
{
"input": "Translate into first-order logic: James is either a manager and appears in the company today or neither a manager nor appears in the company today.",
"output": "Manager(james) ⊕ AppearInCompany(james)"
},
{
"input": "Translate into first-order logic: If James is either a manager or in other countries,  then James either has lunch at home and works remotely from home, or neither has lunch at home nor works remotely from home.",
"output": "(Manager(james) ⊕ InOtherCountries(james)) → (LunchAtHome(james) ⊕ WorkRemotelyFromHome(james))"
},
{
"input": "Translate into first-order logic: Monkeypox is an infectious disease caused by the monkeypox virus.",
"output": "∃x (OccurMonkeypoxVirus(x) ∧ GetMonkeypox(x))"
},
{
"input": "Translate into first-order logic: Monkeypox virus can occur in certain animals, including humans.",
"output": "∃x (Animal(x) ∧ OccurMonkeypoxVirus(x))"
},
{
"input": "Translate into first-order logic: Humans are mammals.",
"output": "∀x (Human(x) → Mammal(x))"
},
{
"input": "Translate into first-order logic: Mammals are animals.",
"output": "∀x (Mammal(x) → Animal(x))"
},
{
"input": "Translate into first-order logic: Symptons of Monkeypox include fever, headache, muscle pains, feeling tired, and so on.",
"output": "∃x (GetMonkeypox(x) ∧ (Fever(x) ∨ Headache(x) ∨ MusclePain(x) ∨ Tired(x)))"
},
{
"input": "Translate into first-order logic: People feel tired when they get a glu.",
"output": "∀x (Human(x) ∧ Flu(x) → Tired(x))"
},
{
"input": "Translate into first-order logic: There is an animal.",
"output": "∃x (Animal(x))"
},
{
"input": "Translate into first-order logic: Monkeypox is an infectious disease caused by the monkeypox virus.",
"output": "∃x (OccurMonkeypoxVirus(x) ∧ GetMonkeypox(x))"
},
{
"input": "Translate into first-order logic: Monkeypox virus can occur in certain animals, including humans.",
"output": "∃x (Animal(x) ∧ OccurMonkeypoxVirus(x))"
},
{
"input": "Translate into first-order logic: Humans are mammals.",
"output": "∀x (Human(x) → Mammal(x))"
},
{
"input": "Translate into first-order logic: Mammals are animals.",
"output": "∀x (Mammal(x) → Animal(x))"
},
{
"input": "Translate into first-order logic: Symptons of Monkeypox include fever, headache, muscle pains, feeling tired, and so on.",
"output": "∃x (GetMonkeypox(x) ∧ (Fever(x) ∨ Headache(x) ∨ MusclePain(x) ∨ Tired(x)))"
},
{
"input": "Translate into first-order logic: People feel tired when they get a glu.",
"output": "∀x (Human(x) ∧ Flu(x) → Tired(x))"
},
{
"input": "Translate into first-order logic: No one gets flu.",
"output": "∀x (Human(x) → ¬Flu(x))"
},
{
"input": "Translate into first-order logic: Monkeypox is an infectious disease caused by the monkeypox virus.",
"output": "∃x (OccurMonkeypoxVirus(x) ∧ GetMonkeypox(x))"
},
{
"input": "Translate into first-order logic: Monkeypox virus can occur in certain animals, including humans.",
"output": "∃x (Animal(x) ∧ OccurMonkeypoxVirus(x))"
},
{
"input": "Translate into first-order logic: Humans are mammals.",
"output": "∀x (Human(x) → Mammal(x))"
},
{
"input": "Translate into first-order logic: Mammals are animals.",
"output": "∀x (Mammal(x) → Animal(x))"
},
{
"input": "Translate into first-order logic: Symptons of Monkeypox include fever, headache, muscle pains, feeling tired, and so on.",
"output": "∃x (GetMonkeypox(x) ∧ (Fever(x) ∨ Headache(x) ∨ MusclePain(x) ∨ Tired(x)))"
},
{
"input": "Translate into first-order logic: People feel tired when they get a glu.",
"output": "∀x (Human(x) ∧ Flu(x) → Tired(x))"
},
{
"input": "Translate into first-order logic: Symptons of Monkeypox include coughing.",
"output": "∃x (GetMonkeypox(x) ∧ Coughing(x))"
},
{
"input": "Translate into first-order logic: There are six types of wild turkeys: Eastern wild turkey, Osceola wild turkey, Gould’s wild turkey, Merriam’s wild",
"output": "∀x (WildTurkey(x) → (Eastern(x) ∨ Osceola(x) ∨ Goulds(x) ∨ Merriams(x) ∨ Riogrande(x) ∨ Ocellated(x)))"
},
{
"input": "Translate into first-order logic: turkey, Rio Grande wild turkey, and Ocellated wild turkey.",
"output": "¬(WildTurkey(tom) ∧ Eastern(tom))"
},
{
"input": "Translate into first-order logic: Tom is not an Eastern wild turkey.",
"output": "¬(WildTurkey(tom) ∧ Osceola(tom))"
},
{
"input": "Translate into first-order logic: Tom is not an Osceola wild turkey.",
"output": "WildTurkey(tom) → ¬(Goulds(tom) ∨ Merriams(tom) ∨ Riogrande(tom))"
},
{
"input": "Translate into first-order logic: Tom is also not a Gould's wild turkey, or a Merriam's wild turkey, or a Rio Grande wild turkey.",
"output": "WildTurkey(tom)"
},
{
"input": "Translate into first-order logic: Tom is an Ocellated wild turkey.",
"output": "Ocellated(tom)"
},
{
"input": "Translate into first-order logic: There are six types of wild turkeys: Eastern wild turkey, Osceola wild turkey, Gould’s wild turkey, Merriam’s wild",
"output": "∀x (WildTurkey(x) → (Eastern(x) ∨ Osceola(x) ∨ Goulds(x) ∨ Merriams(x) ∨ Riogrande(x) ∨ Ocellated(x)))"
},
{
"input": "Translate into first-order logic: turkey, Rio Grande wild turkey, and Ocellated wild turkey.",
"output": "¬(WildTurkey(tom) ∧ Eastern(tom))"
},
{
"input": "Translate into first-order logic: Tom is not an Eastern wild turkey.",
"output": "¬(WildTurkey(tom) ∧ Osceola(tom))"
},
{
"input": "Translate into first-order logic: Tom is not an Osceola wild turkey.",
"output": "WildTurkey(tom) → ¬(Goulds(tom) ∨ Merriams(tom) ∨ Riogrande(tom))"
},
{
"input": "Translate into first-order logic: Tom is also not a Gould's wild turkey, or a Merriam's wild turkey, or a Rio Grande wild turkey.",
"output": "WildTurkey(tom)"
},
{
"input": "Translate into first-order logic: Tom is an Eastern wild turkey.",
"output": "Eastern(tom)"
},
{
"input": "Translate into first-order logic: There are six types of wild turkeys: Eastern wild turkey, Osceola wild turkey, Gould’s wild turkey, Merriam’s wild",
"output": "∀x (WildTurkey(x) → (Eastern(x) ∨ Osceola(x) ∨ Goulds(x) ∨ Merriams(x) ∨ Riogrande(x) ∨ Ocellated(x)))"
},
{
"input": "Translate into first-order logic: turkey, Rio Grande wild turkey, and Ocellated wild turkey.",
"output": "¬(WildTurkey(tom) ∧ Eastern(tom))"
},
{
"input": "Translate into first-order logic: Tom is not an Eastern wild turkey.",
"output": "¬(WildTurkey(tom) ∧ Osceola(tom))"
},
{
"input": "Translate into first-order logic: Tom is not an Osceola wild turkey.",
"output": "WildTurkey(tom) → ¬(Goulds(tom) ∨ Merriams(tom) ∨ Riogrande(tom))"
},
{
"input": "Translate into first-order logic: Tom is also not a Gould's wild turkey, or a Merriam's wild turkey, or a Rio Grande wild turkey.",
"output": "WildTurkey(tom)"
},
{
"input": "Translate into first-order logic: Joey is a wild turkey.",
"output": "WildTurkey(joey)"
},
{
"input": "Translate into first-order logic: A Japanese game company created the game the Legend of Zelda.",
"output": "∃x (Japanese(x) ∧ VideoGameCompany(x) ∧ Game(thelegendofzelda) ∧ Created(x, thelegendofzelda))"
},
{
"input": "Translate into first-order logic: All games in the Top 10 list are made by Japanese game companies.",
"output": "∀x ∀y (Game(x) ∧ InTop10(x) ∧ Created(x, y) → Japanese(y))"
},
{
"input": "Translate into first-order logic: [BG] If a game sells more than one million copies, then it will be selected into the Top 10 list.",
"output": "∀x (Game(x) ∧ SellsMoreThan(x, onemillioncopies) → Top10(x))"
},
{
"input": "Translate into first-order logic: The Legend of Zelda sold more than one million copies.",
"output": "SellsMoreThan(thelegendofzelda, onemillioncopies)"
},
{
"input": "Translate into first-order logic: The Legend of Zelda is in the Top 10 list.",
"output": "Top10(thelegendofzelda)"
},
{
"input": "Translate into first-order logic: A Japanese game company created the game the Legend of Zelda.",
"output": "∃x (Japanese(x) ∧ VideoGameCompany(x) ∧ Game(thelegendofzelda) ∧ Created(x, thelegendofzelda))"
},
{
"input": "Translate into first-order logic: All games in the Top 10 list are made by Japanese game companies.",
"output": "∀x ∀y (Game(x) ∧ InTop10(x) ∧ Created(x, y) → Japanese(y))"
},
{
"input": "Translate into first-order logic: [BG] If a game sells more than one million copies, then it will be selected into the Top 10 list.",
"output": "∀x (Game(x) ∧ SellsMoreThan(x, onemillioncopies) → Top10(x))"
},
{
"input": "Translate into first-order logic: The Legend of Zelda sold more than one million copies.",
"output": "SellsMoreThan(thelegendofzelda, onemillioncopies)"
},
{
"input": "Translate into first-order logic: FIFA 22 is made by a Japanese video game company.",
"output": "∀x (Created(fifa22, x) → Japanese(x) ∧ VideoGameCompany(x))"
},
{
"input": "Translate into first-order logic: A Japanese game company created the game the Legend of Zelda.",
"output": "∃x (Japanese(x) ∧ VideoGameCompany(x) ∧ Game(thelegendofzelda) ∧ Created(x, thelegendofzelda))"
},
{
"input": "Translate into first-order logic: All games in the Top 10 list are made by Japanese game companies.",
"output": "∀x ∀y (Game(x) ∧ InTop10(x) ∧ Created(x, y) → Japanese(y))"
},
{
"input": "Translate into first-order logic: [BG] If a game sells more than one million copies, then it will be selected into the Top 10 list.",
"output": "∀x (Game(x) ∧ SellsMoreThan(x, onemillioncopies) → Top10(x))"
},
{
"input": "Translate into first-order logic: The Legend of Zelda sold more than one million copies.",
"output": "SellsMoreThan(thelegendofzelda, onemillioncopies)"
},
{
"input": "Translate into first-order logic: The Legend of Zelda is not in the Top 10 list.",
"output": "¬Top10(thelegendofzelda)"
},
{
"input": "Translate into first-order logic: All squares have four sides.",
"output": "∀x (Square(x) → FourSides(x))"
},
{
"input": "Translate into first-order logic: All four-sided things are shapes.",
"output": "∀x (FourSides(x) → IsShape(x))"
},
{
"input": "Translate into first-order logic: All squares are shapes.",
"output": "∀x (Square(x) → IsShape(x))"
},
{
"input": "Translate into first-order logic: All rabbits are cute.",
"output": "∀x (Rabbit(x) → Cute(x))"
},
{
"input": "Translate into first-order logic: Some turtles exist.",
"output": "∃x (Turtle(x))"
},
{
"input": "Translate into first-order logic: An animal is either a rabbit or a squirrel.",
"output": "∀x (Rabbit(x) ∨ Squirrel(x))"
},
{
"input": "Translate into first-order logic: If something is skittish, then it is not still.",
"output": "∀x (Skittish(x) → ¬Still(x))"
},
{
"input": "Translate into first-order logic: All squirrels are skittish.",
"output": "∀x (Squirrel(x) → Skittish(x))"
},
{
"input": "Translate into first-order logic: Rock is still.",
"output": "Still(rock)"
},
{
"input": "Translate into first-order logic: Rock is a turtle.",
"output": "Turtle(rock)"
},
{
"input": "Translate into first-order logic: All rabbits are cute.",
"output": "∀x (Rabbit(x) → Cute(x))"
},
{
"input": "Translate into first-order logic: Some turtles exist.",
"output": "∃x (Turtle(x))"
},
{
"input": "Translate into first-order logic: An animal is either a rabbit or a squirrel.",
"output": "∀x (Rabbit(x) ∨ Squirrel(x))"
},
{
"input": "Translate into first-order logic: If something is skittish, then it is not still.",
"output": "∀x (Skittish(x) → ¬Still(x))"
},
{
"input": "Translate into first-order logic: All squirrels are skittish.",
"output": "∀x (Squirrel(x) → Skittish(x))"
},
{
"input": "Translate into first-order logic: Rock is still.",
"output": "Still(rock)"
},
{
"input": "Translate into first-order logic: Rock is not a turtle.",
"output": "¬Turtle(rock)"
},
{
"input": "Translate into first-order logic: All rabbits are cute.",
"output": "∀x (Rabbit(x) → Cute(x))"
},
{
"input": "Translate into first-order logic: Some turtles exist.",
"output": "∃x (Turtle(x))"
},
{
"input": "Translate into first-order logic: An animal is either a rabbit or a squirrel.",
"output": "∀x (Rabbit(x) ∨ Squirrel(x))"
},
{
"input": "Translate into first-order logic: If something is skittish, then it is not still.",
"output": "∀x (Skittish(x) → ¬Still(x))"
},
{
"input": "Translate into first-order logic: All squirrels are skittish.",
"output": "∀x (Squirrel(x) → Skittish(x))"
},
{
"input": "Translate into first-order logic: Rock is still.",
"output": "Still(rock)"
},
{
"input": "Translate into first-order logic: Rock is a turtle or cute.",
"output": "Turtle(rock) ∨ Cute(rock)"
},
{
"input": "Translate into first-order logic: All rabbits are cute.",
"output": "∀x (Rabbit(x) → Cute(x))"
},
{
"input": "Translate into first-order logic: Some turtles exist.",
"output": "∃x (Turtle(x))"
},
{
"input": "Translate into first-order logic: An animal is either a rabbit or a squirrel.",
"output": "∀x (Rabbit(x) ∨ Squirrel(x))"
},
{
"input": "Translate into first-order logic: If something is skittish, then it is not still.",
"output": "∀x (Skittish(x) → ¬Still(x))"
},
{
"input": "Translate into first-order logic: All squirrels are skittish.",
"output": "∀x (Squirrel(x) → Skittish(x))"
},
{
"input": "Translate into first-order logic: Rock is still.",
"output": "Still(rock)"
},
{
"input": "Translate into first-order logic: If Rock is not both a turtle and a squirrel, then Rock is either cute or skittish.",
"output": "¬(Turtle(rock) ∧ Squirrel(rock)) → Cute(rock) ⊕ Skittish(rock)"
},
{
"input": "Translate into first-order logic: All rabbits are cute.",
"output": "∀x (Rabbit(x) → Cute(x))"
},
{
"input": "Translate into first-order logic: Some turtles exist.",
"output": "∃x (Turtle(x))"
},
{
"input": "Translate into first-order logic: An animal is either a rabbit or a squirrel.",
"output": "∀x (Rabbit(x) ∨ Squirrel(x))"
},
{
"input": "Translate into first-order logic: If something is skittish, then it is not still.",
"output": "∀x (Skittish(x) → ¬Still(x))"
},
{
"input": "Translate into first-order logic: All squirrels are skittish.",
"output": "∀x (Squirrel(x) → Skittish(x))"
},
{
"input": "Translate into first-order logic: Rock is still.",
"output": "Still(rock)"
},
{
"input": "Translate into first-order logic: If Rock is cute and still, then Rock is a turtle and skittish.",
"output": "Cute(rock) ∧ Still(rock) → Turtle(rock) ∧ Skittish(rock)"
},
{
"input": "Translate into first-order logic: \"Stranger Things\" is a popular Netflix show.",
"output": "NetflixShow(strangerThings) ∧ Popular(strangerThings)"
},
{
"input": "Translate into first-order logic: If a Netflix show is popular, Karen will binge-watch it.",
"output": "∀x ((NetflixShow(x) ∧ Popular(x)) → BingeWatch(karen, x))"
},
{
"input": "Translate into first-order logic: If and only if Karen binge-watches a Netflix show, she will download it.",
"output": "∀x ((NetflixShow(x) ∧ BingeWatch(karen, x)) ↔ Download(karen, x))"
},
{
"input": "Translate into first-order logic: Karen does not download \"Black Mirror\".",
"output": "¬Download(karen, blackMirror)"
},
{
"input": "Translate into first-order logic: \"Black Mirror\" is a Netflix show.",
"output": "NetflixShow(blackMirror)"
},
{
"input": "Translate into first-order logic: If Karen binge-watches a Netflix show, she will share it to Lisa.",
"output": "∀x ((NetflixShow(x) ∧ BingeWatch(karen, x)) → Share(x, lisa))"
},
{
"input": "Translate into first-order logic: Karen will share \"Stranger Things\" to Lisa.",
"output": "Share(strangerThings, lisa)"
},
{
"input": "Translate into first-order logic: \"Stranger Things\" is a popular Netflix show.",
"output": "NetflixShow(strangerThings) ∧ Popular(strangerThings)"
},
{
"input": "Translate into first-order logic: If a Netflix show is popular, Karen will binge-watch it.",
"output": "∀x ((NetflixShow(x) ∧ Popular(x)) → BingeWatch(karen, x))"
},
{
"input": "Translate into first-order logic: If and only if Karen binge-watches a Netflix show, she will download it.",
"output": "∀x ((NetflixShow(x) ∧ BingeWatch(karen, x)) ↔ Download(karen, x))"
},
{
"input": "Translate into first-order logic: Karen does not download \"Black Mirror\".",
"output": "¬Download(karen, blackMirror)"
},
{
"input": "Translate into first-order logic: \"Black Mirror\" is a Netflix show.",
"output": "NetflixShow(blackMirror)"
},
{
"input": "Translate into first-order logic: If Karen binge-watches a Netflix show, she will share it to Lisa.",
"output": "∀x ((NetflixShow(x) ∧ BingeWatch(karen, x)) → Share(x, lisa))"
},
{
"input": "Translate into first-order logic: \"Black Mirror\" is popular.",
"output": "Popular(blackMirror)"
},
{
"input": "Translate into first-order logic: \"Stranger Things\" is a popular Netflix show.",
"output": "NetflixShow(strangerThings) ∧ Popular(strangerThings)"
},
{
"input": "Translate into first-order logic: If a Netflix show is popular, Karen will binge-watch it.",
"output": "∀x ((NetflixShow(x) ∧ Popular(x)) → BingeWatch(karen, x))"
},
{
"input": "Translate into first-order logic: If and only if Karen binge-watches a Netflix show, she will download it.",
"output": "∀x ((NetflixShow(x) ∧ BingeWatch(karen, x)) ↔ Download(karen, x))"
},
{
"input": "Translate into first-order logic: Karen does not download \"Black Mirror\".",
"output": "¬Download(karen, blackMirror)"
},
{
"input": "Translate into first-order logic: \"Black Mirror\" is a Netflix show.",
"output": "NetflixShow(blackMirror)"
},
{
"input": "Translate into first-order logic: If Karen binge-watches a Netflix show, she will share it to Lisa.",
"output": "∀x ((NetflixShow(x) ∧ BingeWatch(karen, x)) → Share(x, lisa))"
},
{
"input": "Translate into first-order logic: Karen will share \"Black Mirror\" to Lisa.",
"output": "Share(blackMirror, lisa)"
},
{
"input": "Translate into first-order logic: Beijing is the capital of the People's Republic of China.",
"output": "CapitalOf(beijing, prx)"
},
{
"input": "Translate into first-order logic: Beijing is the world's most populous national capital city.",
"output": "MostPopulousNationalCapitalCity(beijing)"
},
{
"input": "Translate into first-order logic: Beijing is located in Northern China.",
"output": "InNorthernChina(beijing)"
},
{
"input": "Translate into first-order logic: Beijing hosted the 2008 Summer Olympics and 2008 Summer Paralympics Games.",
"output": "Hosted(beijing, summer2008olympic) ∧ Hosted(beijing, summer2008paralympicgames)"
},
{
"input": "Translate into first-order logic: Beijing has hosted both the Summer and Winter Olympics, along with the Summer and Winter Paralympics",
"output": "Hosted(beijing, summerolympic) ∧ Hosted(beijing, winterolympic) ∧ Hosted(beijing, summerparalympicgames)  ∧ Hosted(beijing, winterparalympicgames)"
},
{
"input": "Translate into first-order logic: Many of Beijing's 91 universities consistently rank among the best in the Asia-Pacific and the world.",
"output": "∃x (BeijingUniversity(x) ∧ ConsistentlyRankAmongTheBest(x))"
},
{
"input": "Translate into first-order logic: Beijing has hosted both the 2008 Summer Olympics and a winter olympics.",
"output": "Hosted(beijing, summer2008olympic) ∧ Hosted(beijing, winterolympic)"
},
{
"input": "Translate into first-order logic: Beijing is the capital of the People's Republic of China.",
"output": "CapitalOf(beijing, prx)"
},
{
"input": "Translate into first-order logic: Beijing is the world's most populous national capital city.",
"output": "MostPopulousNationalCapitalCity(beijing)"
},
{
"input": "Translate into first-order logic: Beijing is located in Northern China.",
"output": "InNorthernChina(beijing)"
},
{
"input": "Translate into first-order logic: Beijing hosted the 2008 Summer Olympics and 2008 Summer Paralympics Games.",
"output": "Hosted(beijing, summer2008olympic) ∧ Hosted(beijing, summer2008paralympicgames)"
},
{
"input": "Translate into first-order logic: Beijing has hosted both the Summer and Winter Olympics, along with the Summer and Winter Paralympics",
"output": "Hosted(beijing, summerolympic) ∧ Hosted(beijing, winterolympic) ∧ Hosted(beijing, summerparalympicgames)  ∧ Hosted(beijing, winterparalympicgames)"
},
{
"input": "Translate into first-order logic: Many of Beijing's 91 universities consistently rank among the best in the Asia-Pacific and the world.",
"output": "∃x (BeijingUniversity(x) ∧ ConsistentlyRankAmongTheBest(x))"
},
{
"input": "Translate into first-order logic: Beijing is located in southern China.",
"output": "InSouthernChina(beijing)"
},
{
"input": "Translate into first-order logic: Beijing is the capital of the People's Republic of China.",
"output": "CapitalOf(beijing, prx)"
},
{
"input": "Translate into first-order logic: Beijing is the world's most populous national capital city.",
"output": "MostPopulousNationalCapitalCity(beijing)"
},
{
"input": "Translate into first-order logic: Beijing is located in Northern China.",
"output": "InNorthernChina(beijing)"
},
{
"input": "Translate into first-order logic: Beijing hosted the 2008 Summer Olympics and 2008 Summer Paralympics Games.",
"output": "Hosted(beijing, summer2008olympic) ∧ Hosted(beijing, summer2008paralympicgames)"
},
{
"input": "Translate into first-order logic: Beijing has hosted both the Summer and Winter Olympics, along with the Summer and Winter Paralympics",
"output": "Hosted(beijing, summerolympic) ∧ Hosted(beijing, winterolympic) ∧ Hosted(beijing, summerparalympicgames)  ∧ Hosted(beijing, winterparalympicgames)"
},
{
"input": "Translate into first-order logic: Many of Beijing's 91 universities consistently rank among the best in the Asia-Pacific and the world.",
"output": "∃x (BeijingUniversity(x) ∧ ConsistentlyRankAmongTheBest(x))"
},
{
"input": "Translate into first-order logic: Beijing is the second largest Chinese city by urban population.",
"output": "SecondLargestChineseCity(beijing)"
},
{
"input": "Translate into first-order logic: All aliens are extraterrestrial.",
"output": "∀x (Alien(x) → Extraterrestrial(x))"
},
{
"input": "Translate into first-order logic: If someone is from Mars, then they are aliens.",
"output": "∀x (FromMars(x) → Alien(x))"
},
{
"input": "Translate into first-order logic: No extraterrestrial is human.",
"output": "∀x (Extraterrestrial(x) → ¬Human(x))"
},
{
"input": "Translate into first-order logic: Everyone from Earth is a human.",
"output": "∀x (FromEarth(x) → Human(x))"
},
{
"input": "Translate into first-order logic: Marvin cannot be from Earth and from Mars.",
"output": "¬FromEarth(marvin) ∧ ¬FromMars(marvin)"
},
{
"input": "Translate into first-order logic: If Marvin is not from Earth, then Marvin is an extraterrestrial.",
"output": "¬FromEarth(marvin) → Extraterrestrial(marvin)"
},
{
"input": "Translate into first-order logic: Marvin is an alien.",
"output": "Alien(marvin)"
},
{
"input": "Translate into first-order logic: All aliens are extraterrestrial.",
"output": "∀x (Alien(x) → Extraterrestrial(x))"
},
{
"input": "Translate into first-order logic: If someone is from Mars, then they are aliens.",
"output": "∀x (FromMars(x) → Alien(x))"
},
{
"input": "Translate into first-order logic: No extraterrestrial is human.",
"output": "∀x (Extraterrestrial(x) → ¬Human(x))"
},
{
"input": "Translate into first-order logic: Everyone from Earth is a human.",
"output": "∀x (FromEarth(x) → Human(x))"
},
{
"input": "Translate into first-order logic: Marvin cannot be from Earth and from Mars.",
"output": "¬FromEarth(marvin) ∧ ¬FromMars(marvin)"
},
{
"input": "Translate into first-order logic: If Marvin is not from Earth, then Marvin is an extraterrestrial.",
"output": "¬FromEarth(marvin) → Extraterrestrial(marvin)"
},
{
"input": "Translate into first-order logic: Marvin is neither a human nor from Mars.",
"output": "¬Human(marvin) ∧ ¬FromMars(marvin)"
},
{
"input": "Translate into first-order logic: All aliens are extraterrestrial.",
"output": "∀x (Alien(x) → Extraterrestrial(x))"
},
{
"input": "Translate into first-order logic: If someone is from Mars, then they are aliens.",
"output": "∀x (FromMars(x) → Alien(x))"
},
{
"input": "Translate into first-order logic: No extraterrestrial is human.",
"output": "∀x (Extraterrestrial(x) → ¬Human(x))"
},
{
"input": "Translate into first-order logic: Everyone from Earth is a human.",
"output": "∀x (FromEarth(x) → Human(x))"
},
{
"input": "Translate into first-order logic: Marvin cannot be from Earth and from Mars.",
"output": "¬FromEarth(marvin) ∧ ¬FromMars(marvin)"
},
{
"input": "Translate into first-order logic: If Marvin is not from Earth, then Marvin is an extraterrestrial.",
"output": "¬FromEarth(marvin) → Extraterrestrial(marvin)"
},
{
"input": "Translate into first-order logic: If Marvin is not from Mars, then Marvin is a human.",
"output": "¬FromMars(marvin) → Human(marvin)"
},
{
"input": "Translate into first-order logic: A person is either a Grand Slam champion or an Oscar-nominated actor.",
"output": "∀x (GrandSlamChampion(x) ⊕ OscarNominatedActor(x))"
},
{
"input": "Translate into first-order logic: All people who are Grand Slam champions are professional tennis players.",
"output": "∀x (GrandSlamChampion(x) → ProfessionalTennisPlayer(x))"
},
{
"input": "Translate into first-order logic: All Oscar-nominated actors are celebrities.",
"output": "∀x (OscarNominatedActor(x) → Celebrity(x))"
},
{
"input": "Translate into first-order logic: All professional tennis players are athletes.",
"output": "∀x (ProfessionalTennisPlayer(x) → Athlete(x))"
},
{
"input": "Translate into first-order logic: If a person is a celebrity then they are well paid.",
"output": "∀x (Celebrity(x) → WellPaid(x))"
},
{
"input": "Translate into first-order logic: If a person is an athlete then they are famous.",
"output": "∀x (Athlete(x) → Famous(x))"
},
{
"input": "Translate into first-order logic: All well-paid people live in tax havens.",
"output": "∀x (WellPaid(x) → LivesInTaxHaven(x))"
},
{
"input": "Translate into first-order logic: If Djokovic is famous and is an athlete, then Djokovic lives in well paid.",
"output": "Famous(djokovic) ∧ Athlete(djokovic) → LivesInTaxHaven(djokovic)"
},
{
"input": "Translate into first-order logic: Djokovic is a Grand Slam champion.",
"output": "GrandSlamChampion(djokovic)"
},
{
"input": "Translate into first-order logic: A person is either a Grand Slam champion or an Oscar-nominated actor.",
"output": "∀x (GrandSlamChampion(x) ⊕ OscarNominatedActor(x))"
},
{
"input": "Translate into first-order logic: All people who are Grand Slam champions are professional tennis players.",
"output": "∀x (GrandSlamChampion(x) → ProfessionalTennisPlayer(x))"
},
{
"input": "Translate into first-order logic: All Oscar-nominated actors are celebrities.",
"output": "∀x (OscarNominatedActor(x) → Celebrity(x))"
},
{
"input": "Translate into first-order logic: All professional tennis players are athletes.",
"output": "∀x (ProfessionalTennisPlayer(x) → Athlete(x))"
},
{
"input": "Translate into first-order logic: If a person is a celebrity then they are well paid.",
"output": "∀x (Celebrity(x) → WellPaid(x))"
},
{
"input": "Translate into first-order logic: If a person is an athlete then they are famous.",
"output": "∀x (Athlete(x) → Famous(x))"
},
{
"input": "Translate into first-order logic: All well-paid people live in tax havens.",
"output": "∀x (WellPaid(x) → LivesInTaxHaven(x))"
},
{
"input": "Translate into first-order logic: If Djokovic is famous and is an athlete, then Djokovic lives in well paid.",
"output": "Famous(djokovic) ∧ Athlete(djokovic) → LivesInTaxHaven(djokovic)"
},
{
"input": "Translate into first-order logic: Djokovic lives in a tax haven.",
"output": "LivesInTaxHaven(djokovic)"
},
{
"input": "Translate into first-order logic: A person is either a Grand Slam champion or an Oscar-nominated actor.",
"output": "∀x (GrandSlamChampion(x) ⊕ OscarNominatedActor(x))"
},
{
"input": "Translate into first-order logic: All people who are Grand Slam champions are professional tennis players.",
"output": "∀x (GrandSlamChampion(x) → ProfessionalTennisPlayer(x))"
},
{
"input": "Translate into first-order logic: All Oscar-nominated actors are celebrities.",
"output": "∀x (OscarNominatedActor(x) → Celebrity(x))"
},
{
"input": "Translate into first-order logic: All professional tennis players are athletes.",
"output": "∀x (ProfessionalTennisPlayer(x) → Athlete(x))"
},
{
"input": "Translate into first-order logic: If a person is a celebrity then they are well paid.",
"output": "∀x (Celebrity(x) → WellPaid(x))"
},
{
"input": "Translate into first-order logic: If a person is an athlete then they are famous.",
"output": "∀x (Athlete(x) → Famous(x))"
},
{
"input": "Translate into first-order logic: All well-paid people live in tax havens.",
"output": "∀x (WellPaid(x) → LivesInTaxHaven(x))"
},
{
"input": "Translate into first-order logic: If Djokovic is famous and is an athlete, then Djokovic lives in well paid.",
"output": "Famous(djokovic) ∧ Athlete(djokovic) → LivesInTaxHaven(djokovic)"
},
{
"input": "Translate into first-order logic: Djokovic does not live in a tax haven.",
"output": "¬LivesInTaxHaven(djokovic)"
},
{
"input": "Translate into first-order logic: Diamond Mine is a professional wrestling stable, formed in WWE.",
"output": "ProfessionalWrestlingStable(diamondmine) ∧ FormedIn(diamondmine, wwe)"
},
{
"input": "Translate into first-order logic: Roderick Strong leads Diamond Mine.",
"output": "Leads(roderickstrong, diamondmine)"
},
{
"input": "Translate into first-order logic: Diamond Mine includes the Creed Brothers, and Ivy Nile.",
"output": "Includes(diamondmine, creedbrothers) ∧ Includes(diamondmine, ivynile)"
},
{
"input": "Translate into first-order logic: Imperium has a feud with Diamond Mine.",
"output": "HasFeud(imperium, diamondmine)"
},
{
"input": "Translate into first-order logic: Roderick strong leads a professional wrestling stable.",
"output": "∃x (Leads(roderickstrong, x) ∧ ProfessionalWrestlingStable(x))"
},
{
"input": "Translate into first-order logic: Diamond Mine is a professional wrestling stable, formed in WWE.",
"output": "ProfessionalWrestlingStable(diamondmine) ∧ FormedIn(diamondmine, wwe)"
},
{
"input": "Translate into first-order logic: Roderick Strong leads Diamond Mine.",
"output": "Leads(roderickstrong, diamondmine)"
},
{
"input": "Translate into first-order logic: Diamond Mine includes the Creed Brothers, and Ivy Nile.",
"output": "Includes(diamondmine, creedbrothers) ∧ Includes(diamondmine, ivynile)"
},
{
"input": "Translate into first-order logic: Imperium has a feud with Diamond Mine.",
"output": "HasFeud(imperium, diamondmine)"
},
{
"input": "Translate into first-order logic: Roderick strong leads the Creed Brothers.",
"output": "Leads(roderickstrong, creedbrothers)"
},
{
"input": "Translate into first-order logic: Diamond Mine is a professional wrestling stable, formed in WWE.",
"output": "ProfessionalWrestlingStable(diamondmine) ∧ FormedIn(diamondmine, wwe)"
},
{
"input": "Translate into first-order logic: Roderick Strong leads Diamond Mine.",
"output": "Leads(roderickstrong, diamondmine)"
},
{
"input": "Translate into first-order logic: Diamond Mine includes the Creed Brothers, and Ivy Nile.",
"output": "Includes(diamondmine, creedbrothers) ∧ Includes(diamondmine, ivynile)"
},
{
"input": "Translate into first-order logic: Imperium has a feud with Diamond Mine.",
"output": "HasFeud(imperium, diamondmine)"
},
{
"input": "Translate into first-order logic: Imperium doesn't have a feud with a professional wrestling stable that includes Ivy Nile.",
"output": "∀x (ProfessionalWrestlingStable(x) ∧ Includes(x, ivynile) → ¬HasFeud(imperium, x))"
},
{
"input": "Translate into first-order logic: Symphony No. 9 is a music piece.",
"output": "MusicPiece(symphony9)"
},
{
"input": "Translate into first-order logic: Composers write music pieces.",
"output": "∀x ∀y ((MusicPiece(x) ∧ Writtenby(x, y)) → Composer(y))"
},
{
"input": "Translate into first-order logic: Beethoven wrote Symphony No. 9.",
"output": "Writtenby(symphony9, beethoven)"
},
{
"input": "Translate into first-order logic: Vienna Music Society premiered Symphony No. 9.",
"output": "Premiered(viennamusicsociety, symphony9)"
},
{
"input": "Translate into first-order logic: Vienna Music Society is an orchestra.",
"output": "Orchestra(viennamusicsociety)"
},
{
"input": "Translate into first-order logic: Beethoven leads the Vienna Music Society.",
"output": "Lead(beethoven, viennamusicsociety)"
},
{
"input": "Translate into first-order logic: Orchestras are led by conductors.",
"output": "∀x ∀y ((Orchestra(x) ∧ Lead(y, x)) → Conductor(y))"
},
{
"input": "Translate into first-order logic: Beethoven is a composer.",
"output": "Composer(beethoven)"
},
{
"input": "Translate into first-order logic: Symphony No. 9 is a music piece.",
"output": "MusicPiece(symphony9)"
},
{
"input": "Translate into first-order logic: Composers write music pieces.",
"output": "∀x ∀y ((MusicPiece(x) ∧ Writtenby(x, y)) → Composer(y))"
},
{
"input": "Translate into first-order logic: Beethoven wrote Symphony No. 9.",
"output": "Writtenby(symphony9, beethoven)"
},
{
"input": "Translate into first-order logic: Vienna Music Society premiered Symphony No. 9.",
"output": "Premiered(viennamusicsociety, symphony9)"
},
{
"input": "Translate into first-order logic: Vienna Music Society is an orchestra.",
"output": "Orchestra(viennamusicsociety)"
},
{
"input": "Translate into first-order logic: Beethoven leads the Vienna Music Society.",
"output": "Lead(beethoven, viennamusicsociety)"
},
{
"input": "Translate into first-order logic: Orchestras are led by conductors.",
"output": "∀x ∀y ((Orchestra(x) ∧ Lead(y, x)) → Conductor(y))"
},
{
"input": "Translate into first-order logic: Some orchestras premiered music pieces.",
"output": "∃x ∃y (Orchestra(x) ∧ MusicPiece(y) ∧ Premiered(x, y))"
},
{
"input": "Translate into first-order logic: Symphony No. 9 is a music piece.",
"output": "MusicPiece(symphony9)"
},
{
"input": "Translate into first-order logic: Composers write music pieces.",
"output": "∀x ∀y ((MusicPiece(x) ∧ Writtenby(x, y)) → Composer(y))"
},
{
"input": "Translate into first-order logic: Beethoven wrote Symphony No. 9.",
"output": "Writtenby(symphony9, beethoven)"
},
{
"input": "Translate into first-order logic: Vienna Music Society premiered Symphony No. 9.",
"output": "Premiered(viennamusicsociety, symphony9)"
},
{
"input": "Translate into first-order logic: Vienna Music Society is an orchestra.",
"output": "Orchestra(viennamusicsociety)"
},
{
"input": "Translate into first-order logic: Beethoven leads the Vienna Music Society.",
"output": "Lead(beethoven, viennamusicsociety)"
},
{
"input": "Translate into first-order logic: Orchestras are led by conductors.",
"output": "∀x ∀y ((Orchestra(x) ∧ Lead(y, x)) → Conductor(y))"
},
{
"input": "Translate into first-order logic: Beethoven is not a conductor.",
"output": "¬Conductor(beethoven)"
},
{
"input": "Translate into first-order logic: All of Zaha Hadid's design styles are timeless.",
"output": "∀x (ZahaHadidDesignStyle(x) → Timeless(x))"
},
{
"input": "Translate into first-order logic: No mass product design is timeless.",
"output": "∀x (MassProductDesign(x) → ¬Timeless(x))"
},
{
"input": "Translate into first-order logic: Either Zaha Hadid's design style or Kelly Wearstler's design style.",
"output": "∀x (ZahaHadidDesignStyle(x) ∨ KellyWearstlerDesignStyle(x)) "
},
{
"input": "Translate into first-order logic: All of Kelly Wearstler's design styles are evocative.",
"output": "∀x (KellyWearstlerDesignStyle(x) → Evocative(x))"
},
{
"input": "Translate into first-order logic: All of Kelly Wearstler's design styles are dreamy.",
"output": "∀x (KellyWearstlerDesignStyle(x) → Dreamy(x))"
},
{
"input": "Translate into first-order logic: If a design by Max is timeless, then a design by Max is a mass product design and evocative.",
"output": "Timeless(aDesignByMax) → MassProductDesign(aDesignByMax) ∧ Evocative(aDesignByMax)"
},
{
"input": "Translate into first-order logic: A design by Max is a mass product design.",
"output": "MassProductDesign(aDesignByMax)"
},
{
"input": "Translate into first-order logic: All of Zaha Hadid's design styles are timeless.",
"output": "∀x (ZahaHadidDesignStyle(x) → Timeless(x))"
},
{
"input": "Translate into first-order logic: No mass product design is timeless.",
"output": "∀x (MassProductDesign(x) → ¬Timeless(x))"
},
{
"input": "Translate into first-order logic: Either Zaha Hadid's design style or Kelly Wearstler's design style.",
"output": "∀x (ZahaHadidDesignStyle(x) ∨ KellyWearstlerDesignStyle(x)) "
},
{
"input": "Translate into first-order logic: All of Kelly Wearstler's design styles are evocative.",
"output": "∀x (KellyWearstlerDesignStyle(x) → Evocative(x))"
},
{
"input": "Translate into first-order logic: All of Kelly Wearstler's design styles are dreamy.",
"output": "∀x (KellyWearstlerDesignStyle(x) → Dreamy(x))"
},
{
"input": "Translate into first-order logic: If a design by Max is timeless, then a design by Max is a mass product design and evocative.",
"output": "Timeless(aDesignByMax) → MassProductDesign(aDesignByMax) ∧ Evocative(aDesignByMax)"
},
{
"input": "Translate into first-order logic: A design by Max is evocative and dreamy.",
"output": "Evocative(aDesignByMax) ∧ Dreamy(aDesignByMax)"
},
{
"input": "Translate into first-order logic: All of Zaha Hadid's design styles are timeless.",
"output": "∀x (ZahaHadidDesignStyle(x) → Timeless(x))"
},
{
"input": "Translate into first-order logic: No mass product design is timeless.",
"output": "∀x (MassProductDesign(x) → ¬Timeless(x))"
},
{
"input": "Translate into first-order logic: Either Zaha Hadid's design style or Kelly Wearstler's design style.",
"output": "∀x (ZahaHadidDesignStyle(x) ∨ KellyWearstlerDesignStyle(x)) "
},
{
"input": "Translate into first-order logic: All of Kelly Wearstler's design styles are evocative.",
"output": "∀x (KellyWearstlerDesignStyle(x) → Evocative(x))"
},
{
"input": "Translate into first-order logic: All of Kelly Wearstler's design styles are dreamy.",
"output": "∀x (KellyWearstlerDesignStyle(x) → Dreamy(x))"
},
{
"input": "Translate into first-order logic: If a design by Max is timeless, then a design by Max is a mass product design and evocative.",
"output": "Timeless(aDesignByMax) → MassProductDesign(aDesignByMax) ∧ Evocative(aDesignByMax)"
},
{
"input": "Translate into first-order logic: A design by Max is either evocative or dreamy.",
"output": "Evocative(aDesignByMax) ⊕ Dreamy(aDesignByMax)"
},
{
"input": "Translate into first-order logic: If a player is ranked highly by the Women's Tennis Association, then they are among the most active players in major tennis.",
"output": "∀x (RankedHighlyByWomenTennisAssociation(x) → AmongMostActivePlayersInMajorTennis(x))"
},
{
"input": "Translate into first-order logic: Everyone who lost to Iga Świątek is ranked highly by the Women's Tennis Association.",
"output": "∀x (LostToIgaŚwiątek(x) → RankedHighlyByWomenTennisAssociation(x))"
},
{
"input": "Translate into first-order logic: All female tennis players at Roland Garros 2022 lost to Iga Świątek.",
"output": "∀x (FemaleTennisPlayersAtRolandGarros2022(x) → LostToIgaŚwiątek(x)) "
},
{
"input": "Translate into first-order logic: Either female tennis players at Roland Garros 2022 or male tennis players at Roland Garros 2022.",
"output": "∀x (FemaleTennisPlayersAtRolandGarros2022(x) ∨ MaleTennisPlayersAtRolandGarros2022(x)) "
},
{
"input": "Translate into first-order logic: All male tennis players at Roland Garros 2022 lost to Rafael Nadal.",
"output": "∀x (MaleTennisPlayersAtRolandGarros2022(x) → LostToRafaelNadal(x))"
},
{
"input": "Translate into first-order logic: If Coco Gauff is a player who is ranked highly by the Women's Tennis Association or a player who lost to Rafael Nadal, then Coco Gauff is not a male tennis player at Roland Garros 2022.",
"output": "RankedHighlyByWomenTennisAssociation(cocoGauff) ∨ LostToRafaelNadal(cocoGauff) → ¬MaleTennisPlayersAtRolandGarros2022(cocoGauff)"
},
{
"input": "Translate into first-order logic: Coco Gauff is among the most active players in major tennis.",
"output": "AmongMostActivePlayersInMajorTennis(cocoGauff)"
},
{
"input": "Translate into first-order logic: If a player is ranked highly by the Women's Tennis Association, then they are among the most active players in major tennis.",
"output": "∀x (RankedHighlyByWomenTennisAssociation(x) → AmongMostActivePlayersInMajorTennis(x))"
},
{
"input": "Translate into first-order logic: Everyone who lost to Iga Świątek is ranked highly by the Women's Tennis Association.",
"output": "∀x (LostToIgaŚwiątek(x) → RankedHighlyByWomenTennisAssociation(x))"
},
{
"input": "Translate into first-order logic: All female tennis players at Roland Garros 2022 lost to Iga Świątek.",
"output": "∀x (FemaleTennisPlayersAtRolandGarros2022(x) → LostToIgaŚwiątek(x)) "
},
{
"input": "Translate into first-order logic: Either female tennis players at Roland Garros 2022 or male tennis players at Roland Garros 2022.",
"output": "∀x (FemaleTennisPlayersAtRolandGarros2022(x) ∨ MaleTennisPlayersAtRolandGarros2022(x)) "
},
{
"input": "Translate into first-order logic: All male tennis players at Roland Garros 2022 lost to Rafael Nadal.",
"output": "∀x (MaleTennisPlayersAtRolandGarros2022(x) → LostToRafaelNadal(x))"
},
{
"input": "Translate into first-order logic: If Coco Gauff is a player who is ranked highly by the Women's Tennis Association or a player who lost to Rafael Nadal, then Coco Gauff is not a male tennis player at Roland Garros 2022.",
"output": "RankedHighlyByWomenTennisAssociation(cocoGauff) ∨ LostToRafaelNadal(cocoGauff) → ¬MaleTennisPlayersAtRolandGarros2022(cocoGauff)"
},
{
"input": "Translate into first-order logic: Coco Gauff has lost to Rafael Nadal.",
"output": "LostToRafaelNadal(cocoGauff)"
},
{
"input": "Translate into first-order logic: If a player is ranked highly by the Women's Tennis Association, then they are among the most active players in major tennis.",
"output": "∀x (RankedHighlyByWomenTennisAssociation(x) → AmongMostActivePlayersInMajorTennis(x))"
},
{
"input": "Translate into first-order logic: Everyone who lost to Iga Świątek is ranked highly by the Women's Tennis Association.",
"output": "∀x (LostToIgaŚwiątek(x) → RankedHighlyByWomenTennisAssociation(x))"
},
{
"input": "Translate into first-order logic: All female tennis players at Roland Garros 2022 lost to Iga Świątek.",
"output": "∀x (FemaleTennisPlayersAtRolandGarros2022(x) → LostToIgaŚwiątek(x)) "
},
{
"input": "Translate into first-order logic: Either female tennis players at Roland Garros 2022 or male tennis players at Roland Garros 2022.",
"output": "∀x (FemaleTennisPlayersAtRolandGarros2022(x) ∨ MaleTennisPlayersAtRolandGarros2022(x)) "
},
{
"input": "Translate into first-order logic: All male tennis players at Roland Garros 2022 lost to Rafael Nadal.",
"output": "∀x (MaleTennisPlayersAtRolandGarros2022(x) → LostToRafaelNadal(x))"
},
{
"input": "Translate into first-order logic: If Coco Gauff is a player who is ranked highly by the Women's Tennis Association or a player who lost to Rafael Nadal, then Coco Gauff is not a male tennis player at Roland Garros 2022.",
"output": "RankedHighlyByWomenTennisAssociation(cocoGauff) ∨ LostToRafaelNadal(cocoGauff) → ¬MaleTennisPlayersAtRolandGarros2022(cocoGauff)"
},
{
"input": "Translate into first-order logic: Coco Gauff is not a player who lost to Iga Świątek or one of the most active players in major tennis.",
"output": "¬LostToIgaŚwiątek(cocoGauff) ∨ ¬AmongMostActivePlayersInMajorTennis(cocoGauff)"
},
{
"input": "Translate into first-order logic: All cats are mammals.",
"output": "∀x (Cat(x) → Mammal(x))"
},
{
"input": "Translate into first-order logic: Some pets are not mammals.",
"output": "∃x (Pet(x) ∧ ¬Mammal(x))"
},
{
"input": "Translate into first-order logic: No pets are cats.",
"output": "∀x (Pet(x) → ¬Cat(x))"
},
{
"input": "Translate into first-order logic: [BG] There are four seasons in a year: Spring, Summer, Fall, and Winter.",
"output": "Season(spring) ∨ Season(summer) ∨ Season(fall) ∨ Season(winter)"
},
{
"input": "Translate into first-order logic: All students who want to have a long vacation love summer the most.",
"output": "∀x (WantlongVacation(x) → Love(x, summer))"
},
{
"input": "Translate into first-order logic: Emma's favorite season is summer.",
"output": "Love(emma, summer)"
},
{
"input": "Translate into first-order logic: Mia's favorite season is not the same as Emma's.",
"output": "¬Love(mia, emma)"
},
{
"input": "Translate into first-order logic: James wants to have a long vacation.",
"output": "WantlongVacation(james)"
},
{
"input": "Translate into first-order logic: James's favorite season is summer.",
"output": "Love(james, summer)"
},
{
"input": "Translate into first-order logic: [BG] There are four seasons in a year: Spring, Summer, Fall, and Winter.",
"output": "Season(spring) ∨ Season(summer) ∨ Season(fall) ∨ Season(winter)"
},
{
"input": "Translate into first-order logic: All students who want to have a long vacation love summer the most.",
"output": "∀x (WantlongVacation(x) → Love(x, summer))"
},
{
"input": "Translate into first-order logic: Emma's favorite season is summer.",
"output": "Love(emma, summer)"
},
{
"input": "Translate into first-order logic: Mia's favorite season is not the same as Emma's.",
"output": "¬Love(mia, emma)"
},
{
"input": "Translate into first-order logic: James wants to have a long vacation.",
"output": "WantlongVacation(james)"
},
{
"input": "Translate into first-order logic: James's favorite season is fall.",
"output": "Love(james, fall)"
},
{
"input": "Translate into first-order logic: [BG] There are four seasons in a year: Spring, Summer, Fall, and Winter.",
"output": "Season(spring) ∨ Season(summer) ∨ Season(fall) ∨ Season(winter)"
},
{
"input": "Translate into first-order logic: All students who want to have a long vacation love summer the most.",
"output": "∀x (WantlongVacation(x) → Love(x, summer))"
},
{
"input": "Translate into first-order logic: Emma's favorite season is summer.",
"output": "Love(emma, summer)"
},
{
"input": "Translate into first-order logic: Mia's favorite season is not the same as Emma's.",
"output": "¬Love(mia, emma)"
},
{
"input": "Translate into first-order logic: James wants to have a long vacation.",
"output": "WantlongVacation(james)"
},
{
"input": "Translate into first-order logic: Mia's favorite season is spring.",
"output": "Love(mia, spring)"
},
{
"input": "Translate into first-order logic: No digital media are analog.",
"output": "∀x (Digital(x) → ¬Analog(x))"
},
{
"input": "Translate into first-order logic: Every printed text is analog.",
"output": "∀x (PrintedText(x) → Analog(x))"
},
{
"input": "Translate into first-order logic: All streaming services are digital.",
"output": "∀x (StreamingService(x) → Digital(x))"
},
{
"input": "Translate into first-order logic: If an object is a hardcover book then it is printed text.",
"output": "∀x (HardcoverBook(x) → PrintedText(x))"
},
{
"input": "Translate into first-order logic: If 1984 is a streaming service, then 1984 is a hardcover book.",
"output": "StreamingService(y1984) → HardcoverBook(y1984)"
},
{
"input": "Translate into first-order logic: 1984 is printed text.",
"output": "PrintedText(y1984)"
},
{
"input": "Translate into first-order logic: No digital media are analog.",
"output": "∀x (Digital(x) → ¬Analog(x))"
},
{
"input": "Translate into first-order logic: Every printed text is analog.",
"output": "∀x (PrintedText(x) → Analog(x))"
},
{
"input": "Translate into first-order logic: All streaming services are digital.",
"output": "∀x (StreamingService(x) → Digital(x))"
},
{
"input": "Translate into first-order logic: If an object is a hardcover book then it is printed text.",
"output": "∀x (HardcoverBook(x) → PrintedText(x))"
},
{
"input": "Translate into first-order logic: If 1984 is a streaming service, then 1984 is a hardcover book.",
"output": "StreamingService(y1984) → HardcoverBook(y1984)"
},
{
"input": "Translate into first-order logic: 1984 is a streaming service.",
"output": "StreamingService(y1984)"
},
{
"input": "Translate into first-order logic: No digital media are analog.",
"output": "∀x (Digital(x) → ¬Analog(x))"
},
{
"input": "Translate into first-order logic: Every printed text is analog.",
"output": "∀x (PrintedText(x) → Analog(x))"
},
{
"input": "Translate into first-order logic: All streaming services are digital.",
"output": "∀x (StreamingService(x) → Digital(x))"
},
{
"input": "Translate into first-order logic: If an object is a hardcover book then it is printed text.",
"output": "∀x (HardcoverBook(x) → PrintedText(x))"
},
{
"input": "Translate into first-order logic: If 1984 is a streaming service, then 1984 is a hardcover book.",
"output": "StreamingService(y1984) → HardcoverBook(y1984)"
},
{
"input": "Translate into first-order logic: 1984 is not a streaming service.",
"output": "¬StreamingService(y1984)"
},
{
"input": "Translate into first-order logic: All Romance languages are Indo-European languages.",
"output": "∀x (RomanceLanguage(x) → IndoEuropeanLanguage(x))"
},
{
"input": "Translate into first-order logic: The Romance languages are a language family.",
"output": "∀x (RomanceLanguage(x) → MemberOf(x, romancefamily))"
},
{
"input": "Translate into first-order logic: All languages within a language family are related to each other.",
"output": "∀x ∀y ∀z ((MemberOf(x, z) ∧ MemberOf(y, z)) → (Related(x, y) ∧ Related(y, x)))"
},
{
"input": "Translate into first-order logic: French and Spanish are both Romance languages.",
"output": "RomanceLanguage(french) ∧ RomanceLanguage(spanish)"
},
{
"input": "Translate into first-order logic: German is related to Spanish.",
"output": "Related(german, spanish)"
},
{
"input": "Translate into first-order logic: Basque is not related to any other language.",
"output": "∀x (¬Related(basque, x))"
},
{
"input": "Translate into first-order logic: Basque is a Romance language.",
"output": "RomanceLanguage(basque)"
},
{
"input": "Translate into first-order logic: All Romance languages are Indo-European languages.",
"output": "∀x (RomanceLanguage(x) → IndoEuropeanLanguage(x))"
},
{
"input": "Translate into first-order logic: The Romance languages are a language family.",
"output": "∀x (RomanceLanguage(x) → MemberOf(x, romancefamily))"
},
{
"input": "Translate into first-order logic: All languages within a language family are related to each other.",
"output": "∀x ∀y ∀z ((MemberOf(x, z) ∧ MemberOf(y, z)) → (Related(x, y) ∧ Related(y, x)))"
},
{
"input": "Translate into first-order logic: French and Spanish are both Romance languages.",
"output": "RomanceLanguage(french) ∧ RomanceLanguage(spanish)"
},
{
"input": "Translate into first-order logic: German is related to Spanish.",
"output": "Related(german, spanish)"
},
{
"input": "Translate into first-order logic: Basque is not related to any other language.",
"output": "∀x (¬Related(basque, x))"
},
{
"input": "Translate into first-order logic: German is a Romance language.",
"output": "RomanceLanguage(german)"
},
{
"input": "Translate into first-order logic: All Romance languages are Indo-European languages.",
"output": "∀x (RomanceLanguage(x) → IndoEuropeanLanguage(x))"
},
{
"input": "Translate into first-order logic: The Romance languages are a language family.",
"output": "∀x (RomanceLanguage(x) → MemberOf(x, romancefamily))"
},
{
"input": "Translate into first-order logic: All languages within a language family are related to each other.",
"output": "∀x ∀y ∀z ((MemberOf(x, z) ∧ MemberOf(y, z)) → (Related(x, y) ∧ Related(y, x)))"
},
{
"input": "Translate into first-order logic: French and Spanish are both Romance languages.",
"output": "RomanceLanguage(french) ∧ RomanceLanguage(spanish)"
},
{
"input": "Translate into first-order logic: German is related to Spanish.",
"output": "Related(german, spanish)"
},
{
"input": "Translate into first-order logic: Basque is not related to any other language.",
"output": "∀x (¬Related(basque, x))"
},
{
"input": "Translate into first-order logic: French is an Indo-European language.",
"output": "IndoEuropeanLanguage(french)"
},
{
"input": "Translate into first-order logic: Robert Lewandowski is a striker.",
"output": "IsStriker(robertLewandowski)"
},
{
"input": "Translate into first-order logic: [BG] Strikers are soccer players.",
"output": "∀x (IsStriker(x) → IsSoccerPlayer(x))"
},
{
"input": "Translate into first-order logic: Robert Lewandowski left Bayern Munchen.",
"output": "LeftTeam(robertLewandowski, bayernMunchen)"
},
{
"input": "Translate into first-order logic: [BG] If a player left a team they no longer play for that team.",
"output": "∀x ∀y (LeftTeam(x, y) → ¬PlaysForTeam(x, y))"
},
{
"input": "Translate into first-order logic: Robert Lewandowski is a soccer player.",
"output": "IsSoccerPlayer(robertLewandowski)"
},
{
"input": "Translate into first-order logic: Robert Lewandowski is a striker.",
"output": "IsStriker(robertLewandowski)"
},
{
"input": "Translate into first-order logic: [BG] Strikers are soccer players.",
"output": "∀x (IsStriker(x) → IsSoccerPlayer(x))"
},
{
"input": "Translate into first-order logic: Robert Lewandowski left Bayern Munchen.",
"output": "LeftTeam(robertLewandowski, bayernMunchen)"
},
{
"input": "Translate into first-order logic: [BG] If a player left a team they no longer play for that team.",
"output": "∀x ∀y (LeftTeam(x, y) → ¬PlaysForTeam(x, y))"
},
{
"input": "Translate into first-order logic: Robert Lewandowski plays for Bayern Munchen.",
"output": "PlaysForTeam(robertLewandowski, bayernMunchen)"
},
{
"input": "Translate into first-order logic: Robert Lewandowski is a striker.",
"output": "IsStriker(robertLewandowski)"
},
{
"input": "Translate into first-order logic: [BG] Strikers are soccer players.",
"output": "∀x (IsStriker(x) → IsSoccerPlayer(x))"
},
{
"input": "Translate into first-order logic: Robert Lewandowski left Bayern Munchen.",
"output": "LeftTeam(robertLewandowski, bayernMunchen)"
},
{
"input": "Translate into first-order logic: [BG] If a player left a team they no longer play for that team.",
"output": "∀x ∀y (LeftTeam(x, y) → ¬PlaysForTeam(x, y))"
},
{
"input": "Translate into first-order logic: Robert Lewandowski is a star.",
"output": "IsSoccerStar(robertLewandowski)"
},
{
"input": "Translate into first-order logic: Billings is a city in Montana.",
"output": "CityIn(billings, montana)"
},
{
"input": "Translate into first-order logic: Montana includes the cities of Butte, Helena, and Missoula.",
"output": "CityIn(butte, montana) ∧ CityIn(helena, montana) ∧ CityIn(missoula, montana)"
},
{
"input": "Translate into first-order logic: White Sulphur Springs and Butte are cities in the same state.",
"output": "∃x (CityIn(whitesulphursprings, x) ∧ CityIn(butte, x))"
},
{
"input": "Translate into first-order logic: The city of Pierre is not in Montana.",
"output": "¬CityIn(pierre, montana)"
},
{
"input": "Translate into first-order logic: Any city in Butte is not in Pierre.",
"output": "∀x (CityIn(butte, x) → ¬CityIn(pierre, x))"
},
{
"input": "Translate into first-order logic: Butte and Pierre are in the same state.",
"output": "∃x (CityIn(butte, x) ∧ CityIn(pierre, x))"
},
{
"input": "Translate into first-order logic: Billings is a city in Montana.",
"output": "CityIn(billings, montana)"
},
{
"input": "Translate into first-order logic: Montana includes the cities of Butte, Helena, and Missoula.",
"output": "CityIn(butte, montana) ∧ CityIn(helena, montana) ∧ CityIn(missoula, montana)"
},
{
"input": "Translate into first-order logic: White Sulphur Springs and Butte are cities in the same state.",
"output": "∃x (CityIn(whitesulphursprings, x) ∧ CityIn(butte, x))"
},
{
"input": "Translate into first-order logic: The city of Pierre is not in Montana.",
"output": "¬CityIn(pierre, montana)"
},
{
"input": "Translate into first-order logic: Any city in Butte is not in Pierre.",
"output": "∀x (CityIn(butte, x) → ¬CityIn(pierre, x))"
},
{
"input": "Translate into first-order logic: Pierre and Bismarck are in the same state.",
"output": "∃x (CityIn(pierre, x) ∧ CityIn(bismarck, x))"
},
{
"input": "Translate into first-order logic: Billings is a city in Montana.",
"output": "CityIn(billings, montana)"
},
{
"input": "Translate into first-order logic: Montana includes the cities of Butte, Helena, and Missoula.",
"output": "CityIn(butte, montana) ∧ CityIn(helena, montana) ∧ CityIn(missoula, montana)"
},
{
"input": "Translate into first-order logic: White Sulphur Springs and Butte are cities in the same state.",
"output": "∃x (CityIn(whitesulphursprings, x) ∧ CityIn(butte, x))"
},
{
"input": "Translate into first-order logic: The city of Pierre is not in Montana.",
"output": "¬CityIn(pierre, montana)"
},
{
"input": "Translate into first-order logic: Any city in Butte is not in Pierre.",
"output": "∀x (CityIn(butte, x) → ¬CityIn(pierre, x))"
},
{
"input": "Translate into first-order logic: Montana is home to the city of Missoula.",
"output": "CityIn(missoula, montana)"
},
{
"input": "Translate into first-order logic: International students in US have either an F1 visa or a J1 visa.",
"output": "∀x (InternationalStudent(x) → F1(x) ⊕ J1(x))"
},
{
"input": "Translate into first-order logic: An international student in US with an F1 visa needs to apply for CPT or OPT if the student wants to work in the US.",
"output": "∀x (InternationalStudent(x) ∧ F1(x) ∧ WantWorkInUS(x) → Apply(x, cpt) ∨ Apply(x, opt))"
},
{
"input": "Translate into first-order logic: Mike is an international student.",
"output": "InternationalStudent(mike)"
},
{
"input": "Translate into first-order logic: Mike needs to apply for CPT if he wants to work in the US.",
"output": "WantWorkInUS(mike) → Apply(mike, cpt)"
},
{
"input": "Translate into first-order logic: Mike has an F1 visa.",
"output": "F1(mike)"
},
{
"input": "Translate into first-order logic: International students in US have either an F1 visa or a J1 visa.",
"output": "∀x (InternationalStudent(x) → F1(x) ⊕ J1(x))"
},
{
"input": "Translate into first-order logic: An international student in US with an F1 visa needs to apply for CPT or OPT if the student wants to work in the US.",
"output": "∀x (InternationalStudent(x) ∧ F1(x) ∧ WantWorkInUS(x) → Apply(x, cpt) ∨ Apply(x, opt))"
},
{
"input": "Translate into first-order logic: Mike is an international student.",
"output": "InternationalStudent(mike)"
},
{
"input": "Translate into first-order logic: Mike needs to apply for CPT if he wants to work in the US.",
"output": "WantWorkInUS(mike) → Apply(mike, cpt)"
},
{
"input": "Translate into first-order logic: Mike has a J1 visa.",
"output": "J1(mike)"
},
{
"input": "Translate into first-order logic: All cows are bovines.",
"output": "∀x (Cow(x) → Bovine(x))"
},
{
"input": "Translate into first-order logic: Some pets are cows.",
"output": "∃x (Pet(x) ∧ Cow(x))"
},
{
"input": "Translate into first-order logic: If something is a bovine, then it is domesticated.",
"output": "∀x (Bovine(x) → Domesticated(x))"
},
{
"input": "Translate into first-order logic: No domesticated animals are alligators.",
"output": "∀x (Domesticated(x) → ¬Aligator(x))"
},
{
"input": "Translate into first-order logic: Ted is an aligator.",
"output": "Aligator(ted)"
},
{
"input": "Translate into first-order logic: Ted is a pet.",
"output": "Pet(ted)"
},
{
"input": "Translate into first-order logic: All cows are bovines.",
"output": "∀x (Cow(x) → Bovine(x))"
},
{
"input": "Translate into first-order logic: Some pets are cows.",
"output": "∃x (Pet(x) ∧ Cow(x))"
},
{
"input": "Translate into first-order logic: If something is a bovine, then it is domesticated.",
"output": "∀x (Bovine(x) → Domesticated(x))"
},
{
"input": "Translate into first-order logic: No domesticated animals are alligators.",
"output": "∀x (Domesticated(x) → ¬Aligator(x))"
},
{
"input": "Translate into first-order logic: Ted is an aligator.",
"output": "Aligator(ted)"
},
{
"input": "Translate into first-order logic: Ted is a pet and a cow.",
"output": "Pet(ted) ∧ Cow(ted)"
},
{
"input": "Translate into first-order logic: All cows are bovines.",
"output": "∀x (Cow(x) → Bovine(x))"
},
{
"input": "Translate into first-order logic: Some pets are cows.",
"output": "∃x (Pet(x) ∧ Cow(x))"
},
{
"input": "Translate into first-order logic: If something is a bovine, then it is domesticated.",
"output": "∀x (Bovine(x) → Domesticated(x))"
},
{
"input": "Translate into first-order logic: No domesticated animals are alligators.",
"output": "∀x (Domesticated(x) → ¬Aligator(x))"
},
{
"input": "Translate into first-order logic: Ted is an aligator.",
"output": "Aligator(ted)"
},
{
"input": "Translate into first-order logic: If Ted is a cow, then Ted is not a pet.",
"output": "Cow(ted) → ¬Pet(ted)"
},
{
"input": "Translate into first-order logic: Yale University is a private Ivy League research university.",
"output": "PrivateIvyLeagueResearchUniversity(yale)"
},
{
"input": "Translate into first-order logic: Yale University moved to New Haven in 1716.",
"output": "MovedTo(yale, newhaven) ∧ MovedIn(yale, y1716)"
},
{
"input": "Translate into first-order logic: Yale university's endowment was valued at $42.3 billion.",
"output": "ValuedAt(yalesendowment, y42.3billion)"
},
{
"input": "Translate into first-order logic: Yale University has been organized into 27 constituent colleges and schools: the residential colleges, the Yale Graduate School of Arts and Sciences, and twelve professional schools.",
"output": "∃x (OrganizedInto(yale, x) ∧ ConstituentCollegesandSchools(x) ∧ ((ResidentialCollege(x) ⊕ GraduateSchool(x)) ⊕ ProfessionalSchool(x)))"
},
{
"input": "Translate into first-order logic: A list of residential colleges at Yale: Benjamin Franklin College, Berkeley College, Branford College, Davenport College, Ezra Stiles College, Grace Hopper College, Jonathan Edwards College, Morse College, Pauli Murray College, Pierson College, Saybrook College, Silliman College, Timothy Dwight College, and Trumbull College.",
"output": "ResidentialCollege(benjaminfranklincollege) ∧ AtYale(benjaminfranklincollege) ∧ ResidentialCollege(berkeleycollege) ∧ AtYale(berkeleycollege) ∧ ResidentialCollege(branfordcollege) ∧ AtYale(branfordcollege) ∧ ResidentialCollege(davenportcollege) ∧ AtYale(davenportcollege) ∧ ResidentialCollege(ezrastilescollege) ∧ AtYale(ezrastilescollege) ∧ ResidentialCollege(gracehoppercollege) ∧ AtYale(gracehoppercollege) ∧ ResidentialCollege(jonathanedwardscollege) ∧ AtYale(jonathanedwardscollege) ∧ ResidentialCollege(morsecollege) ∧ AtYale(morsecollege) ∧ ResidentialCollege(paulimurraycollege) ∧ AtYale(paulimurraycollege) ∧ ResidentialCollege(piersoncollege) ∧ AtYale(piersoncollege) ∧ ResidentialCollege(saybrookcollege) ∧ AtYale(saybrookcollege) ∧ ResidentialCollege(sillimancollege) ∧ AtYale(sillimancollege) ∧ ResidentialCollege(timothydwightcollege) ∧ AtYale(timothydwightcollege) ∧ ResidentialCollege(trumbullcollege) ∧ AtYale(trumbullcollege)"
},
{
"input": "Translate into first-order logic: A private Ivy League research university moved to New Haven.",
"output": "∃x (PrivateIvyLeagueResearchUniversity(x) ∧ MovedTo(x, newhaven))"
},
{
"input": "Translate into first-order logic: Yale University is a private Ivy League research university.",
"output": "PrivateIvyLeagueResearchUniversity(yale)"
},
{
"input": "Translate into first-order logic: Yale University moved to New Haven in 1716.",
"output": "MovedTo(yale, newhaven) ∧ MovedIn(yale, y1716)"
},
{
"input": "Translate into first-order logic: Yale university's endowment was valued at $42.3 billion.",
"output": "ValuedAt(yalesendowment, y42.3billion)"
},
{
"input": "Translate into first-order logic: Yale University has been organized into 27 constituent colleges and schools: the residential colleges, the Yale Graduate School of Arts and Sciences, and twelve professional schools.",
"output": "∃x (OrganizedInto(yale, x) ∧ ConstituentCollegesandSchools(x) ∧ ((ResidentialCollege(x) ⊕ GraduateSchool(x)) ⊕ ProfessionalSchool(x)))"
},
{
"input": "Translate into first-order logic: A list of residential colleges at Yale: Benjamin Franklin College, Berkeley College, Branford College, Davenport College, Ezra Stiles College, Grace Hopper College, Jonathan Edwards College, Morse College, Pauli Murray College, Pierson College, Saybrook College, Silliman College, Timothy Dwight College, and Trumbull College.",
"output": "ResidentialCollege(benjaminfranklincollege) ∧ AtYale(benjaminfranklincollege) ∧ ResidentialCollege(berkeleycollege) ∧ AtYale(berkeleycollege) ∧ ResidentialCollege(branfordcollege) ∧ AtYale(branfordcollege) ∧ ResidentialCollege(davenportcollege) ∧ AtYale(davenportcollege) ∧ ResidentialCollege(ezrastilescollege) ∧ AtYale(ezrastilescollege) ∧ ResidentialCollege(gracehoppercollege) ∧ AtYale(gracehoppercollege) ∧ ResidentialCollege(jonathanedwardscollege) ∧ AtYale(jonathanedwardscollege) ∧ ResidentialCollege(morsecollege) ∧ AtYale(morsecollege) ∧ ResidentialCollege(paulimurraycollege) ∧ AtYale(paulimurraycollege) ∧ ResidentialCollege(piersoncollege) ∧ AtYale(piersoncollege) ∧ ResidentialCollege(saybrookcollege) ∧ AtYale(saybrookcollege) ∧ ResidentialCollege(sillimancollege) ∧ AtYale(sillimancollege) ∧ ResidentialCollege(timothydwightcollege) ∧ AtYale(timothydwightcollege) ∧ ResidentialCollege(trumbullcollege) ∧ AtYale(trumbullcollege)"
},
{
"input": "Translate into first-order logic: Yale University has the largest university endowment of any educational institution.",
"output": "LargestUniversityEndowmentOf(yale, anyeducationalinstitution)"
},
{
"input": "Translate into first-order logic: Yale University is a private Ivy League research university.",
"output": "PrivateIvyLeagueResearchUniversity(yale)"
},
{
"input": "Translate into first-order logic: Yale University moved to New Haven in 1716.",
"output": "MovedTo(yale, newhaven) ∧ MovedIn(yale, y1716)"
},
{
"input": "Translate into first-order logic: Yale university's endowment was valued at $42.3 billion.",
"output": "ValuedAt(yalesendowment, y42.3billion)"
},
{
"input": "Translate into first-order logic: Yale University has been organized into 27 constituent colleges and schools: the residential colleges, the Yale Graduate School of Arts and Sciences, and twelve professional schools.",
"output": "∃x (OrganizedInto(yale, x) ∧ ConstituentCollegesandSchools(x) ∧ ((ResidentialCollege(x) ⊕ GraduateSchool(x)) ⊕ ProfessionalSchool(x)))"
},
{
"input": "Translate into first-order logic: A list of residential colleges at Yale: Benjamin Franklin College, Berkeley College, Branford College, Davenport College, Ezra Stiles College, Grace Hopper College, Jonathan Edwards College, Morse College, Pauli Murray College, Pierson College, Saybrook College, Silliman College, Timothy Dwight College, and Trumbull College.",
"output": "ResidentialCollege(benjaminfranklincollege) ∧ AtYale(benjaminfranklincollege) ∧ ResidentialCollege(berkeleycollege) ∧ AtYale(berkeleycollege) ∧ ResidentialCollege(branfordcollege) ∧ AtYale(branfordcollege) ∧ ResidentialCollege(davenportcollege) ∧ AtYale(davenportcollege) ∧ ResidentialCollege(ezrastilescollege) ∧ AtYale(ezrastilescollege) ∧ ResidentialCollege(gracehoppercollege) ∧ AtYale(gracehoppercollege) ∧ ResidentialCollege(jonathanedwardscollege) ∧ AtYale(jonathanedwardscollege) ∧ ResidentialCollege(morsecollege) ∧ AtYale(morsecollege) ∧ ResidentialCollege(paulimurraycollege) ∧ AtYale(paulimurraycollege) ∧ ResidentialCollege(piersoncollege) ∧ AtYale(piersoncollege) ∧ ResidentialCollege(saybrookcollege) ∧ AtYale(saybrookcollege) ∧ ResidentialCollege(sillimancollege) ∧ AtYale(sillimancollege) ∧ ResidentialCollege(timothydwightcollege) ∧ AtYale(timothydwightcollege) ∧ ResidentialCollege(trumbullcollege) ∧ AtYale(trumbullcollege)"
},
{
"input": "Translate into first-order logic: Pierson College is a residential college at Yale.",
"output": "ResidentialCollege(piersoncollege) ∧ AtYale(piersoncollege)"
},
{
"input": "Translate into first-order logic: Badults is a British Sitcom series, starring members of Pappy's.",
"output": "∃x (MemberOf(x, pappys) ∧ BritishSitcom(badults) ∧ Series(badults) ∧ Starring(badults, x))"
},
{
"input": "Translate into first-order logic: Badults piloted in July 2013 on BBC Three.",
"output": "PilotedIn(badults, july2013) ∧ PilotedOn(badults, bbcthree)"
},
{
"input": "Translate into first-order logic: The Working title \"The Secret Dude Society\" was used for Badults.",
"output": "WorkingTitle(thesecretdudesociety, badults)"
},
{
"input": "Translate into first-order logic: Andrew Collins was the script editor for Badults",
"output": "ScriptEditor(andrewcollins) ∧ ScriptEditorFor(andrewcollins, badults)"
},
{
"input": "Translate into first-order logic: Andrew Collins was the script editor for a series with the working title \"The Secret Dude Society\".",
"output": "∃x (ScriptEditorFor(andrewcollins, x) ∧ Series(x) ∧ WorkingTitle(thesecretdudesociety, x))"
},
{
"input": "Translate into first-order logic: Badults is a British Sitcom series, starring members of Pappy's.",
"output": "∃x (MemberOf(x, pappys) ∧ BritishSitcom(badults) ∧ Series(badults) ∧ Starring(badults, x))"
},
{
"input": "Translate into first-order logic: Badults piloted in July 2013 on BBC Three.",
"output": "PilotedIn(badults, july2013) ∧ PilotedOn(badults, bbcthree)"
},
{
"input": "Translate into first-order logic: The Working title \"The Secret Dude Society\" was used for Badults.",
"output": "WorkingTitle(thesecretdudesociety, badults)"
},
{
"input": "Translate into first-order logic: Andrew Collins was the script editor for Badults",
"output": "ScriptEditor(andrewcollins) ∧ ScriptEditorFor(andrewcollins, badults)"
},
{
"input": "Translate into first-order logic: No members of Pappy's have starred for a show piloting on BBC Two or BBC Three.",
"output": "∀x ∀y (MemberOf(x, pappys) ∧ Starring(y, x) → ¬(PilotedOn(y, bbctwo) ∨ PilotedOn(y, bbcthree)))"
},
{
"input": "Translate into first-order logic: All growth companies’ stocks are volatile.",
"output": "∀x (GrowthCompanies’Stocks(x) → PriceVolatile(x))"
},
{
"input": "Translate into first-order logic: If the stock price is volatile, then it is not suitable for a retirement fund.",
"output": " ∀x (PriceVolatile(x) → ¬SuitableForRetirementRund(x)) "
},
{
"input": "Translate into first-order logic: Some companies’ stocks are growth companies’ stocks.",
"output": " ∃x (Companies’Stocks(x) ∧ GrowthCompanies’Stocks(x))"
},
{
"input": "Translate into first-order logic: All mature companies’ stocks are suitable for a retirement fund.",
"output": " ∀x (MatureCompanies’Stocks(x) → SuitableForRetirementRund(x))"
},
{
"input": "Translate into first-order logic: KO is a mature company’s stock.",
"output": " MatureCompanies’Stocks(kO)"
},
{
"input": "Translate into first-order logic: KO is a company stock.",
"output": "Companies’Stocks(kO)"
},
{
"input": "Translate into first-order logic: All growth companies’ stocks are volatile.",
"output": "∀x (GrowthCompanies’Stocks(x) → PriceVolatile(x))"
},
{
"input": "Translate into first-order logic: If the stock price is volatile, then it is not suitable for a retirement fund.",
"output": " ∀x (PriceVolatile(x) → ¬SuitableForRetirementRund(x)) "
},
{
"input": "Translate into first-order logic: Some companies’ stocks are growth companies’ stocks.",
"output": " ∃x (Companies’Stocks(x) ∧ GrowthCompanies’Stocks(x))"
},
{
"input": "Translate into first-order logic: All mature companies’ stocks are suitable for a retirement fund.",
"output": " ∀x (MatureCompanies’Stocks(x) → SuitableForRetirementRund(x))"
},
{
"input": "Translate into first-order logic: KO is a mature company’s stock.",
"output": " MatureCompanies’Stocks(kO)"
},
{
"input": "Translate into first-order logic: KO is a company stock and a growth company’s stock.",
"output": "Companies’Stocks(kO) ∧ GrowthCompanies’Stocks(kO)"
},
{
"input": "Translate into first-order logic: All growth companies’ stocks are volatile.",
"output": "∀x (GrowthCompanies’Stocks(x) → PriceVolatile(x))"
},
{
"input": "Translate into first-order logic: If the stock price is volatile, then it is not suitable for a retirement fund.",
"output": " ∀x (PriceVolatile(x) → ¬SuitableForRetirementRund(x)) "
},
{
"input": "Translate into first-order logic: Some companies’ stocks are growth companies’ stocks.",
"output": " ∃x (Companies’Stocks(x) ∧ GrowthCompanies’Stocks(x))"
},
{
"input": "Translate into first-order logic: All mature companies’ stocks are suitable for a retirement fund.",
"output": " ∀x (MatureCompanies’Stocks(x) → SuitableForRetirementRund(x))"
},
{
"input": "Translate into first-order logic: KO is a mature company’s stock.",
"output": " MatureCompanies’Stocks(kO)"
},
{
"input": "Translate into first-order logic: If KO is a growth company’s stock or if its price is volatile, then KO is neither a company’s stock nor is its price volatile.",
"output": "GrowthCompanies’Stocks(kO) ∨ PriceVolatile(kO) → ¬Companies’Stocks(kO) ∨ ¬PriceVolatile(kO)"
},
{
"input": "Translate into first-order logic: All vehicle registration plates in Istanbul begin with the number 34.",
"output": "∀x (Vehicleregistrationplate(x, istanbul) → Beginwith(x, number34))"
},
{
"input": "Translate into first-order logic: Plates that do not begin with the number 34 are not from Istanbul.",
"output": "∀x (¬Beginwith(x, number34) → ¬FromIstanbul(x))"
},
{
"input": "Translate into first-order logic: Joe's vehicle registration plate is from Istanbul.",
"output": "Vehicleregistrationplate(joe, istanbul)"
},
{
"input": "Translate into first-order logic: Tom's license plate begins with the number 35.",
"output": "Beginwith(tom, number35)"
},
{
"input": "Translate into first-order logic: [BG] If a license plate begins with the number 35, then it does not begin with the number 34.",
"output": "∀x (Beginwith(x, number35) → ¬Beginwith(x, number34))"
},
{
"input": "Translate into first-order logic: Joe's license plate begins with the number 34.",
"output": "Beginwith(joe, number34)"
},
{
"input": "Translate into first-order logic: All vehicle registration plates in Istanbul begin with the number 34.",
"output": "∀x (Vehicleregistrationplate(x, istanbul) → Beginwith(x, number34))"
},
{
"input": "Translate into first-order logic: Plates that do not begin with the number 34 are not from Istanbul.",
"output": "∀x (¬Beginwith(x, number34) → ¬FromIstanbul(x))"
},
{
"input": "Translate into first-order logic: Joe's vehicle registration plate is from Istanbul.",
"output": "Vehicleregistrationplate(joe, istanbul)"
},
{
"input": "Translate into first-order logic: Tom's license plate begins with the number 35.",
"output": "Beginwith(tom, number35)"
},
{
"input": "Translate into first-order logic: [BG] If a license plate begins with the number 35, then it does not begin with the number 34.",
"output": "∀x (Beginwith(x, number35) → ¬Beginwith(x, number34))"
},
{
"input": "Translate into first-order logic: Tom's license plate is from Istanbul.",
"output": "Vehicleregistrationplate(tom, istanbul)"
},
{
"input": "Translate into first-order logic: If people work in student jobs on campus, then they need to earn money to help pay for their college tuition.",
"output": "∀x (StudentJobs(x) → Tuition(x))"
},
{
"input": "Translate into first-order logic: If people order takeout frequently in college, then they work in student jobs on campus.",
"output": "∀x (Takeout(x) → StudentJobs(x))"
},
{
"input": "Translate into first-order logic: People either order takeout frequently in college or enjoy the dining hall meals and recipes.",
"output": "∀x (Takeout(x) ∨ DiningHall(x))"
},
{
"input": "Translate into first-order logic: If people enjoy the dining hall meals and recipes, then they are not picky eaters.",
"output": "∀x (DiningHall(x) → NotPicky(x))"
},
{
"input": "Translate into first-order logic: If people enjoy the dining hall meals and recipes, then they spend a lot of their time eating and catching up with friends in the campus dining halls.",
"output": "∀x (DiningHall(x) → Eating(x))"
},
{
"input": "Translate into first-order logic: If Mary works in student jobs on campus and needs to earn money to help pay for her college tuition, then Mary is neither picky nor needs to earn money to help pay for her college tuition.",
"output": "StudentJobs(mary) ∧ Tuition(mary) → ¬(NotPicky(mary) ∨ Tuition(mary))"
},
{
"input": "Translate into first-order logic: Mary needs to earn money to help pay for her college tuition.",
"output": "Tuition(mary)"
},
{
"input": "Translate into first-order logic: If people work in student jobs on campus, then they need to earn money to help pay for their college tuition.",
"output": "∀x (StudentJobs(x) → Tuition(x))"
},
{
"input": "Translate into first-order logic: If people order takeout frequently in college, then they work in student jobs on campus.",
"output": "∀x (Takeout(x) → StudentJobs(x))"
},
{
"input": "Translate into first-order logic: People either order takeout frequently in college or enjoy the dining hall meals and recipes.",
"output": "∀x (Takeout(x) ∨ DiningHall(x))"
},
{
"input": "Translate into first-order logic: If people enjoy the dining hall meals and recipes, then they are not picky eaters.",
"output": "∀x (DiningHall(x) → NotPicky(x))"
},
{
"input": "Translate into first-order logic: If people enjoy the dining hall meals and recipes, then they spend a lot of their time eating and catching up with friends in the campus dining halls.",
"output": "∀x (DiningHall(x) → Eating(x))"
},
{
"input": "Translate into first-order logic: If Mary works in student jobs on campus and needs to earn money to help pay for her college tuition, then Mary is neither picky nor needs to earn money to help pay for her college tuition.",
"output": "StudentJobs(mary) ∧ Tuition(mary) → ¬(NotPicky(mary) ∨ Tuition(mary))"
},
{
"input": "Translate into first-order logic: Mary is not a picky eater and spends a lot of her time eating and catching up with friends in the campus dining halls.",
"output": "NotPicky(mary) ∧ Eating(mary)"
},
{
"input": "Translate into first-order logic: If people work in student jobs on campus, then they need to earn money to help pay for their college tuition.",
"output": "∀x (StudentJobs(x) → Tuition(x))"
},
{
"input": "Translate into first-order logic: If people order takeout frequently in college, then they work in student jobs on campus.",
"output": "∀x (Takeout(x) → StudentJobs(x))"
},
{
"input": "Translate into first-order logic: People either order takeout frequently in college or enjoy the dining hall meals and recipes.",
"output": "∀x (Takeout(x) ∨ DiningHall(x))"
},
{
"input": "Translate into first-order logic: If people enjoy the dining hall meals and recipes, then they are not picky eaters.",
"output": "∀x (DiningHall(x) → NotPicky(x))"
},
{
"input": "Translate into first-order logic: If people enjoy the dining hall meals and recipes, then they spend a lot of their time eating and catching up with friends in the campus dining halls.",
"output": "∀x (DiningHall(x) → Eating(x))"
},
{
"input": "Translate into first-order logic: If Mary works in student jobs on campus and needs to earn money to help pay for her college tuition, then Mary is neither picky nor needs to earn money to help pay for her college tuition.",
"output": "StudentJobs(mary) ∧ Tuition(mary) → ¬(NotPicky(mary) ∨ Tuition(mary))"
},
{
"input": "Translate into first-order logic: Mary either is not a picky eater or, if she is, then she spends a lot of her time eating and catching up with friends in the campus dining halls.",
"output": "NotPicky(mary) ⊕ Eating(mary)"
},
{
"input": "Translate into first-order logic: No bakery is spicy.",
"output": "∀x (Bakery(x) → ¬Spicy(x))"
},
{
"input": "Translate into first-order logic: All cupcakes are bakeries.",
"output": "∀x (Cupcakes(x) → Bakery(x))"
},
{
"input": "Translate into first-order logic: All hotpots are spicy.",
"output": "∀x (Hotpot(x) → Spicy(x))"
},
{
"input": "Translate into first-order logic: All products of Baked by Melissa are cupcakes.",
"output": "∀x (ProductsOfBakedByMelissa(x) → Cupcakes(x))"
},
{
"input": "Translate into first-order logic: If dried Thai chilies are spicy or a bakery, then dried Thai chilies are a hotpot or are spicy.",
"output": "Spicy(driedThaiChilies) ∨ Bakery(driedThaiChilies) → Hotpot(driedThaiChilies) ∨ Spicy(driedThaiChilies)"
},
{
"input": "Translate into first-order logic: Dried Thai chilies are a product of Baked by Melissa.",
"output": "ProductsOfBakedByMelissa(driedThaiChilies)"
},
{
"input": "Translate into first-order logic: No bakery is spicy.",
"output": "∀x (Bakery(x) → ¬Spicy(x))"
},
{
"input": "Translate into first-order logic: All cupcakes are bakeries.",
"output": "∀x (Cupcakes(x) → Bakery(x))"
},
{
"input": "Translate into first-order logic: All hotpots are spicy.",
"output": "∀x (Hotpot(x) → Spicy(x))"
},
{
"input": "Translate into first-order logic: All products of Baked by Melissa are cupcakes.",
"output": "∀x (ProductsOfBakedByMelissa(x) → Cupcakes(x))"
},
{
"input": "Translate into first-order logic: If dried Thai chilies are spicy or a bakery, then dried Thai chilies are a hotpot or are spicy.",
"output": "Spicy(driedThaiChilies) ∨ Bakery(driedThaiChilies) → Hotpot(driedThaiChilies) ∨ Spicy(driedThaiChilies)"
},
{
"input": "Translate into first-order logic: Dried Thai chilies are not a product of Baked by Melissa.",
"output": "¬ProductsOfBakedByMelissa(driedThaiChilies)"
},
{
"input": "Translate into first-order logic: No bakery is spicy.",
"output": "∀x (Bakery(x) → ¬Spicy(x))"
},
{
"input": "Translate into first-order logic: All cupcakes are bakeries.",
"output": "∀x (Cupcakes(x) → Bakery(x))"
},
{
"input": "Translate into first-order logic: All hotpots are spicy.",
"output": "∀x (Hotpot(x) → Spicy(x))"
},
{
"input": "Translate into first-order logic: All products of Baked by Melissa are cupcakes.",
"output": "∀x (ProductsOfBakedByMelissa(x) → Cupcakes(x))"
},
{
"input": "Translate into first-order logic: If dried Thai chilies are spicy or a bakery, then dried Thai chilies are a hotpot or are spicy.",
"output": "Spicy(driedThaiChilies) ∨ Bakery(driedThaiChilies) → Hotpot(driedThaiChilies) ∨ Spicy(driedThaiChilies)"
},
{
"input": "Translate into first-order logic: Dried Thai chilies are a hotpot.",
"output": "Hotpot(driedThaiChilies)"
},
{
"input": "Translate into first-order logic: No bakery is spicy.",
"output": "∀x (Bakery(x) → ¬Spicy(x))"
},
{
"input": "Translate into first-order logic: All cupcakes are bakeries.",
"output": "∀x (Cupcakes(x) → Bakery(x))"
},
{
"input": "Translate into first-order logic: All hotpots are spicy.",
"output": "∀x (Hotpot(x) → Spicy(x))"
},
{
"input": "Translate into first-order logic: All products of Baked by Melissa are cupcakes.",
"output": "∀x (ProductsOfBakedByMelissa(x) → Cupcakes(x))"
},
{
"input": "Translate into first-order logic: If dried Thai chilies are spicy or a bakery, then dried Thai chilies are a hotpot or are spicy.",
"output": "Spicy(driedThaiChilies) ∨ Bakery(driedThaiChilies) → Hotpot(driedThaiChilies) ∨ Spicy(driedThaiChilies)"
},
{
"input": "Translate into first-order logic: Dried Thai chilies are neither a product of Baked by Melissa nor a bakery.",
"output": "¬ProductsOfBakedByMelissa(driedThaiChilies) ∧ ¬Bakery(driedThaiChilies)"
},
{
"input": "Translate into first-order logic: No bakery is spicy.",
"output": "∀x (Bakery(x) → ¬Spicy(x))"
},
{
"input": "Translate into first-order logic: All cupcakes are bakeries.",
"output": "∀x (Cupcakes(x) → Bakery(x))"
},
{
"input": "Translate into first-order logic: All hotpots are spicy.",
"output": "∀x (Hotpot(x) → Spicy(x))"
},
{
"input": "Translate into first-order logic: All products of Baked by Melissa are cupcakes.",
"output": "∀x (ProductsOfBakedByMelissa(x) → Cupcakes(x))"
},
{
"input": "Translate into first-order logic: If dried Thai chilies are spicy or a bakery, then dried Thai chilies are a hotpot or are spicy.",
"output": "Spicy(driedThaiChilies) ∨ Bakery(driedThaiChilies) → Hotpot(driedThaiChilies) ∨ Spicy(driedThaiChilies)"
},
{
"input": "Translate into first-order logic: Dried Thai chilies are cupcakes and a product of Baked by Melissa.",
"output": "Cupcake(driedThaiChilies) ∧ ProductsOfBakedByMelissa(driedThaiChilies)"
},
{
"input": "Translate into first-order logic: If the restaurant is listed in Yelp’s recommendations, then the restaurant does not receive many negative reviews.",
"output": "∀x (YelpRecommendation(x) → ¬NegativeReview(x))"
},
{
"input": "Translate into first-order logic: All restaurants with a rating greater than 9 are listed in Yelp’s recommendations.",
"output": "∀x (RatingGreaterThan9(x) → YelpRecommendation(x))"
},
{
"input": "Translate into first-order logic: Some restaurants that do not provide take-out service receive many negative reviews.",
"output": "∃x (NoTakeOutService(x) ∧ NegativeReview(x))"
},
{
"input": "Translate into first-order logic: All restaurants that are popular among local residents have ratings greater than 9.",
"output": "∀x (PopularAmongLocalResidents(x) → RatingGreaterThan9(x))"
},
{
"input": "Translate into first-order logic: Subway has a rating greater than 9 or is popular among local residents.",
"output": "RatingGreaterThan9(subway) ⊕ PopularAmongLocalResidents(subway)"
},
{
"input": "Translate into first-order logic: If Subway provides take-out service and receives many negative reviews, then its rating is greater than 9 and it does not provide take-out service.",
"output": "NoTakeOutService(subway)"
},
{
"input": "Translate into first-order logic: If the restaurant is listed in Yelp’s recommendations, then the restaurant does not receive many negative reviews.",
"output": "∀x (YelpRecommendation(x) → ¬NegativeReview(x))"
},
{
"input": "Translate into first-order logic: All restaurants with a rating greater than 9 are listed in Yelp’s recommendations.",
"output": "∀x (RatingGreaterThan9(x) → YelpRecommendation(x))"
},
{
"input": "Translate into first-order logic: Some restaurants that do not provide take-out service receive many negative reviews.",
"output": "∃x (NoTakeOutService(x) ∧ NegativeReview(x))"
},
{
"input": "Translate into first-order logic: All restaurants that are popular among local residents have ratings greater than 9.",
"output": "∀x (PopularAmongLocalResidents(x) → RatingGreaterThan9(x))"
},
{
"input": "Translate into first-order logic: Subway has a rating greater than 9 or is popular among local residents.",
"output": "RatingGreaterThan9(subway) ⊕ PopularAmongLocalResidents(subway)"
},
{
"input": "Translate into first-order logic: Subway provides take-out service and does not receive many negative reviews.",
"output": "¬(NoTakeOutService(subway) ∧ NegativeReview(subway))"
},
{
"input": "Translate into first-order logic: If the restaurant is listed in Yelp’s recommendations, then the restaurant does not receive many negative reviews.",
"output": "∀x (YelpRecommendation(x) → ¬NegativeReview(x))"
},
{
"input": "Translate into first-order logic: All restaurants with a rating greater than 9 are listed in Yelp’s recommendations.",
"output": "∀x (RatingGreaterThan9(x) → YelpRecommendation(x))"
},
{
"input": "Translate into first-order logic: Some restaurants that do not provide take-out service receive many negative reviews.",
"output": "∃x (NoTakeOutService(x) ∧ NegativeReview(x))"
},
{
"input": "Translate into first-order logic: All restaurants that are popular among local residents have ratings greater than 9.",
"output": "∀x (PopularAmongLocalResidents(x) → RatingGreaterThan9(x))"
},
{
"input": "Translate into first-order logic: Subway has a rating greater than 9 or is popular among local residents.",
"output": "RatingGreaterThan9(subway) ⊕ PopularAmongLocalResidents(subway)"
},
{
"input": "Translate into first-order logic: Subway does not provide take-out service.",
"output": "¬(NoTakeOutService(subway) ∧ NegativeReview(subway)) → PopularAmongLocalResidents(subway) ∧ NoTakeOutService(subway)"
},
{
"input": "Translate into first-order logic: In superhero movies, the good guys always win.",
"output": "∀x ∀y (SuperheroMovie(x) ∧ GoodGuy(y) ∧ AppearsIn(y, x) → Wins(y))"
},
{
"input": "Translate into first-order logic: The Surprising Adventures of Sir Digby Chicken Caesar is a superhero movie.",
"output": "SuperheroMovie(surprisingAdventuresofSirDigbyChickenCaesar)"
},
{
"input": "Translate into first-order logic: Good guys fight bad guys and vice versa.",
"output": "∀x ∀y (GoodGuy(x) ∧ Fights(x, y) ⟷ BadGuy(y) ∧ Fights(y, x))"
},
{
"input": "Translate into first-order logic: Sir Digby fights his nemesis.",
"output": "Fights(sirDigby, sirDigbyNemesis)"
},
{
"input": "Translate into first-order logic: If a superhero movie is named after a character, that character is a good guy.",
"output": "∀x ∀y (SuperheroMovie(x), NamedAfter(x, y) → GoodGuy(y))"
},
{
"input": "Translate into first-order logic: The Surprising Adventures of Sir Digby Chicken Caesar is named after Sir Digby.",
"output": "NamedAfter(surprisingAdventuresofSirDigbyChickenCaesar, sirDigby)"
},
{
"input": "Translate into first-order logic: If somebody wins a fight, the person they are fighting loses.",
"output": "∀x ∀y (Fights(x, y) ∧ Wins(x) → ¬Wins(y))"
},
{
"input": "Translate into first-order logic: Sir Digby’s nemesis loses.",
"output": "∀x ∀y (SuperheroMovie(x) ∧ AppearsIn(y, x) → GoodGuy(y))"
},
{
"input": "Translate into first-order logic: [BG] Books contain tons of knowledge.",
"output": "∀x (Book(x) → Knowledge(x))"
},
{
"input": "Translate into first-order logic: [BG] When a person reads a book, that person gains knowledge.",
"output": "∀x ∀y (ReadBook(x, y) → GainKnowledge(x))"
},
{
"input": "Translate into first-order logic: [BG] If a person gains knowledge, they become smarter.",
"output": "∀x (GainKnowledge(x) → Smarter(x))"
},
{
"input": "Translate into first-order logic: Harry read the book “Walden” by Henry Thoreau.",
"output": "ReadBook(harry, walden) ∧ Book(walden)"
},
{
"input": "Translate into first-order logic: Walden contains knowledge.",
"output": "Knowledge(walden)"
},
{
"input": "Translate into first-order logic: [BG] Books contain tons of knowledge.",
"output": "∀x (Book(x) → Knowledge(x))"
},
{
"input": "Translate into first-order logic: [BG] When a person reads a book, that person gains knowledge.",
"output": "∀x ∀y (ReadBook(x, y) → GainKnowledge(x))"
},
{
"input": "Translate into first-order logic: [BG] If a person gains knowledge, they become smarter.",
"output": "∀x (GainKnowledge(x) → Smarter(x))"
},
{
"input": "Translate into first-order logic: Harry read the book “Walden” by Henry Thoreau.",
"output": "ReadBook(harry, walden) ∧ Book(walden)"
},
{
"input": "Translate into first-order logic: Harry is smarter than before.",
"output": "Smarter(harry)"
},
{
"input": "Translate into first-order logic: [BG] Books contain tons of knowledge.",
"output": "∀x (Book(x) → Knowledge(x))"
},
{
"input": "Translate into first-order logic: [BG] When a person reads a book, that person gains knowledge.",
"output": "∀x ∀y (ReadBook(x, y) → GainKnowledge(x))"
},
{
"input": "Translate into first-order logic: [BG] If a person gains knowledge, they become smarter.",
"output": "∀x (GainKnowledge(x) → Smarter(x))"
},
{
"input": "Translate into first-order logic: Harry read the book “Walden” by Henry Thoreau.",
"output": "ReadBook(harry, walden) ∧ Book(walden)"
},
{
"input": "Translate into first-order logic: A person who is smarter has gained knowledge.",
"output": "∀x (Smarter(x) → GainKnowledge(x))"
},
{
"input": "Translate into first-order logic: Natural language processing tasks can be categorized as either language generation task or language understanding task.",
"output": "∀x (NLP(x) → NLG(x) ⊕ NLU(x))"
},
{
"input": "Translate into first-order logic: If the output of a natural language processing task is a text sequence, then it is a language generation task.",
"output": "∀x (NLP(x) ∧ OutputSequence(x) → NLG(x))"
},
{
"input": "Translate into first-order logic: Machine translation is a natural language processing task.",
"output": "NLP(machineTranslation)"
},
{
"input": "Translate into first-order logic: The output of machine translation is a text sequence.",
"output": "OutputSequence(machineTranslation)"
},
{
"input": "Translate into first-order logic: Machine translation is a language generation task.",
"output": "NLG(machineTranslation)"
},
{
"input": "Translate into first-order logic: Natural language processing tasks can be categorized as either language generation task or language understanding task.",
"output": "∀x (NLP(x) → NLG(x) ⊕ NLU(x))"
},
{
"input": "Translate into first-order logic: If the output of a natural language processing task is a text sequence, then it is a language generation task.",
"output": "∀x (NLP(x) ∧ OutputSequence(x) → NLG(x))"
},
{
"input": "Translate into first-order logic: Machine translation is a natural language processing task.",
"output": "NLP(machineTranslation)"
},
{
"input": "Translate into first-order logic: The output of machine translation is a text sequence.",
"output": "OutputSequence(machineTranslation)"
},
{
"input": "Translate into first-order logic: Machine translation is a language understanding task.",
"output": "NLU(machineTranslation)"
},
{
"input": "Translate into first-order logic: Pets are allowed in some managed buildings.",
"output": "∃x (ManagedBuilding(x) ∧ AllowPet(x))"
},
{
"input": "Translate into first-order logic: [BG] A deposit is required to rent an apartment in a managed building.",
"output": "∀x (ManagedBuilding(x) → RequireDeposit(x))"
},
{
"input": "Translate into first-order logic: The security deposit can be either equal to one month's rent or more.",
"output": "∀x (Rent2000(x) ↔ ¬DepositNoMoreThan1500(x))"
},
{
"input": "Translate into first-order logic: Fluffy is Tom's cat.",
"output": "∀x (Rent2000(x) ↔ DepositNoLessThan2000(x))"
},
{
"input": "Translate into first-order logic: Cats are pets.",
"output": "Cat(fluffy)"
},
{
"input": "Translate into first-order logic: The Olive Garden is a managed building.",
"output": "∀x (Cat(x) → Pet(x))"
},
{
"input": "Translate into first-order logic: The monthly rent at the Olive Garden is $2000.",
"output": "ManagedBuilding(oliveGarden)"
},
{
"input": "Translate into first-order logic: Tom will rent an apartment in a managed building if and only if he is allowed to move in with Fluffy, and the security deposit is no more than $1500.",
"output": "Rent2000(oliveGarden)"
},
{
"input": "Translate into first-order logic: 2000$ is more than $1500.",
"output": "∀x (TomRent(x) ↔ (ManagedBuilding(x) ∧ AllowPet(x) ∧ DepositNoMoreThan1500(x)))"
},
{
"input": "Translate into first-order logic: Tom will rent an apartment in The Olive Garden.",
"output": "TomRent(oliveGarden)"
},
{
"input": "Translate into first-order logic: Pets are allowed in some managed buildings.",
"output": "∃x (ManagedBuilding(x) ∧ AllowPet(x))"
},
{
"input": "Translate into first-order logic: [BG] A deposit is required to rent an apartment in a managed building.",
"output": "∀x (ManagedBuilding(x) → RequireDeposit(x))"
},
{
"input": "Translate into first-order logic: The security deposit can be either equal to one month's rent or more.",
"output": "∀x (Rent2000(x) ↔ ¬DepositNoMoreThan1500(x))"
},
{
"input": "Translate into first-order logic: Fluffy is Tom's cat.",
"output": "∀x (Rent2000(x) ↔ DepositNoLessThan2000(x))"
},
{
"input": "Translate into first-order logic: Cats are pets.",
"output": "Cat(fluffy)"
},
{
"input": "Translate into first-order logic: The Olive Garden is a managed building.",
"output": "∀x (Cat(x) → Pet(x))"
},
{
"input": "Translate into first-order logic: The monthly rent at the Olive Garden is $2000.",
"output": "ManagedBuilding(oliveGarden)"
},
{
"input": "Translate into first-order logic: Tom will rent an apartment in a managed building if and only if he is allowed to move in with Fluffy, and the security deposit is no more than $1500.",
"output": "Rent2000(oliveGarden)"
},
{
"input": "Translate into first-order logic: 2000$ is more than $1500.",
"output": "∀x (TomRent(x) ↔ (ManagedBuilding(x) ∧ AllowPet(x) ∧ DepositNoMoreThan1500(x)))"
},
{
"input": "Translate into first-order logic: Tom is allowed to move in an apartment in The Olive Garden with Fluffy.",
"output": "AllowPet(oliveGarden)"
},
{
"input": "Translate into first-order logic: Pets are allowed in some managed buildings.",
"output": "∃x (ManagedBuilding(x) ∧ AllowPet(x))"
},
{
"input": "Translate into first-order logic: [BG] A deposit is required to rent an apartment in a managed building.",
"output": "∀x (ManagedBuilding(x) → RequireDeposit(x))"
},
{
"input": "Translate into first-order logic: The security deposit can be either equal to one month's rent or more.",
"output": "∀x (Rent2000(x) ↔ ¬DepositNoMoreThan1500(x))"
},
{
"input": "Translate into first-order logic: Fluffy is Tom's cat.",
"output": "∀x (Rent2000(x) ↔ DepositNoLessThan2000(x))"
},
{
"input": "Translate into first-order logic: Cats are pets.",
"output": "Cat(fluffy)"
},
{
"input": "Translate into first-order logic: The Olive Garden is a managed building.",
"output": "∀x (Cat(x) → Pet(x))"
},
{
"input": "Translate into first-order logic: The monthly rent at the Olive Garden is $2000.",
"output": "ManagedBuilding(oliveGarden)"
},
{
"input": "Translate into first-order logic: Tom will rent an apartment in a managed building if and only if he is allowed to move in with Fluffy, and the security deposit is no more than $1500.",
"output": "Rent2000(oliveGarden)"
},
{
"input": "Translate into first-order logic: 2000$ is more than $1500.",
"output": "∀x (TomRent(x) ↔ (ManagedBuilding(x) ∧ AllowPet(x) ∧ DepositNoMoreThan1500(x)))"
},
{
"input": "Translate into first-order logic: The security deposit at the Olive Garden is either $2000 or more.",
"output": "DepositNoLessThan2000(oliveGarden)"
},
{
"input": "Translate into first-order logic: If animals are loved by tourists, then they are Max's favorite animals.",
"output": "∀x (AnimalsLovedByTourists(x) → MaxFavoriteAnimals(x))"
},
{
"input": "Translate into first-order logic: All animals from Australia are loved by tourists.",
"output": " ∀x (AnimalsFromAustralia(x) → AnimalsLovedByTourists(x))"
},
{
"input": "Translate into first-order logic: All quokka are animals from Australia.",
"output": " ∀x (Quokka(x) → AnimalsFromAustralia(x))"
},
{
"input": "Translate into first-order logic: All of Max's favorite animals are very fluffy.",
"output": " ∀x (MaxFavoriteAnimals(x) → VeryFluffy(x)) "
},
{
"input": "Translate into first-order logic: All of Max's favorite animals love to sleep.",
"output": " ∀x (MaxFavoriteAnimals(x) → LoveToSleep(x))"
},
{
"input": "Translate into first-order logic: If a koala is very fluffy, then the koala is not a quokka.",
"output": " VeryFluffy(koala) → ¬Quokka(koala)"
},
{
"input": "Translate into first-order logic: Koalas love to sleep.",
"output": "LoveToSleep(koala)"
},
{
"input": "Translate into first-order logic: If animals are loved by tourists, then they are Max's favorite animals.",
"output": "∀x (AnimalsLovedByTourists(x) → MaxFavoriteAnimals(x))"
},
{
"input": "Translate into first-order logic: All animals from Australia are loved by tourists.",
"output": " ∀x (AnimalsFromAustralia(x) → AnimalsLovedByTourists(x))"
},
{
"input": "Translate into first-order logic: All quokka are animals from Australia.",
"output": " ∀x (Quokka(x) → AnimalsFromAustralia(x))"
},
{
"input": "Translate into first-order logic: All of Max's favorite animals are very fluffy.",
"output": " ∀x (MaxFavoriteAnimals(x) → VeryFluffy(x)) "
},
{
"input": "Translate into first-order logic: All of Max's favorite animals love to sleep.",
"output": " ∀x (MaxFavoriteAnimals(x) → LoveToSleep(x))"
},
{
"input": "Translate into first-order logic: If a koala is very fluffy, then the koala is not a quokka.",
"output": " VeryFluffy(koala) → ¬Quokka(koala)"
},
{
"input": "Translate into first-order logic: Koalas love to sleep and are quokka.",
"output": "LoveToSleep(koala) ∧ Quokka(koala)"
},
{
"input": "Translate into first-order logic: If animals are loved by tourists, then they are Max's favorite animals.",
"output": "∀x (AnimalsLovedByTourists(x) → MaxFavoriteAnimals(x))"
},
{
"input": "Translate into first-order logic: All animals from Australia are loved by tourists.",
"output": " ∀x (AnimalsFromAustralia(x) → AnimalsLovedByTourists(x))"
},
{
"input": "Translate into first-order logic: All quokka are animals from Australia.",
"output": " ∀x (Quokka(x) → AnimalsFromAustralia(x))"
},
{
"input": "Translate into first-order logic: All of Max's favorite animals are very fluffy.",
"output": " ∀x (MaxFavoriteAnimals(x) → VeryFluffy(x)) "
},
{
"input": "Translate into first-order logic: All of Max's favorite animals love to sleep.",
"output": " ∀x (MaxFavoriteAnimals(x) → LoveToSleep(x))"
},
{
"input": "Translate into first-order logic: If a koala is very fluffy, then the koala is not a quokka.",
"output": " VeryFluffy(koala) → ¬Quokka(koala)"
},
{
"input": "Translate into first-order logic: If a koala is a quokka, then the koala either loves to sleep or is very fluffy.",
"output": "Quokka(koala) → LoveToSleep(koala) ⊕ VeryFluffy(koala)"
},
{
"input": "Translate into first-order logic: A man is either kind or evil.",
"output": "∀x (Kind(x) ⊕ Evil(x))"
},
{
"input": "Translate into first-order logic: No ugly person is handsome.",
"output": "∀x (Ugly(x) → ¬Handsome(x))"
},
{
"input": "Translate into first-order logic: All evil people are ugly.",
"output": "∀x (Evil(x) → Ugly(x))"
},
{
"input": "Translate into first-order logic: All gentlemen are handsome.",
"output": "∀x (Gentleman(x) → Handsome(x))"
},
{
"input": "Translate into first-order logic: All CEOs are gentlemen.",
"output": "∀x (CEO(x) → Gentleman(x))"
},
{
"input": "Translate into first-order logic: Harry is a gentleman.",
"output": "Gentleman(harry)"
},
{
"input": "Translate into first-order logic: Harry is a CEO.",
"output": "CEO(harry)"
},
{
"input": "Translate into first-order logic: A man is either kind or evil.",
"output": "∀x (Kind(x) ⊕ Evil(x))"
},
{
"input": "Translate into first-order logic: No ugly person is handsome.",
"output": "∀x (Ugly(x) → ¬Handsome(x))"
},
{
"input": "Translate into first-order logic: All evil people are ugly.",
"output": "∀x (Evil(x) → Ugly(x))"
},
{
"input": "Translate into first-order logic: All gentlemen are handsome.",
"output": "∀x (Gentleman(x) → Handsome(x))"
},
{
"input": "Translate into first-order logic: All CEOs are gentlemen.",
"output": "∀x (CEO(x) → Gentleman(x))"
},
{
"input": "Translate into first-order logic: Harry is a gentleman.",
"output": "Gentleman(harry)"
},
{
"input": "Translate into first-order logic: Harry is kind or a CEO.",
"output": "Kind(harry) ∨ CEO(harry)"
},
{
"input": "Translate into first-order logic: A man is either kind or evil.",
"output": "∀x (Kind(x) ⊕ Evil(x))"
},
{
"input": "Translate into first-order logic: No ugly person is handsome.",
"output": "∀x (Ugly(x) → ¬Handsome(x))"
},
{
"input": "Translate into first-order logic: All evil people are ugly.",
"output": "∀x (Evil(x) → Ugly(x))"
},
{
"input": "Translate into first-order logic: All gentlemen are handsome.",
"output": "∀x (Gentleman(x) → Handsome(x))"
},
{
"input": "Translate into first-order logic: All CEOs are gentlemen.",
"output": "∀x (CEO(x) → Gentleman(x))"
},
{
"input": "Translate into first-order logic: Harry is a gentleman.",
"output": "Gentleman(harry)"
},
{
"input": "Translate into first-order logic: If Harry is either both evil and ugly, or neither evil nor ugly, then Harry is neither kind nor a CEO.",
"output": "(Evil(harry) ∧ Ugly(harry)) ⊕ (¬Evil(harry) ∧ ¬Ugly(harry)) → ¬Kind(harry) ∧ ¬CEO(harry)"
},
{
"input": "Translate into first-order logic: If people are twins or triplets, then they spend a lot of time hanging out with and playing with their siblings.",
"output": "∀x (TwinTriplet(x) → Playing(x))"
},
{
"input": "Translate into first-order logic: If people have siblings who are the same age, then they are twins or triplets.",
"output": "∀x (SameAge(x) → TwinTriplet(x))"
},
{
"input": "Translate into first-order logic: If people complain often about annoying siblings, then they have siblings who are the same age.",
"output": "∀x (Complain(x) → SameAge(x))"
},
{
"input": "Translate into first-order logic: If people do not live at home regularly, then they do not develop strong bonds with their family members.",
"output": "∀x (NotHome(x) → ¬StrongBonds(x))"
},
{
"input": "Translate into first-order logic: If people spend a lot of time hanging out with and playing with their siblings, then they often did not live at home regularly.",
"output": "∀x (Playing(x) → NotHome(x))"
},
{
"input": "Translate into first-order logic: Luke is either both a twin or triplet and develops strong bonds with his family members, or he neither is a twin or triplet nor develops strong bonds with his family members.",
"output": "(TwinTriplet(luke) ∧ StrongBonds(luke)) ⊕ (¬TwinTriplet(luke) ∧ ¬StrongBonds(luke))"
},
{
"input": "Translate into first-order logic: Luke spends a lot of time hanging out and playing with his siblings.",
"output": "Playing(luke)"
},
{
"input": "Translate into first-order logic: If people are twins or triplets, then they spend a lot of time hanging out with and playing with their siblings.",
"output": "∀x (TwinTriplet(x) → Playing(x))"
},
{
"input": "Translate into first-order logic: If people have siblings who are the same age, then they are twins or triplets.",
"output": "∀x (SameAge(x) → TwinTriplet(x))"
},
{
"input": "Translate into first-order logic: If people complain often about annoying siblings, then they have siblings who are the same age.",
"output": "∀x (Complain(x) → SameAge(x))"
},
{
"input": "Translate into first-order logic: If people do not live at home regularly, then they do not develop strong bonds with their family members.",
"output": "∀x (NotHome(x) → ¬StrongBonds(x))"
},
{
"input": "Translate into first-order logic: If people spend a lot of time hanging out with and playing with their siblings, then they often did not live at home regularly.",
"output": "∀x (Playing(x) → NotHome(x))"
},
{
"input": "Translate into first-order logic: Luke is either both a twin or triplet and develops strong bonds with his family members, or he neither is a twin or triplet nor develops strong bonds with his family members.",
"output": "(TwinTriplet(luke) ∧ StrongBonds(luke)) ⊕ (¬TwinTriplet(luke) ∧ ¬StrongBonds(luke))"
},
{
"input": "Translate into first-order logic: Luke complains often about annoying siblings.",
"output": "Complain(luke)"
},
{
"input": "Translate into first-order logic: If people are twins or triplets, then they spend a lot of time hanging out with and playing with their siblings.",
"output": "∀x (TwinTriplet(x) → Playing(x))"
},
{
"input": "Translate into first-order logic: If people have siblings who are the same age, then they are twins or triplets.",
"output": "∀x (SameAge(x) → TwinTriplet(x))"
},
{
"input": "Translate into first-order logic: If people complain often about annoying siblings, then they have siblings who are the same age.",
"output": "∀x (Complain(x) → SameAge(x))"
},
{
"input": "Translate into first-order logic: If people do not live at home regularly, then they do not develop strong bonds with their family members.",
"output": "∀x (NotHome(x) → ¬StrongBonds(x))"
},
{
"input": "Translate into first-order logic: If people spend a lot of time hanging out with and playing with their siblings, then they often did not live at home regularly.",
"output": "∀x (Playing(x) → NotHome(x))"
},
{
"input": "Translate into first-order logic: Luke is either both a twin or triplet and develops strong bonds with his family members, or he neither is a twin or triplet nor develops strong bonds with his family members.",
"output": "(TwinTriplet(luke) ∧ StrongBonds(luke)) ⊕ (¬TwinTriplet(luke) ∧ ¬StrongBonds(luke))"
},
{
"input": "Translate into first-order logic: Luke is neither a twin nor triplet nor complains often about annoying siblings.",
"output": "¬(TwinTriplet(luke) ∨ Complain(luke))"
},
{
"input": "Translate into first-order logic: It costs US $205 to take the GRE test.",
"output": "Cost205(gre)"
},
{
"input": "Translate into first-order logic: ETS provides financial aid to those GRE applicants who prove economic hardship.",
"output": "∀x (Cost205(x) → CostBelow300(x))"
},
{
"input": "Translate into first-order logic: Economic hardship refers to difficulty caused by having too little money or too few resources.",
"output": "∀x (Hardship(x) → FinancialAid(x))"
},
{
"input": "Translate into first-order logic: Tom lives in a single-parent family.",
"output": "∀x (SingleParent(x) ∨ FewResources(x) → Hardship(x))"
},
{
"input": "Translate into first-order logic: His dad has been out of work for more than a year.",
"output": "SingleParent(tom)"
},
{
"input": "Translate into first-order logic: Tom can apply for financial aid from ETS to take the GRE test.",
"output": "FinancialAid(tom)"
},
{
"input": "Translate into first-order logic: It costs US $205 to take the GRE test.",
"output": "Cost205(gre)"
},
{
"input": "Translate into first-order logic: ETS provides financial aid to those GRE applicants who prove economic hardship.",
"output": "∀x (Cost205(x) → CostBelow300(x))"
},
{
"input": "Translate into first-order logic: Economic hardship refers to difficulty caused by having too little money or too few resources.",
"output": "∀x (Hardship(x) → FinancialAid(x))"
},
{
"input": "Translate into first-order logic: Tom lives in a single-parent family.",
"output": "∀x (SingleParent(x) ∨ FewResources(x) → Hardship(x))"
},
{
"input": "Translate into first-order logic: His dad has been out of work for more than a year.",
"output": "SingleParent(tom)"
},
{
"input": "Translate into first-order logic: It cost below US $300 to take the GRE test.",
"output": "CostBelow300(gre)"
},
{
"input": "Translate into first-order logic: It costs US $205 to take the GRE test.",
"output": "Cost205(gre)"
},
{
"input": "Translate into first-order logic: ETS provides financial aid to those GRE applicants who prove economic hardship.",
"output": "∀x (Cost205(x) → CostBelow300(x))"
},
{
"input": "Translate into first-order logic: Economic hardship refers to difficulty caused by having too little money or too few resources.",
"output": "∀x (Hardship(x) → FinancialAid(x))"
},
{
"input": "Translate into first-order logic: Tom lives in a single-parent family.",
"output": "∀x (SingleParent(x) ∨ FewResources(x) → Hardship(x))"
},
{
"input": "Translate into first-order logic: His dad has been out of work for more than a year.",
"output": "SingleParent(tom)"
},
{
"input": "Translate into first-order logic: There is no financial aid available for the GRE test.",
"output": "¬(∃x (FinancialAid(x)))"
},
{
"input": "Translate into first-order logic: If people spill a lot of food on their clothing, then they do not tidy their spaces consistently and enjoy the process of cleaning.",
"output": "∀x (Spill(x) → ¬Tidy(x))"
},
{
"input": "Translate into first-order logic: All foodies who go out frequently to find new food restaurants to try are people who spill a lot of food on their clothing.",
"output": "∀x (Foodie(x) → Spill(x))"
},
{
"input": "Translate into first-order logic: If people grew up as only children with no siblings, then they tidy their spaces consistently and enjoy the process of cleaning.",
"output": "∀x (OnlyChild(x) → Tidy(x))"
},
{
"input": "Translate into first-order logic: If people have parents who are very busy with their regular jobs, then they grew up as only children with no siblings.",
"output": "∀x (BusyParents(x) → OnlyChild(x))"
},
{
"input": "Translate into first-order logic: All households with a high net income have people who have parents who are very busy with their regular jobs.",
"output": "∀x (HighIncome(x) → BusyParents(x))"
},
{
"input": "Translate into first-order logic: Peter is either both a person who spills a lot of food on his clothing and grew up as an only child with no siblings, or he is neither a person who spills a lot of food on his clothing nor grew up as an only child with no siblings.",
"output": "(Spill(peter) ∧ OnlyChild(peter)) ∨ ¬Spill(peter) ∧ ¬OnlyChild(peter))"
},
{
"input": "Translate into first-order logic: Peter tidies his space consistently and enjoys the process of cleaning.",
"output": "Tidy(peter)"
},
{
"input": "Translate into first-order logic: If people spill a lot of food on their clothing, then they do not tidy their spaces consistently and enjoy the process of cleaning.",
"output": "∀x (Spill(x) → ¬Tidy(x))"
},
{
"input": "Translate into first-order logic: All foodies who go out frequently to find new food restaurants to try are people who spill a lot of food on their clothing.",
"output": "∀x (Foodie(x) → Spill(x))"
},
{
"input": "Translate into first-order logic: If people grew up as only children with no siblings, then they tidy their spaces consistently and enjoy the process of cleaning.",
"output": "∀x (OnlyChild(x) → Tidy(x))"
},
{
"input": "Translate into first-order logic: If people have parents who are very busy with their regular jobs, then they grew up as only children with no siblings.",
"output": "∀x (BusyParents(x) → OnlyChild(x))"
},
{
"input": "Translate into first-order logic: All households with a high net income have people who have parents who are very busy with their regular jobs.",
"output": "∀x (HighIncome(x) → BusyParents(x))"
},
{
"input": "Translate into first-order logic: Peter is either both a person who spills a lot of food on his clothing and grew up as an only child with no siblings, or he is neither a person who spills a lot of food on his clothing nor grew up as an only child with no siblings.",
"output": "(Spill(peter) ∧ OnlyChild(peter)) ∨ ¬Spill(peter) ∧ ¬OnlyChild(peter))"
},
{
"input": "Translate into first-order logic: Peter is either a foodie who goes out frequently to find new food restaurants to try or belongs to a household with a high net income.",
"output": "Foodie(peter) ∨ HighIncome(peter)"
},
{
"input": "Translate into first-order logic: If people spill a lot of food on their clothing, then they do not tidy their spaces consistently and enjoy the process of cleaning.",
"output": "∀x (Spill(x) → ¬Tidy(x))"
},
{
"input": "Translate into first-order logic: All foodies who go out frequently to find new food restaurants to try are people who spill a lot of food on their clothing.",
"output": "∀x (Foodie(x) → Spill(x))"
},
{
"input": "Translate into first-order logic: If people grew up as only children with no siblings, then they tidy their spaces consistently and enjoy the process of cleaning.",
"output": "∀x (OnlyChild(x) → Tidy(x))"
},
{
"input": "Translate into first-order logic: If people have parents who are very busy with their regular jobs, then they grew up as only children with no siblings.",
"output": "∀x (BusyParents(x) → OnlyChild(x))"
},
{
"input": "Translate into first-order logic: All households with a high net income have people who have parents who are very busy with their regular jobs.",
"output": "∀x (HighIncome(x) → BusyParents(x))"
},
{
"input": "Translate into first-order logic: Peter is either both a person who spills a lot of food on his clothing and grew up as an only child with no siblings, or he is neither a person who spills a lot of food on his clothing nor grew up as an only child with no siblings.",
"output": "(Spill(peter) ∧ OnlyChild(peter)) ∨ ¬Spill(peter) ∧ ¬OnlyChild(peter))"
},
{
"input": "Translate into first-order logic: Peter is either a foodie who goes out frequently to find new food restaurants to try and belong to a household with a high net income or he is a foodie who goes out frequently to find new food restaurants to try nor belongs to a household with a high net income.",
"output": "(Foodie(peter) ∧ HighIncome(peter)) ∨ ¬Foodie(peter) ∧ ¬HighIncome(peter))"
},
{
"input": "Translate into first-order logic: All fir trees are evergreens.",
"output": "∀x (FirTree(x) → Evergreen(x))"
},
{
"input": "Translate into first-order logic: Some objects of worship are fir trees.",
"output": "∃x (ObjectOfWorship(x) ∧ FirTree(x))"
},
{
"input": "Translate into first-order logic: Some evergreens are not objects of worship.",
"output": "∃x (Evergreen(x) ∧ ¬ObjectOfWorship(x))"
},
{
"input": "Translate into first-order logic: The Picuris Mountains are a mountain range in New Mexico or Texas.",
"output": "MountainRange(picurismountains) ∧ In(picurismountains, newmexico) ∨ In(picurismountains, texas)"
},
{
"input": "Translate into first-order logic: Juan de Onate visited the Picuris Mountains.",
"output": "Visited(juandeonate, picurismountains)"
},
{
"input": "Translate into first-order logic: The Harding Pegmatite Mine, located in the Picuris Mountains, was donated.",
"output": "In(hardingpegmatitemine, picurismountains) ∧ Mine(hardingpegmatitemine) ∧ Donated(hardingpegmatitemine)"
},
{
"input": "Translate into first-order logic: There are no mountain ranges in texas that have mines which have been donated.",
"output": "∀x ∀y (Mine(x) ∧ Donated(x) ∧ In(x, y) ∧ MountainRange(y) → ¬In(y, texas))"
},
{
"input": "Translate into first-order logic: Juan de Onate visited a mountain range in New Mexico.",
"output": "∃x (Visited(juandeonate, x) ∧ MountainRange(x) ∧ In(x, newmexico))"
},
{
"input": "Translate into first-order logic: The Picuris Mountains are a mountain range in New Mexico or Texas.",
"output": "MountainRange(picurismountains) ∧ In(picurismountains, newmexico) ∨ In(picurismountains, texas)"
},
{
"input": "Translate into first-order logic: Juan de Onate visited the Picuris Mountains.",
"output": "Visited(juandeonate, picurismountains)"
},
{
"input": "Translate into first-order logic: The Harding Pegmatite Mine, located in the Picuris Mountains, was donated.",
"output": "In(hardingpegmatitemine, picurismountains) ∧ Mine(hardingpegmatitemine) ∧ Donated(hardingpegmatitemine)"
},
{
"input": "Translate into first-order logic: There are no mountain ranges in texas that have mines which have been donated.",
"output": "∀x ∀y (Mine(x) ∧ Donated(x) ∧ In(x, y) ∧ MountainRange(y) → ¬In(y, texas))"
},
{
"input": "Translate into first-order logic: Juan de Onate visited a mountain range in Texas.",
"output": "∃x (Visited(juandeonate, x) ∧ MountainRange(x) ∧ In(x, texas))"
},
{
"input": "Translate into first-order logic: The Picuris Mountains are a mountain range in New Mexico or Texas.",
"output": "MountainRange(picurismountains) ∧ In(picurismountains, newmexico) ∨ In(picurismountains, texas)"
},
{
"input": "Translate into first-order logic: Juan de Onate visited the Picuris Mountains.",
"output": "Visited(juandeonate, picurismountains)"
},
{
"input": "Translate into first-order logic: The Harding Pegmatite Mine, located in the Picuris Mountains, was donated.",
"output": "In(hardingpegmatitemine, picurismountains) ∧ Mine(hardingpegmatitemine) ∧ Donated(hardingpegmatitemine)"
},
{
"input": "Translate into first-order logic: There are no mountain ranges in texas that have mines which have been donated.",
"output": "∀x ∀y (Mine(x) ∧ Donated(x) ∧ In(x, y) ∧ MountainRange(y) → ¬In(y, texas))"
},
{
"input": "Translate into first-order logic: The Harding Pegmatite Mine is not located in a mountain range in New Mexico.",
"output": "∀x (MountainRange(x) ∧ In(hardingpegmatitemine, x) → ¬In(x, newmexico))"
},
{
"input": "Translate into first-order logic: If a man is taller than another man, the taller one can block the other's shooting.",
"output": "∀x ∀y (IsMan(x) ∧ IsMan(y) ∧ Taller(x, y) → CanBlock(x, y))"
},
{
"input": "Translate into first-order logic: Michael is a man who is taller than everyone else in his class.",
"output": "∀x (IsMan(x) ∧ SameClass(x, michael) ∧ ¬Be(x, michael) → Taller(michael, x))"
},
{
"input": "Translate into first-order logic: If person x is taller than person y, and person y is taller than person z, than x is taller than z",
"output": "∀x ∀y ∀z ((Taller(x, y) ∧ Taller(y, z)) → Taller(x, z))"
},
{
"input": "Translate into first-order logic: Peter is a man who is taller than Michael.",
"output": "IsMan(peter) ∧ Taller(peter, michael)"
},
{
"input": "Translate into first-order logic: Michael can block any shooting from a person as long as the person does not jump when shooting.",
"output": "∀x (¬JumpWhenShooting(x) → CanBlock(michael, x))"
},
{
"input": "Translate into first-order logic: Michael cannot block Windy's shooting.",
"output": "¬CanBlock(michael, windy)"
},
{
"input": "Translate into first-order logic: Every shooter who can jump when shooting is a great shooter.",
"output": "∀x (JumpWhenShooting(x) → GreatShooter(x))"
},
{
"input": "Translate into first-order logic: Peter is shorter than a man in Michael's class.",
"output": "∃x (IsMan(x) ∧ SameClass(x, michael) ∧ ¬Be(x, michael) ∧ ¬Taller(peter, x))"
},
{
"input": "Translate into first-order logic: If a man is taller than another man, the taller one can block the other's shooting.",
"output": "∀x ∀y (IsMan(x) ∧ IsMan(y) ∧ Taller(x, y) → CanBlock(x, y))"
},
{
"input": "Translate into first-order logic: Michael is a man who is taller than everyone else in his class.",
"output": "∀x (IsMan(x) ∧ SameClass(x, michael) ∧ ¬Be(x, michael) → Taller(michael, x))"
},
{
"input": "Translate into first-order logic: If person x is taller than person y, and person y is taller than person z, than x is taller than z",
"output": "∀x ∀y ∀z ((Taller(x, y) ∧ Taller(y, z)) → Taller(x, z))"
},
{
"input": "Translate into first-order logic: Peter is a man who is taller than Michael.",
"output": "IsMan(peter) ∧ Taller(peter, michael)"
},
{
"input": "Translate into first-order logic: Michael can block any shooting from a person as long as the person does not jump when shooting.",
"output": "∀x (¬JumpWhenShooting(x) → CanBlock(michael, x))"
},
{
"input": "Translate into first-order logic: Michael cannot block Windy's shooting.",
"output": "¬CanBlock(michael, windy)"
},
{
"input": "Translate into first-order logic: Every shooter who can jump when shooting is a great shooter.",
"output": "∀x (JumpWhenShooting(x) → GreatShooter(x))"
},
{
"input": "Translate into first-order logic: Windy is a great shooter.",
"output": "GreatShooter(windy)"
},
{
"input": "Translate into first-order logic: If a man is taller than another man, the taller one can block the other's shooting.",
"output": "∀x ∀y (IsMan(x) ∧ IsMan(y) ∧ Taller(x, y) → CanBlock(x, y))"
},
{
"input": "Translate into first-order logic: Michael is a man who is taller than everyone else in his class.",
"output": "∀x (IsMan(x) ∧ SameClass(x, michael) ∧ ¬Be(x, michael) → Taller(michael, x))"
},
{
"input": "Translate into first-order logic: If person x is taller than person y, and person y is taller than person z, than x is taller than z",
"output": "∀x ∀y ∀z ((Taller(x, y) ∧ Taller(y, z)) → Taller(x, z))"
},
{
"input": "Translate into first-order logic: Peter is a man who is taller than Michael.",
"output": "IsMan(peter) ∧ Taller(peter, michael)"
},
{
"input": "Translate into first-order logic: Michael can block any shooting from a person as long as the person does not jump when shooting.",
"output": "∀x (¬JumpWhenShooting(x) → CanBlock(michael, x))"
},
{
"input": "Translate into first-order logic: Michael cannot block Windy's shooting.",
"output": "¬CanBlock(michael, windy)"
},
{
"input": "Translate into first-order logic: Every shooter who can jump when shooting is a great shooter.",
"output": "∀x (JumpWhenShooting(x) → GreatShooter(x))"
},
{
"input": "Translate into first-order logic: Peter can block Windy's shooting.",
"output": "CanBlock(peter, windy)"
},
{
"input": "Translate into first-order logic: Barutin Cove is named after the Bulgarian settlement of Barutin.",
"output": "Cove(barutin) ∧ NameAfter(barutin, settlement) ∧ Locate(settlement, bulgaria)"
},
{
"input": "Translate into first-order logic: Barutin Cove is on the southwest coast of Snow Island.",
"output": "Locate(barutin, snow)"
},
{
"input": "Translate into first-order logic: The South Shetland Islands include Snow Island, Greenwich Island, and Deception Island.",
"output": "Locate(snow, shetland) ∧ Locate(greenwich, shetland) ∧ Locate(deception, shetland)"
},
{
"input": "Translate into first-order logic: The South Shetland Islands are considered part of Antarctica.",
"output": "Locate(shetland, antarctica)"
},
{
"input": "Translate into first-order logic: If A is located in B and B is located in C, then A is located in C.",
"output": "∀x ∀y ∀z ((Locate(x, y) ∧ Locate(y, z)) → Locate(x, z))"
},
{
"input": "Translate into first-order logic: Barutin is named after all islands in Antarctica.",
"output": "∀x (Locate(x, antarctica) → NameAfter(barutin, x))"
},
{
"input": "Translate into first-order logic: Barutin Cove is named after the Bulgarian settlement of Barutin.",
"output": "Cove(barutin) ∧ NameAfter(barutin, settlement) ∧ Locate(settlement, bulgaria)"
},
{
"input": "Translate into first-order logic: Barutin Cove is on the southwest coast of Snow Island.",
"output": "Locate(barutin, snow)"
},
{
"input": "Translate into first-order logic: The South Shetland Islands include Snow Island, Greenwich Island, and Deception Island.",
"output": "Locate(snow, shetland) ∧ Locate(greenwich, shetland) ∧ Locate(deception, shetland)"
},
{
"input": "Translate into first-order logic: The South Shetland Islands are considered part of Antarctica.",
"output": "Locate(shetland, antarctica)"
},
{
"input": "Translate into first-order logic: If A is located in B and B is located in C, then A is located in C.",
"output": "∀x ∀y ∀z ((Locate(x, y) ∧ Locate(y, z)) → Locate(x, z))"
},
{
"input": "Translate into first-order logic: There is at least one cove in Antarctica named after a place in Bulgaria.",
"output": "∃x ∃y (Cove(x) ∧ NameAfter(x, y) ∧ Locate(y, bulgaria))"
},
{
"input": "Translate into first-order logic: Barutin Cove is named after the Bulgarian settlement of Barutin.",
"output": "Cove(barutin) ∧ NameAfter(barutin, settlement) ∧ Locate(settlement, bulgaria)"
},
{
"input": "Translate into first-order logic: Barutin Cove is on the southwest coast of Snow Island.",
"output": "Locate(barutin, snow)"
},
{
"input": "Translate into first-order logic: The South Shetland Islands include Snow Island, Greenwich Island, and Deception Island.",
"output": "Locate(snow, shetland) ∧ Locate(greenwich, shetland) ∧ Locate(deception, shetland)"
},
{
"input": "Translate into first-order logic: The South Shetland Islands are considered part of Antarctica.",
"output": "Locate(shetland, antarctica)"
},
{
"input": "Translate into first-order logic: If A is located in B and B is located in C, then A is located in C.",
"output": "∀x ∀y ∀z ((Locate(x, y) ∧ Locate(y, z)) → Locate(x, z))"
},
{
"input": "Translate into first-order logic: Barutin is not located in Antarctica.",
"output": "¬Locate(barutin, antarctica)"
},
{
"input": "Translate into first-order logic: Some affection is love.",
"output": "∃x (Affection(x) ∧ Love(x))"
},
{
"input": "Translate into first-order logic: Some love is positive.",
"output": "∃x (Love(x) ∧ Positive(x))"
},
{
"input": "Translate into first-order logic: Some affection is positive.",
"output": "∃x (Affection(x) ∧ Positive(x))"
},
{
"input": "Translate into first-order logic: If something can transport multiple passengers, then they are not empty.",
"output": "∀x (TransportMultiplePassengers(x) → ¬Empty(x))"
},
{
"input": "Translate into first-order logic: All airlines can transport multiple passengers.",
"output": "∀x (Airline(x) → TransportMultiplePassengers(x))"
},
{
"input": "Translate into first-order logic: All planes are empty.",
"output": "∀x (Plane(x) → Empty(x))"
},
{
"input": "Translate into first-order logic: All Boeing 707s are planes.",
"output": "∀x (Boeing707(x) → Plane(x))"
},
{
"input": "Translate into first-order logic: If Greyhound is not an airline, then there are no Greyhound planes.",
"output": "¬Airline(greyhound) → ¬(Airline(greyhound) ∨ Plane(greyhound))"
},
{
"input": "Translate into first-order logic: Greyhound is an airline.",
"output": "Airline(greyhound)"
},
{
"input": "Translate into first-order logic: If something can transport multiple passengers, then they are not empty.",
"output": "∀x (TransportMultiplePassengers(x) → ¬Empty(x))"
},
{
"input": "Translate into first-order logic: All airlines can transport multiple passengers.",
"output": "∀x (Airline(x) → TransportMultiplePassengers(x))"
},
{
"input": "Translate into first-order logic: All planes are empty.",
"output": "∀x (Plane(x) → Empty(x))"
},
{
"input": "Translate into first-order logic: All Boeing 707s are planes.",
"output": "∀x (Boeing707(x) → Plane(x))"
},
{
"input": "Translate into first-order logic: If Greyhound is not an airline, then there are no Greyhound planes.",
"output": "¬Airline(greyhound) → ¬(Airline(greyhound) ∨ Plane(greyhound))"
},
{
"input": "Translate into first-order logic: A Greyhound is a Boeing 707.",
"output": "Boeing707(greyhound)"
},
{
"input": "Translate into first-order logic: If something can transport multiple passengers, then they are not empty.",
"output": "∀x (TransportMultiplePassengers(x) → ¬Empty(x))"
},
{
"input": "Translate into first-order logic: All airlines can transport multiple passengers.",
"output": "∀x (Airline(x) → TransportMultiplePassengers(x))"
},
{
"input": "Translate into first-order logic: All planes are empty.",
"output": "∀x (Plane(x) → Empty(x))"
},
{
"input": "Translate into first-order logic: All Boeing 707s are planes.",
"output": "∀x (Boeing707(x) → Plane(x))"
},
{
"input": "Translate into first-order logic: If Greyhound is not an airline, then there are no Greyhound planes.",
"output": "¬Airline(greyhound) → ¬(Airline(greyhound) ∨ Plane(greyhound))"
},
{
"input": "Translate into first-order logic: A Greyhound is not a Boeing 707.",
"output": "¬Boeing707(greyhound)"
},
{
"input": "Translate into first-order logic: All mammals are animals.",
"output": "∀x  (Mammal (x)→  Animal (x))"
},
{
"input": "Translate into first-order logic: All monkeys are mammals.",
"output": "∀x  (Monkey (x)→  Mammal (x))"
},
{
"input": "Translate into first-order logic: An animal is either a monkey or a bird.",
"output": "∀x ( Monkey (x) ∨  Bird (x))"
},
{
"input": "Translate into first-order logic: All birds fly.",
"output": "∀x  (Bird (x)→  Fly (x))"
},
{
"input": "Translate into first-order logic: All animals breathe.",
"output": "∀x  (Animal (x)→  Breathe (x))"
},
{
"input": "Translate into first-order logic: If something can fly, then it has wings.",
"output": "∀x  (Fly (x)→  HaveWings (x))"
},
{
"input": "Translate into first-order logic: If Rock is neither a fly nor a bird, then Rock neither flies nor breathes.",
"output": "¬ Fly (rock) ∧ ¬ Bird (rock) → ¬ Fly (rock) ∧ ¬ Breathe (rock) "
},
{
"input": "Translate into first-order logic: Rock is a monkey.",
"output": "Monkey(rock)"
},
{
"input": "Translate into first-order logic: All mammals are animals.",
"output": "∀x  (Mammal (x)→  Animal (x))"
},
{
"input": "Translate into first-order logic: All monkeys are mammals.",
"output": "∀x  (Monkey (x)→  Mammal (x))"
},
{
"input": "Translate into first-order logic: An animal is either a monkey or a bird.",
"output": "∀x ( Monkey (x) ∨  Bird (x))"
},
{
"input": "Translate into first-order logic: All birds fly.",
"output": "∀x  (Bird (x)→  Fly (x))"
},
{
"input": "Translate into first-order logic: All animals breathe.",
"output": "∀x  (Animal (x)→  Breathe (x))"
},
{
"input": "Translate into first-order logic: If something can fly, then it has wings.",
"output": "∀x  (Fly (x)→  HaveWings (x))"
},
{
"input": "Translate into first-order logic: If Rock is neither a fly nor a bird, then Rock neither flies nor breathes.",
"output": "¬ Fly (rock) ∧ ¬ Bird (rock) → ¬ Fly (rock) ∧ ¬ Breathe (rock) "
},
{
"input": "Translate into first-order logic: Rock has wings.",
"output": "HaveWings(rock)"
},
{
"input": "Translate into first-order logic: All mammals are animals.",
"output": "∀x  (Mammal (x)→  Animal (x))"
},
{
"input": "Translate into first-order logic: All monkeys are mammals.",
"output": "∀x  (Monkey (x)→  Mammal (x))"
},
{
"input": "Translate into first-order logic: An animal is either a monkey or a bird.",
"output": "∀x ( Monkey (x) ∨  Bird (x))"
},
{
"input": "Translate into first-order logic: All birds fly.",
"output": "∀x  (Bird (x)→  Fly (x))"
},
{
"input": "Translate into first-order logic: All animals breathe.",
"output": "∀x  (Animal (x)→  Breathe (x))"
},
{
"input": "Translate into first-order logic: If something can fly, then it has wings.",
"output": "∀x  (Fly (x)→  HaveWings (x))"
},
{
"input": "Translate into first-order logic: If Rock is neither a fly nor a bird, then Rock neither flies nor breathes.",
"output": "¬ Fly (rock) ∧ ¬ Bird (rock) → ¬ Fly (rock) ∧ ¬ Breathe (rock) "
},
{
"input": "Translate into first-order logic: Rock does not have wings.",
"output": "¬ HaveWings(rock)"
},
{
"input": "Translate into first-order logic: All people who have a wedding are people who have at least one child.",
"output": "∀x (Wedding(x) → Child(x))"
},
{
"input": "Translate into first-order logic: All people who travel to Paris for their honeymoon are people who have a wedding.",
"output": "∀x (Paris(x) → Wedding(x))"
},
{
"input": "Translate into first-order logic: All weddings that occur in July belong to people who travel to Paris for their honeymoon.",
"output": "∀x (July(x) → Paris(x))"
},
{
"input": "Translate into first-order logic: Some weddings in July are well-attended.",
"output": "∃x (July(x) ∧ WellAttended(x))"
},
{
"input": "Translate into first-order logic: If John has at least one child, then John does not travel to Paris for his honeymoon and does not have a wedding.",
"output": "Child(john) → ¬(Paris(john) ∧ Wedding(john))"
},
{
"input": "Translate into first-order logic: If John has a wedding that is well-attended, then John has a wedding in July or, if not, then John travels to Paris for their honeymoon.",
"output": "WellAttended(john) → July(john) ⊕ Paris(john)"
},
{
"input": "Translate into first-order logic: John has a wedding that is well-attended.",
"output": "WellAttended(john)"
},
{
"input": "Translate into first-order logic: All people who have a wedding are people who have at least one child.",
"output": "∀x (Wedding(x) → Child(x))"
},
{
"input": "Translate into first-order logic: All people who travel to Paris for their honeymoon are people who have a wedding.",
"output": "∀x (Paris(x) → Wedding(x))"
},
{
"input": "Translate into first-order logic: All weddings that occur in July belong to people who travel to Paris for their honeymoon.",
"output": "∀x (July(x) → Paris(x))"
},
{
"input": "Translate into first-order logic: Some weddings in July are well-attended.",
"output": "∃x (July(x) ∧ WellAttended(x))"
},
{
"input": "Translate into first-order logic: If John has at least one child, then John does not travel to Paris for his honeymoon and does not have a wedding.",
"output": "Child(john) → ¬(Paris(john) ∧ Wedding(john))"
},
{
"input": "Translate into first-order logic: If John has a wedding that is well-attended, then John has a wedding in July or, if not, then John travels to Paris for their honeymoon.",
"output": "WellAttended(john) → July(john) ⊕ Paris(john)"
},
{
"input": "Translate into first-order logic: John does not have a wedding that is well-attended.",
"output": "¬WellAttended(john)"
},
{
"input": "Translate into first-order logic: All people who have a wedding are people who have at least one child.",
"output": "∀x (Wedding(x) → Child(x))"
},
{
"input": "Translate into first-order logic: All people who travel to Paris for their honeymoon are people who have a wedding.",
"output": "∀x (Paris(x) → Wedding(x))"
},
{
"input": "Translate into first-order logic: All weddings that occur in July belong to people who travel to Paris for their honeymoon.",
"output": "∀x (July(x) → Paris(x))"
},
{
"input": "Translate into first-order logic: Some weddings in July are well-attended.",
"output": "∃x (July(x) ∧ WellAttended(x))"
},
{
"input": "Translate into first-order logic: If John has at least one child, then John does not travel to Paris for his honeymoon and does not have a wedding.",
"output": "Child(john) → ¬(Paris(john) ∧ Wedding(john))"
},
{
"input": "Translate into first-order logic: If John has a wedding that is well-attended, then John has a wedding in July or, if not, then John travels to Paris for their honeymoon.",
"output": "WellAttended(john) → July(john) ⊕ Paris(john)"
},
{
"input": "Translate into first-order logic: John has at least one child.",
"output": "Child(john)"
},
{
"input": "Translate into first-order logic: All people who have a wedding are people who have at least one child.",
"output": "∀x (Wedding(x) → Child(x))"
},
{
"input": "Translate into first-order logic: All people who travel to Paris for their honeymoon are people who have a wedding.",
"output": "∀x (Paris(x) → Wedding(x))"
},
{
"input": "Translate into first-order logic: All weddings that occur in July belong to people who travel to Paris for their honeymoon.",
"output": "∀x (July(x) → Paris(x))"
},
{
"input": "Translate into first-order logic: Some weddings in July are well-attended.",
"output": "∃x (July(x) ∧ WellAttended(x))"
},
{
"input": "Translate into first-order logic: If John has at least one child, then John does not travel to Paris for his honeymoon and does not have a wedding.",
"output": "Child(john) → ¬(Paris(john) ∧ Wedding(john))"
},
{
"input": "Translate into first-order logic: If John has a wedding that is well-attended, then John has a wedding in July or, if not, then John travels to Paris for their honeymoon.",
"output": "WellAttended(john) → July(john) ⊕ Paris(john)"
},
{
"input": "Translate into first-order logic: John has neither a wedding that is well-attended nor does he travel to Paris for his honeymoon.",
"output": "¬(WellAttended(john) ∨ July(john))"
},
{
"input": "Translate into first-order logic: [BG] Some mammals have teeth.",
"output": "∃x (Mammal(x) ∧ Have(x, teeth))"
},
{
"input": "Translate into first-order logic: Platypus have no teeth.",
"output": "¬Have(platypus, teeth)"
},
{
"input": "Translate into first-order logic: Platypus are mammals.",
"output": "Mammal(platypus)"
},
{
"input": "Translate into first-order logic: Humans have teeth.",
"output": "Have(humans, teeth)"
},
{
"input": "Translate into first-order logic: Platypus are mammals with no teeth.",
"output": "Mammal(platypus) ∧ ¬Have(platypus, teeth)"
},
{
"input": "Translate into first-order logic: [BG] Some mammals have teeth.",
"output": "∃x (Mammal(x) ∧ Have(x, teeth))"
},
{
"input": "Translate into first-order logic: Platypus have no teeth.",
"output": "¬Have(platypus, teeth)"
},
{
"input": "Translate into first-order logic: Platypus are mammals.",
"output": "Mammal(platypus)"
},
{
"input": "Translate into first-order logic: Humans have teeth.",
"output": "Have(humans, teeth)"
},
{
"input": "Translate into first-order logic: Platypus are reptiles.",
"output": "Reptile(platypus)"
},
{
"input": "Translate into first-order logic: [BG] Some mammals have teeth.",
"output": "∃x (Mammal(x) ∧ Have(x, teeth))"
},
{
"input": "Translate into first-order logic: Platypus have no teeth.",
"output": "¬Have(platypus, teeth)"
},
{
"input": "Translate into first-order logic: Platypus are mammals.",
"output": "Mammal(platypus)"
},
{
"input": "Translate into first-order logic: Humans have teeth.",
"output": "Have(humans, teeth)"
},
{
"input": "Translate into first-order logic: Humans are mammals.",
"output": "Mammal(humans)"
},
{
"input": "Translate into first-order logic: Plungers suck.",
"output": "∀x (Plunger(x) → Suck(x))"
},
{
"input": "Translate into first-order logic: Vacuums suck.",
"output": "∀x (Vacuum(x) → Suck(x))"
},
{
"input": "Translate into first-order logic: Vampires suck.",
"output": "∀x (Vampire(x) → Suck(x))"
},
{
"input": "Translate into first-order logic: Space is a vacuum.",
"output": "Vacuum(space)"
},
{
"input": "Translate into first-order logic: A duster is a household appliance that doesn't suck.",
"output": "HouseHoldApp(duster) ∧ ¬ Suck(duster)"
},
{
"input": "Translate into first-order logic: Space sucks.",
"output": "Suck(space)"
},
{
"input": "Translate into first-order logic: Plungers suck.",
"output": "∀x (Plunger(x) → Suck(x))"
},
{
"input": "Translate into first-order logic: Vacuums suck.",
"output": "∀x (Vacuum(x) → Suck(x))"
},
{
"input": "Translate into first-order logic: Vampires suck.",
"output": "∀x (Vampire(x) → Suck(x))"
},
{
"input": "Translate into first-order logic: Space is a vacuum.",
"output": "Vacuum(space)"
},
{
"input": "Translate into first-order logic: A duster is a household appliance that doesn't suck.",
"output": "HouseHoldApp(duster) ∧ ¬ Suck(duster)"
},
{
"input": "Translate into first-order logic: Space is a vampire.",
"output": "Vampire(space)"
},
{
"input": "Translate into first-order logic: Plungers suck.",
"output": "∀x (Plunger(x) → Suck(x))"
},
{
"input": "Translate into first-order logic: Vacuums suck.",
"output": "∀x (Vacuum(x) → Suck(x))"
},
{
"input": "Translate into first-order logic: Vampires suck.",
"output": "∀x (Vampire(x) → Suck(x))"
},
{
"input": "Translate into first-order logic: Space is a vacuum.",
"output": "Vacuum(space)"
},
{
"input": "Translate into first-order logic: A duster is a household appliance that doesn't suck.",
"output": "HouseHoldApp(duster) ∧ ¬ Suck(duster)"
},
{
"input": "Translate into first-order logic: If something is a household appliance, it sucks.",
"output": "∀x (HouseHoldApp(x) → Suck(x))"
},
{
"input": "Translate into first-order logic: Machine Learning algorithms can be categorized as supervised learning, unsupervised learning, and reinforcement learning.",
"output": "MLAlgorithm(supervisedLearning) ∨ MLAlgorithm(unsupervisedLearning) ∨ MLAlgorithm(reinforcementLearning)"
},
{
"input": "Translate into first-order logic: Unsupervised learning doesn't require labelled data.",
"output": "¬RequireLabelledData(unsupervisedLearning)"
},
{
"input": "Translate into first-order logic: The state-of-the-art text summarization model is trained with machine learning algorithms.",
"output": "TrainTextSumModel(supervisedLearning) ∨ TrainTextSumModel(unsupervisedLearning) ∨ TrainTextSumModel(reinforcementLearning)"
},
{
"input": "Translate into first-order logic: Reinforcement learning is not used to train the state-of-the-art text summarization model.",
"output": "¬TrainTextSumModel(reinforcementLearning)"
},
{
"input": "Translate into first-order logic: The Machine Learning algorithm for training text summarization model requires labelled data.",
"output": "∀x ((MLAlgorithm(x) ∧ TrainTextSumModel(x)) → RequireLabelledData(x))"
},
{
"input": "Translate into first-order logic: Supervised learning is used to train the state-of-the-art text summarization model.",
"output": "TrainTextSumModel(supervisedLearning)"
},
{
"input": "Translate into first-order logic: Machine Learning algorithms can be categorized as supervised learning, unsupervised learning, and reinforcement learning.",
"output": "MLAlgorithm(supervisedLearning) ∨ MLAlgorithm(unsupervisedLearning) ∨ MLAlgorithm(reinforcementLearning)"
},
{
"input": "Translate into first-order logic: Unsupervised learning doesn't require labelled data.",
"output": "¬RequireLabelledData(unsupervisedLearning)"
},
{
"input": "Translate into first-order logic: The state-of-the-art text summarization model is trained with machine learning algorithms.",
"output": "TrainTextSumModel(supervisedLearning) ∨ TrainTextSumModel(unsupervisedLearning) ∨ TrainTextSumModel(reinforcementLearning)"
},
{
"input": "Translate into first-order logic: Reinforcement learning is not used to train the state-of-the-art text summarization model.",
"output": "¬TrainTextSumModel(reinforcementLearning)"
},
{
"input": "Translate into first-order logic: The Machine Learning algorithm for training text summarization model requires labelled data.",
"output": "∀x ((MLAlgorithm(x) ∧ TrainTextSumModel(x)) → RequireLabelledData(x))"
},
{
"input": "Translate into first-order logic: Unsupervised learning is used to train the state-of-the-art text summarization model.",
"output": "TrainTextSumModel(unsupervisedLearning)"
},
{
"input": "Translate into first-order logic: If a cartoon character is funny, then it is popular.",
"output": "∀x (Funny(x) → Popular(x))"
},
{
"input": "Translate into first-order logic: If a cartoon character is ugly, then it is not popular.",
"output": "∀x (Ugly(x) → ¬Popular(x))"
},
{
"input": "Translate into first-order logic: If a cartoon character is loved by children, then it is funny.",
"output": "∀x (Love(children, x) → Funny(x))"
},
{
"input": "Translate into first-order logic: If a cartoon character is from The Simpsons, then it is loved by children.",
"output": "∀x (Simpsons(x) → Love(children, x))"
},
{
"input": "Translate into first-order logic: If a cartoon character is yellow, then it is from The Simpsons.",
"output": "∀x (Yellow(x) → Simpsons(x))"
},
{
"input": "Translate into first-order logic: Ben is either from The Simpsons or funny.",
"output": "Simpsons(ben) ⊕ Funny(ben)"
},
{
"input": "Translate into first-order logic: Ben is loved by children.",
"output": "Love(children, ben)"
},
{
"input": "Translate into first-order logic: If a cartoon character is funny, then it is popular.",
"output": "∀x (Funny(x) → Popular(x))"
},
{
"input": "Translate into first-order logic: If a cartoon character is ugly, then it is not popular.",
"output": "∀x (Ugly(x) → ¬Popular(x))"
},
{
"input": "Translate into first-order logic: If a cartoon character is loved by children, then it is funny.",
"output": "∀x (Love(children, x) → Funny(x))"
},
{
"input": "Translate into first-order logic: If a cartoon character is from The Simpsons, then it is loved by children.",
"output": "∀x (Simpsons(x) → Love(children, x))"
},
{
"input": "Translate into first-order logic: If a cartoon character is yellow, then it is from The Simpsons.",
"output": "∀x (Yellow(x) → Simpsons(x))"
},
{
"input": "Translate into first-order logic: Ben is either from The Simpsons or funny.",
"output": "Simpsons(ben) ⊕ Funny(ben)"
},
{
"input": "Translate into first-order logic: Ben is ugly or yellow.",
"output": "Ugly(ben) ∨ Yellow(ben)"
},
{
"input": "Translate into first-order logic: If a cartoon character is funny, then it is popular.",
"output": "∀x (Funny(x) → Popular(x))"
},
{
"input": "Translate into first-order logic: If a cartoon character is ugly, then it is not popular.",
"output": "∀x (Ugly(x) → ¬Popular(x))"
},
{
"input": "Translate into first-order logic: If a cartoon character is loved by children, then it is funny.",
"output": "∀x (Love(children, x) → Funny(x))"
},
{
"input": "Translate into first-order logic: If a cartoon character is from The Simpsons, then it is loved by children.",
"output": "∀x (Simpsons(x) → Love(children, x))"
},
{
"input": "Translate into first-order logic: If a cartoon character is yellow, then it is from The Simpsons.",
"output": "∀x (Yellow(x) → Simpsons(x))"
},
{
"input": "Translate into first-order logic: Ben is either from The Simpsons or funny.",
"output": "Simpsons(ben) ⊕ Funny(ben)"
},
{
"input": "Translate into first-order logic: Ben is either yellow and ugly or neither yellow nor ugly.",
"output": "(Yellow(ben) ∧ Ugly(ben)) ⊕ (¬Yellow(ben) ∧ ¬Ugly(ben))"
},
{
"input": "Translate into first-order logic: Breeding back is a form of artificial selection by the deliberate selective breeding of domestic animals.",
"output": "∀x ∀y (BreedingBack(x, y) → ArtificiallySelect(x))"
},
{
"input": "Translate into first-order logic: Heck cattle were bred-back in the 1920s to resemble the aurochs.",
"output": "∃x ∃y (HeckCattle(x) ∧ Aurochs(y) ∧ BreedingBack(x, y))"
},
{
"input": "Translate into first-order logic: [BG] Heck cattle are animals.",
"output": "∀x (HeckCattle(x) → Animal(x))"
},
{
"input": "Translate into first-order logic: [BG] Aurochs are animals.",
"output": "∀x (Aurochs(x) → Animal(x))"
},
{
"input": "Translate into first-order logic: Some animals to be bred-back resemble animals that are extinct.",
"output": "∃x ∃y (Animal(x) ∧ Animal(y) ∧ BreedingBack(x, y) ∧ Extinct(y))"
},
{
"input": "Translate into first-order logic: Some Heck cattle are artificially selected.",
"output": "∃x (HeckCattle(x) ∧ ArtificiallySelect(x))"
},
{
"input": "Translate into first-order logic: Breeding back is a form of artificial selection by the deliberate selective breeding of domestic animals.",
"output": "∀x ∀y (BreedingBack(x, y) → ArtificiallySelect(x))"
},
{
"input": "Translate into first-order logic: Heck cattle were bred-back in the 1920s to resemble the aurochs.",
"output": "∃x ∃y (HeckCattle(x) ∧ Aurochs(y) ∧ BreedingBack(x, y))"
},
{
"input": "Translate into first-order logic: [BG] Heck cattle are animals.",
"output": "∀x (HeckCattle(x) → Animal(x))"
},
{
"input": "Translate into first-order logic: [BG] Aurochs are animals.",
"output": "∀x (Aurochs(x) → Animal(x))"
},
{
"input": "Translate into first-order logic: Some animals to be bred-back resemble animals that are extinct.",
"output": "∃x ∃y (Animal(x) ∧ Animal(y) ∧ BreedingBack(x, y) ∧ Extinct(y))"
},
{
"input": "Translate into first-order logic: Aurochs are extinct.",
"output": "∀x (Aurochs(x) → Extinct(x))"
},
{
"input": "Translate into first-order logic: All students are humans.",
"output": "∀x (Student(x) → Human(x))"
},
{
"input": "Translate into first-order logic: If someone studies, then they are a student.",
"output": "∀x (Study(x) → Student(x))"
},
{
"input": "Translate into first-order logic: A person either studys or teaches.",
"output": "∀x (Study(x) ∨ Teach(x))"
},
{
"input": "Translate into first-order logic: No young person teaches.",
"output": "∀x (Young(x) → ¬Teach(x))"
},
{
"input": "Translate into first-order logic: Jerry neither teaches nor is a manager.",
"output": "¬Teach(jerry) ∧ ¬Manager(jerry)"
},
{
"input": "Translate into first-order logic: Rose is young or a student.",
"output": "Young(rose) ∨ Student(rose)"
},
{
"input": "Translate into first-order logic: Jerry is young.",
"output": "Young(jerry)"
},
{
"input": "Translate into first-order logic: All students are humans.",
"output": "∀x (Student(x) → Human(x))"
},
{
"input": "Translate into first-order logic: If someone studies, then they are a student.",
"output": "∀x (Study(x) → Student(x))"
},
{
"input": "Translate into first-order logic: A person either studys or teaches.",
"output": "∀x (Study(x) ∨ Teach(x))"
},
{
"input": "Translate into first-order logic: No young person teaches.",
"output": "∀x (Young(x) → ¬Teach(x))"
},
{
"input": "Translate into first-order logic: Jerry neither teaches nor is a manager.",
"output": "¬Teach(jerry) ∧ ¬Manager(jerry)"
},
{
"input": "Translate into first-order logic: Rose is young or a student.",
"output": "Young(rose) ∨ Student(rose)"
},
{
"input": "Translate into first-order logic: Jerry is not young.",
"output": "¬Young(jerry)"
},
{
"input": "Translate into first-order logic: All students are humans.",
"output": "∀x (Student(x) → Human(x))"
},
{
"input": "Translate into first-order logic: If someone studies, then they are a student.",
"output": "∀x (Study(x) → Student(x))"
},
{
"input": "Translate into first-order logic: A person either studys or teaches.",
"output": "∀x (Study(x) ∨ Teach(x))"
},
{
"input": "Translate into first-order logic: No young person teaches.",
"output": "∀x (Young(x) → ¬Teach(x))"
},
{
"input": "Translate into first-order logic: Jerry neither teaches nor is a manager.",
"output": "¬Teach(jerry) ∧ ¬Manager(jerry)"
},
{
"input": "Translate into first-order logic: Rose is young or a student.",
"output": "Young(rose) ∨ Student(rose)"
},
{
"input": "Translate into first-order logic: Rose is a human or a manager.",
"output": "Human(rose) ∨ Manager(rose)"
},
{
"input": "Translate into first-order logic: All students are humans.",
"output": "∀x (Student(x) → Human(x))"
},
{
"input": "Translate into first-order logic: If someone studies, then they are a student.",
"output": "∀x (Study(x) → Student(x))"
},
{
"input": "Translate into first-order logic: A person either studys or teaches.",
"output": "∀x (Study(x) ∨ Teach(x))"
},
{
"input": "Translate into first-order logic: No young person teaches.",
"output": "∀x (Young(x) → ¬Teach(x))"
},
{
"input": "Translate into first-order logic: Jerry neither teaches nor is a manager.",
"output": "¬Teach(jerry) ∧ ¬Manager(jerry)"
},
{
"input": "Translate into first-order logic: Rose is young or a student.",
"output": "Young(rose) ∨ Student(rose)"
},
{
"input": "Translate into first-order logic: Rose is a human or Jerry is a manager.",
"output": "Human(rose) ∨ Manager(jerry)"
},
{
"input": "Translate into first-order logic: All students are humans.",
"output": "∀x (Student(x) → Human(x))"
},
{
"input": "Translate into first-order logic: If someone studies, then they are a student.",
"output": "∀x (Study(x) → Student(x))"
},
{
"input": "Translate into first-order logic: A person either studys or teaches.",
"output": "∀x (Study(x) ∨ Teach(x))"
},
{
"input": "Translate into first-order logic: No young person teaches.",
"output": "∀x (Young(x) → ¬Teach(x))"
},
{
"input": "Translate into first-order logic: Jerry neither teaches nor is a manager.",
"output": "¬Teach(jerry) ∧ ¬Manager(jerry)"
},
{
"input": "Translate into first-order logic: Rose is young or a student.",
"output": "Young(rose) ∨ Student(rose)"
},
{
"input": "Translate into first-order logic: It is not true that Rose is a student and Jerry is a human.",
"output": "¬(Student(rose) ∧ Human(jerry))"
},
{
"input": "Translate into first-order logic: New Vessel Press is a publishing house which specializes in translating foreign literature into English.",
"output": "PublishingHouse(newvesselpress) ∧ SpecializesIn(newvessel, translatingforeignliteratureintoenglish)"
},
{
"input": "Translate into first-order logic: All of New Vessel Press's published books are in English.",
"output": "∀x (Book(x) ∧ PublishedBy(x, newvesselpress) → In(x, english))"
},
{
"input": "Translate into first-order logic: Neapolitan Chronicles is a book published by New Vessel Press.",
"output": "Book(neapolitanchronicles) ∧ PublishedBy(neapolitanchronicles, newvesselpress)"
},
{
"input": "Translate into first-order logic: Neapolitan Chronicles was translated from Italian.",
"output": "TranslatedFrom(neapolitanchronicles, italian)"
},
{
"input": "Translate into first-order logic: Palace of Flies is a book published by New Vessel Press.",
"output": "Book(palaceofflies) ∧ PublishedBy(palaceofflies, newvesselpress)"
},
{
"input": "Translate into first-order logic: Neapolitan Chronicles is an English book.",
"output": "Book(neapolitanchronicles) ∧ In(neapolitanchronicles, english)"
},
{
"input": "Translate into first-order logic: New Vessel Press is a publishing house which specializes in translating foreign literature into English.",
"output": "PublishingHouse(newvesselpress) ∧ SpecializesIn(newvessel, translatingforeignliteratureintoenglish)"
},
{
"input": "Translate into first-order logic: All of New Vessel Press's published books are in English.",
"output": "∀x (Book(x) ∧ PublishedBy(x, newvesselpress) → In(x, english))"
},
{
"input": "Translate into first-order logic: Neapolitan Chronicles is a book published by New Vessel Press.",
"output": "Book(neapolitanchronicles) ∧ PublishedBy(neapolitanchronicles, newvesselpress)"
},
{
"input": "Translate into first-order logic: Neapolitan Chronicles was translated from Italian.",
"output": "TranslatedFrom(neapolitanchronicles, italian)"
},
{
"input": "Translate into first-order logic: Palace of Flies is a book published by New Vessel Press.",
"output": "Book(palaceofflies) ∧ PublishedBy(palaceofflies, newvesselpress)"
},
{
"input": "Translate into first-order logic: Harry Potter was published by New Vessel Press.",
"output": "PublishedBy(harrrypotter, newvesselpress)"
},
{
"input": "Translate into first-order logic: New Vessel Press is a publishing house which specializes in translating foreign literature into English.",
"output": "PublishingHouse(newvesselpress) ∧ SpecializesIn(newvessel, translatingforeignliteratureintoenglish)"
},
{
"input": "Translate into first-order logic: All of New Vessel Press's published books are in English.",
"output": "∀x (Book(x) ∧ PublishedBy(x, newvesselpress) → In(x, english))"
},
{
"input": "Translate into first-order logic: Neapolitan Chronicles is a book published by New Vessel Press.",
"output": "Book(neapolitanchronicles) ∧ PublishedBy(neapolitanchronicles, newvesselpress)"
},
{
"input": "Translate into first-order logic: Neapolitan Chronicles was translated from Italian.",
"output": "TranslatedFrom(neapolitanchronicles, italian)"
},
{
"input": "Translate into first-order logic: Palace of Flies is a book published by New Vessel Press.",
"output": "Book(palaceofflies) ∧ PublishedBy(palaceofflies, newvesselpress)"
},
{
"input": "Translate into first-order logic: Palace of Flies was translated from Italian.",
"output": "TranslatedFrom(palaceofflies, italian)"
},
{
"input": "Translate into first-order logic: If people own a large desktop monitor at their home, then they work regularly and often at home.",
"output": "∀x (Desktop(x) → WorkHome(x))"
},
{
"input": "Translate into first-order logic: All people who have a fully stocked and impressive home office are people who own a large desktop monitor at their home.",
"output": "∀x (HomeOffice(x) → Desktop(x))"
},
{
"input": "Translate into first-order logic: All people who work regularly and often at home spend their free time tidying and organizing the spaces in their homes.",
"output": "∀x (WorkHome(x) → Tidying(x))"
},
{
"input": "Translate into first-order logic: All people who work regularly and often at home visit the office supply store regularly.",
"output": "∀x (WorkHome(x) → OfficeStore(x))"
},
{
"input": "Translate into first-order logic: If people spend their free time tidying and organizing the spaces in their home, then they do not go to bed late and wake up every day after noon.",
"output": "∀x (Tidying(x) → ¬Late(x))"
},
{
"input": "Translate into first-order logic: Remy either both goes to bed late and wakes up every day after noon and spends their free time tidying and organizing the spaces in their home, or they do not go to bed late and wake up every day after noon nor spend their free time tidying and organizing the spaces in their home.",
"output": "(Late(remy) ∧ Tidying(remy)) ⊕ (¬Late(remy) ∧ ¬Tidying(remy))"
},
{
"input": "Translate into first-order logic: Remy visits the office supply store regularly.",
"output": "OfficeStore(remy)"
},
{
"input": "Translate into first-order logic: If people own a large desktop monitor at their home, then they work regularly and often at home.",
"output": "∀x (Desktop(x) → WorkHome(x))"
},
{
"input": "Translate into first-order logic: All people who have a fully stocked and impressive home office are people who own a large desktop monitor at their home.",
"output": "∀x (HomeOffice(x) → Desktop(x))"
},
{
"input": "Translate into first-order logic: All people who work regularly and often at home spend their free time tidying and organizing the spaces in their homes.",
"output": "∀x (WorkHome(x) → Tidying(x))"
},
{
"input": "Translate into first-order logic: All people who work regularly and often at home visit the office supply store regularly.",
"output": "∀x (WorkHome(x) → OfficeStore(x))"
},
{
"input": "Translate into first-order logic: If people spend their free time tidying and organizing the spaces in their home, then they do not go to bed late and wake up every day after noon.",
"output": "∀x (Tidying(x) → ¬Late(x))"
},
{
"input": "Translate into first-order logic: Remy either both goes to bed late and wakes up every day after noon and spends their free time tidying and organizing the spaces in their home, or they do not go to bed late and wake up every day after noon nor spend their free time tidying and organizing the spaces in their home.",
"output": "(Late(remy) ∧ Tidying(remy)) ⊕ (¬Late(remy) ∧ ¬Tidying(remy))"
},
{
"input": "Translate into first-order logic: Remy has a fully stocked and impressive home office and also visits the office supply store regularly.",
"output": "HomeOffice(remy) ∧ OfficeStore(remy)"
},
{
"input": "Translate into first-order logic: If people own a large desktop monitor at their home, then they work regularly and often at home.",
"output": "∀x (Desktop(x) → WorkHome(x))"
},
{
"input": "Translate into first-order logic: All people who have a fully stocked and impressive home office are people who own a large desktop monitor at their home.",
"output": "∀x (HomeOffice(x) → Desktop(x))"
},
{
"input": "Translate into first-order logic: All people who work regularly and often at home spend their free time tidying and organizing the spaces in their homes.",
"output": "∀x (WorkHome(x) → Tidying(x))"
},
{
"input": "Translate into first-order logic: All people who work regularly and often at home visit the office supply store regularly.",
"output": "∀x (WorkHome(x) → OfficeStore(x))"
},
{
"input": "Translate into first-order logic: If people spend their free time tidying and organizing the spaces in their home, then they do not go to bed late and wake up every day after noon.",
"output": "∀x (Tidying(x) → ¬Late(x))"
},
{
"input": "Translate into first-order logic: Remy either both goes to bed late and wakes up every day after noon and spends their free time tidying and organizing the spaces in their home, or they do not go to bed late and wake up every day after noon nor spend their free time tidying and organizing the spaces in their home.",
"output": "(Late(remy) ∧ Tidying(remy)) ⊕ (¬Late(remy) ∧ ¬Tidying(remy))"
},
{
"input": "Translate into first-order logic: If Remy either goes to bed late and wakes up every day after noon or visits the office supply store regularly, then Remy neither spends their free time tidying and organizing the spaces in their home nor has a fully stocked and impressive home office.",
"output": "Late(remy) ∨ OfficeStore(remy) → ¬(Tidying(remy) ∨ HomeOffice(remy))"
},
{
"input": "Translate into first-order logic: All humans are mortal.",
"output": "∀x (Human(x) → Mortal(x))"
},
{
"input": "Translate into first-order logic: All Greeks are humans.",
"output": "∀x (Greek(x) → Human(x))"
},
{
"input": "Translate into first-order logic: Some Greeks are mortal.",
"output": "∃x (Greek(x) ∧ Mortal(x))"
},
{
"input": "Translate into first-order logic: No students who work in the library are from the computer science department.",
"output": "∀x (WorkLibrary(x) → ¬ComputerScience(x))"
},
{
"input": "Translate into first-order logic: All students who have part-time jobs offered by the university are students who work in the library.",
"output": "∀x (PartTime(x) → WorkLibrary(x))"
},
{
"input": "Translate into first-order logic: All students who take the database course are from the computer science department.",
"output": "∀x (Database(x) → ComputerScience(x))"
},
{
"input": "Translate into first-order logic: All students instructed by professor David are taking the database course.",
"output": "∀x (ProfessorDavid(x) → Database(x))"
},
{
"input": "Translate into first-order logic: All students working in the lab are instructed by professor David.",
"output": "∀x (WorkInLab(x) → ProfessorDavid(x))"
},
{
"input": "Translate into first-order logic: James is a student working in the lab.",
"output": "WorkInLab(james)"
},
{
"input": "Translate into first-order logic: Jack neither has a part-time job offered by the university nor works in the lab.",
"output": "¬PartTime(jack) ∧ ¬WorkInLab(jack)"
},
{
"input": "Translate into first-order logic: James has a part-time job offered by the university.",
"output": "PartTime(james)"
},
{
"input": "Translate into first-order logic: No students who work in the library are from the computer science department.",
"output": "∀x (WorkLibrary(x) → ¬ComputerScience(x))"
},
{
"input": "Translate into first-order logic: All students who have part-time jobs offered by the university are students who work in the library.",
"output": "∀x (PartTime(x) → WorkLibrary(x))"
},
{
"input": "Translate into first-order logic: All students who take the database course are from the computer science department.",
"output": "∀x (Database(x) → ComputerScience(x))"
},
{
"input": "Translate into first-order logic: All students instructed by professor David are taking the database course.",
"output": "∀x (ProfessorDavid(x) → Database(x))"
},
{
"input": "Translate into first-order logic: All students working in the lab are instructed by professor David.",
"output": "∀x (WorkInLab(x) → ProfessorDavid(x))"
},
{
"input": "Translate into first-order logic: James is a student working in the lab.",
"output": "WorkInLab(james)"
},
{
"input": "Translate into first-order logic: Jack neither has a part-time job offered by the university nor works in the lab.",
"output": "¬PartTime(jack) ∧ ¬WorkInLab(jack)"
},
{
"input": "Translate into first-order logic: James does not have a part-time job offered by the university.",
"output": "¬PartTime(james)"
},
{
"input": "Translate into first-order logic: No students who work in the library are from the computer science department.",
"output": "∀x (WorkLibrary(x) → ¬ComputerScience(x))"
},
{
"input": "Translate into first-order logic: All students who have part-time jobs offered by the university are students who work in the library.",
"output": "∀x (PartTime(x) → WorkLibrary(x))"
},
{
"input": "Translate into first-order logic: All students who take the database course are from the computer science department.",
"output": "∀x (Database(x) → ComputerScience(x))"
},
{
"input": "Translate into first-order logic: All students instructed by professor David are taking the database course.",
"output": "∀x (ProfessorDavid(x) → Database(x))"
},
{
"input": "Translate into first-order logic: All students working in the lab are instructed by professor David.",
"output": "∀x (WorkInLab(x) → ProfessorDavid(x))"
},
{
"input": "Translate into first-order logic: James is a student working in the lab.",
"output": "WorkInLab(james)"
},
{
"input": "Translate into first-order logic: Jack neither has a part-time job offered by the university nor works in the lab.",
"output": "¬PartTime(jack) ∧ ¬WorkInLab(jack)"
},
{
"input": "Translate into first-order logic: James either takes the database course or has a part-time job offered by the university.",
"output": "Database(james) ⊕ PartTime(james)"
},
{
"input": "Translate into first-order logic: No students who work in the library are from the computer science department.",
"output": "∀x (WorkLibrary(x) → ¬ComputerScience(x))"
},
{
"input": "Translate into first-order logic: All students who have part-time jobs offered by the university are students who work in the library.",
"output": "∀x (PartTime(x) → WorkLibrary(x))"
},
{
"input": "Translate into first-order logic: All students who take the database course are from the computer science department.",
"output": "∀x (Database(x) → ComputerScience(x))"
},
{
"input": "Translate into first-order logic: All students instructed by professor David are taking the database course.",
"output": "∀x (ProfessorDavid(x) → Database(x))"
},
{
"input": "Translate into first-order logic: All students working in the lab are instructed by professor David.",
"output": "∀x (WorkInLab(x) → ProfessorDavid(x))"
},
{
"input": "Translate into first-order logic: James is a student working in the lab.",
"output": "WorkInLab(james)"
},
{
"input": "Translate into first-order logic: Jack neither has a part-time job offered by the university nor works in the lab.",
"output": "¬PartTime(jack) ∧ ¬WorkInLab(jack)"
},
{
"input": "Translate into first-order logic: Jack takes the database course.",
"output": "Database(jack)"
},
{
"input": "Translate into first-order logic: If George likes music, he wants to compose.",
"output": "LikesMusic(george) → WantsToCompose(george)"
},
{
"input": "Translate into first-order logic: If George has access to a program, he can compose.",
"output": "AccesstoProgram(george) → CanCompose(george)"
},
{
"input": "Translate into first-order logic: If George can compose and wants to compose, he will compose.",
"output": "(WantsToCompose(george) ∧ CanCompose(george)) → WillCompose(george)"
},
{
"input": "Translate into first-order logic: If George likes music and has access to a program, he will compose.",
"output": "(LikesMusic(george) ∧ AccesstoProgram(george)) → WillCompose(george)"
},
{
"input": "Translate into first-order logic: If George likes music, he wants to compose.",
"output": "LikesMusic(george) → WantsToCompose(george)"
},
{
"input": "Translate into first-order logic: If George has access to a program, he can compose.",
"output": "AccesstoProgram(george) → CanCompose(george)"
},
{
"input": "Translate into first-order logic: If George can compose and wants to compose, he will compose.",
"output": "(WantsToCompose(george) ∧ CanCompose(george)) → WillCompose(george)"
},
{
"input": "Translate into first-order logic: If George will not compose, George can not compose.",
"output": "¬WantsToCompose(george) → ¬WillCompose(george)"
},
{
"input": "Translate into first-order logic: A hawk never lands.",
"output": "∀x (Hawk(x) → ¬Lands(x))"
},
{
"input": "Translate into first-order logic: Some birds are hawks.",
"output": "∃x (Bird(x) ∧ Hawk(x))"
},
{
"input": "Translate into first-order logic: All birds land",
"output": "∀x (Bird(x) → Lands(x))"
},
{
"input": "Translate into first-order logic: On some Mondays at 8 pm, roses are given out on TV.",
"output": "∃x (Mondayat8(x) ∧ RoseGivenOutOnTv(x))"
},
{
"input": "Translate into first-order logic: Every rose given out on TV is on the Bachelor.",
"output": "∀x (RoseGivenOutOnTv(x) → OnBachelor(x))"
},
{
"input": "Translate into first-order logic: Everything on the Bachelor portrays the lives of real people.",
"output": "∀x (OnBachelor(x) → PortrayLiveOfRealPeople(x))"
},
{
"input": "Translate into first-order logic: All shows portraying the lives of real people are reality TV shows.",
"output": "∀x (PortrayLiveOfRealPeople(x) → RealityTVShow(x))"
},
{
"input": "Translate into first-order logic: Breaking Bad is not a reality TV show.",
"output": "¬RealityTVShow(breakingbad)"
},
{
"input": "Translate into first-order logic: Breaking Bad is on Monday at 8 pm.",
"output": "Mondayat8(breakingbad)"
},
{
"input": "Translate into first-order logic: On some Mondays at 8 pm, roses are given out on TV.",
"output": "∃x (Mondayat8(x) ∧ RoseGivenOutOnTv(x))"
},
{
"input": "Translate into first-order logic: Every rose given out on TV is on the Bachelor.",
"output": "∀x (RoseGivenOutOnTv(x) → OnBachelor(x))"
},
{
"input": "Translate into first-order logic: Everything on the Bachelor portrays the lives of real people.",
"output": "∀x (OnBachelor(x) → PortrayLiveOfRealPeople(x))"
},
{
"input": "Translate into first-order logic: All shows portraying the lives of real people are reality TV shows.",
"output": "∀x (PortrayLiveOfRealPeople(x) → RealityTVShow(x))"
},
{
"input": "Translate into first-order logic: Breaking Bad is not a reality TV show.",
"output": "¬RealityTVShow(breakingbad)"
},
{
"input": "Translate into first-order logic: Breaking Bad is a TV show in which roses are given out on Monday at 8 pm.",
"output": "Mondayat8(breakingbad) ∧ RoseGivenOutOnTv(breakingbad)"
},
{
"input": "Translate into first-order logic: On some Mondays at 8 pm, roses are given out on TV.",
"output": "∃x (Mondayat8(x) ∧ RoseGivenOutOnTv(x))"
},
{
"input": "Translate into first-order logic: Every rose given out on TV is on the Bachelor.",
"output": "∀x (RoseGivenOutOnTv(x) → OnBachelor(x))"
},
{
"input": "Translate into first-order logic: Everything on the Bachelor portrays the lives of real people.",
"output": "∀x (OnBachelor(x) → PortrayLiveOfRealPeople(x))"
},
{
"input": "Translate into first-order logic: All shows portraying the lives of real people are reality TV shows.",
"output": "∀x (PortrayLiveOfRealPeople(x) → RealityTVShow(x))"
},
{
"input": "Translate into first-order logic: Breaking Bad is not a reality TV show.",
"output": "¬RealityTVShow(breakingbad)"
},
{
"input": "Translate into first-order logic: If roses are given out during Breaking Bad, then it is on Monday at 8 pm.",
"output": "RoseGivenOutOnTv(breakingbad) → Mondayat8(breakingbad)"
},
{
"input": "Translate into first-order logic: Heinrich Scmidt was a Nazi German politician.",
"output": "From(heinrichScmidt, naziGermany) ∧ Politician(heinrichScmidt)"
},
{
"input": "Translate into first-order logic: Heeinrich Scmidt was also a member of the Prussian State Parliament and the Nazi Reichstag.",
"output": "Member(heinrichScmidt, prussianStateParliament) ∧ Member(heinrichScmidt, naziReichstag)"
},
{
"input": "Translate into first-order logic: Heinrich Schmidt was either German or Russian.",
"output": "From(heinrichScmidt, naziGermany) ∨ From(heinrichScmidt, russia)"
},
{
"input": "Translate into first-order logic: Heinrich Scmidt was a Nazi German politician.",
"output": "From(heinrichScmidt, naziGermany) ∧ Politician(heinrichScmidt)"
},
{
"input": "Translate into first-order logic: Heeinrich Scmidt was also a member of the Prussian State Parliament and the Nazi Reichstag.",
"output": "Member(heinrichScmidt, prussianStateParliament) ∧ Member(heinrichScmidt, naziReichstag)"
},
{
"input": "Translate into first-order logic: Some Nazi German politician was part of both the Prussian State Parliament and the Nazi Reichstag.",
"output": "∃x (From(x, naziGermany) ∧ Politician(x) ∧ Member(x, prussianStateParliament) ∧ Member(x, naziReichstag))"
},
{
"input": "Translate into first-order logic: Heinrich Scmidt was a Nazi German politician.",
"output": "From(heinrichScmidt, naziGermany) ∧ Politician(heinrichScmidt)"
},
{
"input": "Translate into first-order logic: Heeinrich Scmidt was also a member of the Prussian State Parliament and the Nazi Reichstag.",
"output": "Member(heinrichScmidt, prussianStateParliament) ∧ Member(heinrichScmidt, naziReichstag)"
},
{
"input": "Translate into first-order logic: No politicans are part of the Nazi Reichstag.",
"output": "∀x (Politician(x) → ¬Member(x, naziReichstag))"
},
{
"input": "Translate into first-order logic: If something is a deadly disease, then its survival rate is low.",
"output": "∀x (DeadlyDiseases(x) → SurvivalRateIsLow(x))"
},
{
"input": "Translate into first-order logic: All severe cancers are deadly diseases.",
"output": "∀x (SevereCancer(x) → DeadlyDiseases(x))"
},
{
"input": "Translate into first-order logic: Bile duct cancer is a severe cancer.",
"output": "∀x (BileDuctCancer(x) → SevereCancer(x))"
},
{
"input": "Translate into first-order logic: All Cholangiocarcinoma is bile duct cancer.",
"output": "∀x (Cholangiocarcinoma(x) → BileDuctCancer(x))"
},
{
"input": "Translate into first-order logic: No one with mild flu has a low survival rate.",
"output": "∀x (MildFlu(x) → ¬SurvivalRateIsLow(x)) "
},
{
"input": "Translate into first-order logic: If colorectal cancer is a bile duct cancer and the survival rate is low, then colorectal cancer is not a bile duct cancer.",
"output": "BileDuctCancer(colorectalCancer) ∨ SurvivalRateIsLow(colorectalCancer) → ¬BileDuctCancer(colorectalCancer)"
},
{
"input": "Translate into first-order logic: Colorectal cancer is a severe cancer",
"output": "SevereCancer(colorectalCancer)"
},
{
"input": "Translate into first-order logic: If something is a deadly disease, then its survival rate is low.",
"output": "∀x (DeadlyDiseases(x) → SurvivalRateIsLow(x))"
},
{
"input": "Translate into first-order logic: All severe cancers are deadly diseases.",
"output": "∀x (SevereCancer(x) → DeadlyDiseases(x))"
},
{
"input": "Translate into first-order logic: Bile duct cancer is a severe cancer.",
"output": "∀x (BileDuctCancer(x) → SevereCancer(x))"
},
{
"input": "Translate into first-order logic: All Cholangiocarcinoma is bile duct cancer.",
"output": "∀x (Cholangiocarcinoma(x) → BileDuctCancer(x))"
},
{
"input": "Translate into first-order logic: No one with mild flu has a low survival rate.",
"output": "∀x (MildFlu(x) → ¬SurvivalRateIsLow(x)) "
},
{
"input": "Translate into first-order logic: If colorectal cancer is a bile duct cancer and the survival rate is low, then colorectal cancer is not a bile duct cancer.",
"output": "BileDuctCancer(colorectalCancer) ∨ SurvivalRateIsLow(colorectalCancer) → ¬BileDuctCancer(colorectalCancer)"
},
{
"input": "Translate into first-order logic: If colorectal cancer is a bile duct cancer or a Cholangiocarcinoma, then colorectal cancer is a bile duct cancer and a mild flu.",
"output": "BileDuctCancer(colorectalCancer) ∨ Cholangiocarcinoma(colorectalCancer) → BileDuctCancer(colorectalCancer) ∧ MildFlu(colorectalCancer)"
},
{
"input": "Translate into first-order logic: If something is a deadly disease, then its survival rate is low.",
"output": "∀x (DeadlyDiseases(x) → SurvivalRateIsLow(x))"
},
{
"input": "Translate into first-order logic: All severe cancers are deadly diseases.",
"output": "∀x (SevereCancer(x) → DeadlyDiseases(x))"
},
{
"input": "Translate into first-order logic: Bile duct cancer is a severe cancer.",
"output": "∀x (BileDuctCancer(x) → SevereCancer(x))"
},
{
"input": "Translate into first-order logic: All Cholangiocarcinoma is bile duct cancer.",
"output": "∀x (Cholangiocarcinoma(x) → BileDuctCancer(x))"
},
{
"input": "Translate into first-order logic: No one with mild flu has a low survival rate.",
"output": "∀x (MildFlu(x) → ¬SurvivalRateIsLow(x)) "
},
{
"input": "Translate into first-order logic: If colorectal cancer is a bile duct cancer and the survival rate is low, then colorectal cancer is not a bile duct cancer.",
"output": "BileDuctCancer(colorectalCancer) ∨ SurvivalRateIsLow(colorectalCancer) → ¬BileDuctCancer(colorectalCancer)"
},
{
"input": "Translate into first-order logic: If colorectal cancer is not a mild flu and a Cholangiocarcinoma, then colorectal cancer is a bile duct cancer or a Cholangiocarcinoma.",
"output": "¬MildFlu(colorectalCancer) ∨ ¬Cholangiocarcinoma(colorectalCancer) → BileDuctCancer(colorectalCancer) ∨ Cholangiocarcinoma(colorectalCancer)"
},
{
"input": "Translate into first-order logic: All people who eat salads regularly are very conscious about their health and eating habits.",
"output": "∀x (Salad(x) → HealthyHabits(x))"
},
{
"input": "Translate into first-order logic: All people who grew up in health-conscious childhood homes eat salads regularly.",
"output": "∀x (HealthyChildhood(x) → Salad(x))"
},
{
"input": "Translate into first-order logic: All people who fulfill their nutritional daily intakes grew up in health-conscious childhood homes.",
"output": "∀x (Nutritional(x) → HealthyChildhood(x))"
},
{
"input": "Translate into first-order logic: If people have good relationships with their parents, then they fulfill their nutritional daily intakes.",
"output": "∀x (GoodRelationship(x) → ¬HealthyHabits(x))"
},
{
"input": "Translate into first-order logic: If people have good relationships with their parents, then they do not eat salads regularly.",
"output": "∀x (Gym(x) → Nutritional(x))"
},
{
"input": "Translate into first-order logic: If people visit the gym at least once a day, then they always fulfill their daily nutritional intakes.",
"output": "(HealthyChildhood(taylor) ∧ GoodRelationship(taylor)) ∨ ¬HealthyChildhood(taylor) ∧ ¬GoodRelationship(marcy)"
},
{
"input": "Translate into first-order logic: Taylor eats salads regularly.",
"output": "Salad(taylor)"
},
{
"input": "Translate into first-order logic: All people who eat salads regularly are very conscious about their health and eating habits.",
"output": "∀x (Salad(x) → HealthyHabits(x))"
},
{
"input": "Translate into first-order logic: All people who grew up in health-conscious childhood homes eat salads regularly.",
"output": "∀x (HealthyChildhood(x) → Salad(x))"
},
{
"input": "Translate into first-order logic: All people who fulfill their nutritional daily intakes grew up in health-conscious childhood homes.",
"output": "∀x (Nutritional(x) → HealthyChildhood(x))"
},
{
"input": "Translate into first-order logic: If people have good relationships with their parents, then they fulfill their nutritional daily intakes.",
"output": "∀x (GoodRelationship(x) → ¬HealthyHabits(x))"
},
{
"input": "Translate into first-order logic: If people have good relationships with their parents, then they do not eat salads regularly.",
"output": "∀x (Gym(x) → Nutritional(x))"
},
{
"input": "Translate into first-order logic: If people visit the gym at least once a day, then they always fulfill their daily nutritional intakes.",
"output": "(HealthyChildhood(taylor) ∧ GoodRelationship(taylor)) ∨ ¬HealthyChildhood(taylor) ∧ ¬GoodRelationship(marcy)"
},
{
"input": "Translate into first-order logic: Taylor visits the gym at least once a day.",
"output": "Gym(taylor)"
},
{
"input": "Translate into first-order logic: All people who eat salads regularly are very conscious about their health and eating habits.",
"output": "∀x (Salad(x) → HealthyHabits(x))"
},
{
"input": "Translate into first-order logic: All people who grew up in health-conscious childhood homes eat salads regularly.",
"output": "∀x (HealthyChildhood(x) → Salad(x))"
},
{
"input": "Translate into first-order logic: All people who fulfill their nutritional daily intakes grew up in health-conscious childhood homes.",
"output": "∀x (Nutritional(x) → HealthyChildhood(x))"
},
{
"input": "Translate into first-order logic: If people have good relationships with their parents, then they fulfill their nutritional daily intakes.",
"output": "∀x (GoodRelationship(x) → ¬HealthyHabits(x))"
},
{
"input": "Translate into first-order logic: If people have good relationships with their parents, then they do not eat salads regularly.",
"output": "∀x (Gym(x) → Nutritional(x))"
},
{
"input": "Translate into first-order logic: If people visit the gym at least once a day, then they always fulfill their daily nutritional intakes.",
"output": "(HealthyChildhood(taylor) ∧ GoodRelationship(taylor)) ∨ ¬HealthyChildhood(taylor) ∧ ¬GoodRelationship(marcy)"
},
{
"input": "Translate into first-order logic: Taylor neither grew up in a health-conscious childhood home nor does she visit the gym at least once a day.",
"output": "¬(HealthyChildhood(taylor) ∨ Gym(taylor))"
},
{
"input": "Translate into first-order logic: [BG] The Olympic games is a sporting event.",
"output": "SportingEvent(olympics)"
},
{
"input": "Translate into first-order logic: The last Olympic games was in Tokyo.",
"output": "LastOlympics(tokyo)"
},
{
"input": "Translate into first-order logic: The United States won the most medals in Tokyo.",
"output": "MostMedals(unitedStates, tokyo)"
},
{
"input": "Translate into first-order logic: The world championships is a sporting event.",
"output": "SportingEvent(champs)"
},
{
"input": "Translate into first-order logic: [BG] The Olympic games is a sporting event.",
"output": "SportingEvent(olympics)"
},
{
"input": "Translate into first-order logic: The last Olympic games was in Tokyo.",
"output": "LastOlympics(tokyo)"
},
{
"input": "Translate into first-order logic: The United States won the most medals in Tokyo.",
"output": "MostMedals(unitedStates, tokyo)"
},
{
"input": "Translate into first-order logic: The last Olympic games were not in Tokyo.",
"output": "¬LastOlympics(tokyo)"
},
{
"input": "Translate into first-order logic: [BG] The Olympic games is a sporting event.",
"output": "SportingEvent(olympics)"
},
{
"input": "Translate into first-order logic: The last Olympic games was in Tokyo.",
"output": "LastOlympics(tokyo)"
},
{
"input": "Translate into first-order logic: The United States won the most medals in Tokyo.",
"output": "MostMedals(unitedStates, tokyo)"
},
{
"input": "Translate into first-order logic: The United States won the most medals in the last Olympic games.",
"output": "∃x (LastOlympics(x) ∧ MostMedals(unitedStates, x))"
},
{
"input": "Translate into first-order logic: All horses have hooves.",
"output": "∀x (Horse(x) → Hooves(x))"
},
{
"input": "Translate into first-order logic: No humans have hooves.",
"output": "∀x (Human(x) → ¬Hooves(x))"
},
{
"input": "Translate into first-order logic: Some humans are horses.",
"output": "∃x (Human(x) ∧ Horse(x))"
},
{
"input": "Translate into first-order logic: Susan flies to LGA airport.",
"output": "FlyTo(susan, lga)"
},
{
"input": "Translate into first-order logic: The departure and arrival can not be the same airport.",
"output": "∀x ∀y (FlyFrom(x, y) ⊕ FlyTo(x, y))"
},
{
"input": "Translate into first-order logic: John flies from LGA airport.",
"output": "FlyFrom(john, lga)"
},
{
"input": "Translate into first-order logic: Susan flies from LGA airport.",
"output": "FlyFrom(susan, lga)"
},
{
"input": "Translate into first-order logic: Susan flies to LGA airport.",
"output": "FlyTo(susan, lga)"
},
{
"input": "Translate into first-order logic: The departure and arrival can not be the same airport.",
"output": "∀x ∀y (FlyFrom(x, y) ⊕ FlyTo(x, y))"
},
{
"input": "Translate into first-order logic: John flies from LGA airport.",
"output": "FlyFrom(john, lga)"
},
{
"input": "Translate into first-order logic: John flies to LGA airport.",
"output": "FlyTo(john, lga)"
},
{
"input": "Translate into first-order logic: No one nice to animals is mean to animals.",
"output": "∀x (Nice(x) → ¬Mean(x))"
},
{
"input": "Translate into first-order logic: Some grumpy people are mean to animals.",
"output": "∃x (Grumpy(x) ∧ Mean(x))"
},
{
"input": "Translate into first-order logic: All animal lovers are nice to animals.",
"output": "∀x (AnimalLover(x) → Nice(x))"
},
{
"input": "Translate into first-order logic: If someone owns a pet, then they love animals.",
"output": "∀x (PetOwner(x) → AnimalLover(x))"
},
{
"input": "Translate into first-order logic: Tom is a pet owner.",
"output": "PetOwner(tom)"
},
{
"input": "Translate into first-order logic: Tom is a grumpy person.",
"output": "Grumpy(tom)"
},
{
"input": "Translate into first-order logic: No one nice to animals is mean to animals.",
"output": "∀x (Nice(x) → ¬Mean(x))"
},
{
"input": "Translate into first-order logic: Some grumpy people are mean to animals.",
"output": "∃x (Grumpy(x) ∧ Mean(x))"
},
{
"input": "Translate into first-order logic: All animal lovers are nice to animals.",
"output": "∀x (AnimalLover(x) → Nice(x))"
},
{
"input": "Translate into first-order logic: If someone owns a pet, then they love animals.",
"output": "∀x (PetOwner(x) → AnimalLover(x))"
},
{
"input": "Translate into first-order logic: Tom is a pet owner.",
"output": "PetOwner(tom)"
},
{
"input": "Translate into first-order logic: Tom is not a grumpy person and mean to animals.",
"output": "¬(Grumpy(tom) ∧ Mean(tom))"
},
{
"input": "Translate into first-order logic: No one nice to animals is mean to animals.",
"output": "∀x (Nice(x) → ¬Mean(x))"
},
{
"input": "Translate into first-order logic: Some grumpy people are mean to animals.",
"output": "∃x (Grumpy(x) ∧ Mean(x))"
},
{
"input": "Translate into first-order logic: All animal lovers are nice to animals.",
"output": "∀x (AnimalLover(x) → Nice(x))"
},
{
"input": "Translate into first-order logic: If someone owns a pet, then they love animals.",
"output": "∀x (PetOwner(x) → AnimalLover(x))"
},
{
"input": "Translate into first-order logic: Tom is a pet owner.",
"output": "PetOwner(tom)"
},
{
"input": "Translate into first-order logic: If Tom is not a grumpy person and mean to animals, then Tom is neither a grumpy person nor an Animal Lover.",
"output": "¬(Grumpy(tom) ∧ Mean(tom)) → ¬(Grumpy(tom) ∨ AnimalLover(tom))"
},
{
"input": "Translate into first-order logic: A podcast is not a novel.",
"output": "∀x (IsPodcast(x) → ¬IsNovel(x))"
},
{
"input": "Translate into first-order logic: [BG] If a person is born in American City, the person is American.",
"output": "∀x ∃y (BornIn(x, y) ∧ IsCity(y) ∧ IsAmerican(y) → IsAmerican(x))"
},
{
"input": "Translate into first-order logic: [BG] If a book is novel and it is written by a person, then the person is a novel writer.",
"output": "∀x ∀y (IsNovel(x) ∧ WrittenBy(x, y) → WritesNovel(y))"
},
{
"input": "Translate into first-order logic: Dani Shapiro is an American writer.",
"output": "IsAmerican(dani_Shapiro) ∧ IsWriter(dani_Shapiro)"
},
{
"input": "Translate into first-order logic: Family History is written by Dani Shapiro.",
"output": "WrittenBy(family_History, dani_Shapiro)"
},
{
"input": "Translate into first-order logic: Family History is a novel written in 2003.",
"output": "IsNovel(family_History) ∧ WrittenIn(family_History, y2003)"
},
{
"input": "Translate into first-order logic: Dani Shapiro created a podcast called Family Secrets.",
"output": "IsPodcast(family_Secrets) ∧ CreatedBy(family_Secrets, dani_Shapiro)"
},
{
"input": "Translate into first-order logic: [BG] Boston is an American city.",
"output": "IsCity(boston) ∧ IsAmerican(boston)"
},
{
"input": "Translate into first-order logic: Dani Shapiro is a novel writer.",
"output": "WritesNovel(dani_Shapiro)"
},
{
"input": "Translate into first-order logic: A podcast is not a novel.",
"output": "∀x (IsPodcast(x) → ¬IsNovel(x))"
},
{
"input": "Translate into first-order logic: [BG] If a person is born in American City, the person is American.",
"output": "∀x ∃y (BornIn(x, y) ∧ IsCity(y) ∧ IsAmerican(y) → IsAmerican(x))"
},
{
"input": "Translate into first-order logic: [BG] If a book is novel and it is written by a person, then the person is a novel writer.",
"output": "∀x ∀y (IsNovel(x) ∧ WrittenBy(x, y) → WritesNovel(y))"
},
{
"input": "Translate into first-order logic: Dani Shapiro is an American writer.",
"output": "IsAmerican(dani_Shapiro) ∧ IsWriter(dani_Shapiro)"
},
{
"input": "Translate into first-order logic: Family History is written by Dani Shapiro.",
"output": "WrittenBy(family_History, dani_Shapiro)"
},
{
"input": "Translate into first-order logic: Family History is a novel written in 2003.",
"output": "IsNovel(family_History) ∧ WrittenIn(family_History, y2003)"
},
{
"input": "Translate into first-order logic: Dani Shapiro created a podcast called Family Secrets.",
"output": "IsPodcast(family_Secrets) ∧ CreatedBy(family_Secrets, dani_Shapiro)"
},
{
"input": "Translate into first-order logic: [BG] Boston is an American city.",
"output": "IsCity(boston) ∧ IsAmerican(boston)"
},
{
"input": "Translate into first-order logic: Family Secrets is a novel.",
"output": "IsNovel(family_Secrets)"
},
{
"input": "Translate into first-order logic: A podcast is not a novel.",
"output": "∀x (IsPodcast(x) → ¬IsNovel(x))"
},
{
"input": "Translate into first-order logic: [BG] If a person is born in American City, the person is American.",
"output": "∀x ∃y (BornIn(x, y) ∧ IsCity(y) ∧ IsAmerican(y) → IsAmerican(x))"
},
{
"input": "Translate into first-order logic: [BG] If a book is novel and it is written by a person, then the person is a novel writer.",
"output": "∀x ∀y (IsNovel(x) ∧ WrittenBy(x, y) → WritesNovel(y))"
},
{
"input": "Translate into first-order logic: Dani Shapiro is an American writer.",
"output": "IsAmerican(dani_Shapiro) ∧ IsWriter(dani_Shapiro)"
},
{
"input": "Translate into first-order logic: Family History is written by Dani Shapiro.",
"output": "WrittenBy(family_History, dani_Shapiro)"
},
{
"input": "Translate into first-order logic: Family History is a novel written in 2003.",
"output": "IsNovel(family_History) ∧ WrittenIn(family_History, y2003)"
},
{
"input": "Translate into first-order logic: Dani Shapiro created a podcast called Family Secrets.",
"output": "IsPodcast(family_Secrets) ∧ CreatedBy(family_Secrets, dani_Shapiro)"
},
{
"input": "Translate into first-order logic: [BG] Boston is an American city.",
"output": "IsCity(boston) ∧ IsAmerican(boston)"
},
{
"input": "Translate into first-order logic: Dani Shapiro was born in Boston.",
"output": "BornIn(dani_Shapiro, boston)"
},
{
"input": "Translate into first-order logic: Some basketball players are not American.",
"output": "∃x (BasketballPlayer(x) ∧ ¬American(x))"
},
{
"input": "Translate into first-order logic: All basketball players are tall.",
"output": "∀x (BasketballPlayer(x) → Tall(x))"
},
{
"input": "Translate into first-order logic: If someone is tall, they wear large shoes.",
"output": "∀x (Tall(x) → WearLargeShoes(x))"
},
{
"input": "Translate into first-order logic: If someone wears large shoes, they wear large-sized clothes.",
"output": "∀x (WearLargeShoes(x) → WearLargeClothes(x))"
},
{
"input": "Translate into first-order logic: Yuri does not wear large-size clothes.",
"output": "¬WearLargeClothes(yuri)"
},
{
"input": "Translate into first-order logic: Yuri is an American.",
"output": "American(yuri)"
},
{
"input": "Translate into first-order logic: Some basketball players are not American.",
"output": "∃x (BasketballPlayer(x) ∧ ¬American(x))"
},
{
"input": "Translate into first-order logic: All basketball players are tall.",
"output": "∀x (BasketballPlayer(x) → Tall(x))"
},
{
"input": "Translate into first-order logic: If someone is tall, they wear large shoes.",
"output": "∀x (Tall(x) → WearLargeShoes(x))"
},
{
"input": "Translate into first-order logic: If someone wears large shoes, they wear large-sized clothes.",
"output": "∀x (WearLargeShoes(x) → WearLargeClothes(x))"
},
{
"input": "Translate into first-order logic: Yuri does not wear large-size clothes.",
"output": "¬WearLargeClothes(yuri)"
},
{
"input": "Translate into first-order logic: Yuri is not an American basketball player.",
"output": "¬(American(yuri) ∧ BasketballPlayer(yuri))"
},
{
"input": "Translate into first-order logic: Some basketball players are not American.",
"output": "∃x (BasketballPlayer(x) ∧ ¬American(x))"
},
{
"input": "Translate into first-order logic: All basketball players are tall.",
"output": "∀x (BasketballPlayer(x) → Tall(x))"
},
{
"input": "Translate into first-order logic: If someone is tall, they wear large shoes.",
"output": "∀x (Tall(x) → WearLargeShoes(x))"
},
{
"input": "Translate into first-order logic: If someone wears large shoes, they wear large-sized clothes.",
"output": "∀x (WearLargeShoes(x) → WearLargeClothes(x))"
},
{
"input": "Translate into first-order logic: Yuri does not wear large-size clothes.",
"output": "¬WearLargeClothes(yuri)"
},
{
"input": "Translate into first-order logic: Yuri is an American basketball player.",
"output": "American(yuri) ∧ BasketballPlayer(yuri)"
},
{
"input": "Translate into first-order logic: Some basketball players are not American.",
"output": "∃x (BasketballPlayer(x) ∧ ¬American(x))"
},
{
"input": "Translate into first-order logic: All basketball players are tall.",
"output": "∀x (BasketballPlayer(x) → Tall(x))"
},
{
"input": "Translate into first-order logic: If someone is tall, they wear large shoes.",
"output": "∀x (Tall(x) → WearLargeShoes(x))"
},
{
"input": "Translate into first-order logic: If someone wears large shoes, they wear large-sized clothes.",
"output": "∀x (WearLargeShoes(x) → WearLargeClothes(x))"
},
{
"input": "Translate into first-order logic: Yuri does not wear large-size clothes.",
"output": "¬WearLargeClothes(yuri)"
},
{
"input": "Translate into first-order logic: If Yuri does not wear large shoes, then Yuri is an American basketball player.",
"output": "¬WearLargeShoes(yuri) → (American(yuri) ∧ BasketballPlayer(yuri))"
},
{
"input": "Translate into first-order logic: Some basketball players are not American.",
"output": "∃x (BasketballPlayer(x) ∧ ¬American(x))"
},
{
"input": "Translate into first-order logic: All basketball players are tall.",
"output": "∀x (BasketballPlayer(x) → Tall(x))"
},
{
"input": "Translate into first-order logic: If someone is tall, they wear large shoes.",
"output": "∀x (Tall(x) → WearLargeShoes(x))"
},
{
"input": "Translate into first-order logic: If someone wears large shoes, they wear large-sized clothes.",
"output": "∀x (WearLargeShoes(x) → WearLargeClothes(x))"
},
{
"input": "Translate into first-order logic: Yuri does not wear large-size clothes.",
"output": "¬WearLargeClothes(yuri)"
},
{
"input": "Translate into first-order logic: If Yuri is not an American basketball player, then Yuri is a basketball player.",
"output": "¬(American(yuri) ∧ BasketballPlayer(yuri)) → BasketballPlayer(yuri)"
},
{
"input": "Translate into first-order logic: Events are either happy or sad.",
"output": "∀x (Event(x) → Happy(x) ⊕ Sad(x))"
},
{
"input": "Translate into first-order logic: At least one event is happy.",
"output": "∃x (Event(x) ∧ Happy(x)) "
},
{
"input": "Translate into first-order logic: All events are sad.",
"output": "∀x (Event(x) → Sad(x))"
},
{
"input": "Translate into first-order logic: The winner of the 1992 du Maurier Classic was Steinhauer.",
"output": "Winner(maurier, steinhauer)"
},
{
"input": "Translate into first-order logic: Steinhauer participated in the 1992 du Maurier Classic.",
"output": "Participate(maurier, steinhauer)"
},
{
"input": "Translate into first-order logic: There was one six-way tie on the leaderboard and one person in the six-way tie was from Belgium.",
"output": "∃x (LeaderBoard(maurier, x) ∧ SixWayTie(x) ∧ Belgium(x))"
},
{
"input": "Translate into first-order logic: Descampe is from Belgium and is on the leaderboard of the 1992 du Maurier Classic.",
"output": "Belgium(descampe) ∧ LeaderBoard(maurier, descampe)"
},
{
"input": "Translate into first-order logic: All people on the leaderboard of the 1992 du Maurier Classic participated in the 1992 du Maurier Classic.",
"output": "∀x (LeaderBoard(maurier, x) → Participate(maurier, x))"
},
{
"input": "Translate into first-order logic: Steinhauer was not the winner of the 1992 du Maurier Classic.",
"output": "¬Winner(maurier, steinhauer)"
},
{
"input": "Translate into first-order logic: The winner of the 1992 du Maurier Classic was Steinhauer.",
"output": "Winner(maurier, steinhauer)"
},
{
"input": "Translate into first-order logic: Steinhauer participated in the 1992 du Maurier Classic.",
"output": "Participate(maurier, steinhauer)"
},
{
"input": "Translate into first-order logic: There was one six-way tie on the leaderboard and one person in the six-way tie was from Belgium.",
"output": "∃x (LeaderBoard(maurier, x) ∧ SixWayTie(x) ∧ Belgium(x))"
},
{
"input": "Translate into first-order logic: Descampe is from Belgium and is on the leaderboard of the 1992 du Maurier Classic.",
"output": "Belgium(descampe) ∧ LeaderBoard(maurier, descampe)"
},
{
"input": "Translate into first-order logic: All people on the leaderboard of the 1992 du Maurier Classic participated in the 1992 du Maurier Classic.",
"output": "∀x (LeaderBoard(maurier, x) → Participate(maurier, x))"
},
{
"input": "Translate into first-order logic: Descampe is in the six-way tie in the leaderboard of the 1992 du Maurier Classic.",
"output": "SixWayTie(descampe)"
},
{
"input": "Translate into first-order logic: If an animal barks, then Jane does not like it.",
"output": "∀x (Bark(x) → ¬Like(jane, x))"
},
{
"input": "Translate into first-order logic: All dogs are animals that bark.",
"output": "∀x (Dog(x) → Bark(x))"
},
{
"input": "Translate into first-order logic: If an animal jumps, then Jane likes it.",
"output": "∀x (Jump(x) → Like(jane, x))"
},
{
"input": "Translate into first-order logic: If an animal has legs, then it jumps.",
"output": "∀x (HaveLegs(x) → Jump(x))"
},
{
"input": "Translate into first-order logic: If an animal is terricolous, then it has legs.",
"output": "∀x (Terricolous(x) → HaveLegs(x))"
},
{
"input": "Translate into first-order logic: If KiKi neither jumps nor has legs, then KiKi is terricolous or has legs.",
"output": "(¬Jump(kiki) ∧ ¬HaveLegs(kiki)) → (Terricolous(kiki) ∨ HaveLegs(kiki))"
},
{
"input": "Translate into first-order logic: KiKi is terricolous.",
"output": "Terricolous(kiki)"
},
{
"input": "Translate into first-order logic: If an animal barks, then Jane does not like it.",
"output": "∀x (Bark(x) → ¬Like(jane, x))"
},
{
"input": "Translate into first-order logic: All dogs are animals that bark.",
"output": "∀x (Dog(x) → Bark(x))"
},
{
"input": "Translate into first-order logic: If an animal jumps, then Jane likes it.",
"output": "∀x (Jump(x) → Like(jane, x))"
},
{
"input": "Translate into first-order logic: If an animal has legs, then it jumps.",
"output": "∀x (HaveLegs(x) → Jump(x))"
},
{
"input": "Translate into first-order logic: If an animal is terricolous, then it has legs.",
"output": "∀x (Terricolous(x) → HaveLegs(x))"
},
{
"input": "Translate into first-order logic: If KiKi neither jumps nor has legs, then KiKi is terricolous or has legs.",
"output": "(¬Jump(kiki) ∧ ¬HaveLegs(kiki)) → (Terricolous(kiki) ∨ HaveLegs(kiki))"
},
{
"input": "Translate into first-order logic: KiKi barks and is a dog.",
"output": "Bark(kiki) ∧ Dog(kiki)"
},
{
"input": "Translate into first-order logic: If an animal barks, then Jane does not like it.",
"output": "∀x (Bark(x) → ¬Like(jane, x))"
},
{
"input": "Translate into first-order logic: All dogs are animals that bark.",
"output": "∀x (Dog(x) → Bark(x))"
},
{
"input": "Translate into first-order logic: If an animal jumps, then Jane likes it.",
"output": "∀x (Jump(x) → Like(jane, x))"
},
{
"input": "Translate into first-order logic: If an animal has legs, then it jumps.",
"output": "∀x (HaveLegs(x) → Jump(x))"
},
{
"input": "Translate into first-order logic: If an animal is terricolous, then it has legs.",
"output": "∀x (Terricolous(x) → HaveLegs(x))"
},
{
"input": "Translate into first-order logic: If KiKi neither jumps nor has legs, then KiKi is terricolous or has legs.",
"output": "(¬Jump(kiki) ∧ ¬HaveLegs(kiki)) → (Terricolous(kiki) ∨ HaveLegs(kiki))"
},
{
"input": "Translate into first-order logic: KiKi neither barks nor is a dog.",
"output": "¬Bark(kiki) ∧ ¬Dog(kiki)"
},
{
"input": "Translate into first-order logic: Ailton Silva, born in 1995, is commonly known as Ailton.",
"output": "BornIn(ailtonsilva, y1995) ∧ CommonlyKnownAs(ailtonsilva, ailton)"
},
{
"input": "Translate into first-order logic: Ailton is a football player who was loaned out to Braga.",
"output": "FootballPlayer(ailton) ∧ LoanedTo(ailton, braga)"
},
{
"input": "Translate into first-order logic: Ailton Silva is a Brazillian footballer who plays for Nautico.",
"output": "Brazilian(ailtonsilva) ∧ Footballplayer(ailtonsilva) ∧ PlaysFor(ailtonsilva, nautico)"
},
{
"input": "Translate into first-order logic: Nautico is a football club along with Braga.",
"output": "FootballClub(nautico) ∧ FootballClub(braga)"
},
{
"input": "Translate into first-order logic: Fluminense is a football club.",
"output": "FootballClub(fluminense)"
},
{
"input": "Translate into first-order logic: No one playing for Nautico is Brazilian.",
"output": "∀x (PlaysFor(x, nautico) → ¬Brazilian(x))"
},
{
"input": "Translate into first-order logic: Ailton Silva, born in 1995, is commonly known as Ailton.",
"output": "BornIn(ailtonsilva, y1995) ∧ CommonlyKnownAs(ailtonsilva, ailton)"
},
{
"input": "Translate into first-order logic: Ailton is a football player who was loaned out to Braga.",
"output": "FootballPlayer(ailton) ∧ LoanedTo(ailton, braga)"
},
{
"input": "Translate into first-order logic: Ailton Silva is a Brazillian footballer who plays for Nautico.",
"output": "Brazilian(ailtonsilva) ∧ Footballplayer(ailtonsilva) ∧ PlaysFor(ailtonsilva, nautico)"
},
{
"input": "Translate into first-order logic: Nautico is a football club along with Braga.",
"output": "FootballClub(nautico) ∧ FootballClub(braga)"
},
{
"input": "Translate into first-order logic: Fluminense is a football club.",
"output": "FootballClub(fluminense)"
},
{
"input": "Translate into first-order logic: Ailton Silva foes not play for a football club.",
"output": "∀x (FootballClub(x) → ¬PlaysFor(ailtonsilva, x))"
},
{
"input": "Translate into first-order logic: Ailton Silva, born in 1995, is commonly known as Ailton.",
"output": "BornIn(ailtonsilva, y1995) ∧ CommonlyKnownAs(ailtonsilva, ailton)"
},
{
"input": "Translate into first-order logic: Ailton is a football player who was loaned out to Braga.",
"output": "FootballPlayer(ailton) ∧ LoanedTo(ailton, braga)"
},
{
"input": "Translate into first-order logic: Ailton Silva is a Brazillian footballer who plays for Nautico.",
"output": "Brazilian(ailtonsilva) ∧ Footballplayer(ailtonsilva) ∧ PlaysFor(ailtonsilva, nautico)"
},
{
"input": "Translate into first-order logic: Nautico is a football club along with Braga.",
"output": "FootballClub(nautico) ∧ FootballClub(braga)"
},
{
"input": "Translate into first-order logic: Fluminense is a football club.",
"output": "FootballClub(fluminense)"
},
{
"input": "Translate into first-order logic: Ailton was not loaned out to a football club.",
"output": "∀x (FootballClub(x) → ¬LoanedTo(ailton, x))"
},
{
"input": "Translate into first-order logic: Ailton Silva, born in 1995, is commonly known as Ailton.",
"output": "BornIn(ailtonsilva, y1995) ∧ CommonlyKnownAs(ailtonsilva, ailton)"
},
{
"input": "Translate into first-order logic: Ailton is a football player who was loaned out to Braga.",
"output": "FootballPlayer(ailton) ∧ LoanedTo(ailton, braga)"
},
{
"input": "Translate into first-order logic: Ailton Silva is a Brazillian footballer who plays for Nautico.",
"output": "Brazilian(ailtonsilva) ∧ Footballplayer(ailtonsilva) ∧ PlaysFor(ailtonsilva, nautico)"
},
{
"input": "Translate into first-order logic: Nautico is a football club along with Braga.",
"output": "FootballClub(nautico) ∧ FootballClub(braga)"
},
{
"input": "Translate into first-order logic: Fluminense is a football club.",
"output": "FootballClub(fluminense)"
},
{
"input": "Translate into first-order logic: Ailton Silva played for Fluminense.",
"output": "PlaysFor(ailtonsilva, fluminense)"
},
{
"input": "Translate into first-order logic: Ailton Silva, born in 1995, is commonly known as Ailton.",
"output": "BornIn(ailtonsilva, y1995) ∧ CommonlyKnownAs(ailtonsilva, ailton)"
},
{
"input": "Translate into first-order logic: Ailton is a football player who was loaned out to Braga.",
"output": "FootballPlayer(ailton) ∧ LoanedTo(ailton, braga)"
},
{
"input": "Translate into first-order logic: Ailton Silva is a Brazillian footballer who plays for Nautico.",
"output": "Brazilian(ailtonsilva) ∧ Footballplayer(ailtonsilva) ∧ PlaysFor(ailtonsilva, nautico)"
},
{
"input": "Translate into first-order logic: Nautico is a football club along with Braga.",
"output": "FootballClub(nautico) ∧ FootballClub(braga)"
},
{
"input": "Translate into first-order logic: Fluminense is a football club.",
"output": "FootballClub(fluminense)"
},
{
"input": "Translate into first-order logic: Ailton Silva was loaned out to a football club.",
"output": "∃x (FootballClub(x) ∧ LoanedTo(ailtonsilva, x))"
}
]